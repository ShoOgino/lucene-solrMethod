  public NamedList<Object> request( final SolrRequest request ) throws SolrServerException, IOException
  {
    // TODO -- need to set the WRITER TYPE!!!
    // params.set( SolrParams.WT, wt );
   
    HttpMethod method = null;
    SolrParams params = request.getParams();
    Collection<ContentStream> streams = request.getContentStreams();
    String path = request.getPath();
    if( path == null || !path.startsWith( "/" ) ) {
      path = "/select";
    }
    
    // modify the path for multicore access
    String core = getDefaultCore();
    if( request.getCore() != null ) {
      core= request.getCore();
    }
    if( core != null && core.length() > 0 ) {
      path = "/"+core+path;
    }
    
    if( params == null ) {
      params = new ModifiableSolrParams();
    }
    if( _invariantParams != null ) {
      params = new DefaultSolrParams( _invariantParams, params );
    }
    
    int tries = _maxRetries + 1;        
    try {
      while( tries-- > 0 ) {
        // Note: since we aren't do intermittent time keeping
        // ourselves, the potential non-timeout latency could be as
        // much as tries-times (plus scheduling effects) the given
        // timeAllowed.
        try {
          if( SolrRequest.METHOD.GET == request.getMethod() ) {
            if( streams != null ) {
              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "GET can't send streams!" );
            }
            method = new GetMethod( _baseURL + path + ClientUtils.toQueryString( params, false ) );
          }
          else if( SolrRequest.METHOD.POST == request.getMethod() ) {
            
            String url = _baseURL + path;
            boolean isMultipart = ( streams != null && streams.size() > 1 );
            
            if( streams == null || isMultipart ) {
              // Without streams, just post the parameters
              PostMethod post = new PostMethod( url );
            
              Iterator<String> iter = params.getParameterNamesIterator();
              while( iter.hasNext() ) {
                String p = iter.next();
                String[] vals = params.getParams( p );
                if( vals != null && vals.length > 0 ) {
                  for( String v : vals ) {
                    post.addParameter( p, (v==null)?null:v );
                  }
                }
                else {
                  post.addParameter( p, null );
                }
              }
              
              post.getParams().setContentCharset("UTF-8");   

              if( isMultipart ) {
                int i=0;
                Part[] parts = new Part[streams.size()];
                
                for( ContentStream content : streams ) {
                  final ContentStream c = content;
                  
                  String charSet = null;
                  String transferEncoding = null;
                  parts[i++] = new PartBase( c.getName(), c.getContentType(), charSet, transferEncoding ) {
                    @Override
                    protected long lengthOfData() throws IOException {
                      return c.getSize();
                    }
                    
                    @Override
                      protected void sendData(OutputStream out) throws IOException {
                      IOUtils.copy( c.getReader(), out );
                    }
                  }; 
                }
                
                // Set the multi-part request
                post.setRequestEntity( new MultipartRequestEntity( parts, post.getParams() ) );
                method = post;
              }

              method = post;
            }
            // It is has one stream, it is the post body, put the params in the URL
            else {
              String pstr = ClientUtils.toQueryString( params, false );
              PostMethod post = new PostMethod( url+pstr );
              
              // Single stream as body
              // Using a loop just to get the first one
              for( ContentStream content : streams ) {
                post.setRequestEntity( 
                    new InputStreamRequestEntity( content.getStream(), content.getContentType())
                );
                break;
              }
              method = post;
            }
          }
          else {
            throw new SolrServerException("Unsupported method: "+request.getMethod() );
          }
        }
        catch( NoHttpResponseException r ) {
          // This is generally safe to retry on
          method.releaseConnection();
          method = null;
          // If out of tries then just rethrow (as normal error).
          if( ( tries < 1 ) ) {
            throw r;
          }
          //log.warn( "Caught: " + r + ". Retrying..." );
        }
      }
    }
    catch( IOException ex ) {
      throw new SolrServerException("error reading streams", ex );
    }
    
    method.setFollowRedirects( _followRedirects );
    method.addRequestHeader( "User-Agent", AGENT );
    if( _allowCompression ) {
      method.setRequestHeader( new Header( "Accept-Encoding", "gzip,deflate" ) );
    }
    
    try {
      // Execute the method.
      //System.out.println( "EXECUTE:"+method.getURI() );
    
      int statusCode = _httpClient.executeMethod(method);
      if (statusCode != HttpStatus.SC_OK) {
        StringBuilder msg = new StringBuilder();
        msg.append( method.getStatusLine().getReasonPhrase() );
        msg.append( "\n\n" );
        msg.append( method.getStatusText() );
        msg.append( "\n\n" );
        msg.append( "request: "+method.getURI() );
        throw new SolrException(statusCode, java.net.URLDecoder.decode(msg.toString(), "UTF-8") );
      }
      
      // Read the contents
      String charset = "UTF-8";
      if( method instanceof HttpMethodBase ) {
        charset = ((HttpMethodBase)method).getResponseCharSet();
      }
      InputStream respBody = method.getResponseBodyAsStream();
      // Jakarta Commons HTTPClient doesn't handle any
      // compression natively.  Handle gzip or deflate
      // here if applicable.
      if( _allowCompression ) {
        Header contentEncodingHeader = method.getResponseHeader( "Content-Encoding" );
        if( contentEncodingHeader != null ) {
          String contentEncoding = contentEncodingHeader.getValue();
          if( contentEncoding.contains( "gzip" ) ) {
            //log.debug( "wrapping response in GZIPInputStream" );
            respBody = new GZIPInputStream( respBody );
          }
          else if( contentEncoding.contains( "deflate" ) ) {
            //log.debug( "wrapping response in InflaterInputStream" );
            respBody = new InflaterInputStream(respBody);
          }
        }
        else {
          Header contentTypeHeader = method.getResponseHeader( "Content-Type" );
          if( contentTypeHeader != null ) {
            String contentType = contentTypeHeader.getValue();
            if( contentType != null ) {
              if( contentType.startsWith( "application/x-gzip-compressed" ) ) {
                //log.debug( "wrapping response in GZIPInputStream" );
                respBody = new GZIPInputStream( respBody );
              }
              else if ( contentType.startsWith("application/x-deflate") ) {
                //log.debug( "wrapping response in InflaterInputStream" );
                respBody = new InflaterInputStream(respBody);
              }
            }
          }
        }
      }
      Reader reader = new InputStreamReader( respBody, charset ); 
      return _processor.processResponse( reader );
    } 
    catch (HttpException e) {
      throw new SolrServerException( e );
    }
    catch (IOException e) {
      throw new SolrServerException( e );
    }
    finally {
      method.releaseConnection();
    }
  }

