  /**
   * Build lattice from input text
   * @param text
   */
  public ViterbiNode[][][] build(char text[], int offset, int length) throws IOException {
    ViterbiNode[][] startIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS
    ViterbiNode[][] endIndexArr = new ViterbiNode[length + 2][];  // text length + BOS and EOS
    int[] startSizeArr = new int[length + 2]; // array to keep ViterbiNode count in startIndexArr
    int[] endSizeArr = new int[length + 2];   // array to keep ViterbiNode count in endIndexArr
    FST.Arc<Long> arc = new FST.Arc<Long>();
    ViterbiNode bosNode = new ViterbiNode(-1, BOS, 0, BOS.length, 0, 0, 0, -1, Type.KNOWN);
    addToArrays(bosNode, 0, 1, startIndexArr, endIndexArr, startSizeArr, endSizeArr);
    
    final FST.BytesReader fstReader = fst.getBytesReader(0);

    // Process user dictionary;
    if (useUserDictionary) {
      processUserDictionary(text, offset, length, startIndexArr, endIndexArr, startSizeArr, endSizeArr);
    }
    
    int unknownWordEndIndex = -1;	// index of the last character of unknown word
    
    final IntsRef wordIdRef = new IntsRef();
    
    for (int startIndex = 0; startIndex < length; startIndex++) {
      // If no token ends where current token starts, skip this index
      if (endSizeArr[startIndex + 1] == 0) {
        continue;
      }
      
      int suffixStart = offset + startIndex;
      int suffixLength = length - startIndex;
      
      boolean found = false;
      arc = fst.getFirstArc(arc);
      int output = 0;
      for (int endIndex = 1; endIndex < suffixLength + 1; endIndex++) {
        int ch = text[suffixStart + endIndex - 1];
        
        if (fst.findTargetArc(ch, arc, arc, endIndex == 1, fstReader) == null) {
          break; // continue to next position
        }
        output += arc.output.intValue();

        if (arc.isFinal()) {
          output += arc.nextFinalOutput.intValue();
          found = true; // Don't produce unknown word starting from this index
          dictionary.lookupWordIds(output, wordIdRef);
          for (int ofs = 0; ofs < wordIdRef.length; ofs++) {
            final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];
            ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, endIndex, dictionary.getLeftId(wordId), dictionary.getRightId(wordId), dictionary.getWordCost(wordId), startIndex, Type.KNOWN);
            addToArrays(node, startIndex + 1, startIndex + 1 + endIndex, startIndexArr, endIndexArr, startSizeArr, endSizeArr);
          }
        }
      }
      
      // In the case of normal mode, it doesn't process unknown word greedily.
      if(!searchMode && unknownWordEndIndex > startIndex){
        continue;
      }
      
      // Process Unknown Word: hmm what is this isInvoke logic (same no matter what)
      int unknownWordLength = 0;
      char firstCharacter = text[suffixStart];
      boolean isInvoke = characterDefinition.isInvoke(firstCharacter);
      if (isInvoke){	// Process "invoke"
        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);
      } else if (found == false){	// Process not "invoke"
        unknownWordLength = unkDictionary.lookup(text, suffixStart, suffixLength);				
      }
      
      if (unknownWordLength > 0) {      // found unknown word
        final int characterId = characterDefinition.getCharacterClass(firstCharacter);
        unkDictionary.lookupWordIds(characterId, wordIdRef); // characters in input text are supposed to be the same
        for (int ofs = 0; ofs < wordIdRef.length; ofs++) {
          final int wordId = wordIdRef.ints[wordIdRef.offset + ofs];
          ViterbiNode node = new ViterbiNode(wordId, text, suffixStart, unknownWordLength, unkDictionary.getLeftId(wordId), unkDictionary.getRightId(wordId), unkDictionary.getWordCost(wordId), startIndex, Type.UNKNOWN);
          addToArrays(node, startIndex + 1, startIndex + 1 + unknownWordLength, startIndexArr, endIndexArr, startSizeArr, endSizeArr);
        }
        unknownWordEndIndex = startIndex + unknownWordLength;
      }
    }
    
    ViterbiNode eosNode = new ViterbiNode(-1, EOS, 0, EOS.length, 0, 0, 0, length + 1, Type.KNOWN);
    addToArrays(eosNode, length + 1, 0, startIndexArr, endIndexArr, startSizeArr, endSizeArr); //Add EOS node to endIndexArr at index 0
    
    ViterbiNode[][][] result = new ViterbiNode[][][]{startIndexArr, endIndexArr};
    
    return result;
  }

