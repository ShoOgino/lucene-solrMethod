  /**
   * Find best path from input lattice.
   * @param lattice the result of build method
   * @return	List of ViterbiNode which consist best path 
   */
  public List<ViterbiNode> search(ViterbiNode[][][] lattice) {
    ViterbiNode[][] startIndexArr = lattice[0];
    ViterbiNode[][] endIndexArr = lattice[1];
    
    for (int i = 1; i < startIndexArr.length; i++){
      
      if (startIndexArr[i] == null || endIndexArr[i] == null){	// continue since no array which contains ViterbiNodes exists. Or no previous node exists.
        continue;
      }
      
      for (ViterbiNode node : startIndexArr[i]) {
        if (node == null){	// If array doesn't contain ViterbiNode any more, continue to next index
          break;
        }
        
        int backwardConnectionId = node.getLeftId();
        int wordCost = node.getWordCost();
        int leastPathCost = DEFAULT_COST;
        for (ViterbiNode leftNode : endIndexArr[i]) {
          if (leftNode == null){ // If array doesn't contain ViterbiNode any more, continue to next index
            break;
          }
          
          int pathCost = leftNode.getPathCost() + costs.get(leftNode.getRightId(), backwardConnectionId) + wordCost;	// cost = [total cost from BOS to previous node] + [connection cost between previous node and current node] + [word cost]
          
          // "Search mode". Add extra costs if it is long node.
          if (searchMode) {
            //						System.out.print(""); // If this line exists, kuromoji runs faster for some reason when searchMode == false.
            char[] surfaceForm = node.getSurfaceForm();
            int offset = node.getOffset();
            int length = node.getLength();
            if (length > SEARCH_MODE_KANJI_LENGTH) {
              boolean allKanji = true;
              // check if node consists of only kanji
              for (int pos = 0; pos < length; pos++) {
                if (!characterDefinition.isKanji(surfaceForm[offset+pos])){
                  allKanji = false;
                  break;
                }				
              }
              
              if (allKanji) {	// Process only Kanji keywords
                pathCost += (length - SEARCH_MODE_KANJI_LENGTH) * SEARCH_MODE_KANJI_PENALTY;
              } else if (length > SEARCH_MODE_OTHER_LENGTH) {
                pathCost += (length - SEARCH_MODE_OTHER_LENGTH) * SEARCH_MODE_OTHER_PENALTY;								
              }
            }
          }
          
          if (pathCost < leastPathCost){	// If total cost is lower than before, set current previous node as best left node (previous means left).
            leastPathCost = pathCost;
            node.setPathCost(leastPathCost);
            node.setLeftNode(leftNode);
          }					
        }
      }
    }
    
    // track best path
    ViterbiNode node = endIndexArr[0][0];	// EOS
    LinkedList<ViterbiNode> result = new LinkedList<ViterbiNode>();
    result.add(node);
    while (true) {
      ViterbiNode leftNode = node.getLeftNode();
      if (leftNode == null) {
        break;
      }
      
      // EXTENDED mode convert unknown word into unigram node
      if (extendedMode && leftNode.getType() == Type.UNKNOWN) {
        byte unigramWordId = CharacterDefinition.NGRAM;
        int unigramLeftId = unkDictionary.getLeftId(unigramWordId); // isn't required
        int unigramRightId = unkDictionary.getLeftId(unigramWordId); // isn't required
        int unigramWordCost = unkDictionary.getWordCost(unigramWordId); // isn't required
        char[] surfaceForm = leftNode.getSurfaceForm();
        int offset = leftNode.getOffset();
        int length = leftNode.getLength();
        for (int i = length - 1; i >= 0; i--) {
          int charLen = 1;
          if (i > 0 && Character.isLowSurrogate(surfaceForm[offset+i])) {
            i--;
            charLen = 2;
          }
          ViterbiNode uniGramNode = new ViterbiNode(unigramWordId, surfaceForm, offset + i, charLen, unigramLeftId, unigramRightId, unigramWordCost, leftNode.getStartIndex() + i, Type.UNKNOWN);
          result.addFirst(uniGramNode);
        }
      } else {
        result.addFirst(leftNode);		
      }
      node = leftNode;
    }
    
    return result;
  }

