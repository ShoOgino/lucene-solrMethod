  /**
   * <p>Get the next token from the input stream.
   * <p>If the next token has <code>positionIncrement > 1</code>,
   * <code>positionIncrement - 1</code> {@link #FILLER_TOKEN}s are
   * inserted first.
   * @param target Where to put the new token; if null, a new instance is created.
   * @return On success, the populated token; null otherwise
   * @throws IOException if the input stream has a problem
   */
  private InputWindowToken getNextToken(InputWindowToken target) 
    throws IOException {
    InputWindowToken newTarget = target;
    if (numFillerTokensToInsert > 0) {
      if (null == target) {
        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());
      } else {
        nextInputStreamToken.copyTo(target.attSource);
      }
      // A filler token occupies no space
      newTarget.offsetAtt.setOffset(newTarget.offsetAtt.startOffset(), 
                                    newTarget.offsetAtt.startOffset());
      newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);
      newTarget.isFiller = true;
      --numFillerTokensToInsert;
    } else if (isNextInputStreamToken) {
      if (null == target) {
        newTarget = new InputWindowToken(nextInputStreamToken.cloneAttributes());
      } else {
        nextInputStreamToken.copyTo(target.attSource);
      }
      isNextInputStreamToken = false;
      newTarget.isFiller = false;
    } else if (!exhausted && input.incrementToken()) {
      if (null == target) {
        newTarget = new InputWindowToken(cloneAttributes());
      } else {
        this.copyTo(target.attSource);
      }
      if (posIncrAtt.getPositionIncrement() > 1) {
        // Each output shingle must contain at least one input token, 
        // so no more than (maxShingleSize - 1) filler tokens will be inserted.
        numFillerTokensToInsert 
          = Math.min(posIncrAtt.getPositionIncrement() - 1, maxShingleSize - 1);
        // Save the current token as the next input stream token
        if (null == nextInputStreamToken) {
          nextInputStreamToken = cloneAttributes();
        } else {
          this.copyTo(nextInputStreamToken);
        }
        isNextInputStreamToken = true;
        // A filler token occupies no space
        newTarget.offsetAtt.setOffset(offsetAtt.startOffset(), offsetAtt.startOffset());
        newTarget.termAtt.copyBuffer(FILLER_TOKEN, 0, FILLER_TOKEN.length);
        newTarget.isFiller = true;
        --numFillerTokensToInsert;
      } else {
        newTarget.isFiller = false;
      }
    } else {
      newTarget = null;
      exhausted = true;
    }
    return newTarget;
	}

