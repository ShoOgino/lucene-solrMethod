  /**
   * @param in Token stream to be filtered.
   * @param charTypeTable table containing character types
   * @param generateWordParts If 1, causes parts of words to be generated: "PowerShot" => "Power" "Shot"
   * @param generateNumberParts If 1, causes number subwords to be generated: "500-42" => "500" "42"
   * @param catenateWords  1, causes maximum runs of word parts to be catenated: "wi-fi" => "wifi"
   * @param catenateNumbers If 1, causes maximum runs of number parts to be catenated: "500-42" => "50042"
   * @param catenateAll If 1, causes all subword parts to be catenated: "wi-fi-4000" => "wifi4000"
   * @param splitOnCaseChange 1, causes "PowerShot" to be two tokens; ("Power-Shot" remains two parts regards)
   * @param preserveOriginal If 1, includes original words in subwords: "500-42" => "500" "42" "500-42"
   * @param splitOnNumerics 1, causes "j2se" to be three tokens; "j" "2" "se"
   * @param stemEnglishPossessive If 1, causes trailing "'s" to be removed for each subword: "O'Neil's" => "O", "Neil"
   * @param protWords If not null is the set of tokens to protect from being delimited
   * @deprecated Use {@link #WordDelimiterFilter(TokenStream, byte[], int, CharArraySet)}
   */
  @Deprecated
  public WordDelimiterFilter(TokenStream in,
                             byte[] charTypeTable,
                             int generateWordParts,
                             int generateNumberParts,
                             int catenateWords,
                             int catenateNumbers,
                             int catenateAll,
                             int splitOnCaseChange,
                             int preserveOriginal,
                             int splitOnNumerics,
                             int stemEnglishPossessive,
                             CharArraySet protWords) {
    super(in);

    int flags = 0;
    if (generateWordParts != 0) {
      flags |= GENERATE_WORD_PARTS;
    }
    if (generateNumberParts != 0) {
      flags |= GENERATE_NUMBER_PARTS;
    }
    if (catenateWords != 0) {
      flags |= CATENATE_WORDS;
    }
    if (catenateNumbers != 0) {
      flags |= CATENATE_NUMBERS;
    }
    if (catenateAll != 0) {
      flags |= CATENATE_ALL;
    }
    if (preserveOriginal != 0) {
      flags |= PRESERVE_ORIGINAL;
    }
    if (splitOnCaseChange != 0) {
      flags |= SPLIT_ON_CASE_CHANGE;
    }
    if (splitOnNumerics != 0) {
      flags |= SPLIT_ON_NUMERICS;
    }
    if (stemEnglishPossessive != 0) {
      flags |= STEM_ENGLISH_POSSESSIVE;
    }
    this.protWords = protWords;
    this.iterator = new WordDelimiterIterator(charTypeTable, splitOnCaseChange != 0, splitOnNumerics != 0, stemEnglishPossessive != 0);
    this.flags = flags;
  }

