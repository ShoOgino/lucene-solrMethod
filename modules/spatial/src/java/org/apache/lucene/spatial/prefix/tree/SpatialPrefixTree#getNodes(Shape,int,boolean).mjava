  /**
   * Gets the intersecting & including cells for the specified shape, without exceeding detail level.
   * The result is a set of cells (no dups), sorted. Unmodifiable.
   * <p/>
   * This implementation checks if shape is a Point and if so uses an implementation that
   * recursively calls {@link Node#getSubCell(com.spatial4j.core.shape.Point)}. Cell subclasses
   * ideally implement that method with a quick implementation, otherwise, subclasses should
   * override this method to invoke {@link #getNodesAltPoint(com.spatial4j.core.shape.Point, int, boolean)}.
   * TODO consider another approach returning an iterator -- won't build up all cells in memory.
   */
  public List<Node> getNodes(Shape shape, int detailLevel, boolean inclParents) {
    if (detailLevel > maxLevels) {
      throw new IllegalArgumentException("detailLevel > maxLevels");
    }

    List<Node> cells;
    if (shape instanceof Point) {
      //optimized point algorithm
      final int initialCapacity = inclParents ? 1 + detailLevel : 1;
      cells = new ArrayList<Node>(initialCapacity);
      recursiveGetNodes(getWorldNode(), (Point) shape, detailLevel, true, cells);
      assert cells.size() == initialCapacity;
    } else {
      cells = new ArrayList<Node>(inclParents ? 1024 : 512);
      recursiveGetNodes(getWorldNode(), shape, detailLevel, inclParents, cells);
    }
    if (inclParents) {
      Node c = cells.remove(0);//remove getWorldNode()
      assert c.getLevel() == 0;
    }
    return cells;
  }

