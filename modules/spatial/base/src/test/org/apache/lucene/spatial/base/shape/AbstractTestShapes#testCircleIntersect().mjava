  protected void testCircleIntersect() {
    //Now do some randomized tests:
    int i_C = 0, i_I = 0, i_W = 0, i_O = 0;//counters for the different intersection cases
    int laps = 0;
    int MINLAPSPERCASE = 20;
    while(i_C < MINLAPSPERCASE || i_I < MINLAPSPERCASE || i_W < MINLAPSPERCASE || i_O < MINLAPSPERCASE) {
      laps++;
      double cX = randRange(-180,179);
      double cY = randRange(-90,90);
      double cR = randRange(0, 180);
      double cR_dist = ctx.getDistCalc().distance(ctx.makePoint(0, 0), 0, cR);
      Circle c = ctx.makeCircle(cX, cY, cR_dist);

      double rX = randRange(-180,179);
      double rW = randRange(0,360);
      double rY1 = randRange(-90,90);
      double rY2 = randRange(-90,90);
      double rYmin = Math.min(rY1,rY2);
      double rYmax = Math.max(rY1,rY2);
      Rectangle r = ctx.makeRect(rX, rX+rW, rYmin, rYmax);

      SpatialRelation ic = c.relate(r, ctx);

      Point p;
      switch (ic) {
        case CONTAINS:
          i_C++;
          p = randomPointWithin(LuceneTestCase.random,r,ctx);
          Assert.assertEquals(CONTAINS, c.relate(p, ctx));
          break;
        case INTERSECTS:
          i_I++;
          //hard to test anything here; instead we'll test it separately
          break;
        case WITHIN:
          i_W++;
          p = randomPointWithin(LuceneTestCase.random,c,ctx);
          Assert.assertEquals(CONTAINS, r.relate(p, ctx));
          break;
        case DISJOINT:
          i_O++;
          p = randomPointWithin(LuceneTestCase.random,r,ctx);
          Assert.assertEquals(DISJOINT, c.relate(p, ctx));
          break;
        default: Assert.fail("" + ic);
      }
    }
    //System.out.println("Laps: "+laps);

    //TODO deliberately test INTERSECTS based on known intersection point
  }

