    @Override
    public int nextDoc() throws IOException {
      //System.out.println("Q.nextDoc() nextChildDoc=" + nextChildDoc);

      if (nextChildDoc == NO_MORE_DOCS) {
        //System.out.println("  end");
        return parentDoc = NO_MORE_DOCS;
      }

      // Gather all children sharing the same parent as nextChildDoc
      parentDoc = parentBits.nextSetBit(nextChildDoc);
      //System.out.println("  parentDoc=" + parentDoc);
      assert parentDoc != -1;

      float totalScore = 0;
      float maxScore = Float.NEGATIVE_INFINITY;

      childDocUpto = 0;
      do {
        //System.out.println("  c=" + nextChildDoc);
        if (pendingChildDocs.length == childDocUpto) {
          pendingChildDocs = ArrayUtil.grow(pendingChildDocs);
        }
        if (scoreMode != ScoreMode.None && pendingChildScores.length == childDocUpto) {
          pendingChildScores = ArrayUtil.grow(pendingChildScores);
        }
        pendingChildDocs[childDocUpto] = nextChildDoc;
        if (scoreMode != ScoreMode.None) {
          // TODO: specialize this into dedicated classes per-scoreMode
          final float childScore = childScorer.score();
          pendingChildScores[childDocUpto] = childScore;
          maxScore = Math.max(childScore, maxScore);
          totalScore += childScore;
        }
        childDocUpto++;
        nextChildDoc = childScorer.nextDoc();
      } while (nextChildDoc < parentDoc);
      //System.out.println("  nextChildDoc=" + nextChildDoc);

      // Parent & child docs are supposed to be orthogonal:
      assert nextChildDoc != parentDoc;

      switch(scoreMode) {
      case Avg:
        parentScore = totalScore / childDocUpto;
        break;
      case Max:
        parentScore = maxScore;
        break;
      case Total:
        parentScore = totalScore;
        break;
      case None:
        break;
      }

      //System.out.println("  return parentDoc=" + parentDoc);
      return parentDoc;
    }

