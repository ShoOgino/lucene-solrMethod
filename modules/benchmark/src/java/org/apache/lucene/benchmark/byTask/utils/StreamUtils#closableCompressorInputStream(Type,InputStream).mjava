  /**
   * Wrap the compressor input stream so that calling close will also close
   * the underlying stream - workaround for CommonsCompress bug (COMPRESS-127). 
   */
  private static InputStream closableCompressorInputStream(Type type, final InputStream is) throws CompressorException {
    final InputStream delegee = new CompressorStreamFactory().createCompressorInputStream(type.csfType, is);
    if (!Type.GZIP.equals(type)) {
      return delegee; //compressor bug affects only gzip
    }
    return new InputStream() {
			@Override	public int read() throws IOException { return delegee.read();	}
			@Override	public int read(byte[] b) throws IOException { return delegee.read(b);	}
			@Override	public int available() throws IOException {	return delegee.available();	}
			@Override	public synchronized void mark(int readlimit) { delegee.mark(readlimit);	}
			@Override	public boolean markSupported() { return delegee.markSupported(); }
			@Override	public int read(byte[] b, int off, int len) throws IOException { return delegee.read(b, off, len); }
			@Override	public synchronized void reset() throws IOException {	delegee.reset(); }
			@Override	public long skip(long n) throws IOException {	return delegee.skip(n);	}
			@Override	
			public void close() throws IOException { 
				delegee.close();
				is.close();
			}
    };
	}

