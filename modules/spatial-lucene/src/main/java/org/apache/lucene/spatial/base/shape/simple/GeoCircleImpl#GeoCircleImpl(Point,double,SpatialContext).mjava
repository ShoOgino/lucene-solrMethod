  public GeoCircleImpl(Point p, double dist, SpatialContext ctx) {
    super(p, dist, ctx);
    assert ctx.isGeo();

    //In the direction of latitude (N,S), distance is the same number of degrees.
    distDEG = ctx.getDistCalc().distanceToDegrees(distance);

    if (distDEG > 90) {
      assert enclosingBox.getWidth() == 360;
      double backDistDEG = 180 - distDEG;
      if (backDistDEG >= 0) {
        double backDistance = ctx.getDistCalc().degreesToDistance(backDistDEG);
        Point backPoint = ctx.makePoint(getCenter().getX() + 180, getCenter().getY() + 180);
        inverseCircle = new GeoCircleImpl(backPoint,backDistance,ctx);
      } else
        inverseCircle = null;//whole globe
      horizAxisY = getCenter().getY();//although probably not used
    } else {
      inverseCircle = null;
      double _horizAxisY = ctx.getDistCalc().calcBoxByDistFromPtHorizAxis(getCenter(), distance, ctx);
      //some rare numeric conditioning cases can cause this to be barely beyond the box
      if (_horizAxisY > enclosingBox.getMaxY()) {
        horizAxisY = enclosingBox.getMaxY();
      } else if (_horizAxisY < enclosingBox.getMinY()) {
        horizAxisY = enclosingBox.getMinY();
      } else {
        horizAxisY = _horizAxisY;
      }
      //assert enclosingBox.relate_yRange(horizAxis,horizAxis,ctx).intersects();
    }

  }

