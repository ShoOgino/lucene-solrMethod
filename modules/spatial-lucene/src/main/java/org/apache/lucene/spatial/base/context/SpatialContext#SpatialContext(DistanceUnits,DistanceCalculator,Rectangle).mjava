  /**
   *
   * @param units Required; and establishes geo vs cartesian.
   * @param calculator Optional; defaults to Haversine or cartesian depending on units.
   * @param worldBounds Optional; defaults to GEO_WORLDBOUNDS or MAX_WORLDBOUNDS depending on units.
   */
  protected SpatialContext(DistanceUnits units, DistanceCalculator calculator, Rectangle worldBounds) {
    if (units == null)
      throw new IllegalArgumentException("units can't be null");
    this.units = units;

    if (calculator == null) {
      calculator = isGeo()
          ? new GeodesicSphereDistCalc.Haversine(units.earthRadius())
          : new CartesianDistCalc();
    }
    this.calculator = calculator;

    if (worldBounds == null) {
      worldBounds = isGeo() ? GEO_WORLDBOUNDS : MAX_WORLDBOUNDS;
    } else {
      if (isGeo())
        assert new RectangleImpl(worldBounds).equals(GEO_WORLDBOUNDS);
      if (worldBounds.getCrossesDateLine())
        throw new IllegalArgumentException("worldBounds shouldn't cross dateline: "+worldBounds);
    }
    //copy so we can ensure we have the right implementation
    worldBounds = makeRect(worldBounds.getMinX(),worldBounds.getMaxX(),worldBounds.getMinY(),worldBounds.getMaxY());
    this.worldBounds = worldBounds;
    
    this.maxCircleDistance = isGeo() ? calculator.degreesToDistance(180) : null;
  }

