  /**
   * Take all the categories of one or more given taxonomies, and add them to
   * the main taxonomy (this), if they are not already there.
   * <P>
   * Additionally, fill a <I>mapping</I> for each of the added taxonomies,
   * mapping its ordinals to the ordinals in the enlarged main taxonomy.
   * These mapping are saved into an array of OrdinalMap objects given by the
   * user, one for each of the given taxonomies (not including "this", the main
   * taxonomy). Often the first of these will be a MemoryOrdinalMap and the
   * others will be a DiskOrdinalMap - see discussion in {OrdinalMap}. 
   * <P> 
   * Note that the taxonomies to be added are given as Directory objects,
   * not opened TaxonomyReader/TaxonomyWriter objects, so if any of them are
   * currently managed by an open TaxonomyWriter, make sure to commit() (or
   * close()) it first. The main taxonomy (this) is an open TaxonomyWriter,
   * and does not need to be commit()ed before this call. 
   */
  public void addTaxonomies(Directory[] taxonomies, OrdinalMap[] ordinalMaps) throws IOException {
    // To prevent us stepping on the rest of this class's decisions on when
    // to open a reader, and when not, we'll be opening a new reader instead
    // of using the existing "reader" object:
    IndexReader mainreader = openReader();
    // TODO (Facet): can this then go segment-by-segment and avoid MultiDocsEnum etc?
    Terms terms = MultiFields.getTerms(mainreader, Consts.FULL);
    assert terms != null; // TODO (Facet): explicit check / throw exception?
    TermsEnum mainte = terms.iterator();
    DocsEnum mainde = null;

    IndexReader[] otherreaders = new IndexReader[taxonomies.length];
    TermsEnum[] othertes = new TermsEnum[taxonomies.length];
    DocsEnum[] otherdocsEnum = new DocsEnum[taxonomies.length]; // just for reuse
    for (int i=0; i<taxonomies.length; i++) {
      otherreaders[i] = IndexReader.open(taxonomies[i]);
      terms = MultiFields.getTerms(otherreaders[i], Consts.FULL);
      assert terms != null; // TODO (Facet): explicit check / throw exception?
      othertes[i] = terms.iterator();
      // Also tell the ordinal maps their expected sizes:
      ordinalMaps[i].setSize(otherreaders[i].numDocs());
    }

    CategoryPath cp = new CategoryPath();

    // We keep a "current" cursor over the alphabetically-ordered list of
    // categories in each taxonomy. We start the cursor on the first
    // (alphabetically) category of each taxonomy:

    String currentMain;
    String[] currentOthers = new String[taxonomies.length];
    currentMain = nextTE(mainte);
    int otherTaxonomiesLeft = 0;
    for (int i=0; i<taxonomies.length; i++) {
      currentOthers[i] = nextTE(othertes[i]);
      if (currentOthers[i]!=null) {
        otherTaxonomiesLeft++;
      }
    }

    // And then, at each step look at the first (alphabetically) of the
    // current taxonomies.
    // NOTE: The most efficient way we could have done this is using a
    // PriorityQueue. But for simplicity, and assuming that usually we'll
    // have a very small number of other taxonomies (often just 1), we use
    // a more naive algorithm (o(ntaxonomies) instead of o(ln ntaxonomies)
    // per step)

    while (otherTaxonomiesLeft>0) {
      // TODO: use a pq here
      String first=null;
      for (int i=0; i<taxonomies.length; i++) {
        if (currentOthers[i]==null) continue;
        if (first==null || first.compareTo(currentOthers[i])>0) {
          first = currentOthers[i];
        }
      }
      int comp = 0;
      if (currentMain==null || (comp = currentMain.compareTo(first))>0) {
        // If 'first' is before currentMain, or currentMain is null,
        // then 'first' is a new category and we need to add it to the
        // main taxonomy. Then for all taxonomies with this 'first'
        // category, we need to add the new category number to their
        // map, and move to the next category in all of them.
        cp.clear();
        cp.add(first, delimiter);
        // We can call internalAddCategory() instead of addCategory()
        // because we know the category hasn't been seen yet.
        int newordinal = internalAddCategory(cp, cp.length());
        // TODO (Facet): we already had this term in our hands before, in nextTE...
        // // TODO (Facet): no need to make this term?
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // remember the remapping of this ordinal. Note how
            // this requires reading a posting list from the index -
            // but since we do this in lexical order of terms, just
            // like Lucene's merge works, we hope there are few seeks.
            // TODO (Facet): is there a quicker way? E.g., not specifying the
            // next term by name every time?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);
            // and move to the next category in the i'th taxonomy 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }
      } else if (comp==0) {
        // 'first' and currentMain are the same, so both the main and some
        // other taxonomies need to be moved, but a category doesn't need
        // to be added because it already existed in the main taxonomy.

        // TODO (Facet): Again, is there a quicker way?
        mainde = mainte.docs(MultiFields.getDeletedDocs(mainreader), mainde);
        mainde.nextDoc(); // TODO (Facet): check?
        int newordinal = mainde.docID();

        currentMain = nextTE(mainte);
        for (int i=0; i<taxonomies.length; i++) {
          if (first.equals(currentOthers[i])) {
            // TODO (Facet): again, is there a quicker way?
            otherdocsEnum[i] = othertes[i].docs(MultiFields.getDeletedDocs(otherreaders[i]), otherdocsEnum[i]);
            otherdocsEnum[i].nextDoc(); // TODO (Facet): check?
            int origordinal = otherdocsEnum[i].docID();
            ordinalMaps[i].addMapping(origordinal, newordinal);

            // and move to the next category 
            currentOthers[i] = nextTE(othertes[i]);
            if (currentOthers[i]==null) {
              otherTaxonomiesLeft--;
            }
          }
        }
      } else /* comp > 0 */ {
        // The currentMain doesn't appear in any of the other taxonomies -
        // we don't need to do anything, just continue to the next one
        currentMain = nextTE(mainte);
      }
    }

    // Close all the readers we've opened, and also tell the ordinal maps
    // we're done adding to them
    mainreader.close();
    for (int i=0; i<taxonomies.length; i++) {
      otherreaders[i].close();
      // We never actually added a mapping for the root ordinal - let's do
      // it now, just so that the map is complete (every ordinal between 0
      // and size-1 is remapped)
      ordinalMaps[i].addMapping(0, 0);
      ordinalMaps[i].addDone();
    }
  }

