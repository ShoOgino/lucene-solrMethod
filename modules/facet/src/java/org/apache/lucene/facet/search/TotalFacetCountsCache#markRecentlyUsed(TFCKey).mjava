  /**
   * Mark key as it as recently used.
   * <p>
   * <b>Implementation notes: Synchronization considerations and the interaction between lruKeys and cache:</b>
   * <ol>
   *  <li>A concurrent {@link LinkedHashMap} would have made this class much simpler.
   *      But unfortunately, Java does not provide one.
   *      Instead, we combine two concurrent objects:
   *  <ul>
   *   <li>{@link ConcurrentHashMap} for the cached TFCs.
   *   <li>{@link ConcurrentLinkedQueue} for active keys
   *  </ul>
   *  <li>Both {@link #lruKeys} and {@link #cache} are concurrently safe.
   *  <li>Checks for a cached item through getTotalCounts() are not synchronized.
   *      Therefore, the case that a needed TFC is in the cache is very fast:
   *      it does not wait for the computation of other TFCs.
   *  <li>computeAndCache() is synchronized, and, has a (double) check of the required
   *       TFC, to avoid computing the same TFC twice. 
   *  <li>A race condition in this method (markRecentlyUsed) might result in two copies 
   *      of the same 'key' in lruKeys, but this is handled by the loop in trimCache(), 
   *      where an attempt to remove the same key twice is a no-op.
   * </ol>
   */
  private void markRecentlyUsed(TFCKey key) {
    lruKeys.remove(key);  
    lruKeys.add(key);
  }

