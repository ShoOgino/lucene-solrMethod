  /**
   * Self-test.
   */
  public static void main(String[] args) throws Exception {
    RandomSample.returnTimings = true;
    /*
     * Create an array of sequential integers, from which samples will be taken.
     */
    final int COLLECTION_SIZE = 10 * 1000 * 1000;
    ScoredDocIDs collection = createAllScoredDocs(COLLECTION_SIZE);

    /*
     * Factor PHI.
     *
        int[] factors = RandomSample.factor(PHI_32);
        System.out.print("Factors of PHI_32: ");
        for (int k : factors) {
          System.out.print(k+", ");
        }
        System.out.println("");

     * Verify inverse relationship of PHI & phi.
     *
        boolean inverseValid = true;
        for (int j = 0; j < Integer.MAX_VALUE; j++) {
          int k = (int)(j * PHI_32) & 0x7FFFFFFF;
          int m = (int)(k * PHI_32I) & 0X7FFFFFFF;
          if (j != m) {
            System.out.println("Inverse not valid for "+j);
            inverseValid = false;
          }
        }
        System.out.println("Inverse valid? "+inverseValid);
     */
    /*
     * Take samples of various sizes from the full set, verify no duplicates,
     * check flatness.
     */
    int[] sampleSizes = {
        10, 57, 100, 333, 1000, 2154, 10000
    };
    Algorithm[] algorithms = { Algorithm.HASHING, Algorithm.TRAVERSAL };
    for (int sampleSize : sampleSizes) {
      for (Algorithm algorithm : algorithms) {
        System.out.println("Sample size " + sampleSize
            + ", algorithm " + algorithm + "...");
        /*
         * Take the sample.
         */
        int[] sample = RandomSample.repeatableSample(
            collection, COLLECTION_SIZE, sampleSize, algorithm, Sorted.YES);
        /*
         * Check for duplicates.
         */
        boolean noDups = true;
        for (int j = 0; j < sampleSize - 1; j++) {
          if (sample[j] == sample[j + 1]) {
            System.out.println("Duplicate value "
                + sample[j] + " at " + j + ", "
                + (j + 1));
            noDups = false;
            break;
          }
        }
        if (noDups) {
          System.out.println("No duplicates.");
        }
        if (algorithm == Algorithm.HASHING) {
          System.out.print("Hashed sample, up to 100 of "+sampleSize+": ");
          int lim = Math.min(100, sampleSize);
          for (int k = 0; k < lim; k++) {
            System.out.print(sample[k]+", ");
          }
          System.out.println("");
        }
        /*
         * Check flatness of distribution in sample.
         */
        final int N_INTERVALS = 100;
        int[] counts = RandomSample.countsBySubrange(sample, COLLECTION_SIZE, N_INTERVALS);
        int minCount = Integer.MAX_VALUE;
        int maxCount = Integer.MIN_VALUE;
        int avgCount = 0;
        for (int j = 0; j < N_INTERVALS; j++) {
          int count = counts[j];
          if (count < minCount) {
            minCount = count;
          }
          if (count > maxCount) {
            maxCount = count;
          }
          avgCount += count;
        }
        avgCount /= N_INTERVALS;
        System.out.println("Min, max, avg: "+minCount+", "+maxCount+", "+avgCount);

        if (((double)minCount - avgCount)/avgCount < -0.05 && (minCount - avgCount) < -5) {
          System.out.println("Not flat enough.");
        } else if (((double)maxCount - avgCount)/avgCount > 0.05 && (maxCount - avgCount) > 5) {
          System.out.println("Not flat enough.");
        } else {
          System.out.println("Flat enough.");
        }
        if (sampleSize == 10544 && algorithm == Algorithm.TRAVERSAL) {
          System.out.print("Counts of interest: ");
          for (int j = 0; j < N_INTERVALS; j++) {
            System.out.print(counts[j]+", ");
          }
          System.out.println("");
        }
      }
    }
    System.out.println("Last prime is "
        + RandomSample.primes[RandomSample.N_PRIMES - 1]);
  }

