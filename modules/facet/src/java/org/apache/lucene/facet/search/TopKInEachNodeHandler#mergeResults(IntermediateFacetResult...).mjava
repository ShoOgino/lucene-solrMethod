  /**
   * Merge several partitions' {@link IntermediateFacetResult}-s into one of the
   * same format
   * 
   * @see FacetResultsHandler#mergeResults(IntermediateFacetResult...)
   */
  @Override
  public IntermediateFacetResult mergeResults(IntermediateFacetResult... tmpResults)
  throws ClassCastException, IllegalArgumentException {

    if (tmpResults.length == 0) {
      return null;
    }

    int i=0;
    // skip over null tmpResults
    for (; (i < tmpResults.length)&&(tmpResults[i] == null); i++) {}
    if (i == tmpResults.length) {
      // all inputs are null
      return null;
    }

    // i points to the first non-null input 
    int K = this.facetRequest.getNumResults(); // number of best result in each node
    IntermediateFacetResultWithHash tmpToReturn = (IntermediateFacetResultWithHash)tmpResults[i++];

    // now loop over the rest of tmpResults and merge each into tmpToReturn
    for ( ; i < tmpResults.length; i++) {
      IntermediateFacetResultWithHash tfr = (IntermediateFacetResultWithHash)tmpResults[i];
      tmpToReturn.totalNumOfFacetsConsidered += tfr.totalNumOfFacetsConsidered;
      if (tfr.isRootNodeIncluded) {
        tmpToReturn.isRootNodeIncluded = true;
        tmpToReturn.rootNodeValue = tfr.rootNodeValue;
      }
      // now merge the HashMap of tfr into this of tmpToReturn
      IntToObjectMap<AACO> tmpToReturnMapToACCOs = tmpToReturn.mapToAACOs;
      IntToObjectMap<AACO> tfrMapToACCOs = tfr.mapToAACOs;
      IntIterator tfrIntIterator = tfrMapToACCOs.keyIterator();
      //iterate over all ordinals in tfr that are maps to their children (and the residue over 
      // non included chilren)
      while (tfrIntIterator.hasNext()) {
        int tfrkey = tfrIntIterator.next();
        AACO tmpToReturnAACO = null;
        if (null == (tmpToReturnAACO = tmpToReturnMapToACCOs.get(tfrkey))) {
          // if tmpToReturn does not have any kids of tfrkey, map all the kids
          // from tfr to it as one package, along with their redisude
          tmpToReturnMapToACCOs.put(tfrkey, tfrMapToACCOs.get(tfrkey));
        } else {
          // merge the best K children of tfrkey as appear in tmpToReturn and in tfr
          AACO tfrAACO = tfrMapToACCOs.get(tfrkey);
          int resLength = tfrAACO.ordinals.length + tmpToReturnAACO.ordinals.length;
          if (K < resLength) {
            resLength = K;
          }
          int[] resOrds = new int [resLength];
          double[] resVals = new double [resLength];
          double resResidue = tmpToReturnAACO.residue + tfrAACO.residue;
          int indexIntoTmpToReturn = 0;
          int indexIntoTFR = 0;
          ACComparator merger = getSuitableACComparator(); // by facet Request
          for (int indexIntoRes = 0; indexIntoRes < resLength; indexIntoRes++) {
            if (indexIntoTmpToReturn >= tmpToReturnAACO.ordinals.length) {
              //tmpToReturnAACO (former result to return) ran out of indices
              // it is all merged into resOrds and resVal
              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];
              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];
              indexIntoTFR++;
              continue;
            }
            if (indexIntoTFR >= tfrAACO.ordinals.length) {
              // tfr ran out of indices
              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];
              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];
              indexIntoTmpToReturn++;
              continue;
            }
            // select which goes now to res: next (ord, value) from tmpToReturn or from tfr:
            if (merger.leftGoesNow(  tmpToReturnAACO.ordinals[indexIntoTmpToReturn], 
                tmpToReturnAACO.values[indexIntoTmpToReturn], 
                tfrAACO.ordinals[indexIntoTFR], 
                tfrAACO.values[indexIntoTFR])) {
              resOrds[indexIntoRes] = tmpToReturnAACO.ordinals[indexIntoTmpToReturn];
              resVals[indexIntoRes] = tmpToReturnAACO.values[indexIntoTmpToReturn];
              indexIntoTmpToReturn++;
            } else {
              resOrds[indexIntoRes] = tfrAACO.ordinals[indexIntoTFR];
              resVals[indexIntoRes] = tfrAACO.values[indexIntoTFR];
              indexIntoTFR++;
            }
          } // end of merge of best kids of tfrkey that appear in tmpToReturn and its kids that appear in tfr
          // altogether yielding no more that best K kids for tfrkey, not to appear in the new shape of 
          // tmpToReturn

          while (indexIntoTmpToReturn < tmpToReturnAACO.ordinals.length) {
            resResidue += tmpToReturnAACO.values[indexIntoTmpToReturn++];
          }
          while (indexIntoTFR < tfrAACO.ordinals.length) {
            resResidue += tfrAACO.values[indexIntoTFR++];
          }
          //update the list of best kids of tfrkey as appear in tmpToReturn
          tmpToReturnMapToACCOs.put(tfrkey, new AACO(resOrds, resVals, resResidue));
        } // endof need to merge both AACO -- children and residue for same ordinal

      } // endof loop over all ordinals in tfr 
    } // endof loop over all temporary facet results to merge

    return tmpToReturn;
  }

