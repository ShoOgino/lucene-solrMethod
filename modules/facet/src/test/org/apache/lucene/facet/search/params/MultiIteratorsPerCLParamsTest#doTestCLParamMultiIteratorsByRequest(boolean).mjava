  private void doTestCLParamMultiIteratorsByRequest(boolean cacheCLI) throws Exception,
      CorruptIndexException, IOException {
    // Create a CLP which generates different CLIs according to the
    // FacetRequest's dimension
    CategoryListParams clp = new CategoryListParams();
    FacetIndexingParams iParams = new DefaultFacetIndexingParams(clp);
    Directory indexDir = newDirectory();
    Directory taxoDir = newDirectory();
    populateIndex(iParams, indexDir, taxoDir);

    TaxonomyReader taxo = new LuceneTaxonomyReader(taxoDir);
    IndexReader reader = IndexReader.open(indexDir);

    CategoryListCache clCache = null;
    if (cacheCLI) {
      // caching the iteratorr, so:
      // 1: create the cached iterator, using original params
      clCache = new CategoryListCache();
      clCache.loadAndRegister(clp, reader, taxo, iParams);
    }
    
    ScoredDocIDs allDocs = ScoredDocIdsUtils
        .createAllDocsScoredDocIDs(reader);

    // Search index with 'author' should filter ONLY ordinals whose parent
    // is 'author'
    countForbiddenDimension = "date";
    validateFacetedSearch(iParams, taxo, reader, clCache, allDocs, "author", 5, 5);

    // Search index with 'date' should filter ONLY ordinals whose parent is
    // 'date'
    countForbiddenDimension = "author";
    validateFacetedSearch(iParams, taxo, reader, clCache, allDocs, "date", 5, 2);

    // Search index with both 'date' and 'author'
    countForbiddenDimension = null;
    validateFacetedSearch(iParams, taxo, reader, clCache, allDocs, new String[] {
            "author", "date" }, new int[] { 5, 5 }, new int[] { 5, 2 });
    taxo.close();
    reader.close();
    indexDir.close();
    taxoDir.close();
  }

