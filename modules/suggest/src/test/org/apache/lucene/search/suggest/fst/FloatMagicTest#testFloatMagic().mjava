  public void testFloatMagic() {
    ArrayList<Float> floats = new ArrayList<Float>(Arrays.asList(new Float [] {
        Float.intBitsToFloat(0x7f800001), // NaN (invalid combination).
        Float.intBitsToFloat(0x7fffffff), // NaN (invalid combination).
        Float.intBitsToFloat(0xff800001), // NaN (invalid combination).
        Float.intBitsToFloat(0xffffffff), // NaN (invalid combination).
        Float.POSITIVE_INFINITY,
        Float.MAX_VALUE,
        100f,
        0f,
        0.1f,
        Float.MIN_VALUE,
        Float.NaN,
        -0.0f,
        -Float.MIN_VALUE,
        -0.1f,
        -1f,
        -10f,
        Float.NEGATIVE_INFINITY }));

    // Sort them using juc.
    Collections.sort(floats);
    
    // Convert to sortable int4 representation (as long to have an unsigned sort).
    long [] int4 = new long [floats.size()];
    for (int i = 0; i < floats.size(); i++) {
      int4[i] = FloatMagic.toSortable(floats.get(i)) & 0xffffffffL;

      System.out.println(
          String.format("raw %8s sortable %8s %8s numutils %8s %s",
              Integer.toHexString(Float.floatToRawIntBits(floats.get(i))),
              Integer.toHexString(FloatMagic.toSortable(floats.get(i))),
              Integer.toHexString(FloatMagic.unsignedOrderedToFloatBits(FloatMagic.toSortable(floats.get(i)))),
              Integer.toHexString(NumericUtils.floatToSortableInt(floats.get(i))),
              floats.get(i)));
    }

    // Sort and compare. Should be identical order.
    Arrays.sort(int4);
    ArrayList<Float> backFromFixed = new ArrayList<Float>();
    for (int i = 0; i < int4.length; i++) {
      backFromFixed.add(FloatMagic.fromSortable((int) int4[i]));
    }

    for (int i = 0; i < int4.length; i++) {
      System.out.println(
          floats.get(i) + " " + FloatMagic.fromSortable((int) int4[i]));
    }
    
    assertEquals(floats, backFromFixed);
  }

