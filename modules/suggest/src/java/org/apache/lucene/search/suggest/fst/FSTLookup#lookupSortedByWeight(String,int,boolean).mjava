  /**
   * Lookup suggestions sorted by weight (descending order).
   * 
   * @param collectAll If <code>true</code>, the routine terminates immediately when <code>num</code>
   * suggestions have been collected. If <code>false</code>, it will collect suggestions from
   * all weight arcs (needed for {@link #lookupSortedAlphabetically}.
   */
  private ArrayList<LookupResult> lookupSortedByWeight(String key, int num, boolean collectAll) throws IOException {
    // Don't overallocate the results buffers. This also serves the purpose of allowing
    // the user of this class to request all matches using Integer.MAX_VALUE as the number
    // of results.
    final ArrayList<LookupResult> res = new ArrayList<LookupResult>(Math.min(10, num));
    final StringBuilder output = new StringBuilder(key);
    final int matchLength = key.length() - 1;
    
    for (int i = 0; i < rootArcs.length; i++) {
      final FST.Arc<Object> rootArc = rootArcs[i];
      final FST.Arc<Object> arc = new FST.Arc<Object>().copyFrom(rootArc);

      // Descend into the automaton using the key as prefix.
      if (descendWithPrefix(arc, key)) {
        // Prefix-encoded weight.
        final float weight = rootArc.label / (float) buckets;

        // A subgraph starting from the current node has the completions 
        // of the key prefix. The arc we're at is the last key's byte,
        // so we will collect it too.
        output.setLength(matchLength);
        if (collect(res, num, weight, output, arc) && !collectAll) {
          // We have enough suggestions to return immediately. Keep on looking for an
          // exact match, if requested.
          if (exactMatchFirst) {
            if (!checkExistingAndReorder(res, key)) {
              Float exactMatchWeight = getExactMatchStartingFromRootArc(i, key);
              if (exactMatchWeight != null) {
                // Insert as the first result and truncate at num.
                while (res.size() >= num) {
                  res.remove(res.size() - 1);
                }
                res.add(0, new LookupResult(key, exactMatchWeight));
              }
            }
          }
          break;
        }
      }
    }
    return res;
  }

