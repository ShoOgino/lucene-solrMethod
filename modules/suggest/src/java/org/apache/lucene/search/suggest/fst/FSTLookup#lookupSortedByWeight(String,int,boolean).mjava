  /**
   * Lookup suggestions sorted by weight (descending order).
   * 
   * @param greedy If <code>true</code>, the routine terminates immediately when <code>num</code>
   * suggestions have been collected. If <code>false</code>, it will collect suggestions from
   * all weight arcs (needed for {@link #lookupSortedAlphabetically}.
   */
  private ArrayList<LookupResult> lookupSortedByWeight(String key, int num, boolean greedy) throws IOException {
    final ArrayList<LookupResult> res = new ArrayList<LookupResult>(Math.min(10, num));
    final StringBuilder output = new StringBuilder(key);
    final int matchLength = key.length() - 1;
    
    for (int i = 0; i < rootArcs.length; i++) {
      final FST.Arc<Object> rootArc = rootArcs[i];
      final FST.Arc<Object> arc = new FST.Arc<Object>().copyFrom(rootArc);

      // Descend into the automaton using the key as prefix.
      if (descendWithPrefix(arc, key)) {
        // Prefix-encoded weight.
        final float weight = rootArc.label / (float) buckets;

        // A subgraph starting from the current node has the completions 
        // of the key prefix. The arc we're at is the last key's byte,
        // so we will collect it too.
        output.setLength(matchLength);
        if (collect(res, num, weight, output, arc) && greedy) {
          // We have enough suggestion to return immediately. Keep on looking for an
          // exact match, if requested.
          if (exactMatchFirst) {
            Float exactMatchWeight = getExactMatchStartingFromRootArc(i, key);
            if (exactMatchWeight != null) {
              res.add(0, new LookupResult(key, exactMatchWeight));
              while (res.size() > num) {
                res.remove(res.size() - 1);
              }
            }
          }
          break;
        }
      }
    }
    return res;
  }

