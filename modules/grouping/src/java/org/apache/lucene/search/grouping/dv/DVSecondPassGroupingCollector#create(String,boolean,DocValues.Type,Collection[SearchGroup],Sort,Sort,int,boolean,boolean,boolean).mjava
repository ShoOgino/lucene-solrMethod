  /**
   * Constructs a {@link DVSecondPassGroupingCollector}.
   * Selects and constructs the most optimal second pass collector implementation for grouping by {@link DocValues}.
   *
   * @param groupField      The field to group by
   * @param diskResident    Whether the values to group by should be disk resident
   * @param type            The {@link Type} which is used to select a concrete implementation.
   * @param searchGroups    The groups from the first phase search
   * @param groupSort       The sort used for the groups
   * @param withinGroupSort The sort used for documents inside a group
   * @param maxDocsPerGroup The maximum number of documents to collect per group
   * @param getScores       Whether to include scores for the documents inside a group
   * @param getMaxScores    Whether to keep track of the higest score per group
   * @param fillSortFields  Whether to include the sort values
   * @return the most optimal second pass collector implementation for grouping by {@link DocValues}
   * @throws IOException    If I/O related errors occur
   */
  @SuppressWarnings("unchecked")
  public static DVSecondPassGroupingCollector create(String groupField,
                                                     boolean diskResident,
                                                     DocValues.Type type,
                                                     Collection<SearchGroup> searchGroups,
                                                     Sort groupSort,
                                                     Sort withinGroupSort,
                                                     int maxDocsPerGroup,
                                                     boolean getScores,
                                                     boolean getMaxScores,
                                                     boolean fillSortFields) throws IOException {
    switch (type) {
      case VAR_INTS:
      case FIXED_INTS_8:
      case FIXED_INTS_16:
      case FIXED_INTS_32:
      case FIXED_INTS_64:
        // Type erasure b/c otherwise we have inconvertible types...
        return new Lng(groupField, type, diskResident, (Collection) searchGroups, groupSort, withinGroupSort, maxDocsPerGroup, getScores, getMaxScores, fillSortFields);
      case FLOAT_32:
      case FLOAT_64:
        // Type erasure b/c otherwise we have inconvertible types...
        return new Dbl(groupField, type, diskResident, (Collection) searchGroups, groupSort, withinGroupSort, maxDocsPerGroup, getScores, getMaxScores, fillSortFields);
      case BYTES_FIXED_STRAIGHT:
      case BYTES_FIXED_DEREF:
      case BYTES_VAR_STRAIGHT:
      case BYTES_VAR_DEREF:
        // Type erasure b/c otherwise we have inconvertible types...
        return new BR(groupField, type, diskResident, (Collection) searchGroups, groupSort, withinGroupSort, maxDocsPerGroup, getScores, getMaxScores, fillSortFields);
      case BYTES_VAR_SORTED:
      case BYTES_FIXED_SORTED:
        // Type erasure b/c otherwise we have inconvertible types...
        return new SortedBR(groupField, type, diskResident, (Collection) searchGroups, groupSort, withinGroupSort, maxDocsPerGroup, getScores, getMaxScores, fillSortFields);
      default:
        throw new IllegalArgumentException(String.format("ValueType %s not supported", type));
    }
  }

