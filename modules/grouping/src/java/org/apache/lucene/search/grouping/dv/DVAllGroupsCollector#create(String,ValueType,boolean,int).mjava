  /**
   * Expert: Constructs a {@link DVAllGroupsCollector}.
   * Selects and constructs the most optimal all groups collector implementation for grouping by {@link IndexDocValues}.
   * 
   *
   * @param groupField  The field to group by
   * @param type The {@link ValueType} which is used to select a concrete implementation.
   * @param diskResident Whether the values to group by should be disk resident
   * @param initialSize The initial allocation size of the
   *                    internal int set and group list
   *                    which should roughly match the total
   *                    number of expected unique groups. Be aware that the
   *                    heap usage is 4 bytes * initialSize. Not all concrete implementions use this!
   * @return the most optimal all groups collector implementation for grouping by {@link IndexDocValues}
   */
  public static DVAllGroupsCollector create(String groupField, ValueType type, boolean diskResident, int initialSize) {
    switch (type) {
      case VAR_INTS:
      case FIXED_INTS_8:
      case FIXED_INTS_16:
      case FIXED_INTS_32:
      case FIXED_INTS_64:
        return new Lng(groupField, type, diskResident);
      case FLOAT_32:
      case FLOAT_64:
        return new Dbl(groupField, type, diskResident);
      case BYTES_FIXED_STRAIGHT:
      case BYTES_FIXED_DEREF:
      case BYTES_VAR_STRAIGHT:
      case BYTES_VAR_DEREF:
        return new BR(groupField, type, diskResident);
      case BYTES_VAR_SORTED:
      case BYTES_FIXED_SORTED:
        return new SortedBR(groupField, type, diskResident, initialSize);
      default:
        throw new IllegalArgumentException(String.format("ValueType %s not supported", type));
    }
  }

