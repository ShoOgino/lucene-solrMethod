  /**
   * Replays the cached doc IDs (and scores) to the given Collector.
   * 
   * @throws IllegalStateException
   *           if this collector is not cached (i.e., if the RAM limits were too
   *           low for the number of documents + scores to cache).
   * @throws IllegalArgumentException
   *           if the given Collect's does not support out-of-order collection,
   *           while the collector passed to the ctor does.
   */
  public void replay(Collector other) throws IOException {
    if (!isCached()) {
      throw new IllegalStateException("cannot replay: cache was cleared because too much RAM was required");
    }
    
    if (!other.acceptsDocsOutOfOrder() && this.other.acceptsDocsOutOfOrder()) {
      throw new IllegalArgumentException(
          "cannot replay: given collector does not support "
              + "out-of-order collection, while the wrapped collector does. "
              + "Therefore cached documents may be out-of-order.");
    }

    //System.out.println("CC: replay totHits=" + (upto + base));
    if (lastReaderContext != null) {
      cachedSegs.add(new SegStart(lastReaderContext, base+upto));
      lastReaderContext = null;
    }
    
    int curupto = 0;
    int curbase = 0;
    int chunkUpto = 0;
    other.setScorer(cachedScorer);
    curDocs = EMPTY_INT_ARRAY;
    for(SegStart seg : cachedSegs) {
      other.setNextReader(seg.readerContext);
      while(curbase+curupto < seg.end) {
        if (curupto == curDocs.length) {
          curbase += curDocs.length;
          curDocs = cachedDocs.get(chunkUpto);
          if (cacheScores) {
            curScores = cachedScores.get(chunkUpto);
          }
          chunkUpto++;
          curupto = 0;
        }
        if (cacheScores) {
          cachedScorer.score = curScores[curupto];
        }
        other.collect(curDocs[curupto++]);
      }
    }
  }

