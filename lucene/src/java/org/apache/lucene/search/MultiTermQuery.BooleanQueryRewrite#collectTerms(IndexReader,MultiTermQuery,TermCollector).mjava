    protected final int collectTerms(IndexReader reader, MultiTermQuery query, TermCollector collector) throws IOException {
      final List<IndexReader> subReaders = new ArrayList<IndexReader>();
      ReaderUtil.gatherSubReaders(subReaders, reader);
      int count = 0;
      Comparator<BytesRef> lastTermComp = null;
      
      for (IndexReader r : subReaders) {
        final Fields fields = r.fields();
        if (fields == null) {
          // reader has no fields
          continue;
        }

        final Terms terms = fields.terms(query.field);
        if (terms == null) {
          // field does not exist
          continue;
        }

        final TermsEnum termsEnum = query.getTermsEnum(r, collector.attributes);
        assert termsEnum != null;

        if (termsEnum == TermsEnum.EMPTY)
          continue;
        
        // Check comparator compatibility:
        final Comparator<BytesRef> newTermComp = termsEnum.getComparator();
        if (lastTermComp != null && newTermComp != lastTermComp)
          throw new RuntimeException("term comparator should not change between segments: "+lastTermComp+" != "+newTermComp);
        lastTermComp = newTermComp;
        
        collector.setNextEnum(termsEnum);
        BytesRef bytes;
        while ((bytes = termsEnum.next()) != null) {
          if (collector.collect(bytes)) {
            termsEnum.cacheCurrentTerm();
            count++;
          } else {
            return count; // interrupt whole term collection, so also don't iterate other subReaders
          }
        }
      }
      return count;
    }

