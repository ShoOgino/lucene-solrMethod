  /**
   * Expert ctor:
   * Construct an enumerator based upon an automaton, enumerating the specified
   * field, working on a supplied reader.
   * <p>
   * @lucene.internal Use the public ctor instead. 
   * <p>
   * @param runAutomaton pre-compiled ByteRunAutomaton
   * @param finite true if the automaton accepts a finite language
   */
  AutomatonTermsEnum(ByteRunAutomaton runAutomaton,
                     String field, IndexReader reader,
                     boolean finite, BytesRef commonSuffixRef)
      throws IOException {
    super(reader, field);
    this.automaton = runAutomaton.getAutomaton();
    this.finite = finite;

    this.runAutomaton = runAutomaton;
    if (finite) {
      // don't use suffix w/ finite DFAs
      this.commonSuffixRef = null;
    } else if (commonSuffixRef == null) {
      // compute now
      this.commonSuffixRef = SpecialOperations.getCommonSuffixBytesRef(automaton);
    } else {
      // precomputed
      this.commonSuffixRef = commonSuffixRef;
    }

    // build a cache of sorted transitions for every state
    allTransitions = new Transition[runAutomaton.getSize()][];
    for (State state : this.automaton.getNumberedStates()) {
      state.sortTransitions(Transition.CompareByMinMaxThenDest);
      state.trimTransitionsArray();
      allTransitions[state.getNumber()] = state.transitionsArray;
    }
    // used for path tracking, where each bit is a numbered state.
    visited = new long[runAutomaton.getSize()];

    setUseTermsCache(finite);
    termComp = getComparator();
  }

