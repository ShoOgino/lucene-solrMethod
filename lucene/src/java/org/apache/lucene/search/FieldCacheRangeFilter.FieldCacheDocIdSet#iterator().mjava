    @Override
    public DocIdSetIterator iterator() throws IOException {
      // Synchronization needed because deleted docs BitVector
      // can change after call to hasDeletions until TermDocs creation.
      // We only use an iterator with termDocs, when this was requested (e.g.
      // range contains 0)
      // and the index has deletions

      final Bits skipDocs;
      synchronized (reader) {
        if (isCacheable()) {
          skipDocs = null;
        } else {
          skipDocs = MultiFields.getDeletedDocs(reader);
        }
      }
      final int maxDoc = reader.maxDoc();

      // a DocIdSetIterator generating docIds by
      // incrementing a variable & checking skipDocs -
      return new DocIdSetIterator() {
        private int doc = -1;
        @Override
        public int docID() {
          return doc;
        }
        
        @Override
        public int nextDoc() {
          try {
            do {
              doc++;
            } while ((skipDocs != null && doc < maxDoc && skipDocs.get(doc))
                || !matchDoc(doc));
            return doc;
          } catch (ArrayIndexOutOfBoundsException e) {
            return doc = NO_MORE_DOCS;
          }
        }
        
        @Override
        public int advance(int target) {
          try {
            doc = target;
            while (!matchDoc(doc)) {
              doc++;
            }
            return doc;
          } catch (ArrayIndexOutOfBoundsException e) {
            return doc = NO_MORE_DOCS;
          }

        }
      };
    }

