  /**
   * Increments the utf16 buffer to the next String in lexicographic order after s that will not put
   * the machine into a reject state. If such a string does not exist, returns
   * false.
   * 
   * The correctness of this method depends upon the automaton being deterministic,
   * and having no transitions to dead states.
   * 
   * @return true if more possible solutions exist for the DFA
   */
  private boolean nextString() {
    int state;
    int pos = 0;

    while (true) {
      curGen++;
      linear = false;
      state = runAutomaton.getInitialState();
      // walk the automaton until a character is rejected.
      for (pos = 0; pos < seekBytesRef.length; pos++) {
        visited[state] = curGen;
        int nextState = runAutomaton.step(state, seekBytesRef.bytes[pos] & 0xff);
        if (nextState == -1)
          break;
        // we found a loop, record it for faster enumeration
        if (!finite && !linear && visited[nextState] == curGen) {
          linear = true;
          infinitePosition = pos;
        }
        state = nextState;
      }

      // take the useful portion, and the last non-reject state, and attempt to
      // append characters that will match.
      if (nextString(state, pos)) {
        return true;
      } else { /* no more solutions exist from this useful portion, backtrack */
        if (!backtrack(pos)) /* no more solutions at all */
          return false;
        else if (runAutomaton.run(seekBytesRef.bytes, 0, seekBytesRef.length)) 
          /* String is good to go as-is */
          return true;
        /* else advance further */
      }
    }
  }

