    private Scorer createConjunctionTermScorer(AtomicReaderContext context, Bits acceptDocs)
        throws IOException {

      // TODO: fix scorer API to specify "needsScores" up
      // front, so we can do match-only if caller doesn't
      // needs scores

      final DocsAndFreqs[] docsAndFreqs = new DocsAndFreqs[weights.size()];
      for (int i = 0; i < docsAndFreqs.length; i++) {
        final TermWeight weight = (TermWeight) weights.get(i);
        final TermsEnum termsEnum = weight.getTermsEnum(context);
        if (termsEnum == null) {
          return null;
        }
        final ExactDocScorer docScorer = weight.createDocScorer(context);
        final DocsEnum docsAndFreqsEnum = termsEnum.docs(acceptDocs, null, true);
        if (docsAndFreqsEnum == null) {
          // TODO: we could carry over TermState from the
          // terms we already seek'd to, to save re-seeking
          // to make the match-only scorer, but it's likely
          // rare that BQ mixes terms from omitTf and
          // non-omitTF fields:

          // At least one sub cannot provide freqs; abort
          // and fallback to full match-only scorer:
          return createMatchOnlyConjunctionTermScorer(context, acceptDocs);
        }

        docsAndFreqs[i] = new DocsAndFreqs(docsAndFreqsEnum,
                                           docsAndFreqsEnum,
                                           termsEnum.docFreq(), docScorer);
      }
      return new ConjunctionTermScorer(this, disableCoord ? 1.0f : coord(
          docsAndFreqs.length, docsAndFreqs.length), docsAndFreqs);
    }

