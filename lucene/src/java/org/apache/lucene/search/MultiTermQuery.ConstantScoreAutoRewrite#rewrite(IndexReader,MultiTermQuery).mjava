    @Override
    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {

      // Get the enum and start visiting terms.  If we
      // exhaust the enum before hitting either of the
      // cutoffs, we use ConstantBooleanQueryRewrite; else,
      // ConstantFilterRewrite:
      final int docCountCutoff = (int) ((docCountPercent / 100.) * reader.maxDoc());
      final int termCountLimit = Math.min(BooleanQuery.getMaxClauseCount(), termCountCutoff);

      final CutOffTermCollector col = new CutOffTermCollector(docCountCutoff, termCountLimit);
      collectTerms(reader, query, col);
      final int size = col.pendingTerms.size();
      if (col.hasCutOff) {
        return CONSTANT_SCORE_FILTER_REWRITE.rewrite(reader, query);
      } else if (size == 0) {
        return new BooleanQuery(true);
      } else {
        final BooleanQuery bq = new BooleanQuery(true);
        final Term placeholderTerm = new Term(query.field);
        final BytesRefHash pendingTerms = col.pendingTerms;
        final int sort[] = pendingTerms.sort(col.termsEnum.getComparator());
        for(int i = 0; i < size; i++) {
          // docFreq is not used for constant score here, we pass 1
          // to explicitely set a fake value, so it's not calculated
          bq.add(new TermQuery(
            placeholderTerm.createTerm(pendingTerms.get(sort[i], new BytesRef())), 1
          ), BooleanClause.Occur.SHOULD);
        }
        // Strip scores
        final Query result = new ConstantScoreQuery(new QueryWrapperFilter(bq));
        result.setBoost(query.getBoost());
        query.incTotalNumberOfTerms(size);
        return result;
      }
    }

