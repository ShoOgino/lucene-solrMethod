  /** Provide the DocIdSet to be cached, using the DocIdSet provided
   *  by the wrapped Filter.
   *  <p>This implementation returns the given {@link DocIdSet}, if {@link DocIdSet#isCacheable}
   *  returns <code>true</code>, else it copies the {@link DocIdSetIterator} into
   *  an {@link FixedBitSet}.
   */
  protected SpanFilterResult spanFilterResultToCache(SpanFilterResult result, IndexReader reader) throws IOException {
    if (result == null || result.getDocIdSet() == null) {
      // this is better than returning null, as the nonnull result can be cached
      return SpanFilterResult.EMPTY_SPAN_FILTER_RESULT;
    } else if (result.getDocIdSet().isCacheable()) {
      return result;
    } else {
      final DocIdSetIterator it = result.getDocIdSet().iterator();
      // null is allowed to be returned by iterator(),
      // in this case we wrap with the empty set,
      // which is cacheable.
      if (it == null) {
        return SpanFilterResult.EMPTY_SPAN_FILTER_RESULT;
      } else {
        final FixedBitSet bits = new FixedBitSet(reader.maxDoc());
        bits.or(it);
        return new SpanFilterResult(bits, result.getPositions());
      }
    }
  }

