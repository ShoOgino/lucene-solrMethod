  /**
   * Returns the next String in lexicographic order that will not put
   * the machine into a reject state. 
   * 
   * This method traverses the DFA from the given position in the String,
   * starting at the given state.
   * 
   * If this cannot satisfy the machine, returns false. This method will
   * walk the minimal path, in lexicographic order, as long as possible.
   * 
   * If this method returns false, then there might still be more solutions,
   * it is necessary to backtrack to find out.
   * 
   * @param state current non-reject state
   * @param position useful portion of the string
   * @return true if more possible solutions exist for the DFA from this
   *         position
   */
  private boolean nextString(int state, int position) {
    /* 
     * the next lexicographic character must be greater than the existing
     * character, if it exists.
     */
    char c = 0;
    if (position < utf16.length) {
      c = utf16.result[position];
      // if the next character is U+FFFF and is not part of the useful portion,
      // then by definition it puts us in a reject state, and therefore this
      // path is dead. there cannot be any higher transitions. backtrack.
      if (c == '\uFFFF')
        return false;
      else
        c++;
    }

    utf16.setLength(position);
    visited[state] = curGen;

    Transition transitions[] = allTransitions[state];

    // find the minimal path (lexicographic order) that is >= c
    
    for (int i = 0; i < transitions.length; i++) {
      Transition transition = transitions[i];
      if (transition.getMax() >= c) {
        char nextChar = (char) Math.max(c, transition.getMin());
        // append either the next sequential char, or the minimum transition
        utf16.setLength(utf16.length + 1);
        utf16.result[utf16.length - 1] = nextChar;
        state = transition.getDest().getNumber();
        /* 
         * as long as is possible, continue down the minimal path in
         * lexicographic order. if a loop or accept state is encountered, stop.
         */
        while (visited[state] != curGen && !runAutomaton.isAccept(state)) {
          visited[state] = curGen;
          /* 
           * Note: we work with a DFA with no transitions to dead states.
           * so the below is ok, if it is not an accept state,
           * then there MUST be at least one transition.
           */
          transition = allTransitions[state][0];
          state = transition.getDest().getNumber();
          // we found a loop, record it for faster enumeration
          if (!finite && !linear && visited[state] == curGen) {
            linear = true;
            infinitePosition = utf16.length;
          }
          // append the minimum transition
          utf16.setLength(utf16.length + 1);
          utf16.result[utf16.length - 1] = transition.getMin();
        }
        return true;
      }
    }
    return false;
  }

