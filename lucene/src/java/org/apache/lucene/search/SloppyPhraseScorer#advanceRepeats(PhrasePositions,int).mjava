  /**
   * Advance repeating pps of an input (non-repeating) pp.
   * Return a modified 'end' in case pp or its repeats exceeds original 'end'.
   * "Dirty" trick: when there are repeats, modifies pp's position to that of 
   * least repeater of pp (needed when due to holes repeaters' positions are "back").
   */
  private int advanceRepeats(PhrasePositions pp, int end) throws IOException {
    int repeatsEnd = end;
    if (pp.position > repeatsEnd) {
      repeatsEnd = pp.position;
    }
    if (!hasRepeats) {
      return repeatsEnd;
    }
    int tpPos = tpPos(pp);
    for (PhrasePositions pp2=pp.nextRepeating; pp2!=null; pp2=pp2.nextRepeating) {
      while (tpPos(pp2) <= tpPos) {
        if (!pp2.nextPosition()) {
          return Integer.MIN_VALUE;
        }
      }
      tpPos = tpPos(pp2);
      if (pp2.position > repeatsEnd) {
        repeatsEnd = pp2.position;
      }
      // "dirty" trick: with holes, given a pp, its repeating pp2 might have smaller position.
      // so in order to have the right "start" in matchLength computation we fake pp.position.
      // this relies on pp.nextPosition() not using pp.position.
      if (pp2.position < pp.position) { 
        pp.position = pp2.position;     
      }
    }
    return repeatsEnd;
  }

