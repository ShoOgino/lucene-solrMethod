  /**
   * fired when the max non-competitive boost has changed. this is the hook to
   * swap in a smarter actualEnum
   */
  private void bottomChanged(float boostValue, BytesRef lastTerm)
      throws IOException {
    int oldMaxEdits = maxEdits;
    
    // as long as the max non-competitive boost is >= the max boost
    // for some edit distance, keep dropping the max edit distance.
    while (maxEdits > 0 && boostValue >= calculateMaxBoost(maxEdits))
      maxEdits--;
    
    if (oldMaxEdits != maxEdits) { // the maximum n has changed
      TermsEnum newEnum = getAutomatonEnum(maxEdits, lastTerm);
      if (newEnum != null) {
        setEnum(newEnum);
      }
    }
    // TODO, besides changing linear -> automaton, and swapping in a smaller
    // automaton, we can also use this information to optimize the linear case
    // itself: re-init maxDistances so the fast-fail happens for more terms due
    // to the now stricter constraints.
  }

