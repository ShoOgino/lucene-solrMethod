  /**
   * Returns a Weight that applies the filter to the enclosed query's Weight.
   * This is accomplished by overriding the Scorer returned by the Weight.
   */
  @Override
  public Weight createWeight(final IndexSearcher searcher) throws IOException {
    final Weight weight = query.createWeight (searcher);
    return new Weight() {
      
      @Override
      public boolean scoresDocsOutOfOrder() {
        // TODO: Support out-of-order scoring!
        // For now we return false here, as we always get the scorer in order
        return false;
      }

      @Override
      public float getValueForNormalization() throws IOException { 
        return weight.getValueForNormalization() * getBoost() * getBoost(); // boost sub-weight
      }

      @Override
      public void normalize (float norm, float topLevelBoost) { 
        weight.normalize(norm, topLevelBoost * getBoost()); // incorporate boost
      }

      @Override
      public Explanation explain (AtomicReaderContext ir, int i) throws IOException {
        Explanation inner = weight.explain (ir, i);
        Filter f = FilteredQuery.this.filter;
        DocIdSet docIdSet = f.getDocIdSet(ir, ir.reader().getLiveDocs());
        DocIdSetIterator docIdSetIterator = docIdSet == null ? DocIdSet.EMPTY_DOCIDSET.iterator() : docIdSet.iterator();
        if (docIdSetIterator == null) {
          docIdSetIterator = DocIdSet.EMPTY_DOCIDSET.iterator();
        }
        if (docIdSetIterator.advance(i) == i) {
          return inner;
        } else {
          Explanation result = new Explanation
            (0.0f, "failure to match filter: " + f.toString());
          result.addDetail(inner);
          return result;
        }
      }

      // return this query
      @Override
      public Query getQuery() { return FilteredQuery.this; }

      // return a filtering scorer
      @Override
      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder, boolean topScorer, Bits acceptDocs) throws IOException {
        assert filter != null;

        final DocIdSet filterDocIdSet = filter.getDocIdSet(context, acceptDocs);
        if (filterDocIdSet == null) {
          // this means the filter does not accept any documents.
          return null;
        }
        
        final DocIdSetIterator filterIter = filterDocIdSet.iterator();
        if (filterIter == null) {
          // this means the filter does not accept any documents.
          return null;
        }

        final int firstFilterDoc = filterIter.nextDoc();
        if (firstFilterDoc == DocIdSetIterator.NO_MORE_DOCS) {
          return null;
        }
        
        final Bits filterAcceptDocs = filterDocIdSet.bits();
        final boolean useRandomAccess = (filterAcceptDocs != null && FilteredQuery.this.useRandomAccess(filterAcceptDocs, firstFilterDoc));

        if (useRandomAccess) {
          // if we are using random access, we return the inner scorer, just with other acceptDocs
          // TODO, replace this by when BooleanWeight is fixed to be consistent with its scorer implementations:
          // return weight.scorer(context, scoreDocsInOrder, topScorer, filterAcceptDocs);
          return weight.scorer(context, true, topScorer, filterAcceptDocs);
        } else {
          assert firstFilterDoc > -1;
          // we are gonna advance() this scorer, so we set inorder=true/toplevel=false
          // we pass null as acceptDocs, as our filter has already respected acceptDocs, no need to do twice
          final Scorer scorer = weight.scorer(context, true, false, null);
          return (scorer == null) ? null : new Scorer(this) {
            private int scorerDoc = -1, filterDoc = firstFilterDoc;
            
            // optimization: we are topScorer and collect directly using short-circuited algo
            @Override
            public void score(Collector collector) throws IOException {
              int filterDoc = firstFilterDoc;
              int scorerDoc = scorer.advance(filterDoc);
              // the normalization trick already applies the boost of this query,
              // so we can use the wrapped scorer directly:
              collector.setScorer(scorer);
              for (;;) {
                if (scorerDoc == filterDoc) {
                  // Check if scorer has exhausted, only before collecting.
                  if (scorerDoc == DocIdSetIterator.NO_MORE_DOCS) {
                    break;
                  }
                  collector.collect(scorerDoc);
                  filterDoc = filterIter.nextDoc();
                  scorerDoc = scorer.advance(filterDoc);
                } else if (scorerDoc > filterDoc) {
                  filterDoc = filterIter.advance(scorerDoc);
                } else {
                  scorerDoc = scorer.advance(filterDoc);
                }
              }
            }
            
            private int advanceToNextCommonDoc() throws IOException {
              for (;;) {
                if (scorerDoc < filterDoc) {
                  scorerDoc = scorer.advance(filterDoc);
                } else if (scorerDoc == filterDoc) {
                  return scorerDoc;
                } else {
                  filterDoc = filterIter.advance(scorerDoc);
                }
              }
            }

            @Override
            public int nextDoc() throws IOException {
              // don't go to next doc on first call
              // (because filterIter is already on first doc):
              if (scorerDoc != -1) {
                filterDoc = filterIter.nextDoc();
              }
              return advanceToNextCommonDoc();
            }
            
            @Override
            public int advance(int target) throws IOException {
              if (target > filterDoc) {
                filterDoc = filterIter.advance(target);
              }
              return advanceToNextCommonDoc();
            }

            @Override
            public int docID() {
              return scorerDoc;
            }
            
            @Override
            public float score() throws IOException {
              return scorer.score();
            }
          };
        }
      }
    };
  }

