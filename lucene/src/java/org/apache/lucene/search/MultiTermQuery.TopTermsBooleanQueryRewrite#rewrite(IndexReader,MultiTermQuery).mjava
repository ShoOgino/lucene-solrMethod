    @Override
    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {
      final int maxSize = Math.min(size, BooleanQuery.getMaxClauseCount());
      final PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>();
      collectTerms(reader, query, new TermCollector() {
        private final MaxNonCompetitiveBoostAttribute maxBoostAtt =
          attributes.addAttribute(MaxNonCompetitiveBoostAttribute.class);
        
        private final Map<BytesRef,ScoreTerm> visitedTerms = new HashMap<BytesRef,ScoreTerm>();
        
        private TermsEnum termsEnum;
        private Comparator<BytesRef> termComp;
        private BoostAttribute boostAtt;        
        private ScoreTerm st;
        
        @Override
        public void setNextEnum(TermsEnum termsEnum) throws IOException {
          this.termsEnum = termsEnum;
          this.termComp = termsEnum.getComparator();
          // lazy init the initial ScoreTerm because comparator is not known on ctor:
          if (st == null)
            st = new ScoreTerm(this.termComp);
          boostAtt = termsEnum.attributes().addAttribute(BoostAttribute.class);
        }
      
        @Override
        public boolean collect(BytesRef bytes) {
          final float boost = boostAtt.getBoost();
          // ignore uncompetetive hits
          if (stQueue.size() == maxSize) {
            final ScoreTerm t = stQueue.peek();
            if (boost < t.boost)
              return true;
            if (boost == t.boost && termComp.compare(bytes, t.bytes) > 0)
              return true;
          }
          ScoreTerm t = visitedTerms.get(bytes);
          if (t != null) {
            // if the term is already in the PQ, only update docFreq of term in PQ
            t.docFreq += termsEnum.docFreq();
            assert t.boost == boost : "boost should be equal in all segment TermsEnums";
          } else {
            // add new entry in PQ, we must clone the term, else it may get overwritten!
            st.bytes.copy(bytes);
            st.boost = boost;
            st.docFreq = termsEnum.docFreq();
            visitedTerms.put(st.bytes, st);
            stQueue.offer(st);
            // possibly drop entries from queue
            if (stQueue.size() > maxSize) {
              st = stQueue.poll();
              visitedTerms.remove(st.bytes);
            } else {
              st = new ScoreTerm(termComp);
            }
            assert stQueue.size() <= maxSize : "the PQ size must be limited to maxSize";
            // set maxBoostAtt with values to help FuzzyTermsEnum to optimize
            if (stQueue.size() == maxSize) {
              t = stQueue.peek();
              maxBoostAtt.setMaxNonCompetitiveBoost(t.boost);
              maxBoostAtt.setCompetitiveTerm(t.bytes);
            }
          }
          return true;
        }
      });
      
      final Term placeholderTerm = new Term(query.field);
      final BooleanQuery bq = new BooleanQuery(true);
      final ScoreTerm[] scoreTerms = stQueue.toArray(new ScoreTerm[stQueue.size()]);
      ArrayUtil.quickSort(scoreTerms, scoreTermSortByTermComp);
      for (final ScoreTerm st : scoreTerms) {
        final Term term = placeholderTerm.createTerm(st.bytes);
        assert reader.docFreq(term) == st.docFreq;
        Query tq = getQuery(term, st.docFreq);
        tq.setBoost(query.getBoost() * st.boost); // set the boost
        bq.add(tq, BooleanClause.Occur.SHOULD);   // add to query
      }
      query.incTotalNumberOfTerms(scoreTerms.length);
      return bq;
    }

