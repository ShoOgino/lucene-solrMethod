  /**
   * Expert ctor:
   * Construct an enumerator based upon an automaton, enumerating the specified
   * field, working on a supplied reader.
   * <p>
   * @lucene.internal Use the public ctor instead. This constructor allows the
   * (dangerous) option of passing in a pre-compiled RunAutomaton. If you use 
   * this ctor and compile your own RunAutomaton, you are responsible for 
   * ensuring it is in sync with the Automaton object, including internal
   * State numbering, or you will get undefined behavior.
   * <p>
   * @param preCompiled optional pre-compiled RunAutomaton (can be null)
   * @param finite true if the automaton accepts a finite language
   */
  AutomatonTermsEnum(Automaton automaton, RunAutomaton preCompiled,
      Term queryTerm, IndexReader reader, boolean finite)
      throws IOException {
    super(reader, queryTerm.field());
    this.automaton = automaton;
    this.finite = finite;

    /* 
     * tableize the automaton. this also ensures it is deterministic, and has no 
     * transitions to dead states. it also invokes Automaton.setStateNumbers to
     * number the original states (this is how they are tableized)
     */
    if (preCompiled == null)
      runAutomaton = new RunAutomaton(this.automaton);
    else
      runAutomaton = preCompiled;

    commonSuffixRef = finite ? null : new BytesRef(getValidUTF16Suffix(SpecialOperations
        .getCommonSuffix(automaton)));
    
    // build a cache of sorted transitions for every state
    allTransitions = new Transition[runAutomaton.getSize()][];
    for (State state : this.automaton.getStates())
      allTransitions[state.getNumber()] = state.getSortedTransitionArray(false);
    // used for path tracking, where each bit is a numbered state.
    visited = new long[runAutomaton.getSize()];

    setUseTermsCache(finite);
    termComp = getComparator();
  }

