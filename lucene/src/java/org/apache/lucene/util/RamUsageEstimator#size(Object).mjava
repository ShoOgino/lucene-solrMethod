  private long size(Object obj) {
    if (obj == null) {
      return 0;
    }
    // interned not part of this object
    if (checkInterned && obj instanceof String
        && obj == ((String) obj).intern()) { // interned string will be eligible
                                             // for GC on
                                             // estimateRamUsage(Object) return
      return 0;
    }

    // skip if we have seen before
    if (seen.containsKey(obj)) {
      return 0;
    }

    // add to seen
    seen.put(obj, null);

    Class<?> clazz = obj.getClass();
    if (clazz.isArray()) {
      return sizeOfArray(obj);
    }

    long size = 0;

    // walk type hierarchy
    while (clazz != null) {
      Field[] fields = clazz.getDeclaredFields();
      for (int i = 0; i < fields.length; i++) {
        if (Modifier.isStatic(fields[i].getModifiers())) {
          continue;
        }

        if (fields[i].getType().isPrimitive()) {
          size += memoryModel.getPrimitiveSize(fields[i].getType());
        } else {
          size += refSize;
          fields[i].setAccessible(true);
          try {
            Object value = fields[i].get(obj);
            if (value != null) {
              size += size(value);
            }
          } catch (IllegalAccessException ex) {
            // ignore for now?
          }
        }

      }
      clazz = clazz.getSuperclass();
    }
    size += classSize;
    return size;
  }

