  private void quickSort(int lo, int hi, int maxDepth) {
    final int diff = hi - lo;
    if (diff <= QUICKSORT_THRESHOLD) {
      insertionSort(lo, hi);
      return;
    }
    
    final int mid = lo + (diff >>> 1);
    
    if (compare(lo, mid) > 0) {
      swap(lo, mid);
    }

    if (compare(mid, hi) > 0) {
      swap(mid, hi);
      if (compare(lo, mid) > 0) {
        swap(lo, mid);
      }
    }
    
    int left = lo + 1;
    int right = hi - 1;

    setPivot(mid);
    for (;;) {
      while (comparePivot(right) < 0)
        --right;

      while (left < right && comparePivot(left) >= 0)
        ++left;

      if (left < right) {
        swap(left, right);
        --right;
      } else {
        break;
      }
    }

    // fall back to merge sort when recursion depth gets too big
    if (maxDepth == 0) {
      // for testing: new Exception("Hit recursion depth limit").printStackTrace();
      mergeSort(lo, left);
      mergeSort(left + 1, hi);
    } else {
      --maxDepth;
      quickSort(lo, left, maxDepth);
      quickSort(left + 1, hi, maxDepth);
    }
  }

