  /** NOTE: target must be >= where we are already
   *  positioned */
  public InputOutput<T> advance(IntsRef target) throws IOException {

    assert target.compareTo(current) >= 0;

    //System.out.println("    advance len=" + target.length + " curlen=" + current.length);

    // special case empty string
    if (current.length == 0) {
      if (target.length == 0) {
        final T output = fst.getEmptyOutput();      
        if (output != null) {
          if (!didEmpty) {
            current.length = 0;
            lastFinal = true;
            result.output = output;
            didEmpty = true;
          }
          return result;
        } else {
          return next();
        }
      }
      
      if (fst.noNodes()) {
        return null;
      }
    }

    // TODO: possibly caller could/should provide common
    // prefix length?  ie this work may be redundant if
    // caller is in fact intersecting against its own
    // automaton

    // what prefix does target share w/ current
    int idx = 0;
    while (idx < current.length && idx < target.length) {
      if (current.ints[idx] != target.ints[target.offset + idx]) {
        break;
      }
      idx++;
    }

    //System.out.println("  shared " + idx);

    FST.Arc<T> arc;
    if (current.length == 0) {
      // new enum (no seek/next yet)
      arc = fst.readFirstArc(fst.getStartNode(), getArc(0));
      //System.out.println("  new enum");
    } else if (idx < current.length) {
      // roll back to shared point
      lastFinal = false;
      current.length = idx;
      arc = arcs[idx];
      if (arc.isLast()) {
        if (idx == 0) {
          return null;
        } else {
          return next();
        }
      }
      arc = fst.readNextArc(arc);
    } else if (idx == target.length) {
      // degenerate case -- seek to term we are already on
      assert target.equals(current);
      return result;
    } else {
      // current is a full prefix of target
      if (lastFinal) {
        arc = fst.readFirstArc(arcs[current.length-1].target, getArc(current.length));
      } else {
        return next();
      }
    }

    lastFinal = false;

    assert arc == arcs[current.length];
    int targetLabel = target.ints[target.offset+current.length];

    while(true) {
      //System.out.println("    cycle len=" + current.length + " target=" + ((char) targetLabel) + " vs " + ((char) arc.label));
      if (arc.label == targetLabel) {
        grow();
        current.ints[current.length] = arc.label;
        appendOutput(arc.output);
        current.length++;
        grow();
        if (current.length == target.length) {
          result.output = output[current.length-1];
          if (arc.isFinal()) {
            // target is exact match
            if (fst.hasArcs(arc.target)) {
              // target is also a proper prefix of other terms
              lastFinal = true;
              appendFinalOutput(arc.nextFinalOutput);
            }
          } else {
            // target is not a match but is a prefix of
            // other terms
            current.length--;
            push();
          }
          return result;
        } else if (!fst.hasArcs(arc.target)) {
          // we only match a prefix of the target
          return next();
        } else {
          targetLabel = target.ints[target.offset+current.length];
          arc = fst.readFirstArc(arc.target, getArc(current.length));
        }
      } else if (arc.label > targetLabel) {
        // we are now past the target
        push();
        return result;
      } else if (arc.isLast()) {
        if (current.length == 0) {
          return null;
        }
        return next();
      } else {
        arc = fst.readNextArc(getArc(current.length));
      }
    }
  }

