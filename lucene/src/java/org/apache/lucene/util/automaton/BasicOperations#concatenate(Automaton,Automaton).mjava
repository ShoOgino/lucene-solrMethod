  /**
   * Returns an automaton that accepts the concatenation of the languages of the
   * given automata.
   * <p>
   * Complexity: linear in number of states.
   */
  static public Automaton concatenate(Automaton a1, Automaton a2) {
    if (a1.isSingleton() && a2.isSingleton()) return BasicAutomata
        .makeString(a1.singleton + a2.singleton);
    // adding epsilon transitions with the NFA concatenation algorithm
    // in this case always produces a resulting DFA, preventing expensive
    // redundant determinize() calls for this common case.
    boolean deterministic = a1.isSingleton() && a2.isDeterministic();
    if (a1 == a2) {
      a1 = a1.cloneExpanded();
      a2 = a2.cloneExpanded();
    } else {
      a1 = a1.cloneExpandedIfRequired();
      a2 = a2.cloneExpandedIfRequired();
    }
    for (State s : a1.getAcceptStates()) {
      s.accept = false;
      s.addEpsilon(a2.initial);
    }
    a1.deterministic = deterministic;
    //a1.clearHashCode();
    a1.clearNumberedStates();
    a1.checkMinimizeAlways();
    return a1;
  }

