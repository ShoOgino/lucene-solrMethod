    public RandomAcceptedStrings(Automaton a) {
      this.a = a;
      if (a.isSingleton()) {
        leadsToAccept = null;
        return;
      }

      // must use IdentityHashmap because two Transitions w/
      // different start nodes can be considered the same
      leadsToAccept = new IdentityHashMap<Transition,Boolean>();
      final Map<State,List<ArrivingTransition>> allArriving = new HashMap<State,List<ArrivingTransition>>();

      final LinkedList<State> q = new LinkedList<State>();
      final Set<State> seen = new HashSet<State>();

      // reverse map the transitions, so we can quickly look
      // up all arriving transitions to a given state
      for(State s: a.getNumberedStates()) {
        for(int i=0;i<s.numTransitions;i++) {
          final Transition t = s.transitionsArray[i];
          List<ArrivingTransition> tl = allArriving.get(t.to);
          if (tl == null) {
            tl = new ArrayList<ArrivingTransition>();
            allArriving.put(t.to, tl);
          }
          tl.add(new ArrivingTransition(s, t));
        }
        if (s.accept) {
          q.add(s);
          seen.add(s);
        }
      }

      // Breadth-first search, from accept states,
      // backwards:
      while(!q.isEmpty()) {
        final State s = q.removeFirst();
        List<ArrivingTransition> arriving = allArriving.get(s);
        if (arriving != null) {
          for(ArrivingTransition at : arriving) {
            final State from = at.from;
            if (!seen.contains(from)) {
              q.add(from);
              seen.add(from);
              leadsToAccept.put(at.t, Boolean.TRUE);
            }
          }
        }
      }
    }

