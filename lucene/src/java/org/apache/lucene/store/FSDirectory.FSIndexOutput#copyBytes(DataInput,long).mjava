    @Override
    public void copyBytes(DataInput input, long numBytes) throws IOException {
      // Optimized copy only if the number of bytes to copy is larger than the
      // buffer size, and the given IndexInput supports FileChannel copying.
      // NOTE: the below check relies on NIOIndexInput extending Simple. If that
      // changes in the future, we should change the check as well.
      if (numBytes <= BUFFER_SIZE || !(input instanceof SimpleFSIndexInput)) {
        super.copyBytes(input, numBytes);
        return;
      }

      SimpleFSIndexInput fsInput = (SimpleFSIndexInput) input;

      // flush any bytes in the buffer
      flush();
      
      // flush any bytes in the input's buffer.
      numBytes -= fsInput.flushBuffer(this, numBytes);
      
      // do the optimized copy
      FileChannel in = fsInput.file.getChannel();

      // Necessary because BufferedIndexInput does lazy seeking:
      in.position(fsInput.getFilePointer());

      FileChannel out = file.getChannel();
      long pos = out.position();
      long writeTo = numBytes + pos;
      while (pos < writeTo) {
        pos += out.transferFrom(in, pos, Math.min(CHANNEL_CHUNK_SIZE, writeTo - pos));
      }
      // transferFrom does not change the position of the channel. Need to change it manually
      out.position(pos);
      
      // corrects the position in super (BufferedIndexOutput), so that calls
      // to getFilePointer will return the correct pointer.
      // Perhaps a specific method is better?
      super.seek(out.position());
    }

