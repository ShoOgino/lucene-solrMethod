  /** Pauses, if necessary, to keep the instantaneous IO
   *  rate at or below the target. NOTE: multiple threads
   *  may safely use this, however the implementation is
   *  not perfectly thread safe but likely in practice this
   *  is harmless (just means in some rare cases the rate
   *  might exceed the target).  It's best to call this
   *  with a biggish count, not one byte at a time. */
  public void pause(long bytes) {

    // TODO: this is purely instantaneous rate; maybe we
    // should also offer decayed recent history one?
    final long targetNS = lastNS = lastNS + ((long) (bytes * nsPerByte));
    long curNS = System.nanoTime();
    if (lastNS < curNS) {
      lastNS = curNS;
    }

    // While loop because Thread.sleep doesn't always sleep
    // enough:
    while(true) {
      final long pauseNS = targetNS - curNS;
      if (pauseNS > 0) {
        try {
          Thread.sleep((int) (pauseNS/1000000), (int) (pauseNS % 1000000));
        } catch (InterruptedException ie) {
          throw new ThreadInterruptedException(ie);
        }
        curNS = System.nanoTime();
        continue;
      }
      break;
    }
  }

