  /**
   * Test the term index.
   */
  private Status.TermIndexStatus testTermIndex(SegmentReader reader) {
    final Status.TermIndexStatus status = new Status.TermIndexStatus();

    final int maxDoc = reader.maxDoc();
    final Bits liveDocs = reader.getLiveDocs();

    final IndexSearcher is = new IndexSearcher(reader);

    try {

      if (infoStream != null) {
        infoStream.print("    test: terms, freq, prox...");
      }

      final Fields fields = reader.fields();
      if (fields == null) {
        msg("OK [no fields/terms]");
        return status;
      }
     
      DocsEnum docs = null;
      DocsAndPositionsEnum postings = null;

      final FieldsEnum fieldsEnum = fields.iterator();
      while(true) {
        final String field = fieldsEnum.next();
        if (field == null) {
          break;
        }
        
        final TermsEnum terms = fieldsEnum.terms();
        assert terms != null;
        boolean hasOrd = true;
        final long termCountStart = status.termCount;

        BytesRef lastTerm = null;

        Comparator<BytesRef> termComp = terms.getComparator();

        long sumTotalTermFreq = 0;
        long sumDocFreq = 0;
        FixedBitSet visitedDocs = new FixedBitSet(reader.maxDoc());
        while(true) {

          final BytesRef term = terms.next();
          if (term == null) {
            break;
          }

          // make sure terms arrive in order according to
          // the comp
          if (lastTerm == null) {
            lastTerm = new BytesRef(term);
          } else {
            if (termComp.compare(lastTerm, term) >= 0) {
              throw new RuntimeException("terms out of order: lastTerm=" + lastTerm + " term=" + term);
            }
            lastTerm.copy(term);
          }

          final int docFreq = terms.docFreq();
          status.totFreq += docFreq;
          sumDocFreq += docFreq;

          docs = terms.docs(liveDocs, docs);
          postings = terms.docsAndPositions(liveDocs, postings);

          if (hasOrd) {
            long ord = -1;
            try {
              ord = terms.ord();
            } catch (UnsupportedOperationException uoe) {
              hasOrd = false;
            }

            if (hasOrd) {
              final long ordExpected = status.termCount - termCountStart;
              if (ord != ordExpected) {
                throw new RuntimeException("ord mismatch: TermsEnum has ord=" + ord + " vs actual=" + ordExpected);
              }
            }
          }

          status.termCount++;

          final DocsEnum docs2;
          final boolean hasPositions;
          if (postings != null) {
            docs2 = postings;
            hasPositions = true;
          } else {
            docs2 = docs;
            hasPositions = false;
          }

          int lastDoc = -1;
          int docCount = 0;
          long totalTermFreq = 0;
          while(true) {
            final int doc = docs2.nextDoc();
            if (doc == DocIdSetIterator.NO_MORE_DOCS) {
              break;
            }
            visitedDocs.set(doc);
            final int freq = docs2.freq();
            status.totPos += freq;
            totalTermFreq += freq;
            docCount++;

            if (doc <= lastDoc) {
              throw new RuntimeException("term " + term + ": doc " + doc + " <= lastDoc " + lastDoc);
            }
            if (doc >= maxDoc) {
              throw new RuntimeException("term " + term + ": doc " + doc + " >= maxDoc " + maxDoc);
            }

            lastDoc = doc;
            if (freq <= 0) {
              throw new RuntimeException("term " + term + ": doc " + doc + ": freq " + freq + " is out of bounds");
            }
            
            int lastPos = -1;
            if (postings != null) {
              for(int j=0;j<freq;j++) {
                final int pos = postings.nextPosition();
                if (pos < -1) {
                  throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " is out of bounds");
                }
                if (pos < lastPos) {
                  throw new RuntimeException("term " + term + ": doc " + doc + ": pos " + pos + " < lastPos " + lastPos);
                }
                lastPos = pos;
                if (postings.hasPayload()) {
                  postings.getPayload();
                }
              }
            }
          }
          
          final long totalTermFreq2 = terms.totalTermFreq();
          final boolean hasTotalTermFreq = postings != null && totalTermFreq2 != -1;

          // Re-count if there are deleted docs:
          if (reader.hasDeletions()) {
            final DocsEnum docsNoDel = terms.docs(null, docs);
            docCount = 0;
            totalTermFreq = 0;
            while(docsNoDel.nextDoc() != DocIdSetIterator.NO_MORE_DOCS) {
              visitedDocs.set(docsNoDel.docID());
              docCount++;
              totalTermFreq += docsNoDel.freq();
            }
          }

          if (docCount != docFreq) {
            throw new RuntimeException("term " + term + " docFreq=" + docFreq + " != tot docs w/o deletions " + docCount);
          }
          if (hasTotalTermFreq) {
            sumTotalTermFreq += totalTermFreq;
            if (totalTermFreq != totalTermFreq2) {
              throw new RuntimeException("term " + term + " totalTermFreq=" + totalTermFreq2 + " != recomputed totalTermFreq=" + totalTermFreq);
            }
          }

          // Test skipping
          if (hasPositions) {
            for(int idx=0;idx<7;idx++) {
              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);
              postings = terms.docsAndPositions(liveDocs, postings);
              final int docID = postings.advance(skipDocID);
              if (docID == DocsEnum.NO_MORE_DOCS) {
                break;
              } else {
                if (docID < skipDocID) {
                  throw new RuntimeException("term " + term + ": advance(docID=" + skipDocID + ") returned docID=" + docID);
                }
                final int freq = postings.freq();
                if (freq <= 0) {
                  throw new RuntimeException("termFreq " + freq + " is out of bounds");
                }
                int lastPosition = -1;
                for(int posUpto=0;posUpto<freq;posUpto++) {
                  final int pos = postings.nextPosition();
                  if (pos < 0) {
                    throw new RuntimeException("position " + pos + " is out of bounds");
                  }
                  if (pos < lastPosition) {
                    throw new RuntimeException("position " + pos + " is < lastPosition " + lastPosition);
                  }
                  lastPosition = pos;
                } 

                final int nextDocID = postings.nextDoc();
                if (nextDocID == DocsEnum.NO_MORE_DOCS) {
                  break;
                }
                if (nextDocID <= docID) {
                  throw new RuntimeException("term " + term + ": advance(docID=" + skipDocID + "), then .next() returned docID=" + nextDocID + " vs prev docID=" + docID);
                }
              }
            }
          } else {
            for(int idx=0;idx<7;idx++) {
              final int skipDocID = (int) (((idx+1)*(long) maxDoc)/8);
              docs = terms.docs(liveDocs, docs);
              final int docID = docs.advance(skipDocID);
              if (docID == DocsEnum.NO_MORE_DOCS) {
                break;
              } else {
                if (docID < skipDocID) {
                  throw new RuntimeException("term " + term + ": advance(docID=" + skipDocID + ") returned docID=" + docID);
                }
                final int nextDocID = docs.nextDoc();
                if (nextDocID == DocsEnum.NO_MORE_DOCS) {
                  break;
                }
                if (nextDocID <= docID) {
                  throw new RuntimeException("term " + term + ": advance(docID=" + skipDocID + "), then .next() returned docID=" + nextDocID + " vs prev docID=" + docID);
                }
              }
            }
          }
        }
        
        final Terms fieldTerms = fields.terms(field);
        if (fieldTerms == null) {
          // Unusual: the FieldsEnum returned a field but
          // the Terms for that field is null; this should
          // only happen if it's a ghost field (field with
          // no terms, eg there used to be terms but all
          // docs got deleted and then merged away):
          // make sure TermsEnum is empty:
          if (fieldsEnum.terms().next() != null) {
            throw new RuntimeException("Fields.terms(field=" + field + ") returned null yet the field appears to have terms");
          }
        } else {
          if (fieldTerms instanceof BlockTreeTermsReader.FieldReader) {
            final BlockTreeTermsReader.Stats stats = ((BlockTreeTermsReader.FieldReader) fieldTerms).computeStats();
            assert stats != null;
            if (status.blockTreeStats == null) {
              status.blockTreeStats = new HashMap<String,BlockTreeTermsReader.Stats>();
            }
            status.blockTreeStats.put(field, stats);
          }

          if (sumTotalTermFreq != 0) {
            final long v = fields.terms(field).getSumTotalTermFreq();
            if (v != -1 && sumTotalTermFreq != v) {
              throw new RuntimeException("sumTotalTermFreq for field " + field + "=" + v + " != recomputed sumTotalTermFreq=" + sumTotalTermFreq);
            }
          }
        
          if (sumDocFreq != 0) {
            final long v = fields.terms(field).getSumDocFreq();
            if (v != -1 && sumDocFreq != v) {
              throw new RuntimeException("sumDocFreq for field " + field + "=" + v + " != recomputed sumDocFreq=" + sumDocFreq);
            }
          }
        
        if (fieldTerms != null) {
          final int v = fieldTerms.getDocCount();
          if (v != -1 && visitedDocs.cardinality() != v) {
            throw new RuntimeException("docCount for field " + field + "=" + v + " != recomputed docCount=" + visitedDocs.cardinality());
          }
        }

          // Test seek to last term:
          if (lastTerm != null) {
            if (terms.seekCeil(lastTerm) != TermsEnum.SeekStatus.FOUND) { 
              throw new RuntimeException("seek to last term " + lastTerm + " failed");
            }

            is.search(new TermQuery(new Term(field, lastTerm)), 1);
          }

          // Test seeking by ord
          if (hasOrd && status.termCount-termCountStart > 0) {
            long termCount;
            try {
              termCount = fields.terms(field).getUniqueTermCount();
            } catch (UnsupportedOperationException uoe) {
              termCount = -1;
            }

            if (termCount != -1 && termCount != status.termCount - termCountStart) {
              throw new RuntimeException("termCount mismatch " + termCount + " vs " + (status.termCount - termCountStart));
            }

            int seekCount = (int) Math.min(10000L, termCount);
            if (seekCount > 0) {
              BytesRef[] seekTerms = new BytesRef[seekCount];
            
              // Seek by ord
              for(int i=seekCount-1;i>=0;i--) {
                long ord = i*(termCount/seekCount);
                terms.seekExact(ord);
                seekTerms[i] = new BytesRef(terms.term());
              }

              // Seek by term
              long totDocCount = 0;
              for(int i=seekCount-1;i>=0;i--) {
                if (terms.seekCeil(seekTerms[i]) != TermsEnum.SeekStatus.FOUND) {
                  throw new RuntimeException("seek to existing term " + seekTerms[i] + " failed");
                }
              
                docs = terms.docs(liveDocs, docs);
                if (docs == null) {
                  throw new RuntimeException("null DocsEnum from to existing term " + seekTerms[i]);
                }

                while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {
                  totDocCount++;
                }
              }

              // TermQuery
              long totDocCount2 = 0;
              for(int i=0;i<seekCount;i++) {
                totDocCount2 += is.search(new TermQuery(new Term(field, seekTerms[i])), 1).totalHits;
              }

              if (totDocCount != totDocCount2) {
                throw new RuntimeException("search to seek terms produced wrong number of hits: " + totDocCount + " vs " + totDocCount2);
              }
            }
          }
        }
      }

      msg("OK [" + status.termCount + " terms; " + status.totFreq + " terms/docs pairs; " + status.totPos + " tokens]");

      if (verbose && status.blockTreeStats != null && infoStream != null && status.termCount > 0) {
        for(Map.Entry<String,BlockTreeTermsReader.Stats> ent : status.blockTreeStats.entrySet()) {
          infoStream.println("      field \"" + ent.getKey() + "\":");
          infoStream.println("      " + ent.getValue().toString().replace("\n", "\n      "));
        }
      }

    } catch (Throwable e) {
      msg("ERROR: " + e);
      status.error = e;
      if (infoStream != null) {
        e.printStackTrace(infoStream);
      }
    }

    return status;
  }

