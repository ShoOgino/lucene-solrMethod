    public LegacyTermEnum(Term t) throws IOException {
      fields = core.fields.iterator();
      currentField = fields.next();
      if (currentField == null) {
        // no fields
        done = true;
      } else if (t != null) {
        // Pre-seek to this term

        while(currentField.compareTo(t.field) < 0) {
          currentField = fields.next();
          if (currentField == null) {
            // Hit end of fields
            done = true;
            break;
          }
        }

        if (!done) {
          // We found some field -- get its terms:
          terms = fields.terms();

          if (currentField == t.field) {
            // We found exactly the requested field; now
            // seek the term text:
            String text = t.text();

            // this is only for backwards compatibility.
            // previously you could supply a term with unpaired surrogates,
            // and it would return the next Term.
            // if someone does this, tack on the lowest possible trail surrogate.
            // this emulates the old behavior, and forms "valid UTF-8" unicode.
            BytesRef tr = new BytesRef(UnicodeUtil.nextValidUTF16String(text));
            TermsEnum.SeekStatus status = terms.seek(tr);

            if (status == TermsEnum.SeekStatus.END) {
              // Rollover to the next field
              terms = null;
              next();
            } else if (status == TermsEnum.SeekStatus.FOUND) {
              // Found exactly the term
              currentTerm = tr;
            } else {
              // Found another term, in this same field
              currentTerm = terms.term();
            }
          } else {
            // We didn't find exact field (we found the
            // following field); advance to first term in
            // this field
            next();
          }
        }
      } else {
        terms = fields.terms();
      }
    }

