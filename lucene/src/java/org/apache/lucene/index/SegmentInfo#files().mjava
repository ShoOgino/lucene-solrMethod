  public List<String> files() throws IOException {
    final long fisVersion = fieldInfosVersion;
    if (fisVersion != (fieldInfosVersion = getFieldInfos().getVersion())) {
      clearFilesCache(); // FIS has modifications - need to recompute
    } else if (files != null) {
      // Already cached:
      return files;
    }
    final Set<String> fileSet = new HashSet<String>();

    boolean useCompoundFile = getUseCompoundFile();

    if (useCompoundFile) {
      fileSet.add(IndexFileNames.segmentFileName(name, "", IndexFileNames.COMPOUND_FILE_EXTENSION));
      if (version != null && StringHelper.getVersionComparator().compare("4.0", version) <= 0) {
        fileSet.add(IndexFileNames.segmentFileName(name, "",
            IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION));
      }
    } else {
      codec.files(dir, this, fileSet);
    }

    if (docStoreOffset != -1) {
      // We are sharing doc stores (stored fields, term
      // vectors) with other segments
      assert docStoreSegment != null;
      // TODO: push this out into preflex fieldsFormat?
      if (docStoreIsCompoundFile) {
        fileSet.add(IndexFileNames.segmentFileName(docStoreSegment, "", IndexFileNames.COMPOUND_FILE_STORE_EXTENSION));
      }
    }

    String delFileName = IndexFileNames.fileNameFromGeneration(name, IndexFileNames.DELETES_EXTENSION, delGen);
    if (delFileName != null && (delGen >= YES || dir.fileExists(delFileName))) {
      fileSet.add(delFileName);
    }

    // because separate norm files are unconditionally stored outside cfs,
    // we must explicitly ask for their filenames if we might have separate norms:
    // remove this when 3.x indexes are no longer supported
    if (normGen != null) {
      codec.normsFormat().separateFiles(dir, this, fileSet);
    }

    files = new ArrayList<String>(fileSet);

    return files;
  }

