  final boolean flushAllThreads(final boolean flushDeletes)
    throws IOException {

    if (flushDeletes) {
      pushToLastSegment(pendingDeletes);
    }

    Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();
    boolean anythingFlushed = false;

    while (threadsIterator.hasNext()) {
      SegmentInfo newSegment = null;

      ThreadState perThread = threadsIterator.next();
      perThread.lock();
      try {
        DocumentsWriterPerThread dwpt = perThread.perThread;
        final int numDocs = dwpt.getNumDocsInRAM();

        // Always flush docs if there are any
        boolean flushDocs = numDocs > 0;

        String segment = dwpt.getSegment();

        // If we are flushing docs, segment must not be null:
        assert segment != null || !flushDocs;

        if (flushDocs) {
          newSegment = dwpt.flush();

          if (newSegment != null) {
            anythingFlushed = true;
            perThreadPool.clearThreadBindings(perThread);
            if (dwpt.pendingDeletes.any()) {
              bufferedDeletes.pushDeletes(dwpt.pendingDeletes, newSegment);
              dwpt.pendingDeletes = new SegmentDeletes();
            }
          }
        }
        else if (flushDeletes && dwpt.pendingDeletes.any()) {
          pushToLastSegment(dwpt.pendingDeletes);
        }
      } finally {
        perThread.unlock();
      }

      if (newSegment != null) {
        // important do unlock the perThread before finishFlushedSegment
        // is called to prevent deadlock on IndexWriter mutex
        finishFlushedSegment(newSegment);
      }
    }

    numDocsInRAM.set(0);
    return anythingFlushed;
  }

