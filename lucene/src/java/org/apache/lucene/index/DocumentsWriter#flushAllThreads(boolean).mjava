  final boolean flushAllThreads(final boolean flushDeletes)
    throws IOException {

    if (flushDeletes) {
      synchronized (this) {
        pushDeletes(null, pendingDeletes);
        pendingDeletes = new BufferedDeletes(false);
      }
    }

    Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();
    boolean anythingFlushed = false;

    while (threadsIterator.hasNext()) {
      SegmentInfo newSegment = null;
      BufferedDeletes segmentDeletes = null;
      BitVector deletedDocs = null;

      ThreadState perThread = threadsIterator.next();
      perThread.lock();
      try {

        DocumentsWriterPerThread dwpt = perThread.perThread;
        final int numDocs = dwpt.getNumDocsInRAM();

        // Always flush docs if there are any
        boolean flushDocs = numDocs > 0;

        String segment = dwpt.getSegment();

        // If we are flushing docs, segment must not be null:
        assert segment != null || !flushDocs;

        if (flushDocs) {
          newSegment = dwpt.flush();

          if (newSegment != null) {
            anythingFlushed = true;
            deletedDocs = dwpt.flushState.deletedDocs;
            perThreadPool.clearThreadBindings(perThread);
            if (dwpt.pendingDeletes.any()) {
              segmentDeletes = dwpt.pendingDeletes;
              dwpt.pendingDeletes = new BufferedDeletes(false);
            }
          }
        } else if (flushDeletes && dwpt.pendingDeletes.any()) {
          segmentDeletes = dwpt.pendingDeletes;
          dwpt.pendingDeletes = new BufferedDeletes(false);
        }
      } finally {
        perThread.unlock();
      }

      if (segmentDeletes != null) {
          pushDeletes(newSegment, segmentDeletes);
      }


      if (newSegment != null) {
        // important do unlock the perThread before finishFlushedSegment
        // is called to prevent deadlock on IndexWriter mutex
        indexWriter.addFlushedSegment(newSegment, deletedDocs);
      }
    }

    return anythingFlushed;
  }

