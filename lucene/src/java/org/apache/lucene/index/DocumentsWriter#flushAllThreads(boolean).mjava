  final boolean flushAllThreads(final boolean flushDeletes)
    throws IOException {

    if (flushDeletes) {
      synchronized (this) {
        pushDeletes(null, pendingDeletes);
        pendingDeletes = new SegmentDeletes();
      }
    }

    Iterator<ThreadState> threadsIterator = perThreadPool.getActivePerThreadsIterator();
    boolean anythingFlushed = false;

    while (threadsIterator.hasNext()) {
      SegmentInfo newSegment = null;
      SegmentDeletes segmentDeletes = null;

      ThreadState perThread = threadsIterator.next();
      perThread.lock();
      try {
        DocumentsWriterPerThread dwpt = perThread.perThread;
        final int numDocs = dwpt.getNumDocsInRAM();

        // Always flush docs if there are any
        boolean flushDocs = numDocs > 0;

        String segment = dwpt.getSegment();

        // If we are flushing docs, segment must not be null:
        assert segment != null || !flushDocs;

        if (flushDocs) {
          newSegment = dwpt.flush();

          if (newSegment != null) {
            fieldInfos.update(dwpt.getFieldInfos());
            anythingFlushed = true;
            perThreadPool.clearThreadBindings(perThread);
            if (dwpt.pendingDeletes.any()) {
              segmentDeletes = dwpt.pendingDeletes;
              dwpt.pendingDeletes = new SegmentDeletes();
            }
          }
        } else if (flushDeletes && dwpt.pendingDeletes.any()) {
          segmentDeletes = dwpt.pendingDeletes;
          dwpt.pendingDeletes = new SegmentDeletes();
        }
      } finally {
        perThread.unlock();
      }

      if (segmentDeletes != null) {
          pushDeletes(newSegment, segmentDeletes);
      }


      if (newSegment != null) {
        // important do unlock the perThread before finishFlushedSegment
        // is called to prevent deadlock on IndexWriter mutex
        indexWriter.addFlushedSegment(newSegment);
      }
    }

    return anythingFlushed;
  }

