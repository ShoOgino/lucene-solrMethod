  final boolean flushAllThreads(final boolean flushDeletes)
      throws IOException {
    return threadPool.executeAllThreads(new DocumentsWriterThreadPool.AllThreadsTask<Boolean>() {
      @Override
      public Boolean process(Iterator<DocumentsWriterPerThread> threadsIterator) throws IOException {
        boolean anythingFlushed = false;
        
        if (flushDeletes) {
          if (applyDeletes(indexWriter.segmentInfos)) {
            indexWriter.checkpoint();
          }
        }

        while (threadsIterator.hasNext()) {
          DocumentsWriterPerThread perThread = threadsIterator.next();
          final int numDocs = perThread.getNumDocsInRAM();
          
          // Always flush docs if there are any
          boolean flushDocs = numDocs > 0;
          
          String segment = perThread.getSegment();

          // If we are flushing docs, segment must not be null:
          assert segment != null || !flushDocs;
    
          if (flushDocs) {
            SegmentInfo newSegment = perThread.flush();
            
            if (newSegment != null) {
              anythingFlushed = true;
              
              IndexWriter.setDiagnostics(newSegment, "flush");
              finishFlushedSegment(newSegment, perThread);
            }
          }
        }

        if (anythingFlushed) {
          clearThreadBindings();

          sequenceIDLock.lock();
          try {
            flushedSequenceID = sequenceID;
          } finally {
            sequenceIDLock.unlock();
          }
          numDocsInRAM.set(0);
        }
        
        if (flushDeletes) {
          deletesInRAM.clear();
        }


        return anythingFlushed;
      }
    });
  }

