  public <T> T executeAllThreads(DocumentsWriter documentsWriter, AllThreadsTask<T> task) throws IOException {
    T result = null;
    
    lock.lock();
    try {
      try {
        while (globalLock) {
          threadStateAvailable.await();
        }
      } catch (InterruptedException ie) {
        throw new ThreadInterruptedException(ie);
      }

      assert !globalLock;
      globalLock = true;

      pauseAllThreads();
      
    } finally {
      lock.unlock();
    }

    final ThreadState[] localAllThreads = allThreadStates;
    
    // all threads are idle now
    boolean success = false;
    try {
      result = task.process(new Iterator<DocumentsWriterPerThread>() {
        int i = 0;
  
        @Override
        public boolean hasNext() {
          return i < localAllThreads.length;
        }
  
        @Override
        public DocumentsWriterPerThread next() {
          return localAllThreads[i++].perThread;
        }
  
        @Override
        public void remove() {
          throw new UnsupportedOperationException("remove() not supported.");
        }
      });
      success = true;
      return result;
    } finally {
      boolean abort = false;
      if (!success) {
        for (ThreadState state : localAllThreads) {
          if (state.perThread.aborting) {
            abort = true;
          }
        }
      }
      
      lock.lock();
      try {
        try {
          if (task.doClearThreadBindings()) {
            clearAllThreadBindings();
          }
        } finally {
          globalLock = false;
          resumeAllThreads();
          threadStateAvailable.signalAll();
        }
      } finally {
        lock.unlock();
      }
      
      if (!aborting && abort) {
        documentsWriter.abort();
      }
      
    }
  }

