  /* We have three pools of RAM: Postings, byte blocks
   * (holds freq/prox posting data) and per-doc buffers
   * (stored fields/term vectors).  Different docs require
   * varying amount of storage from these classes.  For
   * example, docs with many unique single-occurrence short
   * terms will use up the Postings RAM and hardly any of
   * the other two.  Whereas docs with very large terms will
   * use alot of byte blocks RAM.  This method just frees
   * allocations from the pools once we are over-budget,
   * which balances the pools to match the current docs. */
  void balanceRAM() {

    final boolean doBalance;
    final long deletesRAMUsed;

    synchronized(this) {
      if (ramBufferSize == IndexWriterConfig.DISABLE_AUTO_FLUSH || bufferIsFull) {
        return;
      }
    
      deletesRAMUsed = deletesInRAM.bytesUsed+deletesFlushed.bytesUsed;
      doBalance = numBytesUsed+deletesRAMUsed >= ramBufferSize;
    }

    if (doBalance) {

      if (infoStream != null)
        message("  RAM: now balance allocations: usedMB=" + toMB(numBytesUsed) +
                " vs trigger=" + toMB(ramBufferSize) +
                " deletesMB=" + toMB(deletesRAMUsed) +
                " byteBlockFree=" + toMB(byteBlockAllocator.freeByteBlocks.size()*BYTE_BLOCK_SIZE) +
                " perDocFree=" + toMB(perDocAllocator.freeByteBlocks.size()*PER_DOC_BLOCK_SIZE));

      final long startBytesUsed = numBytesUsed + deletesRAMUsed;

      int iter = 0;

      // We free equally from each pool in 32 KB
      // chunks until we are below our threshold
      // (freeLevel)

      boolean any = true;

      while(numBytesUsed+deletesRAMUsed > freeLevel) {
      
        synchronized(this) {
          if (0 == perDocAllocator.freeByteBlocks.size() &&
              0 == byteBlockAllocator.freeByteBlocks.size() &&
              0 == freeIntBlocks.size() && !any) {
            // Nothing else to free -- must flush now.
            bufferIsFull = numBytesUsed+deletesRAMUsed > ramBufferSize;
            if (infoStream != null) {
              if (numBytesUsed+deletesRAMUsed > ramBufferSize)
                message("    nothing to free; now set bufferIsFull");
              else
                message("    nothing to free");
            }
            break;
          }

          if ((0 == iter % 4) && byteBlockAllocator.freeByteBlocks.size() > 0) {
            byteBlockAllocator.freeByteBlocks.remove(byteBlockAllocator.freeByteBlocks.size()-1);
            numBytesUsed -= BYTE_BLOCK_SIZE;
          }

          if ((1 == iter % 4) && freeIntBlocks.size() > 0) {
            freeIntBlocks.remove(freeIntBlocks.size()-1);
            numBytesUsed -= INT_BLOCK_SIZE * INT_NUM_BYTE;
          }

          if ((2 == iter % 4) && perDocAllocator.freeByteBlocks.size() > 0) {
            // Remove upwards of 32 blocks (each block is 1K)
            for (int i = 0; i < 32; ++i) {
              perDocAllocator.freeByteBlocks.remove(perDocAllocator.freeByteBlocks.size() - 1);
              numBytesUsed -= PER_DOC_BLOCK_SIZE;
              if (perDocAllocator.freeByteBlocks.size() == 0) {
                break;
              }
            }
          }
        }

        if ((3 == iter % 4) && any)
          // Ask consumer to free any recycled state
          any = consumer.freeRAM();

        iter++;
      }

      if (infoStream != null)
        message("    after free: freedMB=" + nf.format((startBytesUsed-numBytesUsed-deletesRAMUsed)/1024./1024.) + " usedMB=" + nf.format((numBytesUsed+deletesRAMUsed)/1024./1024.));
    }
  }

