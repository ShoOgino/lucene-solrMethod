  @Override
  public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse) throws IOException {
    MultiDocsAndPositionsEnum docsAndPositionsEnum;
    // Can only reuse if incoming enum is also a MultiDocsAndPositionsEnum
    if (reuse != null && reuse instanceof MultiDocsAndPositionsEnum) {
      docsAndPositionsEnum = (MultiDocsAndPositionsEnum) reuse;
      // ... and was previously created w/ this MultiTermsEnum:
      if (!docsAndPositionsEnum.canReuse(this)) {
        docsAndPositionsEnum = new MultiDocsAndPositionsEnum(this, subs.length);
      }
    } else {
      docsAndPositionsEnum = new MultiDocsAndPositionsEnum(this, subs.length);
    }
    
    final MultiBits multiLiveDocs;
    if (liveDocs instanceof MultiBits) {
      multiLiveDocs = (MultiBits) liveDocs;
    } else {
      multiLiveDocs = null;
    }

    int upto = 0;

    for(int i=0;i<numTop;i++) {

      final TermsEnumWithSlice entry = top[i];

      final Bits b;

      if (multiLiveDocs != null) {
        // Optimize for common case: requested skip docs is a
        // congruent sub-slice of MultiBits: in this case, we
        // just pull the liveDocs from the sub reader, rather
        // than making the inefficient
        // Slice(Multi(sub-readers)):
        final MultiBits.SubResult sub = multiLiveDocs.getMatchingSub(top[i].subSlice);
        if (sub.matches) {
          b = sub.result;
        } else {
          // custom case: requested skip docs is foreign:
          // must slice it on every access (very
          // inefficient)
          b = new BitsSlice(liveDocs, top[i].subSlice);
        }
      } else if (liveDocs != null) {
        b = new BitsSlice(liveDocs, top[i].subSlice);
      } else {
        // no deletions
        b = null;
      }

      assert entry.index < docsAndPositionsEnum.subDocsAndPositionsEnum.length: entry.index + " vs " + docsAndPositionsEnum.subDocsAndPositionsEnum.length + "; " + subs.length;
      final DocsAndPositionsEnum subPostings = entry.terms.docsAndPositions(b, docsAndPositionsEnum.subDocsAndPositionsEnum[entry.index]);

      if (subPostings != null) {
        docsAndPositionsEnum.subDocsAndPositionsEnum[entry.index] = subPostings;
        subDocsAndPositions[upto].docsAndPositionsEnum = subPostings;
        subDocsAndPositions[upto].slice = entry.subSlice;
        upto++;
      } else {
        if (entry.terms.docs(b, null, false) != null) {
          // At least one of our subs does not store
          // positions -- we can't correctly produce a
          // MultiDocsAndPositions enum
          return null;
        }
      }
    }

    if (upto == 0) {
      return null;
    } else {
      return docsAndPositionsEnum.reset(subDocsAndPositions, upto);
    }
  }

