  /** Called if we hit an exception at a bad time (when
   *  updating the index files) and must discard all
   *  currently buffered docs.  This resets our state,
   *  discarding any docs added since last flush. */
  synchronized void abort() throws IOException {

    if (infoStream != null) {
      message("docWriter: abort");
    }

    boolean success = false;

    try {

      // Forcefully remove waiting ThreadStates from line
      waitQueue.abort();

      // Wait for all other threads to finish with
      // DocumentsWriter:
      waitIdle();

      if (infoStream != null) {
        message("docWriter: abort waitIdle done");
      }

      assert 0 == waitQueue.numWaiting: "waitQueue.numWaiting=" + waitQueue.numWaiting;

      waitQueue.waitingBytes = 0;

      try {
        abortedFiles = openFiles();
      } catch (Throwable t) {
        abortedFiles = null;
      }

      pendingDeletes.clear();
        
      openFiles.clear();

      for(int i=0;i<threadStates.length;i++)
        try {
          threadStates[i].consumer.abort();
        } catch (Throwable t) {
        }

      try {
        consumer.abort();
      } catch (Throwable t) {
      }

      docStoreSegment = null;
      numDocsInStore = 0;
      docStoreOffset = 0;

      // Reset all postings data
      doAfterFlush();
      success = true;
    } finally {
      aborting = false;
      notifyAll();
      if (infoStream != null) {
        message("docWriter: done abort; abortedFiles=" + abortedFiles + " success=" + success);
      }
    }
  }

