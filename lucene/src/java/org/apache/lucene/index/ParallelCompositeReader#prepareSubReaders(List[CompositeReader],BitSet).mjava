  private static IndexReader[] prepareSubReaders(List<CompositeReader> parallelReaders, BitSet ignoreStoredFieldsSet) throws IOException {
    if (parallelReaders.isEmpty()) {
      return new IndexReader[0];
    } else {
      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:
      final IndexReader[]
        firstSubReaders = parallelReaders.get(0).getSequentialSubReaders(),
        subReaders = new IndexReader[firstSubReaders.length];
      for (int i = 0; i < subReaders.length; i++) {
        if (firstSubReaders[i] instanceof AtomicReader) {
          // we simply enable closing of subReaders, to prevent incRefs on subReaders
          // -> for synthetic subReaders, close() is never called by our doClose()
          final ParallelAtomicReader.Builder builder = new ParallelAtomicReader.Builder(true); 
          for (int j = 0, c = parallelReaders.size(); j < c; j++) {
            builder.add((AtomicReader) parallelReaders.get(j).getSequentialSubReaders()[i], ignoreStoredFieldsSet.get(j));
          }
          subReaders[i] = builder.build();
        } else {
          assert firstSubReaders[i] instanceof CompositeReader;
          // we simply enable closing of subReaders, to prevent incRefs on subReaders
          // -> for synthetic subReaders, close() is never called by our doClose()
          final ParallelCompositeReader.Builder builder = new ParallelCompositeReader.Builder(true); 
          for (int j = 0, c = parallelReaders.size(); j < c; j++) {
            builder.add((CompositeReader) parallelReaders.get(j).getSequentialSubReaders()[i], ignoreStoredFieldsSet.get(j));
          }
          subReaders[i] = builder.build();
        }
      }
      return subReaders;
    }
  }

