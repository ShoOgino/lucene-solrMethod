  // Apply buffered delete terms, queries and docIDs to the
  // provided reader
  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)
    throws CorruptIndexException, IOException {

    final int docEnd = docIDStart + reader.maxDoc();
    boolean any = false;

    assert checkDeleteTerm(null);

    // Delete by term
    if (deletesFlushed.terms.size() > 0) {
      Fields fields = reader.fields();
      if (fields == null) {
        // This reader has no postings
        return false;
      }

      TermsEnum termsEnum = null;
        
      String currentField = null;
      DocsEnum docs = null;
        
      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {
        Term term = entry.getKey();
        // Since we visit terms sorted, we gain performance
        // by re-using the same TermsEnum and seeking only
        // forwards
        if (term.field() != currentField) {
          assert currentField == null || currentField.compareTo(term.field()) < 0;
          currentField = term.field();
          Terms terms = fields.terms(currentField);
          if (terms != null) {
            termsEnum = terms.iterator();
          } else {
            termsEnum = null;
          }
        }
          
        if (termsEnum == null) {
          continue;
        }
        assert checkDeleteTerm(term);
          
        if (termsEnum.seek(term.bytes(), false) == TermsEnum.SeekStatus.FOUND) {
          DocsEnum docsEnum = termsEnum.docs(reader.getDeletedDocs(), docs);
            
          if (docsEnum != null) {
            docs = docsEnum;
            int limit = entry.getValue().getNum();
            while (true) {
              final int docID = docs.nextDoc();
              if (docID == DocsEnum.NO_MORE_DOCS || docIDStart+docID >= limit) {
                break;
              }
              reader.deleteDocument(docID);
              any = true;
            }
          }
        }
      }
    }

    // Delete by docID
    for (Integer docIdInt : deletesFlushed.docIDs) {
      int docID = docIdInt.intValue();
      if (docID >= docIDStart && docID < docEnd) {
        reader.deleteDocument(docID-docIDStart);
        any = true;
      }
    }

    // Delete by query
    if (deletesFlushed.queries.size() > 0) {
      IndexSearcher searcher = new IndexSearcher(reader);
      try {
        for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {
          Query query = entry.getKey();
          int limit = entry.getValue().intValue();
          Weight weight = query.weight(searcher);
          Scorer scorer = weight.scorer(reader, true, false);
          if (scorer != null) {
            while(true)  {
              int doc = scorer.nextDoc();
              if (((long) docIDStart) + doc >= limit)
                break;
              reader.deleteDocument(doc);
              any = true;
            }
          }
        }
      } finally {
        searcher.close();
      }
    }
    return any;
  }

