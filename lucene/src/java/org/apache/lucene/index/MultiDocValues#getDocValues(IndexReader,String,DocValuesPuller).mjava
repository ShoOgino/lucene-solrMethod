  private static DocValues getDocValues(IndexReader r, final String field, final DocValuesPuller puller) throws IOException {
    if (r instanceof AtomicIndexReader) {
      // already an atomic reader
      return puller.pull((AtomicIndexReader) r, field);
    }
    assert r instanceof CompositeIndexReader;
    final IndexReader[] subs = ((CompositeIndexReader) r).getSequentialSubReaders();
    if (subs.length == 0) {
      // no fields
      return null;
    } else if (subs.length == 1) {
      return getDocValues(subs[0], field, puller);
    } else {      
      final List<DocValuesSlice> slices = new ArrayList<DocValuesSlice>();
      
      final TypePromoter promotedType[] = new TypePromoter[1];
      promotedType[0] = TypePromoter.getIdentityPromoter();
      
      // gather all docvalues fields, accumulating a promoted type across 
      // potentially incompatible types
      
      new ReaderUtil.Gather(r) {
        boolean stop = false;
        @Override
        protected void add(int base, AtomicIndexReader r) throws IOException {
          if (stop) {
            return;
          }
          final DocValues d = puller.pull(r, field);
          if (d != null) {
            TypePromoter incoming = TypePromoter.create(d.type(), d.getValueSize());
            promotedType[0] = promotedType[0].promote(incoming);
          } else if (puller.stopLoadingOnNull(r, field)){
            promotedType[0] = TypePromoter.getIdentityPromoter(); // set to identity to return null
            stop = true;
          }
          slices.add(new DocValuesSlice(d, base, r.maxDoc()));
        }
      }.run();
      
      // return null if no docvalues encountered anywhere
      if (promotedType[0] == TypePromoter.getIdentityPromoter()) {
        return null;
      }
           
      // populate starts and fill gaps with empty docvalues 
      int starts[] = new int[slices.size()];
      for (int i = 0; i < slices.size(); i++) {
        DocValuesSlice slice = slices.get(i);
        starts[i] = slice.start;
        if (slice.docValues == null) {
          Type promoted = promotedType[0].type();
          switch(promoted) {
            case BYTES_FIXED_DEREF:
            case BYTES_FIXED_STRAIGHT:
            case BYTES_FIXED_SORTED:
              assert promotedType[0].getValueSize() >= 0;
              slice.docValues = new EmptyFixedDocValues(slice.length, promoted, promotedType[0].getValueSize());
              break;
            default:
              slice.docValues = new EmptyDocValues(slice.length, promoted);
          }
        }
      }
      
      return new MultiDocValues(slices.toArray(new DocValuesSlice[slices.size()]), starts, promotedType[0]);
    }
  }

