  // Delete by query
  private synchronized long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, SegmentReader reader) throws IOException {
    long delCount = 0;
    IndexSearcher searcher = new IndexSearcher(reader);
    assert searcher.getTopReaderContext().isAtomic;
    final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();
    try {
      for (QueryAndLimit ent : queriesIter) {
        Query query = ent.query;
        int limit = ent.limit;
        Weight weight = query.weight(searcher);
        Scorer scorer = weight.scorer(readerContext, Weight.ScorerContext.def());
        if (scorer != null) {
          while(true)  {
            int doc = scorer.nextDoc();
            if (doc >= limit)
              break;

            reader.deleteDocument(doc);
            // TODO: we could/should change
            // reader.deleteDocument to return boolean
            // true if it did in fact delete, because here
            // we could be deleting an already-deleted doc
            // which makes this an upper bound:
            delCount++;
          }
        }
      }
    } finally {
      searcher.close();
    }

    return delCount;
  }

