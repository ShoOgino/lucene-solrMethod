  public void write(IndexOutput output) throws IOException {
    output.writeVInt(FORMAT_CURRENT);
    output.writeVInt(size());
    for (FieldInfo fi : this) {
      assert fi.indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS || !fi.storePayloads;
      byte bits = 0x0;
      if (fi.isIndexed) bits |= IS_INDEXED;
      if (fi.storeTermVector) bits |= STORE_TERMVECTOR;
      if (fi.storePositionWithTermVector) bits |= STORE_POSITIONS_WITH_TERMVECTOR;
      if (fi.storeOffsetWithTermVector) bits |= STORE_OFFSET_WITH_TERMVECTOR;
      if (fi.omitNorms) bits |= OMIT_NORMS;
      if (fi.storePayloads) bits |= STORE_PAYLOADS;
      if (fi.indexOptions == IndexOptions.DOCS_ONLY)
        bits |= OMIT_TERM_FREQ_AND_POSITIONS;
      else if (fi.indexOptions == IndexOptions.DOCS_AND_FREQS)
        bits |= OMIT_POSITIONS;
      output.writeString(fi.name);
      output.writeInt(fi.number);
      output.writeByte(bits);

      final byte b;

      if (fi.docValues == null) {
        b = 0;
      } else {
        switch(fi.docValues) {
        case VAR_INTS:
          b = 1;
          break;
        case FLOAT_32:
          b = 2;
          break;
        case FLOAT_64:
          b = 3;
          break;
        case BYTES_FIXED_STRAIGHT:
          b = 4;
          break;
        case BYTES_FIXED_DEREF:
          b = 5;
          break;
        case BYTES_VAR_STRAIGHT:
          b = 6;
          break;
        case BYTES_VAR_DEREF:
          b = 7;
          break;
        case FIXED_INTS_16:
          b = 8;
          break;
        case FIXED_INTS_32:
          b = 9;
          break;
        case FIXED_INTS_64:
          b = 10;
          break;
        case FIXED_INTS_8:
          b = 11;
          break;
        case BYTES_FIXED_SORTED:
          b = 12;
          break;
        case BYTES_VAR_SORTED:
          b = 13;
          break;
        default:
          throw new IllegalStateException("unhandled indexValues type " + fi.docValues);
        }
      }
      output.writeByte(b);
    }
  }

