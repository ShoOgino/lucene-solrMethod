  /**
   * Returns a single {@link DocValues} instance for this field, merging
   * their values on the fly.
   * 
   * <p>
   * <b>NOTE</b>: this is a slow way to access DocValues. It's better to get the
   * sub-readers (using {@link Gather}) and iterate through them yourself.
   */
  public static DocValues getDocValues(IndexReader r, final String field) throws IOException {
    final IndexReader[] subs = r.getSequentialSubReaders();
    if (subs == null) {
      // already an atomic reader
      return r.docValues(field);
    } else if (subs.length == 0) {
      // no fields
      return null;
    } else if (subs.length == 1) {
      return getDocValues(subs[0], field);
    } else {      
      final List<DocValuesSlice> slices = new ArrayList<DocValuesSlice>();
      
      final TypePromoter promotedType[] = new TypePromoter[1];
      promotedType[0] = TypePromoter.getIdentityPromoter();
      
      // gather all docvalues fields, accumulating a promoted type across 
      // potentially incompatible types
      
      new ReaderUtil.Gather(r) {
        @Override
        protected void add(int base, IndexReader r) throws IOException {
          final DocValues d = r.docValues(field);
          if (d != null) {
            TypePromoter incoming = TypePromoter.create(d.type(), d.getValueSize());
            promotedType[0] = promotedType[0].promote(incoming);
          }
          slices.add(new DocValuesSlice(d, base, r.maxDoc()));
        }
      }.run();
      
      // return null if no docvalues encountered anywhere
      if (promotedType[0] == TypePromoter.getIdentityPromoter()) {
        return null;
      }
           
      // populate starts and fill gaps with empty docvalues 
      int starts[] = new int[slices.size()];
      for (int i = 0; i < slices.size(); i++) {
        DocValuesSlice slice = slices.get(i);
        starts[i] = slice.start;
        if (slice.docValues == null) {
          slice.docValues = new EmptyDocValues(slice.length, promotedType[0].type());
        }
      }
      
      return new MultiDocValues(slices.toArray(new DocValuesSlice[slices.size()]), starts, promotedType[0]);
    }
  }

