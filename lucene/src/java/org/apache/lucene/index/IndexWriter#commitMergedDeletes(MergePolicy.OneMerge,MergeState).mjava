  /** Carefully merges deletes for the segments we just
   *  merged.  This is tricky because, although merging will
   *  clear all deletes (compacts the documents), new
   *  deletes may have been flushed to the segments since
   *  the merge was started.  This method "carries over"
   *  such new deletes onto the newly merged segment, and
   *  saves the resulting deletes file (incrementing the
   *  delete generation for merge.info).  If no deletes were
   *  flushed, no new deletes file is saved. */
  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {

    assert testPoint("startCommitMergeDeletes");

    final List<SegmentInfo> sourceSegments = merge.segments;

    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW", "commitMergeDeletes " + segString(merge.segments));
    }

    // Carefully merge deletes that occurred after we
    // started merging:
    int docUpto = 0;
    long minGen = Long.MAX_VALUE;

    // Lazy init (only when we find a delete to carry over):
    ReadersAndLiveDocs mergedDeletes = null;

    for(int i=0; i < sourceSegments.size(); i++) {
      SegmentInfo info = sourceSegments.get(i);
      minGen = Math.min(info.getBufferedDeletesGen(), minGen);
      final int docCount = info.docCount;
      final Bits prevLiveDocs = merge.readerLiveDocs.get(i);
      final Bits currentLiveDocs;
      ReadersAndLiveDocs rld = readerPool.get(info, false);
      // We enrolled in mergeInit:
      assert rld != null;
      currentLiveDocs = rld.liveDocs;

      if (prevLiveDocs != null) {

        // If we had deletions on starting the merge we must
        // still have deletions now:
        assert currentLiveDocs != null;

        // There were deletes on this segment when the merge
        // started.  The merge has collapsed away those
        // deletes, but, if new deletes were flushed since
        // the merge started, we must now carefully keep any
        // newly flushed deletes but mapping them to the new
        // docIDs.

        // Since we copy-on-write, if any new deletes were
        // applied after merging has started, we can just
        // check if the before/after liveDocs have changed.
        // If so, we must carefully merge the liveDocs one
        // doc at a time:
        if (currentLiveDocs != prevLiveDocs) {

          // This means this segment received new deletes
          // since we started the merge, so we
          // must merge them:
          final int startDocUpto = docUpto;
          for(int j=0;j<docCount;j++) {
            if (!prevLiveDocs.get(j)) {
              assert !currentLiveDocs.get(j);
            } else {
              if (!currentLiveDocs.get(j)) {
                if (mergedDeletes == null) {
                  mergedDeletes = readerPool.get(merge.info, true);
                  mergedDeletes.initWritableLiveDocs();
                }
                mergedDeletes.delete(docUpto);
              }
              docUpto++;
            }
          }
        } else {
          assert mergeState.readers != null;
          assert mergeState.segmentDocCounts != null;
          docUpto += mergeState.segmentDocCounts.get(info);
        }
      } else if (currentLiveDocs != null) {
        // This segment had no deletes before but now it
        // does:
        for(int j=0; j<docCount; j++) {
          if (!currentLiveDocs.get(j)) {
            if (mergedDeletes == null) {
              mergedDeletes = readerPool.get(merge.info, true);
              mergedDeletes.initWritableLiveDocs();
            }
            mergedDeletes.delete(docUpto);
          }
          docUpto++;
        }
      } else {
        // No deletes before or after
        docUpto += info.docCount;
      }
    }

    if (infoStream.isEnabled("IW")) {
      if (mergedDeletes == null) {
        infoStream.message("IW", "no new deletes since merge started");
      } else {
        infoStream.message("IW", mergedDeletes.pendingDeleteCount + " new deletes since merge started");
      }
    }

    // If new deletes were applied while we were merging
    // (which happens if eg commit() or getReader() is
    // called during our merge), then it better be the case
    // that the delGen has increased for all our merged
    // segments:
    assert mergedDeletes == null || minGen > merge.info.getBufferedDeletesGen();

    merge.info.setBufferedDeletesGen(minGen);

    return mergedDeletes;
  }

