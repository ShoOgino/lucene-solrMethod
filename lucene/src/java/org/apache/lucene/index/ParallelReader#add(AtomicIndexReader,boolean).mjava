 /** Add an AtomicIndexReader whose stored fields will not be returned.  This can
  * accelerate search when stored fields are only needed from a subset of
  * the IndexReaders.
  *
  * @throws IllegalArgumentException if not all indexes contain the same number
  *     of documents
  * @throws IllegalArgumentException if not all indexes have the same value
  *     of {@link AtomicIndexReader#maxDoc()}
  * @throws IOException if there is a low-level IO error
  */
  public void add(AtomicIndexReader reader, boolean ignoreStoredFields)
    throws IOException {

    ensureOpen();
    if (readers.size() == 0) {
      this.maxDoc = reader.maxDoc();
      this.numDocs = reader.numDocs();
      this.hasDeletions = reader.hasDeletions();
    }

    if (reader.maxDoc() != maxDoc)                // check compatibility
      throw new IllegalArgumentException
        ("All readers must have same maxDoc: "+maxDoc+"!="+reader.maxDoc());
    if (reader.numDocs() != numDocs)
      throw new IllegalArgumentException
        ("All readers must have same numDocs: "+numDocs+"!="+reader.numDocs());

    final FieldInfos readerFieldInfos = ReaderUtil.getMergedFieldInfos(reader);
    for(FieldInfo fieldInfo : readerFieldInfos) {   // update fieldToReader map
      // NOTE: first reader having a given field "wins":
      if (fieldToReader.get(fieldInfo.name) == null) {
        fieldInfos.add(fieldInfo);
        fieldToReader.put(fieldInfo.name, reader);
        this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));
      }
    }

    if (!ignoreStoredFields)
      storedFieldReaders.add(reader);             // add to storedFieldReaders
    readers.add(reader);
    
    if (incRefReaders) {
      reader.incRef();
    }
    decrefOnClose.add(Boolean.valueOf(incRefReaders));
    synchronized(normsCache) {
      normsCache.clear(); // TODO: don't need to clear this for all fields really?
    }
  }

