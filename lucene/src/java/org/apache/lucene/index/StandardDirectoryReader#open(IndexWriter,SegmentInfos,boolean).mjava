  /** Used by near real-time search */
  static DirectoryReader open(IndexWriter writer, SegmentInfos infos, boolean applyAllDeletes) throws IOException {
    // IndexWriter synchronizes externally before calling
    // us, which ensures infos will not change; so there's
    // no need to process segments in reverse order
    final int numSegments = infos.size();

    List<SegmentReader> readers = new ArrayList<SegmentReader>();
    final Directory dir = writer.getDirectory();

    final SegmentInfos segmentInfos = (SegmentInfos) infos.clone();
    int infosUpto = 0;
    for (int i=0;i<numSegments;i++) {
      IOException prior = null;
      boolean success = false;
      try {
        final SegmentInfo info = infos.info(i);
        assert info.dir == dir;
        final IndexWriter.ReadersAndLiveDocs rld = writer.readerPool.get(info, true);
        final SegmentReader reader = rld.getReadOnlyClone(IOContext.READ);
        if (reader.numDocs() > 0 || writer.getKeepFullyDeletedSegments()) {
          readers.add(reader);
          infosUpto++;
        } else {
          reader.close();
          segmentInfos.remove(infosUpto);
        }
        success = true;
      } catch(IOException ex) {
        prior = ex;
      } finally {
        if (!success)
          IOUtils.closeWhileHandlingException(prior, readers);
      }
    }
    return new StandardDirectoryReader(dir, readers.toArray(new SegmentReader[readers.size()]),
      writer, segmentInfos, writer.getConfig().getReaderTermsIndexDivisor(), applyAllDeletes);
  }

