    // Important that we get docCount, in case there were
    // some last docs that we didn't see
    @Override
    public void finish(int docCount) throws IOException {
      final IndexOutput datOut = getDataOut();
      boolean success = false;
      final int count = hash.size();
      final int[] address = new int[count];

      try {
        datOut.writeInt(size);
        if (size != -1) {
          final int[] sortedEntries = hash.sort(comp);
          // first dump bytes data, recording address as we go
          final BytesRef bytesRef = new BytesRef(size);
          for (int i = 0; i < count; i++) {
            final int e = sortedEntries[i];
            final BytesRef bytes = hash.get(e, bytesRef);
            assert bytes.length == size;
            datOut.writeBytes(bytes.bytes, bytes.offset, bytes.length);
            address[e] = 1 + i;
          }
        }
        success = true;
      } finally {
        IOUtils.closeSafely(!success, datOut);
        hash.close();
      }
      final IndexOutput idxOut = getIndexOut();
      success = false;
      try {
        idxOut.writeInt(count);
        // next write index
        final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
            PackedInts.bitsRequired(count));
        final int limit;
        if (docCount > docToEntry.length) {
          limit = docToEntry.length;
        } else {
          limit = docCount;
        }
        for (int i = 0; i < limit; i++) {
          final int e = docToEntry[i];
          if (e == 0) {
            // null is encoded as zero
            w.add(0);
          } else {
            assert e > 0 && e <= count : "index must  0 > && <= " + count
                + " was: " + e;
            w.add(address[e - 1]);
          }
        }

        for (int i = limit; i < docCount; i++) {
          w.add(0);
        }
        w.finish();
      } finally {
        IOUtils.closeSafely(!success, idxOut);
        bytesUsed.addAndGet((-docToEntry.length)
            * RamUsageEstimator.NUM_BYTES_INT);
        docToEntry = null;
      }
    }

