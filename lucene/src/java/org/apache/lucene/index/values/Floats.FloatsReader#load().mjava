    /**
     * Loads the actual values. You may call this more than once, eg if you
     * already previously loaded but then discarded the Source.
     */
    @Override
    public Source load() throws IOException {
      /* we always read BIG_ENDIAN here since the writer uses
       * DataOutput#writeInt() / writeLong() we can simply read the ints / longs
       * back in using readInt / readLong */
      final IndexInput indexInput = (IndexInput) datIn.clone();
      indexInput.seek(CodecUtil.headerLength(CODEC_NAME));
      // skip precision:
      indexInput.readByte();
      if (precisionBytes == 4) {
        final float[] values = new float[(4 * maxDoc) >> 2];
        assert values.length == maxDoc;
        for (int i = 0; i < values.length; i++) {
          values[i] = Float.intBitsToFloat(indexInput.readInt());
        }
        return new Source4(values);
      } else {
        final double[] values = new double[(8 * maxDoc) >> 3];
        assert values.length == maxDoc;
        for (int i = 0; i < values.length; i++) {
          values[i] = Double.longBitsToDouble(indexInput.readLong());
        }
        return new Source8(values);
      }
    }

