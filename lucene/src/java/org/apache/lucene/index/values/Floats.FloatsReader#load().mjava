    /**
     * Loads the actual values. You may call this more than once, eg if you
     * already previously loaded but then discarded the Source.
     */
    @Override
    public Source load() throws IOException {
      /*
       *  the allocated byteBuffer always uses BIG_ENDIAN here
       *  and since the writer uses DataOutput#writeInt() / writeLong()
       *  we can allways assume BIGE_ENDIAN
       */
      final ByteBuffer buffer = ByteBuffer.allocate(precisionBytes * maxDoc);
      IndexInput indexInput = (IndexInput) datIn.clone();
      indexInput.seek(CodecUtil.headerLength(CODEC_NAME));
      // skip precision:
      indexInput.readByte();
      assert buffer.hasArray() : "Buffer must support Array";
      final byte[] arr = buffer.array();
      indexInput.readBytes(arr, 0, arr.length);
      return precisionBytes == 4 ? new Source4(buffer) : new Source8(buffer);
    }

