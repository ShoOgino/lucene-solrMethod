    @Override
    public void finish(int docCount) throws IOException {
      boolean success = false;
      assert (!merge && datOut == null) || (merge && datOut != null); 
      final IndexOutput datOut = getDataOut();
      try {
        if (!merge) {
          // header is already written in getDataOut()
          pool.writePool(datOut);
        }
        success = true;
      } finally {
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
        pool.dropBuffersAndReset();
      }

      success = false;
      final IndexOutput idxOut = getIndexOut();
      try {
        if (lastDocID == -1) {
          idxOut.writeVLong(0);
          final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
              PackedInts.bitsRequired(0));
          for (int i = 0; i < docCount; i++) {
            w.add(0);
          }
          w.finish();
        } else {
          fill(docCount);
          idxOut.writeVLong(address);
          final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount,
              PackedInts.bitsRequired(address));
          for (int i = 0; i < docCount; i++) {
            w.add(docToAddress[i]);
          }
          w.finish();
        }
        success = true;
      } finally {
        bytesUsed.addAndGet(-(docToAddress.length)
            * RamUsageEstimator.NUM_BYTES_INT);
        docToAddress = null;
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
      }
    }

