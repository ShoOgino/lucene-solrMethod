  /**
   * Publishes the flushed segment, segment private deletes (if any) and its
   * associated global delete (if present) to IndexWriter.  The actual
   * publishing operation is synced on IW -> BDS so that the {@link SegmentInfo}'s
   * delete generation is always GlobalPacket_deleteGeneration + 1
   */
  private void publishFlushedSegment(FlushedSegment newSegment, FrozenBufferedDeletes globalPacket)
      throws IOException {
    assert newSegment != null;
    final SegmentInfo segInfo = indexWriter.prepareFlushedSegment(newSegment);
    final BufferedDeletes deletes = newSegment.segmentDeletes;
    if (infoStream != null) {
      infoStream.message("DW", Thread.currentThread().getName() + ": publishFlushedSegment seg-private deletes=" + deletes);  
    }
    FrozenBufferedDeletes packet = null;
    if (deletes != null && deletes.any()) {
      // Segment private delete
      packet = new FrozenBufferedDeletes(deletes, true);
      if (infoStream != null) {
        infoStream.message("DW", "flush: push buffered seg private deletes: " + packet);
      }
    }

    // now publish!
    indexWriter.publishFlushedSegment(segInfo, packet, globalPacket);
  }

