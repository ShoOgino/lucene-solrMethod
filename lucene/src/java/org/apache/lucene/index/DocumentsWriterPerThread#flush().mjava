  /** Flush all pending docs to a new segment */
  SegmentInfo flush() throws IOException {
    assert numDocsInRAM > 0;

    flushState = new SegmentWriteState(infoStream, directory, segment, fieldInfos,
        numDocsInRAM, writer.getConfig().getTermIndexInterval(),
        SegmentCodecs.build(fieldInfos, writer.codecs));

    if (infoStream != null) {
      message("flush postings as segment " + flushState.segmentName + " numDocs=" + numDocsInRAM);
    }

    boolean success = false;

    try {
      consumer.flush(flushState);

      boolean hasVectors = flushState.hasVectors;

      if (infoStream != null) {
        SegmentInfo si = new SegmentInfo(flushState.segmentName,
            flushState.numDocs,
            directory, false,
            hasProx(),
            getCodec(),
            hasVectors);

        final long newSegmentSize = si.sizeInBytes(true);
        String message = "  ramUsed=" + nf.format(((double) bytesUsed.get())/1024./1024.) + " MB" +
          " newFlushedSize=" + newSegmentSize +
          " docs/MB=" + nf.format(numDocsInRAM/(newSegmentSize/1024./1024.)) +
          " new/old=" + nf.format(100.0*newSegmentSize/bytesUsed.get()) + "%";
        message(message);
      }

      flushedDocCount += flushState.numDocs;

      doAfterFlush();

      // Create new SegmentInfo, but do not add to our
      // segmentInfos until deletes are flushed
      // successfully.
      SegmentInfo newSegment = new SegmentInfo(flushState.segmentName,
                                   flushState.numDocs,
                                   directory, false,
                                   hasProx(),
                                   getCodec(),
                                   hasVectors);


      IndexWriter.setDiagnostics(newSegment, "flush");
      success = true;

      return newSegment;
    } finally {
      if (!success) {
        abort();
      }
    }
  }

