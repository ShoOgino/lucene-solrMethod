  private synchronized long applyDeletes(SegmentDeletes deletes, SegmentReader reader) throws IOException {

    long delCount = 0;

    assert checkDeleteTerm(null);
    
    if (deletes.terms.size() > 0) {
      Fields fields = reader.fields();
      if (fields == null) {
        // This reader has no postings
        return 0;
      }

      TermsEnum termsEnum = null;
        
      String currentField = null;
      DocsEnum docs = null;
        
      for (Entry<Term,Integer> entry: deletes.terms.entrySet()) {
        Term term = entry.getKey();
        // Since we visit terms sorted, we gain performance
        // by re-using the same TermsEnum and seeking only
        // forwards
        if (term.field() != currentField) {
          assert currentField == null || currentField.compareTo(term.field()) < 0;
          currentField = term.field();
          Terms terms = fields.terms(currentField);
          if (terms != null) {
            termsEnum = terms.iterator();
          } else {
            termsEnum = null;
          }
        }
          
        if (termsEnum == null) {
          continue;
        }
        assert checkDeleteTerm(term);
          
        if (termsEnum.seek(term.bytes(), false) == TermsEnum.SeekStatus.FOUND) {
          DocsEnum docsEnum = termsEnum.docs(reader.getDeletedDocs(), docs);
            
          if (docsEnum != null) {
            docs = docsEnum;
            final int limit = entry.getValue();
            while (true) {
              final int docID = docs.nextDoc();
              if (docID == DocsEnum.NO_MORE_DOCS || docID >= limit) {
                break;
              }
              reader.deleteDocument(docID);
              // TODO: we could/should change
              // reader.deleteDocument to return boolean
              // true if it did in fact delete, because here
              // we could be deleting an already-deleted doc
              // which makes this an upper bound:
              delCount++;
            }
          }
        }
      }
    }

    // Delete by docID
    for (Integer docIdInt : deletes.docIDs) {
      int docID = docIdInt.intValue();
      reader.deleteDocument(docID);
      delCount++;
    }

    // Delete by query
    if (deletes.queries.size() > 0) {
      IndexSearcher searcher = new IndexSearcher(reader);
      assert searcher.getTopReaderContext().isAtomic;
      final AtomicReaderContext readerContext = (AtomicReaderContext) searcher.getTopReaderContext();
      try {
        for (Entry<Query, Integer> entry : deletes.queries.entrySet()) {
          Query query = entry.getKey();
          int limit = entry.getValue().intValue();
          Weight weight = query.weight(searcher);
          Scorer scorer = weight.scorer(readerContext, true, false);
          if (scorer != null) {
            while(true)  {
              int doc = scorer.nextDoc();
              if (doc >= limit)
                break;

              reader.deleteDocument(doc);
              // TODO: we could/should change
              // reader.deleteDocument to return boolean
              // true if it did in fact delete, because here
              // we could be deleting an already-deleted doc
              // which makes this an upper bound:
              delCount++;
            }
          }
        }
      } finally {
        searcher.close();
      }
    }

    return delCount;
  }

