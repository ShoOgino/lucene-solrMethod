  @Override
  public void flush(Collection<DocConsumerPerThread> threads, SegmentWriteState state) throws IOException {

    Map<DocFieldConsumerPerThread, Collection<DocFieldConsumerPerField>> childThreadsAndFields = new HashMap<DocFieldConsumerPerThread, Collection<DocFieldConsumerPerField>>();
    for ( DocConsumerPerThread thread : threads) {
      DocFieldProcessorPerThread perThread = (DocFieldProcessorPerThread) thread;
      childThreadsAndFields.put(perThread.consumer, perThread.fields());
    }
    fieldsWriter.flush(state);
    consumer.flush(childThreadsAndFields, state);

    for(DocValuesConsumer p : docValues.values()) {
      if (p != null) {
        p.finish(state.numDocs);
      }
    }
    docValues.clear();
    if(fieldsConsumer != null) {
      fieldsConsumer.close(); // TODO remove this once docvalues are fully supported by codecs
      docValuesConsumerState = null;
      fieldsConsumer = null;
    }

    // Important to save after asking consumer to flush so
    // consumer can alter the FieldInfo* if necessary.  EG,
    // FreqProxTermsWriter does this with
    // FieldInfo.storePayload.
    final String fileName = IndexFileNames.segmentFileName(state.segmentName, "", IndexFileNames.FIELD_INFOS_EXTENSION);
    state.fieldInfos.write(state.directory, fileName);
  }

