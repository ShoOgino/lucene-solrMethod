  /** Produce _X.nrm if any document had a field with norms
   *  not disabled */
  @Override
  public void flush(Map<FieldInfo,InvertedDocEndConsumerPerField> fieldsToFlush, SegmentWriteState state) throws IOException {
    boolean success = false;
    boolean anythingFlushed = false;
    try {
      if (state.fieldInfos.hasNorms()) {
        for (FieldInfo fi : state.fieldInfos) {
          final NormsConsumerPerField toWrite = (NormsConsumerPerField) fieldsToFlush.get(fi);
          // we must check the final value of omitNorms for the fieldinfo, it could have 
          // changed for this field since the first time we added it.
          if (!fi.omitNorms) {
            if (toWrite != null && toWrite.initialized()) {
              anythingFlushed = true;
              toWrite.flush(state.numDocs);
            } else if (fi.isIndexed) {
              anythingFlushed = true;
              final DocValuesConsumer valuesConsumer = newConsumer(new PerDocWriteState(state), fi);
              final DocValuesField value = new DocValuesField("", new BytesRef(new byte[] {0x0}), Type.BYTES_FIXED_STRAIGHT);
              valuesConsumer.add(state.numDocs-1, value);
              valuesConsumer.finish(state.numDocs);
            }
          }
        }
      } 
      
      success = true;
      if (!anythingFlushed && consumer != null) {
        consumer.abort();
      }
    } finally {
      if (success) {
        IOUtils.close(consumer);
      } else {
        IOUtils.closeWhileHandlingException(consumer);
      }
    }
  }

