      /** Seeks until the first term that's >= the provided
       *  text; returns SeekStatus.FOUND if the exact term
       *  is found, SeekStatus.NOT_FOUND if a different term
       *  was found, SeekStatus.END if we hit EOF */
      @Override
      public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {

        if (indexEnum == null) {
          throw new IllegalStateException("terms index was not loaded");
        }
        
        //System.out.println("te.seek term=" + fieldInfo.name + ":" + term.utf8ToString() + " current=" + term().utf8ToString() + " useCache=" + useCache + " this="  + this);

        // Check cache
        fieldTerm.term = term;
        TermState cachedState;
        if (useCache) {
          cachedState = termsCache.get(fieldTerm);
          if (cachedState != null) {
            state.copyFrom(cachedState);
            seekPending = true;
            positioned = false;
            bytesReader.term.copy(term);
            //System.out.println("  cached!");
            return SeekStatus.FOUND;
          }
        } else {
          cachedState = null;
        }

        boolean doSeek = true;

        if (positioned) {

          final int cmp = termComp.compare(bytesReader.term, term);

          if (cmp == 0) {
            // already at the requested term
            return SeekStatus.FOUND;
          } else if (cmp < 0) {

            if (seekPending) {
              seekPending = false;
              in.seek(state.filePointer);
              indexEnum.seek(bytesReader.term);
              didIndexNext = false;
            }

            // Target term is after current term
            if (!didIndexNext) {
              if (indexEnum.next() == -1) {
                nextIndexTerm = null;
              } else {
                nextIndexTerm = indexEnum.term();
              }
              //System.out.println("  now do index next() nextIndexTerm=" + (nextIndexTerm == null ? "null" : nextIndexTerm.utf8ToString()));
              didIndexNext = true;
            }

            if (nextIndexTerm == null || termComp.compare(term, nextIndexTerm) < 0) {
              // Optimization: requested term is within the
              // same index block we are now in; skip seeking
              // (but do scanning):
              doSeek = false;
              //System.out.println("  skip seek: nextIndexTerm=" + nextIndexTerm);
            }
          }
        }

        if (doSeek) {

          positioned = true;

          // Ask terms index to find biggest index term that's <=
          // our text:
          in.seek(indexEnum.seek(term));
          didIndexNext = false;
          if (doOrd) {
            state.ord = indexEnum.ord()-1;
          }
          seekPending = false;

          // NOTE: the first next() after an index seek is
          // wasteful, since it redundantly reads the same
          // bytes into the buffer.  We could avoid storing
          // those bytes in the primary file, but then when
          // scanning over an index term we'd have to
          // special case it:
          bytesReader.reset(indexEnum.term());
          //System.out.println("  doSeek term=" + indexEnum.term().utf8ToString() + " vs target=" + term.utf8ToString());
        } else {
          //System.out.println("  skip seek");
        }

        assert startSeek();

        // Now scan:
        while (next() != null) {
          final int cmp = termComp.compare(bytesReader.term, term);
          if (cmp == 0) {
            // Done!
            if (useCache) {
              // Store in cache
              FieldAndTerm entryKey = new FieldAndTerm(fieldTerm);
              cachedState = (TermState) state.clone();
              // this is fp after current term
              cachedState.filePointer = in.getFilePointer();
              termsCache.put(entryKey, cachedState);
            }

            return SeekStatus.FOUND;
          } else if (cmp > 0) {
            return SeekStatus.NOT_FOUND;
          }

          // The purpose of the terms dict index is to seek
          // the enum to the closest index term before the
          // term we are looking for.  So, we should never
          // cross another index term (besides the first
          // one) while we are scanning:
          assert checkSeekScan();
        }

        positioned = false;
        return SeekStatus.END;
      }

