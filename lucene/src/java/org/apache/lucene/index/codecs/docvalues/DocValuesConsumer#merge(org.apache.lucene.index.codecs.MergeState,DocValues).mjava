  /**
   * Merges the given {@link org.apache.lucene.index.codecs.MergeState} into
   * this {@link DocValuesConsumer}.
   * 
   * @param mergeState
   *          the state to merge
   * @param values
   *          the docValues to merge in
   * @throws IOException
   *           if an {@link IOException} occurs
   */
  public void merge(org.apache.lucene.index.codecs.MergeState mergeState,
      DocValues values) throws IOException {
    assert mergeState != null;
    // TODO we need some kind of compatibility notation for values such
    // that two slightly different segments can be merged eg. fixed vs.
    // variable byte len or float32 vs. float64
    int docBase = 0;
    boolean merged = false;
    /*
     * We ignore the given DocValues here and merge from the subReaders directly
     * to support bulk copies on the DocValues Writer level. if this gets merged
     * with MultiDocValues the writer can not optimize for bulk-copyable data
     */
    for (final IndexReader reader : mergeState.readers) {
      final DocValues r = reader.docValues(mergeState.fieldInfo.name);
      if (r != null) {
        merged = true;
        merge(new Writer.MergeState(r, docBase, reader.maxDoc(), reader
            .getDeletedDocs()));
      }
      docBase += reader.numDocs();
    }
    if (merged) {
      finish(mergeState.mergedDocCount);
    }
  }

