    private boolean pushNewSurrogate() throws IOException {
      if (DEBUG_SURROGATES) {
        System.out.println("  check push newSuffix=" + newSuffixStart + " stack=" + getStack());
      }
      final Term t = termEnum.term();
      if (t == null || t.field() != fieldInfo.name) {
        return false;
      }

      final BytesRef bytes = t.bytes();
      UnicodeUtil.UTF8toUTF16(bytes.bytes, bytes.offset, bytes.length, termBuffer);

      for(int i=Math.max(0,newSuffixStart);i<termBuffer.length;i++) {
        final char ch = termBuffer.result[i];
        if (ch >= UnicodeUtil.UNI_SUR_HIGH_START && ch <= UnicodeUtil.UNI_SUR_HIGH_END && (surrogateSeekUpto == 0 || i > surrogateSeekPending[surrogateSeekUpto-1])) {

          if (DEBUG_SURROGATES) {
            System.out.println("    found high surr 0x" + Integer.toHexString(ch) + " at pos=" + i);
          }

          // the next() that we just did read in a new
          // suffix, containing a surrogate pair

          // seek forward to see if there are any terms with
          // this same prefix, but with characters after the
          // surrogate range; if so, we must first iterate
          // them, then seek back to the surrogates

          char[] testPrefix = new char[i+2];
          for(int j=0;j<i;j++) {
            testPrefix[j] = termBuffer.result[j];
          }
          testPrefix[i] = 1+UnicodeUtil.UNI_SUR_LOW_END;

          getTermsDict().seekEnum(seekTermEnum, protoTerm.createTerm(new BytesRef(testPrefix, 0, i+1)));

          Term t2 = seekTermEnum.term();
          boolean isPrefix;
          if (t2 != null && t2.field() == fieldInfo.name) {

            final BytesRef seekBytes = t2.bytes();
            UnicodeUtil.UTF8toUTF16(seekBytes.bytes, seekBytes.offset, seekBytes.length, seekBuffer);

            isPrefix = true;
            if (DEBUG_SURROGATES) {
              System.out.println("      seek found " + UnicodeUtil.toHexString(t2.text()));
            }
            for(int j=0;j<i;j++) {
              if (testPrefix[j] != seekBuffer.result[j]) {
                isPrefix = false;
                break;
              }
            }
            if (DEBUG_SURROGATES && !isPrefix) {
              System.out.println("      no end terms");
            }
          } else {
            if (DEBUG_SURROGATES) {
              System.out.println("      no end terms");
            }
            isPrefix = false;
          }

          if (isPrefix) {
            // we found a term, sharing the same prefix,
            // with characters after the surrogates, so we
            // must first enum those, and then return the
            // the surrogates afterwards.  push that pending
            // seek on the surrogates stack now:
            pendingPrefix = testPrefix;

            getTermsDict().seekEnum(termEnum, t2);

            if (surrogateSeekUpto == surrogateSeekPending.length) {
              surrogateSeekPending = ArrayUtil.grow(surrogateSeekPending);
            }
            if (surrogateSeekUpto == surrogateDidSeekBack.length) {
              surrogateDidSeekBack = ArrayUtil.grow(surrogateDidSeekBack);
            }
            surrogateSeekPending[surrogateSeekUpto] = i;
            surrogateDidSeekBack[surrogateSeekUpto] = false;
            surrogateSeekUpto++;

            if (DEBUG_SURROGATES) {
              System.out.println("      do push " + i + "; end term=" + UnicodeUtil.toHexString(t2.text()));
            }

            newSuffixStart = i+1;

            return true;
          } else {
            // there are no terms after the surrogates, so
            // we do nothing to the enum and just step
            // through the surrogates like normal.  but we
            // must keep iterating through the term, in case
            // another surrogate pair appears later
          }
        }
      }

      return false;
    }

