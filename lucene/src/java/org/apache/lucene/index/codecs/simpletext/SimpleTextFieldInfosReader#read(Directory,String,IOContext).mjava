  @Override
  public FieldInfos read(Directory directory, String segmentName, IOContext iocontext) throws IOException {
    final String fileName = IndexFileNames.segmentFileName(segmentName, "", FIELD_INFOS_EXTENSION);
    IndexInput input = directory.openInput(fileName, iocontext);
    BytesRef scratch = new BytesRef();
    
    boolean hasVectors = false;
    boolean hasFreq = false;
    boolean hasProx = false;
    
    try {
      
      SimpleTextUtil.readLine(input, scratch);
      assert scratch.startsWith(NUMFIELDS);
      final int size = Integer.parseInt(readString(NUMFIELDS.length, scratch));
      FieldInfo infos[] = new FieldInfo[size];

      for (int i = 0; i < size; i++) {
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(NAME);
        String name = readString(NAME.length, scratch);
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(NUMBER);
        int fieldNumber = Integer.parseInt(readString(NUMBER.length, scratch));

        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(ISINDEXED);
        boolean isIndexed = Boolean.parseBoolean(readString(ISINDEXED.length, scratch));
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(STORETV);
        boolean storeTermVector = Boolean.parseBoolean(readString(STORETV.length, scratch));
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(STORETVPOS);
        boolean storePositionsWithTermVector = Boolean.parseBoolean(readString(STORETVPOS.length, scratch));
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(STORETVOFF);
        boolean storeOffsetWithTermVector = Boolean.parseBoolean(readString(STORETVOFF.length, scratch));
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(PAYLOADS);
        boolean storePayloads = Boolean.parseBoolean(readString(PAYLOADS.length, scratch));
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(NORMS);
        boolean omitNorms = !Boolean.parseBoolean(readString(NORMS.length, scratch));

        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(DOCVALUES);
        String dvType = readString(DOCVALUES.length, scratch);
        final ValueType docValuesType;
        
        if ("false".equals(dvType)) {
          docValuesType = null;
        } else {
          docValuesType = ValueType.valueOf(dvType);
        }
        
        SimpleTextUtil.readLine(input, scratch);
        assert scratch.startsWith(INDEXOPTIONS);
        IndexOptions indexOptions = IndexOptions.valueOf(readString(INDEXOPTIONS.length, scratch));

        hasVectors |= storeTermVector;
        hasProx |= isIndexed && indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS;
        hasFreq |= isIndexed && indexOptions != IndexOptions.DOCS_ONLY;
        
        infos[i] = new FieldInfo(name, isIndexed, fieldNumber, storeTermVector, 
          storePositionsWithTermVector, storeOffsetWithTermVector, 
          omitNorms, storePayloads, indexOptions, docValuesType);
      }

      if (input.getFilePointer() != input.length()) {
        throw new CorruptIndexException("did not read all bytes from file \"" + fileName + "\": read " + input.getFilePointer() + " vs size " + input.length() + " (resource: " + input + ")");
      }
      
      return new FieldInfos(infos, hasFreq, hasProx, hasVectors);
    } finally {
      input.close();
    }
  }

