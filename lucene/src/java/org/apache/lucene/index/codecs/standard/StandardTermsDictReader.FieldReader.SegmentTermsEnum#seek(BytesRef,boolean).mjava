      /** Seeks until the first term that's >= the provided
       *  text; returns SeekStatus.FOUND if the exact term
       *  is found, SeekStatus.NOT_FOUND if a different term
       *  was found, SeekStatus.END if we hit EOF */
      @Override
      public SeekStatus seek(BytesRef term, boolean useCache) throws IOException {
        // Check cache
        fieldTerm.term = term;
        TermState cachedState;
        if (useCache) {
          cachedState = termsCache.get(fieldTerm);
          if (cachedState != null) {
            state.copy(cachedState);
            seekPending = true;
            bytesReader.term.copy(term);
            return SeekStatus.FOUND;
          }
        } else {
          cachedState = null;
        }

        boolean doSeek = true;

        if (state.ord != -1) {
          // we are positioned

          final int cmp = termComp.compare(bytesReader.term, term);

          if (cmp == 0) {
            // already at the requested term
            return SeekStatus.FOUND;
          }

          if (cmp < 0 &&
              fieldIndexReader.nextIndexTerm(state.ord, indexResult) &&
              termComp.compare(indexResult.term, term) > 0) {
            // Optimization: requested term is within the
            // same index block we are now in; skip seeking
            // (but do scanning):
            doSeek = false;
          }
        }

        // Used only for assert:
        final long startOrd;

        if (doSeek) {

          // As index to find biggest index term that's <=
          // our text:
          fieldIndexReader.getIndexOffset(term, indexResult);

          in.seek(indexResult.offset);
          seekPending = false;

          // NOTE: the first next() after an index seek is
          // wasteful, since it redundantly reads the same
          // bytes into the buffer.  We could avoid storing
          // those bytes in the primary file, but then when
          // scanning over an index term we'd have to
          // special case it:
          bytesReader.reset(indexResult.term);
          
          state.ord = indexResult.position-1;
          assert state.ord >= -1: "ord=" + state.ord;

          startOrd = indexResult.position;
        } else {
          startOrd = -1;
        }

        // Now scan:
        while(next() != null) {
          final int cmp = termComp.compare(bytesReader.term, term);
          if (cmp == 0) {

            if (doSeek && useCache) {
              // Store in cache
              FieldAndTerm entryKey = new FieldAndTerm(fieldTerm);
              cachedState = (TermState) state.clone();
              // this is fp after current term
              cachedState.filePointer = in.getFilePointer();
              termsCache.put(entryKey, cachedState);
            }
              
            return SeekStatus.FOUND;
          } else if (cmp > 0) {
            return SeekStatus.NOT_FOUND;
          }
          // The purpose of the terms dict index is to seek
          // the enum to the closest index term before the
          // term we are looking for.  So, we should never
          // cross another index term (besides the first
          // one) while we are scanning:
          assert state.ord == startOrd || !fieldIndexReader.isIndexTerm(state.ord, state.docFreq, true): "state.ord=" + state.ord + " startOrd=" + startOrd + " ir.isIndexTerm=" + fieldIndexReader.isIndexTerm(state.ord, state.docFreq, true) + " state.docFreq=" + state.docFreq;
        }

        return SeekStatus.END;
      }

