  /**
   * Consumes and merges the given {@link PerDocValues} producer
   * into this consumers format.   
   */
  public void merge(MergeState mergeState)
      throws IOException {
    final FieldInfos fieldInfos = mergeState.fieldInfos;
    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];
    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];
    // pull all PerDocValues 
    for (int i = 0; i < perDocValues.length; i++) {
      perDocValues[i] =  mergeState.readers.get(i).reader.perDocValues();
    }
    for (FieldInfo fieldInfo : fieldInfos) {
      mergeState.fieldInfo = fieldInfo;
      TypePromoter currentPromoter = TypePromoter.getIdentityPromoter();
      if (fieldInfo.hasDocValues()) {
        for (int i = 0; i < perDocValues.length; i++) {
          if (perDocValues[i] != null) { // get all IDV to merge
            docValues[i] = perDocValues[i].docValues(fieldInfo.name);
            if (docValues[i] != null) {
              currentPromoter = promoteValueType(fieldInfo, docValues[i], currentPromoter);
              if (currentPromoter == null) {
                break;
              }     
            }
          }
        }
        
        if (currentPromoter == null) {
          fieldInfo.resetDocValues(null);
          continue;
        }
        assert currentPromoter != TypePromoter.getIdentityPromoter();
        if (fieldInfo.getDocValues() != currentPromoter.type()) {
          // reset the type if we got promoted
          fieldInfo.resetDocValues(currentPromoter.type());
        }
        
        final DocValuesConsumer docValuesConsumer = addValuesField(mergeState.fieldInfo);
        assert docValuesConsumer != null;
        docValuesConsumer.merge(mergeState, docValues);
      }
    }
    /* NOTE: don't close the perDocProducers here since they are private segment producers
     * and will be closed once the SegmentReader goes out of scope */ 
  }

