  public void merge(MergeState mergeState, Fields fields) throws IOException {
    FieldsEnum fieldsEnum = fields.iterator();
    assert fieldsEnum != null;
    String field;
    while((field = fieldsEnum.next()) != null) {
      mergeState.fieldInfo = mergeState.fieldInfos.fieldInfo(field);
      assert mergeState.fieldInfo != null : "FieldInfo for field is null: "+ field;
      TermsEnum terms = fieldsEnum.terms();
      if(terms != null) {
        final TermsConsumer termsConsumer = addField(mergeState.fieldInfo);
        termsConsumer.merge(mergeState, terms);
      }
      
      DocValues docValues = fieldsEnum.docValues();   // fix this - does not work due to multi fields
      if(docValues != null) {
      // TODO we need some kind of compatibility notation for values such
      // that two slighly different segments can be merged eg. fixed vs.
      // variable byte len or float32 vs. float64
        int docBase = 0;
        final List<Writer.MergeState> mergeStates = new ArrayList<Writer.MergeState>();
        for (IndexReader reader : mergeState.readers) {
          DocValues r = reader.docValues(mergeState.fieldInfo.name);
          if (r != null) {
            mergeStates.add(new Writer.MergeState(r, docBase, reader
                .maxDoc(), reader.getDeletedDocs()));
          }
          docBase += reader.numDocs();
        }
        if (mergeStates.isEmpty()) {
          continue;
        }
        final DocValuesConsumer docValuesConsumer = addValuesField(mergeState.fieldInfo);
        docValuesConsumer.merge(mergeStates);
        docValuesConsumer.finish(mergeState.mergedDocCount);
      }
      
      // merge doc values
//   
    }
  }

