  /**
   * Constructs a new IndexWriter per the settings given in <code>conf</code>.
   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making
   * changes to it after IndexWriter has been instantiated will not affect
   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the
   * parameters does not affect that IndexWriter instance.
   * <p>
   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}
   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to
   * whether this setting fits your application.
   * 
   * @param d
   *          the index directory. The index is either created or appended
   *          according <code>conf.getOpenMode()</code>.
   * @param conf
   *          the configuration settings according to which IndexWriter should
   *          be initalized.
   * @throws CorruptIndexException
   *           if the index is corrupt
   * @throws LockObtainFailedException
   *           if another writer has this index open (<code>write.lock</code>
   *           could not be obtained)
   * @throws IOException
   *           if the directory cannot be read/written to, or if it does not
   *           exist and <code>conf.getOpenMode()</code> is
   *           <code>OpenMode.APPEND</code> or if there is any other low-level
   *           IO error
   */
  public IndexWriter(Directory d, IndexWriterConfig conf)
      throws CorruptIndexException, LockObtainFailedException, IOException {
    config = (IndexWriterConfig) conf.clone();
    directory = d;
    analyzer = conf.getAnalyzer();
    setMessageID(defaultInfoStream);
    maxFieldLength = conf.getMaxFieldLength();
    termIndexInterval = conf.getTermIndexInterval();
    writeLockTimeout = conf.getWriteLockTimeout();
    similarity = conf.getSimilarity();
    mergePolicy = conf.getMergePolicy();
    mergePolicy.setIndexWriter(this);
    mergeScheduler = conf.getMergeScheduler();
    mergedSegmentWarmer = conf.getMergedSegmentWarmer();
    poolReaders = conf.getReaderPooling();

    OpenMode mode = conf.getOpenMode();
    boolean create;
    if (mode == OpenMode.CREATE) {
      create = true;
    } else if (mode == OpenMode.APPEND) {
      create = false;
    } else {
      // CREATE_OR_APPEND - create only if an index does not exist
      create = !IndexReader.indexExists(directory);
    }

    if (create) {
      // Clear the write lock in case it's leftover:
      directory.clearLock(WRITE_LOCK_NAME);
    }

    writeLock = directory.makeLock(WRITE_LOCK_NAME);
    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock
      throw new LockObtainFailedException("Index locked for write: " + writeLock);

    try {
      if (create) {
        // Try to read first.  This is to allow create
        // against an index that's currently open for
        // searching.  In this case we write the next
        // segments_N file with no segments:
        boolean doCommit;
        try {
          segmentInfos.read(directory);
          segmentInfos.clear();
          doCommit = false;
        } catch (IOException e) {
          // Likely this means it's a fresh directory
          doCommit = true;
        }

        if (doCommit) {
          // Only commit if there is no segments file in
          // this dir already.
          segmentInfos.commit(directory);
          synced.addAll(segmentInfos.files(directory, true));
        } else {
          // Record that we have a change (zero out all
          // segments) pending:
          changeCount++;
        }
      } else {
        segmentInfos.read(directory);

        IndexCommit commit = conf.getIndexCommit();
        if (commit != null) {
          // Swap out all segments, but, keep metadata in
          // SegmentInfos, like version & generation, to
          // preserve write-once.  This is important if
          // readers are open against the future commit
          // points.
          if (commit.getDirectory() != directory)
            throw new IllegalArgumentException("IndexCommit's directory doesn't match my directory");
          SegmentInfos oldInfos = new SegmentInfos();
          oldInfos.read(directory, commit.getSegmentsFileName());
          segmentInfos.replace(oldInfos);
          changeCount++;
          if (infoStream != null)
            message("init: loaded commit \"" + commit.getSegmentsFileName() + "\"");
        }

        // We assume that this segments_N was previously
        // properly sync'd:
        synced.addAll(segmentInfos.files(directory, true));
      }

      setRollbackSegmentInfos(segmentInfos);

      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());
      docWriter.setInfoStream(infoStream);
      docWriter.setMaxFieldLength(maxFieldLength);

      // Default deleter (for backwards compatibility) is
      // KeepOnlyLastCommitDeleter:
      deleter = new IndexFileDeleter(directory,
                                     conf.getIndexDeletionPolicy(),
                                     segmentInfos, infoStream, docWriter);

      if (deleter.startingCommitDeleted)
        // Deletion policy deleted the "head" commit point.
        // We have to mark ourself as changed so that if we
        // are closed w/o any further changes we write a new
        // segments_N file.
        changeCount++;

      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());
      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());
      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());
      pushMaxBufferedDocs();

      if (infoStream != null) {
        messageState();
      }

    } catch (IOException e) {
      writeLock.release();
      writeLock = null;
      throw e;
    }
  }

