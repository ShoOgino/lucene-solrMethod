  /**
   * Flush all in-memory buffered udpates (adds and deletes)
   * to the Directory.
   * @param triggerMerge if true, we may merge segments (if
   *  deletes or docs were flushed) if necessary
   * @param flushDocStores if false we are allowed to keep
   *  doc stores open to share with the next segment
   * @param flushDeletes whether pending deletes should also
   *  be flushed
   */
  protected final void flush(boolean triggerMerge, boolean flushDeletes) throws CorruptIndexException, IOException {
    // We can be called during close, when closing==true, so we must pass false to ensureOpen:
    ensureOpen(false);
    
    doBeforeFlush();
    
    if (flushDeletes) {
      if (applyDeletes()) {
        checkpoint();
      }
    }
    boolean maybeMerge = false;
    boolean success = false;
    try {
      maybeMerge = docWriter.flushAllThreads(flushDeletes) && triggerMerge;
      success = true;
    } finally {
      if (!success) {
        synchronized (this) {
          // If docWriter has some aborted files that were
          // never incref'd, then we clean them up here
          final Collection<String> files = docWriter.abortedFiles();
          if (files != null) {
            deleter.deleteNewFiles(files);
          }
        }
      }
    }
    
    doAfterFlush();
    
    if (maybeMerge) {
      maybeMerge();
    }
  }

