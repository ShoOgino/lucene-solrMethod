    /** Add an CompositeReader whose stored fields will not be returned.  This can
     * accelerate search when stored fields are only needed from a subset of
     * the IndexReaders.
     *
     * @throws IllegalArgumentException if not all indexes contain the same number
     *     of documents
     * @throws IllegalArgumentException if not all indexes have the same value
     *     of {@link AtomicReader#maxDoc()}
     * @throws IOException if there is a low-level IO error
     */
    public Builder add(CompositeReader reader, boolean ignoreStoredFields) throws IOException {
      final IndexReader[] subs = reader.getSequentialSubReaders();
      if (readers.isEmpty()) {
        this.maxDoc = reader.maxDoc();
        this.numDocs = reader.numDocs();
        childSizes = new int[subs.length];
        for (int i = 0; i < subs.length; i++) {
          childSizes[i] = subs[i].maxDoc();
        }
        final AtomicReaderContext[] leaves = reader.getTopReaderContext().leaves();
        leaveSizes = new int[leaves.length];
        for (int i = 0; i < leaves.length; i++) {
          leaveSizes[i] = leaves[i].reader().maxDoc();
        }
      } else {
        // check compatibility
        if (reader.maxDoc() != maxDoc)
          throw new IllegalArgumentException("All readers must have same maxDoc: "+maxDoc+"!="+reader.maxDoc());
        if (reader.numDocs() != numDocs)
          throw new IllegalArgumentException("All readers must have same numDocs: "+numDocs+"!="+reader.numDocs());
        if (subs.length != childSizes.length)
          throw new IllegalArgumentException("All readers must have same number of subReaders");
        for (int i = 0; i < subs.length; i++) {
          if (subs[i].maxDoc() != childSizes[i])
            throw new IllegalArgumentException("All readers must have same subReader maxDoc");
        }
        // the following checks are only to detect errors early, otherwise a wrong leaf
        // structure would only cause errors on build(). These checks are still incomplete...
        final AtomicReaderContext[] leaves = reader.getTopReaderContext().leaves();
        if (leaves.length != leaveSizes.length)
          throw new IllegalArgumentException("All readers must have same number of atomic leaves");
        for (int i = 0; i < leaves.length; i++) {
          if (leaves[i].reader().maxDoc() != leaveSizes[i])
            throw new IllegalArgumentException("All readers must have atomic leaves with same maxDoc");
        }
      }
      
      ignoreStoredFieldsSet.set(readers.size(), ignoreStoredFields);
      readers.add(reader);
      return this;
    }

