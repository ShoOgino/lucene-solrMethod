  public final Document doc(int n, FieldSelector fieldSelector) throws CorruptIndexException, IOException {
    seekIndex(n);
    long position = indexStream.readLong();
    fieldsStream.seek(position);

    Document doc = new Document();
    int numFields = fieldsStream.readVInt();
    out: for (int i = 0; i < numFields; i++) {
      int fieldNumber = fieldsStream.readVInt();
      FieldInfo fi = fieldInfos.fieldInfo(fieldNumber);
      FieldSelectorResult acceptField = fieldSelector == null ? FieldSelectorResult.LOAD : fieldSelector.accept(fi.name);
      
      int bits = fieldsStream.readByte() & 0xFF;
      assert bits <= (FieldsWriter.FIELD_IS_NUMERIC_MASK | FieldsWriter.FIELD_IS_TOKENIZED | FieldsWriter.FIELD_IS_BINARY): "bits=" + Integer.toHexString(bits);

      boolean tokenize = (bits & FieldsWriter.FIELD_IS_TOKENIZED) != 0;
      boolean binary = (bits & FieldsWriter.FIELD_IS_BINARY) != 0;
      final int numeric = bits & FieldsWriter.FIELD_IS_NUMERIC_MASK;

      switch (acceptField) {
        case LOAD:
          addField(doc, fi, binary, tokenize, numeric);
          break;
        case LOAD_AND_BREAK:
          addField(doc, fi, binary, tokenize, numeric);
          break out; //Get out of this loop
        case LAZY_LOAD:
          addFieldLazy(doc, fi, binary, tokenize, true, numeric);
          break;
        case LATENT:
          addFieldLazy(doc, fi, binary, tokenize, false, numeric);
          break;
        case SIZE:
          skipFieldBytes(addFieldSize(doc, fi, binary, numeric));
          break;
        case SIZE_AND_BREAK:
          addFieldSize(doc, fi, binary, numeric);
          break out; //Get out of this loop
        default:
          skipField(numeric);
      }
    }

    return doc;
  }

