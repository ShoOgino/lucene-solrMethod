  /**
   * Updates a document by first deleting the document(s)
   * containing <code>term</code> and then adding the new
   * document.  The delete and then add are atomic as seen
   * by a reader on the same index (flush may happen only after
   * the add).
   *
   * <p><b>NOTE</b>: if this method hits an OutOfMemoryError
   * you should immediately close the writer.  See <a
   * href="#OOME">above</a> for details.</p>
   *
   * @param term the term to identify the document(s) to be
   * deleted
   * @param doc the document to be added
   * @param analyzer the analyzer to use when analyzing the document
   * @throws CorruptIndexException if the index is corrupt
   * @throws IOException if there is a low-level IO error
   */
  public long updateDocument(Term term, Document doc, Analyzer analyzer)
      throws CorruptIndexException, IOException {
    ensureOpen();
    try {
      boolean success = false;
      try {
        long sequenceID = docWriter.updateDocument(term, doc, analyzer);
        success = true;
        return sequenceID;
      } finally {
        if (!success) {

          if (infoStream != null) {
            message("hit exception updating document");
          }
          
          synchronized (this) {
            // If docWriter has some aborted files that were
            // never incref'd, then we clean them up here
            final Collection<String> files = docWriter.abortedFiles();
            if (files != null) {
              deleter.deleteNewFiles(files);
            }
          }
        }
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "updateDocument");
    }
    
    return -1;
  }

