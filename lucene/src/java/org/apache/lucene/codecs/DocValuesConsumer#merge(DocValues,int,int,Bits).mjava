  /**
   * Merges the given {@link DocValues} into this {@link DocValuesConsumer}.
   * 
   * @throws IOException
   *           if an {@link IOException} occurs
   */
  protected void merge(DocValues reader, int docBase, int docCount, Bits liveDocs) throws IOException {
    // This enables bulk copies in subclasses per MergeState, subclasses can
    // simply override this and decide if they want to merge
    // segments using this generic implementation or if a bulk merge is possible
    // / feasible.
    final Source source = reader.getDirectSource();
    assert source != null;
    int docID = docBase;
    final DocValues.Type type = reader.type();
    final Field scratchField;
    switch(type) {
    case VAR_INTS:
      scratchField = new DocValuesField("", (long) 0, type);
      break;
    case FIXED_INTS_16:
      scratchField = new DocValuesField("", (short) 0, type);
      break;
    case FIXED_INTS_32:
      scratchField = new DocValuesField("", 0, type);
      break;
    case FIXED_INTS_64:
      scratchField = new DocValuesField("", (long) 0, type);
      break;
    case FIXED_INTS_8:
      scratchField = new DocValuesField("", (byte) 0, type);
      break;
    case FLOAT_32:
      scratchField = new DocValuesField("", (float) 0, type);
      break;
    case FLOAT_64:
      scratchField = new DocValuesField("", (double) 0, type);
      break;
    case BYTES_FIXED_STRAIGHT:
    case BYTES_FIXED_DEREF:
    case BYTES_FIXED_SORTED:
    case BYTES_VAR_STRAIGHT:
    case BYTES_VAR_DEREF:
    case BYTES_VAR_SORTED:
      scratchField = new DocValuesField("", new BytesRef(), type);
      break;
    default:
      assert false;
      scratchField = null;
    }
    for (int i = 0; i < docCount; i++) {
      if (liveDocs == null || liveDocs.get(i)) {
        mergeDoc(scratchField, source, docID++, i);
      }
    }
  }

