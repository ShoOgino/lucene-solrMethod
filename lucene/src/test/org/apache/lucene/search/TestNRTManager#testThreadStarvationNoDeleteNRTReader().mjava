  /*
   * LUCENE-3528 - NRTManager hangs in certain situations 
   */
  public void testThreadStarvationNoDeleteNRTReader() throws IOException, InterruptedException {
    IndexWriterConfig conf = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random));
    Directory d = newDirectory();
    final CountDownLatch latch = new CountDownLatch(1);
    final CountDownLatch signal = new CountDownLatch(1);

    LatchedIndexWriter writer = new LatchedIndexWriter(d, conf, latch, signal);
    final NRTManager manager = new NRTManager(writer, null, false);
    Document doc = new Document();
    doc.add(newField("test","test", TextField.TYPE_STORED));
    long gen = manager.addDocument(doc);
    assertTrue(manager.maybeReopen(false));
    assertFalse(gen < manager.getCurrentSearchingGen(false));
    Thread t = new Thread() {
      public void run() {
        try {
          signal.await();
          assertTrue(manager.maybeReopen(false));
          manager.deleteDocuments(new TermQuery(new Term("foo", "barista")));
          manager.maybeReopen(false); // kick off another reopen so we inc. the internal gen
        } catch (Exception e) {
          e.printStackTrace();
        } finally {
          latch.countDown(); // let the add below finish
        }
      }
    };
    t.start();
    writer.waitAfterUpdate = true; // wait in addDocument to let some reopens go through
    final long lastGen = manager.updateDocument(new Term("foo", "bar"), doc); // once this returns the doc is already reflected in the last reopen
    assertFalse(manager.getSearcherManager(false).isSearcherCurrent()); // false since there is a delete in the queue
    
    IndexSearcher acquire = manager.getSearcherManager(false).acquire();
    try {
      assertEquals(2, acquire.getIndexReader().numDocs());
    } finally {
      acquire.getIndexReader().decRef();
    }
    NRTManagerReopenThread thread = new NRTManagerReopenThread(manager, 0.01, 0.01);
    thread.start(); // start reopening
    if (VERBOSE) {
      System.out.println("waiting now for generation " + lastGen);
    }
    
    final AtomicBoolean finished = new AtomicBoolean(false);
    Thread waiter = new Thread() {
      public void run() {
        manager.waitForGeneration(lastGen, false);
        finished.set(true);
      }
    };
    waiter.start();
    manager.maybeReopen(false);
    waiter.join(1000);
    if (!finished.get()) {
      waiter.interrupt();
      fail("thread deadlocked on waitForGeneration");
    }
    thread.close();
    thread.join();
    IOUtils.close(manager, writer, d);
  }

