  public void testSplitIntRange() throws Exception {
    // a hard-coded "standard" range
    assertIntRangeSplit(-5000, 9500, 4, true, Arrays.asList(new Integer[]{
      Integer.valueOf(0x7fffec78),Integer.valueOf(0x7fffec7f),
      Integer.valueOf(0x80002510),Integer.valueOf(0x8000251c),
      Integer.valueOf(0x7fffec8), Integer.valueOf(0x7fffecf),
      Integer.valueOf(0x8000250), Integer.valueOf(0x8000250),
      Integer.valueOf(0x7fffed),  Integer.valueOf(0x7fffef),
      Integer.valueOf(0x800020),  Integer.valueOf(0x800024),
      Integer.valueOf(0x7ffff),   Integer.valueOf(0x80001)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(0), Integer.valueOf(0),
      Integer.valueOf(4), Integer.valueOf(4),
      Integer.valueOf(8), Integer.valueOf(8),
      Integer.valueOf(12)
    }).iterator());
    
    // the same with no range splitting
    assertIntRangeSplit(-5000, 9500, 32, true, Arrays.asList(new Integer[]{
      Integer.valueOf(0x7fffec78),Integer.valueOf(0x8000251c)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(0)
    }).iterator());
    
    // this tests optimized range splitting, if one of the inner bounds
    // is also the bound of the next lower precision, it should be used completely
    assertIntRangeSplit(0, 1024+63, 4, true, Arrays.asList(new Integer[]{
      Integer.valueOf(0x8000040), Integer.valueOf(0x8000043),
      Integer.valueOf(0x800000),  Integer.valueOf(0x800003)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(4), Integer.valueOf(8)
    }).iterator());
    
    // the full int range should only consist of a lowest precision range; no bitset testing here, as too much memory needed :-)
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 8, false, Arrays.asList(new Integer[]{
      Integer.valueOf(0x00),Integer.valueOf(0xff)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(24)
    }).iterator());

    // the same with precisionStep=4
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 4, false, Arrays.asList(new Integer[]{
      Integer.valueOf(0x0),Integer.valueOf(0xf)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(28)
    }).iterator());

    // the same with precisionStep=2
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 2, false, Arrays.asList(new Integer[]{
      Integer.valueOf(0x0),Integer.valueOf(0x3)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(30)
    }).iterator());

    // the same with precisionStep=1
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, false, Arrays.asList(new Integer[]{
      Integer.valueOf(0x0),Integer.valueOf(0x1)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(31)
    }).iterator());

    // a inverse range should produce no sub-ranges
    assertIntRangeSplit(9500, -5000, 4, false, Collections.<Integer>emptyList().iterator(), Collections.<Integer>emptyList().iterator());    

    // a 0-length range should reproduce the range itsself
    assertIntRangeSplit(9500, 9500, 4, false, Arrays.asList(new Integer[]{
      Integer.valueOf(0x8000251c),Integer.valueOf(0x8000251c)
    }).iterator(), Arrays.asList(new Integer[]{
      Integer.valueOf(0)
    }).iterator());
  }

