  private static void threadCleanup(String context) {
    // we will only actually fail() after all cleanup has happened!
    boolean shouldFail = false;
    
    // educated guess
    Thread[] stillRunning = new Thread[Thread.activeCount()+1];
    int threadCount = 0;
    int rogueCount = 0;
    
    if ((threadCount = Thread.enumerate(stillRunning)) > 1) {
      while (threadCount == stillRunning.length) {
        // truncated response
        stillRunning = new Thread[stillRunning.length*2];
        threadCount = Thread.enumerate(stillRunning);
      }
      
      for (int i = 0; i < threadCount; i++) {
        Thread t = stillRunning[i];
          
        if (t.isAlive() && 
            !rogueThreads.containsKey(t) && 
            t != Thread.currentThread() &&
            // TODO: TimeLimitingCollector starts a thread statically.... WTF?!
            !t.getName().equals("TimeLimitedCollector timer thread")) {
          System.err.println("WARNING: " + context  + " left thread running: " + t);
          rogueThreads.put(t, true);
          shouldFail = true;
          rogueCount++;
          // wait on the thread to die of natural causes
          try {
            t.join(THREAD_STOP_GRACE_MSEC);
          } catch (InterruptedException e) { e.printStackTrace(); }
          // try to stop the thread:
          t.setUncaughtExceptionHandler(null);
          t.interrupt();
          try {
            t.join(THREAD_STOP_GRACE_MSEC);
          } catch (InterruptedException e) { e.printStackTrace(); }
        }
      }
    }
    
    if (shouldFail && !testsFailed /* don't be loud if the test failed, maybe it didnt join() etc */) {
      // TODO: we can't fail until we fix contrib and solr
      //fail("test '" + getName() + "' left " + rogueCount + " thread(s) running");
      System.err.println("RESOURCE LEAK: " + context + " left " + rogueCount + " thread(s) running");
    }
  }

