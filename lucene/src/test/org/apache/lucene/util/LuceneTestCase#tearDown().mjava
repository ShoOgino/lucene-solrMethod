  @Override
  protected void tearDown() throws Exception {
    assertTrue("ensure your setUp() calls super.setUp()!!!", setup);
    setup = false;
    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);
    LuceneTestCaseJ4.removeTestCodecs(codec);
    Locale.setDefault(savedLocale);
    TimeZone.setDefault(savedTimeZone);
    
    try {
      Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);
      if (!uncaughtExceptions.isEmpty()) {
        System.err.println("The following exceptions were thrown by threads:");
        for (UncaughtExceptionEntry entry : uncaughtExceptions) {
          System.err.println("*** Thread: " + entry.thread.getName() + " ***");
          entry.exception.printStackTrace(System.err);
        }
        fail("Some threads threw uncaught exceptions!");
      }

      // this isn't as useful as calling directly from the scope where the 
      // index readers are used, because they could be gc'ed just before
      // tearDown is called.
      // But it's better then nothing.
      assertSaneFieldCaches(getTestLabel());
      
      if (ConcurrentMergeScheduler.anyUnhandledExceptions()) {
        // Clear the failure so that we don't just keep
        // failing subsequent test cases
        ConcurrentMergeScheduler.clearUnhandledExceptions();
        fail("ConcurrentMergeScheduler hit unhandled exceptions");
      }
    } finally {
      purgeFieldCache(FieldCache.DEFAULT);
    }

    // now look for unclosed resources
    for (MockRAMDirectory d : stores.keySet()) {
      if (d.isOpen()) {
        StackTraceElement elements[] = stores.get(d);
        StackTraceElement element = (elements.length > 1) ? elements[1] : null;
        fail("directory of testcase " + getName() + " was not closed, opened from: " + element);
      }
    }
    stores = null;
    super.tearDown();
  }

