  /** This test checks that *only* IndexFormatTooOldExceptions are throws when you open and operate on too old indexes! */
  public void testUnsupportedOldIndexes() throws Exception {
    for(int i=0;i<unsupportedNames.length;i++) {
      unzip(getDataFile("unsupported." + unsupportedNames[i] + ".zip"), unsupportedNames[i]);

      String fullPath = fullDir(unsupportedNames[i]);
      Directory dir = FSDirectory.open(new File(fullPath));

      IndexReader reader = null;
      IndexWriter writer = null;
      try {
        reader = IndexReader.open(dir);
        MultiFields.getFields(reader).terms("content");
        reader.document(0); // to catch also 2.9->3.0 stored field change
        fail("IndexReader.open should not pass for "+unsupportedNames[i]);
      } catch (IndexFormatTooOldException e) {
        // pass
      } finally {
        if (reader != null) reader.close();
        reader = null;
      }

      try {
        writer = new IndexWriter(dir, new IndexWriterConfig(
          TEST_VERSION_CURRENT, new MockAnalyzer())
          .setMergeScheduler(new SerialMergeScheduler()) // no threads!
        );
        writer.optimize();
        reader = writer.getReader();
        reader.document(0); // to catch also 2.9->3.0 stored field change
        fail("IndexWriter creation should not pass for "+unsupportedNames[i]);
      } catch (IndexFormatTooOldException e) {
        // pass
      } finally {
        if (reader != null) reader.close();
        reader = null;
        if (writer != null) writer.close();
        writer = null;
      }
      
      ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);
      CheckIndex checker = new CheckIndex(dir);
      checker.setInfoStream(new PrintStream(bos));
      CheckIndex.Status indexStatus = checker.checkIndex();
      assertFalse(indexStatus.clean);
      assertTrue(bos.toString().contains(IndexFormatTooOldException.class.getName()));

      dir.close();
      rmDir(unsupportedNames[i]);
    }
  }

