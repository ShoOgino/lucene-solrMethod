  private static void testRandomSkips(Random rand, IndexReader r) throws Exception {

    TermEnum termEnum = r.terms();
    Fields fields = MultiFields.getFields(r);
    if (fields == null) {
      return;
    }
    FieldsEnum fieldsEnum = fields.iterator();
    boolean skipNext = false;
    int[] docs2 = new int[16];
    int[] freqs2 = new int[16];
    while(true) {
      final String field = fieldsEnum.next();
      if (field == null) {
        boolean result = termEnum.next();
        if (result) {
          System.out.println("got unexpected term=" + termEnum.term() + " termEnum=" + termEnum);
        }
        assertFalse(result);
        break;
      }
      if (rand.nextInt(3) <= 1) {
        // Enum the terms
        //System.out.println("TEST:   get terms");
        TermsEnum terms = fieldsEnum.terms();
        final TermPositions termPos = r.termPositions();
        final TermDocs termDocs = r.termDocs();
        DocsEnum docs = null;
        DocsAndPositionsEnum postings = null;
        while(true) {
          final BytesRef termRef = terms.next();
          if (termRef == null) {
            break;
          } else {
            if (skipNext) {
              skipNext = false;
            } else {
              assertTrue(termEnum.next());
            }
            Term t = termEnum.term();
            assertEquals(t.field(), field);
            assertEquals(t.text(), termRef.utf8ToString());
            assertEquals(termEnum.docFreq(), terms.docFreq());
            //allTerms.add(t);

            if (rand.nextInt(3) <= 1) {
              docs = terms.docs(MultiFields.getDeletedDocs(r), docs);
              assert !(docs instanceof DocsAndPositionsEnum): "docs=" + docs;
              postings = terms.docsAndPositions(MultiFields.getDeletedDocs(r), postings);
              final DocsEnum docsEnum;
              if (postings == null) {
                docsEnum = docs;
              } else {
                docsEnum = postings;
              }
              if (rand.nextBoolean()) {
                // use bulk read API
                termDocs.seek(t);
                DocsEnum.BulkReadResult result1 = docs.getBulkResult();
                int result1Count = 0;
                int count2 = 0;
                while(true) {
                  if (result1Count == 0) {
                    result1Count = docs.read();
                  }
                  if (count2 == 0) {
                    count2 = termDocs.read(docs2, freqs2);
                  }

                  if (result1Count == 0 || count2 == 0) {
                    assertEquals(0, count2);
                    assertEquals(0, result1Count);
                    break;
                  }
                  final int limit = Math.min(result1Count, count2);
                  for(int i=0;i<limit;i++) {
                    assertEquals(result1.docs.ints[i], docs2[i]);
                    assertEquals(result1.freqs.ints[i], freqs2[i]);
                  }
                  if (result1Count > limit) {
                    // copy down
                    // TODO: in general I should not muck w/
                    // the int[]'s returned to me like
                    // this... this could mess up codecs
                    // that have persistent RAM storage of
                    // these int[]'s
                    System.arraycopy(result1.docs.ints, limit, result1.docs.ints, 0, result1Count-limit);
                    System.arraycopy(result1.freqs.ints, limit, result1.freqs.ints, 0, result1Count-limit);
                  }
                  result1Count -= limit;

                  if (count2 > limit) {
                    // copy down
                    System.arraycopy(docs2, limit, docs2, 0, count2-limit);
                    System.arraycopy(freqs2, limit, freqs2, 0, count2-limit);
                  }
                  count2 -= limit;
                }
              } else {
                // Enum the docs one by one
                //System.out.println("TEST:      get docs");
                termPos.seek(t);
                while(true) {
                  final int doc = docsEnum.nextDoc();
                  if (doc == DocsEnum.NO_MORE_DOCS) {
                    assertFalse(termPos.next());
                    break;
                  } else {
                    assertTrue(termPos.next());
                    assertEquals(termPos.doc(), doc);
                    assertEquals(termPos.freq(), docsEnum.freq());
                    //System.out.println("TEST:     doc=" + doc + " freq=" + docs.freq());
                    if (rand.nextInt(3) <= 1) {
                      // enum the positions
                      final int freq = docsEnum.freq();
                      if (postings == null) {
                        assertEquals(1, termPos.freq());
                        // Old API did not always do this,
                        // specifically in the MultiTermPositions
                        // case when some segs omit positions and
                        // some don't
                        //assertEquals(0, termPos.nextPosition());
                        assertFalse(termPos.isPayloadAvailable());
                      } else {
                        // we have positions
                        for(int i=0;i<freq;i++) {
                          final int position = postings.nextPosition();
                          //System.out.println("TEST:       pos=" + position);
                          assertEquals(position, termPos.nextPosition());
                          assertEquals(postings.hasPayload(), termPos.isPayloadAvailable());
                          if (postings.hasPayload()) {
                            if (rand.nextInt(3) <= 1) {
                              BytesRef payload = postings.getPayload();
                              assertEquals(payload.length, termPos.getPayloadLength());
                              byte[] b2 = termPos.getPayload(null, 0);
                              assertNotNull(payload);
                              assertNotNull(b2);
                              assertTrue(equals(payload, b2));
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            } else {
              //System.out.println("TEST:      skip docs");
            }
          }
        }
      } else {
        // Skip terms for this field
        termEnum = r.terms(new Term(field, "\uFFFF"));
        skipNext = true;
        //System.out.println("TEST:   skip terms; now=" + termEnum.term());
      }
    }

    // seek to before first term in a field
    // seek to after last term in a field
    // seek to random terms
    // enum docs, sometimes skipping
    // enum positions, sometimes skipping payloads
  }

