  // Tests whether merging of docs that have different
  // omitTermFreqAndPositions for the same field works
  public void testMixedMerge() throws Exception {
    Directory ram = new MockRAMDirectory();
    Analyzer analyzer = new MockAnalyzer();
    IndexWriter writer = new IndexWriter(ram, new IndexWriterConfig(
        TEST_VERSION_CURRENT, analyzer).setMaxBufferedDocs(3));
    ((LogMergePolicy) writer.getConfig().getMergePolicy()).setMergeFactor(2);
    Document d = new Document();
        
    // this field will have Tf
    Field f1 = new Field("f1", "This field has term freqs", Field.Store.NO, Field.Index.ANALYZED);
    d.add(f1);
       
    // this field will NOT have Tf
    Field f2 = new Field("f2", "This field has NO Tf in all docs", Field.Store.NO, Field.Index.ANALYZED);
    f2.setOmitTermFreqAndPositions(true);
    d.add(f2);

    for(int i=0;i<30;i++)
      writer.addDocument(d);
        
    // now we add another document which has term freq for field f2 and not for f1 and verify if the SegmentMerger
    // keep things constant
    d = new Document();
        
    // Reverese
    f1.setOmitTermFreqAndPositions(true);
    d.add(f1);
        
    f2.setOmitTermFreqAndPositions(false);        
    d.add(f2);
        
    for(int i=0;i<30;i++)
      writer.addDocument(d);
        
    // force merge
    writer.optimize();
    // flush
    writer.close();

    _TestUtil.checkIndex(ram);

    SegmentReader reader = SegmentReader.getOnlySegmentReader(ram);
    FieldInfos fi = reader.fieldInfos();
    assertTrue("OmitTermFreqAndPositions field bit should be set.", fi.fieldInfo("f1").omitTermFreqAndPositions);
    assertTrue("OmitTermFreqAndPositions field bit should be set.", fi.fieldInfo("f2").omitTermFreqAndPositions);
        
    reader.close();
    ram.close();
  }

