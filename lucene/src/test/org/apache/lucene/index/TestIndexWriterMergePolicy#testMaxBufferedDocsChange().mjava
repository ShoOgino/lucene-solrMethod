  // Test the case where both mergeFactor and maxBufferedDocs change
  public void testMaxBufferedDocsChange() throws IOException {
    Directory dir = new RAMDirectory();

    IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(101));
    ((LogMergePolicy) writer.getMergePolicy()).setMergeFactor(101);
    writer.setMergePolicy(new LogDocMergePolicy(writer));

    // leftmost* segment has 1 doc
    // rightmost* segment has 100 docs
    for (int i = 1; i <= 100; i++) {
      for (int j = 0; j < i; j++) {
        addDoc(writer);
        checkInvariants(writer);
      }
      writer.close();

      writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))
          .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(101));
      ((LogMergePolicy) writer.getMergePolicy()).setMergeFactor(101);
      writer.setMergePolicy(new LogDocMergePolicy(writer));
    }

    writer.close();
    writer = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT))
        .setOpenMode(OpenMode.APPEND).setMaxBufferedDocs(10));
    writer.setMergePolicy(new LogDocMergePolicy(writer));
    ((LogMergePolicy) writer.getMergePolicy()).setMergeFactor(10);

    // merge policy only fixes segments on levels where merges
    // have been triggered, so check invariants after all adds
    for (int i = 0; i < 100; i++) {
      addDoc(writer);
    }
    checkInvariants(writer);

    for (int i = 100; i < 1000; i++) {
      addDoc(writer);
    }
    writer.commit();
    ((ConcurrentMergeScheduler) writer.getConfig().getMergeScheduler()).sync();
    writer.commit();
    checkInvariants(writer);

    writer.close();
  }

