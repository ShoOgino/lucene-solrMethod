  public static void verifyEquals(IndexReader r1, IndexReader r2, String idField) throws Throwable {
    if (VERBOSE) {
      System.out.println("\nr1 docs:");
      printDocs(r1);
      System.out.println("\nr2 docs:");
      printDocs(r2);
    }
    if (r1.numDocs() != r2.numDocs()) {
      assert false: "r1.numDocs()=" + r1.numDocs() + " vs r2.numDocs()=" + r2.numDocs();
    }
    boolean hasDeletes = !(r1.maxDoc()==r2.maxDoc() && r1.numDocs()==r1.maxDoc());

    int[] r2r1 = new int[r2.maxDoc()];   // r2 id to r1 id mapping

    // create mapping from id2 space to id2 based on idField
    final Fields f1 = MultiFields.getFields(r1);
    if (f1 == null) {
      // make sure r2 is empty
      assertNull(MultiFields.getFields(r2));
      return;
    }
    final Terms terms1 = f1.terms(idField);
    if (terms1 == null) {
      assertTrue(MultiFields.getFields(r2) == null ||
                 MultiFields.getFields(r2).terms(idField) == null);
      return;
    }
    final TermsEnum termsEnum = terms1.iterator();

    final Bits liveDocs1 = MultiFields.getLiveDocs(r1);
    final Bits liveDocs2 = MultiFields.getLiveDocs(r2);
    
    Fields fields = MultiFields.getFields(r2);
    if (fields == null) {
      // make sure r1 is in fact empty (eg has only all
      // deleted docs):
      DocsEnum docs = null;
      while(termsEnum.next() != null) {
        docs = termsEnum.docs(liveDocs1, docs);
        while(docs.nextDoc() != DocsEnum.NO_MORE_DOCS) {
          fail("r1 is not empty but r2 is");
        }
      }
      return;
    }
    Terms terms2 = fields.terms(idField);

    DocsEnum termDocs1 = null;
    DocsEnum termDocs2 = null;

    while(true) {
      BytesRef term = termsEnum.next();
      //System.out.println("TEST: match id term=" + term);
      if (term == null) {
        break;
      }

      termDocs1 = termsEnum.docs(liveDocs1, termDocs1);
      termDocs2 = terms2.docs(liveDocs2, term, termDocs2);

      if (termDocs1.nextDoc() == DocsEnum.NO_MORE_DOCS) {
        // This doc is deleted and wasn't replaced
        assertTrue(termDocs2 == null || termDocs2.nextDoc() == DocsEnum.NO_MORE_DOCS);
        continue;
      }

      int id1 = termDocs1.docID();
      assertEquals(DocsEnum.NO_MORE_DOCS, termDocs1.nextDoc());

      assertTrue(termDocs2.nextDoc() != DocsEnum.NO_MORE_DOCS);
      int id2 = termDocs2.docID();
      assertEquals(DocsEnum.NO_MORE_DOCS, termDocs2.nextDoc());

      r2r1[id2] = id1;

      // verify stored fields are equivalent
      try {
        verifyEquals(r1.document(id1), r2.document(id2));
      } catch (Throwable t) {
        System.out.println("FAILED id=" + term + " id1=" + id1 + " id2=" + id2 + " term="+ term);
        System.out.println("  d1=" + r1.document(id1));
        System.out.println("  d2=" + r2.document(id2));
        throw t;
      }

      try {
        // verify term vectors are equivalent        
        verifyEquals(r1.getTermFreqVectors(id1), r2.getTermFreqVectors(id2));
      } catch (Throwable e) {
        System.out.println("FAILED id=" + term + " id1=" + id1 + " id2=" + id2);
        TermFreqVector[] tv1 = r1.getTermFreqVectors(id1);
        System.out.println("  d1=" + tv1);
        if (tv1 != null)
          for(int i=0;i<tv1.length;i++)
            System.out.println("    " + i + ": " + tv1[i]);
        
        TermFreqVector[] tv2 = r2.getTermFreqVectors(id2);
        System.out.println("  d2=" + tv2);
        if (tv2 != null)
          for(int i=0;i<tv2.length;i++)
            System.out.println("    " + i + ": " + tv2[i]);
        
        throw e;
      }

    }

    //System.out.println("TEST: done match id");

    // Verify postings
    //System.out.println("TEST: create te1");
    final FieldsEnum fields1 = MultiFields.getFields(r1).iterator();
    final FieldsEnum fields2 = MultiFields.getFields(r2).iterator();

    String field1=null, field2=null;
    TermsEnum termsEnum1 = null;
    TermsEnum termsEnum2 = null;
    DocsEnum docs1=null, docs2=null;

    // pack both doc and freq into single element for easy sorting
    long[] info1 = new long[r1.numDocs()];
    long[] info2 = new long[r2.numDocs()];

    for(;;) {
      BytesRef term1=null, term2=null;

      // iterate until we get some docs
      int len1;
      for(;;) {
        len1=0;
        if (termsEnum1 == null) {
          field1 = fields1.next();
          if (field1 == null) {
            break;
          } else {
            termsEnum1 = fields1.terms();
          }
        }
        term1 = termsEnum1.next();
        if (term1 == null) {
          // no more terms in this field
          termsEnum1 = null;
          continue;
        }
        
        //System.out.println("TEST: term1=" + term1);
        docs1 = termsEnum1.docs(liveDocs1, docs1);
        while (docs1.nextDoc() != DocsEnum.NO_MORE_DOCS) {
          int d = docs1.docID();
          int f = docs1.freq();
          info1[len1] = (((long)d)<<32) | f;
          len1++;
        }
        if (len1>0) break;
      }

      // iterate until we get some docs
      int len2;
      for(;;) {
        len2=0;
        if (termsEnum2 == null) {
          field2 = fields2.next();
          if (field2 == null) {
            break;
          } else {
            termsEnum2 = fields2.terms();
          }
        }
        term2 = termsEnum2.next();
        if (term2 == null) {
          // no more terms in this field
          termsEnum2 = null;
          continue;
        }
        
        //System.out.println("TEST: term1=" + term1);
        docs2 = termsEnum2.docs(liveDocs2, docs2);
        while (docs2.nextDoc() != DocsEnum.NO_MORE_DOCS) {
          int d = r2r1[docs2.docID()];
          int f = docs2.freq();
          info2[len2] = (((long)d)<<32) | f;
          len2++;
        }
        if (len2>0) break;
      }

      assertEquals(len1, len2);
      if (len1==0) break;  // no more terms

      assertEquals(field1, field2);
      assertTrue(term1.bytesEquals(term2));

      if (!hasDeletes)
        assertEquals(termsEnum1.docFreq(), termsEnum2.docFreq());

      assertEquals("len1=" + len1 + " len2=" + len2 + " deletes?=" + hasDeletes, term1, term2);

      // sort info2 to get it into ascending docid
      Arrays.sort(info2, 0, len2);

      // now compare
      for (int i=0; i<len1; i++) {
        assertEquals("i=" + i + " len=" + len1 + " d1=" + (info1[i]>>>32) + " f1=" + (info1[i]&Integer.MAX_VALUE) + " d2=" + (info2[i]>>>32) + " f2=" + (info2[i]&Integer.MAX_VALUE) +
                     " field=" + field1 + " term=" + term1.utf8ToString(),
                     info1[i],
                     info2[i]);
      }
    }
  }

