  public void testHealthyness() throws InterruptedException,
      CorruptIndexException, LockObtainFailedException, IOException {

    int[] numThreads = new int[] { 3 + random.nextInt(8), 1 };
    final int numDocumentsToIndex = 50 + random.nextInt(50);
    for (int i = 0; i < numThreads.length; i++) {
      AtomicInteger numDocs = new AtomicInteger(numDocumentsToIndex);
      MockDirectoryWrapper dir = newDirectory();
      // mock a very slow harddisk here so that flushing is very slow
      dir.setThrottledIndexOutput(new ThrottledIndexOutput(ThrottledIndexOutput
          .mBitsToBytes(50 + random.nextInt(10)), 5 + random.nextInt(5), null));
      IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT,
          new MockAnalyzer());
      iwc.setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH);
      iwc.setMaxBufferedDeleteTerms(IndexWriterConfig.DISABLE_AUTO_FLUSH);
      FlushPolicy flushPolicy = new FlushByRamOrCountsPolicy();
      iwc.setFlushPolicy(flushPolicy);

      DocumentsWriterPerThreadPool threadPool = new ThreadAffinityDocumentsWriterThreadPool(
          numThreads[i]== 1 ? 1 : 2);
      iwc.setIndexerThreadPool(threadPool);
      // with such a small ram buffer we should be stalled quiet quickly
      iwc.setRAMBufferSizeMB(0.25);
      IndexWriter writer = new IndexWriter(dir, iwc);
      IndexThread[] threads = new IndexThread[numThreads[i]];
      for (int x = 0; x < threads.length; x++) {
        threads[x] = new IndexThread(numDocs, numThreads[i], writer,
            lineDocFile, false);
        threads[x].start();
      }

      for (int x = 0; x < threads.length; x++) {
        threads[x].join();
      }
      DocumentsWriter docsWriter = writer.getDocsWriter();
      assertNotNull(docsWriter);
      DocumentsWriterFlushControl flushControl = docsWriter.flushControl;
      assertEquals(" all flushes must be due", 0, flushControl.flushBytes());
      assertEquals(numDocumentsToIndex, writer.numDocs());
      assertEquals(numDocumentsToIndex, writer.maxDoc());
      if (flushControl.peakNetBytes > (long)(iwc.getRAMBufferSizeMB() * 1024d * 1024d * 2d)) {
        assertTrue("should be unhealthy here numThreads: " + numThreads[i],
            docsWriter.healthiness.wasStalled);
      }

      if (numThreads[i] == 1) { // single thread could be unhealthy is a single
                                // doc is very large?!
        assertFalse(
            "single thread must not block numThreads: " + numThreads[i],
            docsWriter.healthiness.hasBlocked());
      } else {
        if (docsWriter.healthiness.wasStalled) {
          // TODO maybe this assumtion is too strickt
          assertTrue(" we should have blocked here numThreads: "
              + numThreads[i], docsWriter.healthiness.hasBlocked());
        }
      }
      assertActiveBytesAfter(flushControl);
      writer.close(true);
      dir.close();
    }
  }

