    // TODO: we can actually use the defaul DV merge here and drop this specific stuff entirely
    /** we override merge and bulk-merge norms when there are no deletions */
    public void merge(MergeState mergeState) throws IOException {
      int numMergedDocs = 0;
      for (FieldInfo fi : mergeState.fieldInfos) {
        if (fi.normsPresent()) {
          startField(fi);
          int numMergedDocsForField = 0;
          for (MergeState.IndexReaderAndLiveDocs reader : mergeState.readers) {
            final int maxDoc = reader.reader.maxDoc();
            byte[] normBuffer;
            DocValues normValues = reader.reader.normValues(fi.name);
            if (normValues == null) {
              // Can be null if this segment doesn't have
              // any docs with this field
              normBuffer = new byte[maxDoc];
              Arrays.fill(normBuffer, (byte)0);
            } else {
              Source directSource = normValues.getDirectSource();
              assert directSource.hasArray();
              normBuffer = (byte[]) directSource.getArray();
            }
            if (reader.liveDocs == null) {
              //optimized case for segments without deleted docs
              output.writeBytes(normBuffer, maxDoc);
              numMergedDocsForField += maxDoc;
            } else {
              // this segment has deleted docs, so we have to
              // check for every doc if it is deleted or not
              final Bits liveDocs = reader.liveDocs;
              for (int k = 0; k < maxDoc; k++) {
                if (liveDocs.get(k)) {
                  numMergedDocsForField++;
                  output.writeByte(normBuffer[k]);
                }
              }
            }
            mergeState.checkAbort.work(maxDoc);
          }
          assert numMergedDocs == 0 || numMergedDocs == numMergedDocsForField;
          numMergedDocs = numMergedDocsForField;
        }
      }
      this.numTotalDocs = numMergedDocs;
    }

