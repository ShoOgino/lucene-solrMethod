  /** create a new searcher over the reader.
   * This searcher might randomly use threads.
   * if <code>maybeWrap</code> is true, this searcher might wrap the reader
   * with one that returns null for getSequentialSubReaders.
   */
  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {
    if (random.nextBoolean()) {
      if (maybeWrap && rarely()) {
        r = new SlowMultiReaderWrapper(r);
      }
      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());
      ret.setSimilarityProvider(similarityProvider);
      return ret;
    } else {
      int threads = 0;
      final ExecutorService ex = (random.nextBoolean()) ? null
          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),
                      new NamedThreadFactory("LuceneTestCase"));
      if (ex != null && VERBOSE) {
        System.out.println("NOTE: newSearcher using ExecutorService with " + threads + " threads");
      }
      IndexSearcher ret = random.nextBoolean() ? 
        new AssertingIndexSearcher(random, r, ex) {
          @Override
          public void close() throws IOException {
            super.close();
            shutdownExecutorService(ex);
          }
        } : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex) {
          @Override
          public void close() throws IOException {
            super.close();
            shutdownExecutorService(ex);
          }
        };
      ret.setSimilarityProvider(similarityProvider);
      return ret;
    }
  }

