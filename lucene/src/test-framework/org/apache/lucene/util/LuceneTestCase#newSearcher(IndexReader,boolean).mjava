  /** create a new searcher over the reader.
   * This searcher might randomly use threads.
   * if <code>maybeWrap</code> is true, this searcher might wrap the reader
   * with one that returns null for getSequentialSubReaders.
   */
  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {
    if (random.nextBoolean()) {
      if (maybeWrap && random.nextBoolean()) {
        return new IndexSearcher(new SlowMultiReaderWrapper(r));
      } else {
        return new IndexSearcher(r);
      }
    } else {
      int threads = 0;
      final ExecutorService ex = (random.nextBoolean()) ? null
          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),
                      new NamedThreadFactory("LuceneTestCase"));
      if (ex != null && VERBOSE) {
        System.out.println("NOTE: newSearcher using ExecutorService with " + threads + " threads");
      }
      return new IndexSearcher(r.getTopReaderContext(), ex) {
        @Override
        public void close() throws IOException {
          super.close();
          if (ex != null) {
            ex.shutdown();
            try {
              ex.awaitTermination(1000, TimeUnit.MILLISECONDS);
            } catch (InterruptedException e) {
              e.printStackTrace();
            }
          }
        }
      };
    }
  }

