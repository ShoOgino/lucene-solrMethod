  @After
  public void tearDown() throws Exception {
    State oldState = state; // capture test execution state
    state = State.TEARDOWN; // set the state for subsequent tests
    
    // NOTE: with junit 4.7, we don't get a reproduceWith because our Watchman
    // does not know if something fails in tearDown. so we ensure this happens ourselves for now.
    // we can remove this if we upgrade to 4.8
    Throwable problem = null;
    
    try {
      if (!testsFailed) {
        // Note: we allow a test to go straight from SETUP -> TEARDOWN (without ever entering the RANTEST state)
        // because if you assume() inside setUp(), it skips the test and the TestWatchman has no way to know...
        assertTrue("ensure your setUp() calls super.setUp()!!!", oldState == State.RANTEST || oldState == State.SETUP);
      }
    } catch (Throwable t) {
      if (problem == null) problem = t;
    }

    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);

    // this won't throw any exceptions or fail the test
    // if we change this, then change this logic
    checkRogueThreadsAfter();
    // restore the default uncaught exception handler
    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);
    
    try {
      checkUncaughtExceptionsAfter();
    } catch (Throwable t) {
      if (problem == null) problem = t;
    }
    
    try {
      // calling assertSaneFieldCaches here isn't as useful as having test
      // classes call it directly from the scope where the index readers
      // are used, because they could be gc'ed just before this tearDown
      // method is called.
      //
      // But it's better then nothing.
      //
      // If you are testing functionality that you know for a fact
      // "violates" FieldCache sanity, then you should either explicitly
      // call purgeFieldCache at the end of your test method, or refactor
      // your Test class so that the inconsistant FieldCache usages are
      // isolated in distinct test methods
      assertSaneFieldCaches(getTestLabel());
    } catch (Throwable t) {
      if (problem == null) problem = t;
    }
    
    purgeFieldCache(FieldCache.DEFAULT);
    
    if (problem != null) {
      testsFailed = true;
      reportAdditionalFailureInfo();
      throw new RuntimeException(problem);
    }
  }

