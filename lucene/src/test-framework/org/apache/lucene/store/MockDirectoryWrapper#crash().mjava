  /** Simulates a crash of OS or machine by overwriting
   *  unsynced files. */
  public synchronized void crash() throws IOException {
    crashed = true;
    openFiles = new HashMap<String,Integer>();
    openFilesForWrite = new HashSet<String>();
    openFilesDeleted = new HashSet<String>();
    Iterator<String> it = unSyncedFiles.iterator();
    unSyncedFiles = new HashSet<String>();
    // first force-close all files, so we can corrupt on windows etc.
    // clone the file map, as these guys want to remove themselves on close.
    Map<Closeable,Exception> m = new IdentityHashMap<Closeable,Exception>(openFileHandles);
    for (Closeable f : m.keySet())
      try {
        f.close();
      } catch (Exception ignored) {}
    
    int count = 0;
    while(it.hasNext()) {
      String name = it.next();
      if (count % 3 == 0) {
        deleteFile(name, true);
      } else if (count % 3 == 1) {
        // Zero out file entirely
        long length = fileLength(name);
        byte[] zeroes = new byte[256];
        long upto = 0;
        IndexOutput out = delegate.createOutput(name);
        while(upto < length) {
          final int limit = (int) Math.min(length-upto, zeroes.length);
          out.writeBytes(zeroes, 0, limit);
          upto += limit;
        }
        out.close();
      } else if (count % 3 == 2) {
        // Truncate the file:
        IndexOutput out = delegate.createOutput(name);
        out.setLength(fileLength(name)/2);
        out.close();
      }
      count++;
    }
  }

