  /** 
   * Returns a "fake" DocsAndPositionsEnum over the tokenstream, returning offsets where {@code matchers}
   * matches tokens.
   * <p>
   * This is solely used internally by PostingsHighlighter: <b>DO NOT USE THIS METHOD!</b>
   */
  static DocsAndPositionsEnum getDocsEnum(final TokenStream ts, final CharacterRunAutomaton[] matchers) throws IOException {
    final CharTermAttribute charTermAtt = ts.addAttribute(CharTermAttribute.class);
    final OffsetAttribute offsetAtt = ts.addAttribute(OffsetAttribute.class);
    ts.reset();
    
    // TODO: we could use CachingWrapperFilter, (or consume twice) to allow us to have a true freq()
    // but this would have a performance cost for likely little gain in the user experience, it
    // would only serve to make this method less bogus.
    // instead, we always return freq() = Integer.MAX_VALUE and let PH terminate based on offset...
    
    return new DocsAndPositionsEnum() {
      int currentDoc = -1;
      int currentMatch = -1;
      int currentStartOffset = -1;
      int currentEndOffset = -1;
      TokenStream stream = ts;
      
      final BytesRef matchDescriptions[] = new BytesRef[matchers.length];
      
      @Override
      public int nextPosition() throws IOException {
        if (stream != null) {
          while (stream.incrementToken()) {
            for (int i = 0; i < matchers.length; i++) {
              if (matchers[i].run(charTermAtt.buffer(), 0, charTermAtt.length())) {
                currentStartOffset = offsetAtt.startOffset();
                currentEndOffset = offsetAtt.endOffset();
                currentMatch = i;
                return 0;
              }
            }
          }
          stream.end();
          stream.close();
          stream = null;
        }
        // exhausted
        currentStartOffset = currentEndOffset = Integer.MAX_VALUE;
        return Integer.MAX_VALUE;
      }
      
      @Override
      public int freq() throws IOException {
        return Integer.MAX_VALUE; // lie
      }

      @Override
      public int startOffset() throws IOException {
        assert currentStartOffset >= 0;
        return currentStartOffset;
      }

      @Override
      public int endOffset() throws IOException {
        assert currentEndOffset >= 0;
        return currentEndOffset;
      }

      @Override
      public BytesRef getPayload() throws IOException {
        if (matchDescriptions[currentMatch] == null) {
          matchDescriptions[currentMatch] = new BytesRef(matchers[currentMatch].toString());
        }
        return matchDescriptions[currentMatch];
      }

      @Override
      public int docID() {
        return currentDoc;
      }

      @Override
      public int nextDoc() throws IOException {
        throw new UnsupportedOperationException();
      }

      @Override
      public int advance(int target) throws IOException {
        return currentDoc = target;
      }

      @Override
      public long cost() {
        return 0;
      }
    };
  }

