  //We delay initialization because we can see which attributes the consumer wants, particularly payloads
  private void init() throws IOException {
    assert !initialized;
    int dpEnumFlags = 0;
    if (vector.hasOffsets()) {
      offsetAttribute = addAttribute(OffsetAttribute.class);
      dpEnumFlags |= PostingsEnum.OFFSETS;
    }
    if (vector.hasPayloads() && hasAttribute(PayloadAttribute.class)) {
      payloadAttribute = getAttribute(PayloadAttribute.class);
      payloadsBytesRefArray = new BytesRefArray(Counter.newCounter());
      spareBytesRefBuilder = new BytesRefBuilder();
      dpEnumFlags |= PostingsEnum.PAYLOADS;
    }

    // We put term data here
    termCharsBuilder = new CharsRefBuilder();
    termCharsBuilder.grow(initTotalTermCharLen());

    // Step 1: iterate termsEnum and create a token, placing into a bucketed array (given a load factor)

    final TokenLL[] tokenBuckets = initTokenBucketsArray();
    final double OFFSET_TO_BUCKET_IDX = loadFactor / AVG_CHARS_PER_POSITION;
    final double POSITION_TO_BUCKET_IDX = loadFactor;

    final TermsEnum termsEnum = vector.iterator();
    BytesRef termBytesRef;
    PostingsEnum dpEnum = null;
    final CharsRefBuilder tempCharsRefBuilder = new CharsRefBuilder();//only for UTF8->UTF16 call

    TERM_LOOP:
    while ((termBytesRef = termsEnum.next()) != null) {
      //Grab the term (in same way as BytesRef.utf8ToString() but we don't want a String obj)
      // note: if term vectors supported seek by ord then we might just keep an int and seek by ord on-demand
      tempCharsRefBuilder.grow(termBytesRef.length);
      final int termCharsLen = UnicodeUtil.UTF8toUTF16(termBytesRef, tempCharsRefBuilder.chars());
      final int termCharsOff = termCharsBuilder.length();
      termCharsBuilder.append(tempCharsRefBuilder.chars(), 0, termCharsLen);
      dpEnum = termsEnum.postings(dpEnum, dpEnumFlags);
      assert dpEnum != null; // presumably checked by TokenSources.hasPositions earlier
      int currentDocId = dpEnum.advance(filteredDocId);
      if (currentDocId != filteredDocId) {
        continue; //Not expected
      }
      final int freq = dpEnum.freq();
      for (int j = 0; j < freq; j++) {
        TokenLL token = new TokenLL();
        token.position = dpEnum.nextPosition(); // can be -1 if not in the TV
        token.termCharsOff = termCharsOff;
        token.termCharsLen = (short) Math.min(termCharsLen, Short.MAX_VALUE);
        // copy offset (if it's there) and compute bucketIdx
        int bucketIdx;
        if (offsetAttribute != null) {
          token.startOffset = dpEnum.startOffset();
          if (offsetLength >= 0 && token.startOffset > offsetLength) {
            continue TERM_LOOP;//filter this token out; exceeds threshold
          }
          token.endOffsetInc = (short) Math.min(dpEnum.endOffset() - token.startOffset, Short.MAX_VALUE);
          bucketIdx = (int) (token.startOffset * OFFSET_TO_BUCKET_IDX);
        } else {
          bucketIdx = (int) (token.position * POSITION_TO_BUCKET_IDX);
        }
        if (bucketIdx >= tokenBuckets.length) {
          bucketIdx = tokenBuckets.length - 1;
        }

        if (payloadAttribute != null) {
          final BytesRef payload = dpEnum.getPayload();
          token.payloadIndex = payload == null ? -1 : payloadsBytesRefArray.append(payload);
        }

        //Add token to the head of the bucket linked list
        token.next = tokenBuckets[bucketIdx];
        tokenBuckets[bucketIdx] = token;
      }
    }

    // Step 2:  Link all Tokens into a linked-list and sort all tokens at the same position

    firstToken = initLinkAndSortTokens(tokenBuckets);

    // If the term vector didn't have positions, synthesize them
    if (!vector.hasPositions() && firstToken != null) {
      TokenLL prevToken = firstToken;
      prevToken.position = 0;
      for (TokenLL token = prevToken.next; token != null; prevToken = token, token = token.next) {
        if (prevToken.startOffset == token.startOffset) {
          token.position = prevToken.position;
        } else {
          token.position = prevToken.position + 1;
        }
      }
    }

    initialized = true;
  }

