  // called while the current position is the start of a new passage; find end of passage
  @Override
  public int following(int followingIdx) {
    final int startIdx = current();
    if (followingIdx < startIdx) {
      assert false : "Not supported";
      return baseIter.following(followingIdx);
    }
    final int targetIdx = startIdx + lengthGoal;
    // When followingIdx >= targetIdx, we can simply delegate since it will be >= the target
    if (followingIdx >= targetIdx - 1) {
      return baseIter.following(followingIdx);
    }
    // If target exceeds the text length, return the last index.
    if (targetIdx >= getText().getEndIndex()) {
      return baseIter.last();
    }

    // Find closest break >= the target
    final int afterIdx = baseIter.following(targetIdx - 1);
    if (afterIdx == DONE) { // we're at the end; can this happen?
      return current();
    }
    if (afterIdx == targetIdx) { // right on the money
      return afterIdx;
    }
    if (isMinimumLength) { // thus never undershoot
      return afterIdx;
    }

    // note: it is a shame that we invoke preceding() *in addition to* following(); BI's are sometimes expensive.

    // Find closest break < target
    final int beforeIdx = baseIter.preceding(targetIdx); // or could do baseIter.previous() but we hope the BI implements preceding()
    if (beforeIdx <= followingIdx) { // too far back
      return moveToBreak(afterIdx);
    }

    if (targetIdx - beforeIdx <= afterIdx - targetIdx) {
      return beforeIdx;
    }
    return moveToBreak(afterIdx);
  }

