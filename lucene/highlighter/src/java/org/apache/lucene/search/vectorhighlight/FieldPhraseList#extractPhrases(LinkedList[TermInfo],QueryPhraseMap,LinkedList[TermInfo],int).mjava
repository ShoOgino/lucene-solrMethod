  void extractPhrases(LinkedList<TermInfo> terms, QueryPhraseMap currMap, LinkedList<TermInfo> phraseCandidate, int longest) {
    if (phraseCandidate.size() > 1 && phraseCandidate.getLast().getPosition() - phraseCandidate.getFirst().getPosition() > currMap.getMaxPhraseWindow()) {
      return;
    }
    if (terms.isEmpty()) {
      if (longest > 0) {
        addIfNoOverlap( new WeightedPhraseInfo( phraseCandidate.subList(0, longest), currMap.getBoost(), currMap.getTermOrPhraseNumber() ) );
      }
      return;
    }
    ArrayList<TermInfo> samePositionTerms = new ArrayList<TermInfo>();
    do {
      samePositionTerms.add(terms.pop());
    } while (!terms.isEmpty() && terms.get(0).getPosition() == samePositionTerms.get(0).getPosition());

    // try all next terms at the same position
    for (TermInfo nextTerm : samePositionTerms) {
      QueryPhraseMap nextMap = currMap.getTermMap(nextTerm.getText());
      if (nextMap != null) {
        phraseCandidate.add(nextTerm);
        int l = longest;
        if(nextMap.isValidTermOrPhrase( phraseCandidate ) ){
          l = phraseCandidate.size();
        }
        extractPhrases(terms, nextMap, phraseCandidate, l);
        phraseCandidate.removeLast();
      }
    }

    // ignore the next term
    extractPhrases(terms, currMap, phraseCandidate, longest);

    // add terms back
    for (TermInfo nextTerm : samePositionTerms) {
      terms.push(nextTerm);
    }
  }

