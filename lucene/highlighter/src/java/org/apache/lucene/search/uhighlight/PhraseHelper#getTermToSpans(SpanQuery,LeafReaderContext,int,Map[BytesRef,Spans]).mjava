  // code extracted & refactored from WSTE.extractWeightedSpanTerms()
  private void getTermToSpans(SpanQuery spanQuery, LeafReaderContext readerContext,
                              int doc, Map<BytesRef, Spans> result)
      throws IOException {
    // note: in WSTE there was some field specific looping that seemed pointless so that isn't here.
    final IndexSearcher searcher = new IndexSearcher(readerContext.reader());
    searcher.setQueryCache(null);
    if (willRewrite) {
      spanQuery = (SpanQuery) searcher.rewrite(spanQuery); // searcher.rewrite loops till done
    }

    // Get the underlying query terms
    TreeSet<Term> termSet = new FieldFilteringTermSet(); // sorted so we can loop over results in order shortly...
    searcher.createWeight(spanQuery, false, 1.0f).extractTerms(termSet);//needsScores==false

    // Get Spans by running the query against the reader
    // TODO it might make sense to re-use/cache the Spans instance, to advance forward between docs
    SpanWeight spanWeight = (SpanWeight) searcher.createNormalizedWeight(spanQuery, false);
    Spans spans = spanWeight.getSpans(readerContext, SpanWeight.Postings.POSITIONS);
    if (spans == null) {
      return;
    }
    TwoPhaseIterator twoPhaseIterator = spans.asTwoPhaseIterator();
    if (twoPhaseIterator != null) {
      if (twoPhaseIterator.approximation().advance(doc) != doc || !twoPhaseIterator.matches()) {
        return;
      }
    } else if (spans.advance(doc) != doc) { // preposition, and return doing nothing if find none
      return;
    }

    // Consume the Spans into a cache.  This instance is used as a source for multiple cloned copies.
    // It's important we do this and not re-use the same original Spans instance since these will be iterated
    // independently later on; sometimes in ways that prevents sharing the original Spans.
    CachedSpans cachedSpansSource = new CachedSpans(spans); // consumes spans for this doc only and caches
    spans = null;// we don't use it below

    // Map terms to a Spans instance (aggregate if necessary)
    for (final Term queryTerm : termSet) {
      // note: we expect that at least one query term will pass these filters. This is because the collected
      //   spanQuery list were already filtered by these conditions.
      if (positionInsensitiveTerms.contains(queryTerm)) {
        continue;
      }
      // copy-constructor refers to same data (shallow) but has iteration state from the beginning
      CachedSpans cachedSpans = new CachedSpans(cachedSpansSource);
      // Add the span to whatever span may or may not exist
      Spans existingSpans = result.get(queryTerm.bytes());
      if (existingSpans != null) {
        if (existingSpans instanceof MultiSpans) {
          ((MultiSpans) existingSpans).addSpans(cachedSpans);
        } else { // upgrade to MultiSpans
          MultiSpans multiSpans = new MultiSpans();
          multiSpans.addSpans(existingSpans);
          multiSpans.addSpans(cachedSpans);
          result.put(queryTerm.bytes(), multiSpans);
        }
      } else {
        result.put(queryTerm.bytes(), cachedSpans);
      }
    }
  }

