  private static CharacterRunAutomaton binaryToCharRunAutomaton(Automaton binaryAutomaton, String description) {
    return new CharacterRunAutomaton(Automata.makeEmpty()) { // empty here is bogus just to satisfy API
      //   TODO can we get access to the aq.compiledAutomaton.runAutomaton ?
      ByteRunAutomaton byteRunAutomaton =
          new ByteRunAutomaton(binaryAutomaton, true, Operations.DEFAULT_MAX_DETERMINIZED_STATES);

      @Override
      public String toString() {
        return description;
      }

      @Override
      public boolean run(char[] chars, int offset, int length) {
        int state = 0;
        final int maxIdx = offset + length;
        for (int i = offset; i < maxIdx; i++) {
          final int code = chars[i];
          int b;
          // UTF16 to UTF8   (inlined logic from UnicodeUtil.UTF16toUTF8 )
          if (code < 0x80) {
            state = byteRunAutomaton.step(state, code);
            if (state == -1) return false;
          } else if (code < 0x800) {
            b = (0xC0 | (code >> 6));
            state = byteRunAutomaton.step(state, b);
            if (state == -1) return false;
            b = (0x80 | (code & 0x3F));
            state = byteRunAutomaton.step(state, b);
            if (state == -1) return false;
          } else {
            // more complex
            byte[] utf8Bytes = new byte[4 * (maxIdx - i)];
            int utf8Len = UnicodeUtil.UTF16toUTF8(chars, i, maxIdx - i, utf8Bytes);
            for (int utfIdx = 0; utfIdx < utf8Len; utfIdx++) {
              state = byteRunAutomaton.step(state, utf8Bytes[utfIdx] & 0xFF);
              if (state == -1) return false;
            }
            break;
          }
        }
        return byteRunAutomaton.isAccept(state);
      }
    };
  }

