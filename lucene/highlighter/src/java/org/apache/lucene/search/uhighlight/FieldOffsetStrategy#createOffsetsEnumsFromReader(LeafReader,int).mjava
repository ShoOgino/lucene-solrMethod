  protected List<OffsetsEnum> createOffsetsEnumsFromReader(LeafReader leafReader, int doc) throws IOException {
    final Terms termsIndex = leafReader.terms(field);
    if (termsIndex == null) {
      return Collections.emptyList();
    }

    // For strict positions, get a Map of term to Spans:
    //    note: ScriptPhraseHelper.NONE does the right thing for these method calls
    final Map<BytesRef, Spans> strictPhrasesTermToSpans =
        phraseHelper.getTermToSpans(leafReader, doc);
    // Usually simply wraps terms in a List; but if willRewrite() then can be expanded
    final List<BytesRef> sourceTerms =
        phraseHelper.expandTermsIfRewrite(terms, strictPhrasesTermToSpans);

    final List<OffsetsEnum> offsetsEnums = new ArrayList<>(sourceTerms.size() + automata.length);

    // Handle sourceTerms:
    if (!sourceTerms.isEmpty()) {
      TermsEnum termsEnum = termsIndex.iterator();//does not return null
      for (BytesRef term : sourceTerms) {
        if (termsEnum.seekExact(term)) {
          PostingsEnum postingsEnum = termsEnum.postings(null, PostingsEnum.OFFSETS);

          if (postingsEnum == null) {
            // no offsets or positions available
            throw new IllegalArgumentException("field '" + field + "' was indexed without offsets, cannot highlight");
          }

          if (doc == postingsEnum.advance(doc)) { // now it's positioned, although may be exhausted
            postingsEnum = phraseHelper.filterPostings(term, postingsEnum, strictPhrasesTermToSpans.get(term));
            if (postingsEnum != null) {
              offsetsEnums.add(new OffsetsEnum(term, postingsEnum));
            }
          }
        }
      }
    }

    // Handle automata
    if (automata.length > 0) {
      offsetsEnums.addAll(createAutomataOffsetsFromTerms(termsIndex, doc));
    }

    return offsetsEnums;
  }

