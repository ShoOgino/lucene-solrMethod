  /**
   * Build one {@link CharacterRunAutomaton} matching any term the query might match.
   */
  private static CharacterRunAutomaton buildCombinedAutomaton(String field, BytesRef[] terms,
                                                              CharacterRunAutomaton[] automata,
                                                              PhraseHelper strictPhrases) {
    List<CharacterRunAutomaton> allAutomata = new ArrayList<>();
    if (terms.length > 0) {
      allAutomata.add(new CharacterRunAutomaton(Automata.makeStringUnion(Arrays.asList(terms))));
    }
    Collections.addAll(allAutomata, automata);
    for (SpanQuery spanQuery : strictPhrases.getSpanQueries()) {
      Collections.addAll(allAutomata,
          MultiTermHighlighting.extractAutomata(spanQuery, field, true));//true==lookInSpan
    }

    if (allAutomata.size() == 1) {
      return allAutomata.get(0);
    }
    //TODO it'd be nice if we could get at the underlying Automaton in CharacterRunAutomaton so that we
    //  could union them all. But it's not exposed, and note TermRangeQuery isn't modelled as an Automaton
    //  by MultiTermHighlighting.

    // Return an aggregate CharacterRunAutomaton of others
    return new CharacterRunAutomaton(Automata.makeEmpty()) {// the makeEmpty() is bogus; won't be used
      @Override
      public boolean run(char[] chars, int offset, int length) {
        for (int i = 0; i < allAutomata.size(); i++) {// don't use foreach to avoid Iterator allocation
          if (allAutomata.get(i).run(chars, offset, length)) {
            return true;
          }
        }
        return false;
      }
    };
  }

