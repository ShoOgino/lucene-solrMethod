  private static TokenLL initLinkAndSortTokens(TokenLL[] tokenBuckets) {
    TokenLL firstToken = null;
    List<TokenLL> scratchTokenArray = new ArrayList<>(); // declare here for re-use.  TODO use native array
    TokenLL prevToken = null;
    for (TokenLL tokenHead : tokenBuckets) {
      if (tokenHead == null) {
        continue;
      }
      //sort tokens at this position and link them; return the first
      TokenLL tokenTail;
      // just one token
      if (tokenHead.next == null) {
        tokenTail = tokenHead;
      } else {
        // add the linked list to a temporary array
        for (TokenLL cur = tokenHead; cur != null; cur = cur.next) {
          scratchTokenArray.add(cur);
        }
        // sort; and set tokenHead & tokenTail
        if (scratchTokenArray.size() < INSERTION_SORT_THRESHOLD) {
          // insertion sort by creating a linked list (leave scratchTokenArray alone)
          tokenHead = tokenTail = scratchTokenArray.get(0);
          tokenHead.next = null;
          for (int i = 1; i < scratchTokenArray.size(); i++) {
            TokenLL insertToken = scratchTokenArray.get(i);
            if (insertToken.compareTo(tokenHead) <= 0) {
              // takes the place of tokenHead
              insertToken.next = tokenHead;
              tokenHead = insertToken;
            } else {
              // goes somewhere after tokenHead
              for (TokenLL prev = tokenHead; true; prev = prev.next) {
                if (prev.next == null || insertToken.compareTo(prev.next) <= 0) {
                  if (prev.next == null) {
                    tokenTail = insertToken;
                  }
                  insertToken.next = prev.next;
                  prev.next = insertToken;
                  break;
                }
              }
            }
          }
        } else {
          Collections.sort(scratchTokenArray);
          // take back out and create a linked list
          TokenLL prev = tokenHead = scratchTokenArray.get(0);
          for (int i = 1; i < scratchTokenArray.size(); i++) {
            prev.next = scratchTokenArray.get(i);
            prev = prev.next;
          }
          tokenTail = prev;
          tokenTail.next = null;
        }
        scratchTokenArray.clear();//too bad ArrayList nulls it out; we don't actually need that
      }

      //link to previous
      if (prevToken != null) {
        assert prevToken.next == null;
        prevToken.next = tokenHead; //concatenate linked-list
        assert prevToken.compareTo(tokenHead) < 0 : "wrong offset / position ordering expectations";
      } else {
        assert firstToken == null;
        firstToken = tokenHead;
      }

      prevToken = tokenTail;
    }
    return firstToken;
  }

