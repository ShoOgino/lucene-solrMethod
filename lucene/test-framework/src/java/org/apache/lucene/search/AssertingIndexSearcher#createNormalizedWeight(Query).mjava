  /** Ensures, that the returned {@code Weight} is not normalized again, which may produce wrong scores. */
  @Override
  public Weight createNormalizedWeight(Query query) throws IOException {
    final Weight w = super.createNormalizedWeight(query);
    return new Weight() {
      @Override
      public Explanation explain(AtomicReaderContext context, int doc) throws IOException {
        return w.explain(context, doc);
      }

      @Override
      public Query getQuery() {
        return w.getQuery();
      }

      @Override
      public void normalize(float norm, float topLevelBoost) {
        throw new IllegalStateException("Weight already normalized.");
      }

      @Override
      public Scorer scorer(AtomicReaderContext context, boolean scoreDocsInOrder,
          boolean topScorer, Bits acceptDocs) throws IOException {
        Scorer scorer = w.scorer(context, scoreDocsInOrder, topScorer, acceptDocs);
        if (scorer != null) {
          // check that scorer obeys disi contract for docID() before next()/advance
          try {
            int docid = scorer.docID();
            assert docid == -1 || docid == DocIdSetIterator.NO_MORE_DOCS;
          } catch (UnsupportedOperationException ignored) {
            // from a top-level BS1
            assert topScorer;
          }
        }
        return scorer;
      }

      @Override
      public float getValueForNormalization() {
        throw new IllegalStateException("Weight already normalized.");
      }

      @Override
      public boolean scoresDocsOutOfOrder() {
        // TODO: if this returns false, we should wrap
        // Scorer with AssertingScorer that confirms docIDs
        // are in order?
        return w.scoresDocsOutOfOrder();
      }
    };
  }

