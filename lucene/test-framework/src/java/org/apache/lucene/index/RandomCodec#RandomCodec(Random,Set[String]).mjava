  public RandomCodec(Random random, Set<String> avoidCodecs) {
    this.perFieldSeed = random.nextInt();
    // TODO: make it possible to specify min/max iterms per
    // block via CL:
    int minItemsPerBlock = _TestUtil.nextInt(random, 2, 100);
    int maxItemsPerBlock = 2*(Math.max(2, minItemsPerBlock-1)) + random.nextInt(100);
    int lowFreqCutoff = _TestUtil.nextInt(random, 2, 100);

    // nocommit: temporary disable other format tests
    /*
    add(avoidCodecs,
        new Lucene41PostingsFormat(minItemsPerBlock, maxItemsPerBlock),
        new DirectPostingsFormat(LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : maxItemsPerBlock),
                                 LuceneTestCase.rarely(random) ? 1 : (LuceneTestCase.rarely(random) ? Integer.MAX_VALUE : lowFreqCutoff)),
        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),
        // add pulsing again with (usually) different parameters
        new Pulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock),
        //TODO as a PostingsFormat which wraps others, we should allow TestBloomFilteredLucene41Postings to be constructed 
        //with a choice of concrete PostingsFormats. Maybe useful to have a generic means of marking and dealing 
        //with such "wrapper" classes?
        new TestBloomFilteredLucene41Postings(),                
        new MockSepPostingsFormat(),
        new MockFixedIntBlockPostingsFormat(_TestUtil.nextInt(random, 1, 2000)),
        new MockVariableIntBlockPostingsFormat( _TestUtil.nextInt(random, 1, 127)),
        new MockRandomPostingsFormat(random),
        new NestedPulsingPostingsFormat(),
        new Lucene41WithOrds(_TestUtil.nextInt(random, 1, 1000)),
        new Lucene41VarGapFixedInterval(_TestUtil.nextInt(random, 1, 1000)),
        new Lucene41VarGapDocFreqInterval(_TestUtil.nextInt(random, 1, 100), _TestUtil.nextInt(random, 1, 1000)),
        new SimpleTextPostingsFormat(),
        new AssertingPostingsFormat(),
        new MemoryPostingsFormat(true, random.nextFloat()),
        new MemoryPostingsFormat(false, random.nextFloat()));
    */
    add(avoidCodecs,
        new TempBlockPostingsFormat(_TestUtil.nextInt(random, 1, 1000)),
        new TempBlockTreePostingsFormat(minItemsPerBlock, maxItemsPerBlock),
        new TempRandomPostingsFormat(random),
        new TempNestedPulsingPostingsFormat(),
        new TempPulsing41PostingsFormat(1 + random.nextInt(20), minItemsPerBlock, maxItemsPerBlock));

    addDocValues(avoidCodecs,
        new Lucene45DocValuesFormat(),
        new DiskDocValuesFormat(),
        new MemoryDocValuesFormat(),
        new SimpleTextDocValuesFormat(),
        new AssertingDocValuesFormat());

    Collections.shuffle(formats, random);
    Collections.shuffle(dvFormats, random);

    // Avoid too many open files:
    if (formats.size() > 4) {
      formats = formats.subList(0, 4);
    }
    if (dvFormats.size() > 4) {
      dvFormats = dvFormats.subList(0, 4);
    }
  }

