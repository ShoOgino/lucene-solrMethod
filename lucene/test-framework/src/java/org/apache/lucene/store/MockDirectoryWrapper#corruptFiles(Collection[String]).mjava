  public synchronized void corruptFiles(Collection<String> files) {
    // Must make a copy because we change the incoming unsyncedFiles
    // when we create temp files, delete, etc., below:
    for(String name : new ArrayList<>(files)) {
      int damage = randomState.nextInt(6);
      String action = null;

      switch(damage) {

      case 0:
        action = "deleted";
        try {
          deleteFile(name, true);
        } catch (IOException ioe) {
          // ignore
        }
        break;

      case 1:
        action = "zeroed";
        // Zero out file entirely
        long length;
        try {
          length = fileLength(name);
        } catch (IOException ioe) {
          // Ignore
          continue;
        }
        byte[] zeroes = new byte[256];
        long upto = 0;
        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {
          while(upto < length) {
            final int limit = (int) Math.min(length-upto, zeroes.length);
            out.writeBytes(zeroes, 0, limit);
            upto += limit;
          }
        } catch (IOException ioe) {
          // ignore
        }
        break;

      case 2:
        {
          action = "partially truncated";
          // Partially Truncate the file:

          // First, make temp file and copy only half this
          // file over:
          String tempFileName = null;
          try (IndexOutput tempOut = in.createTempOutput("name", "mdw_corrupt", LuceneTestCase.newIOContext(randomState));
               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {
              tempFileName = tempOut.getName();
              tempOut.copyBytes(ii, ii.length()/2);
            } catch (IOException ioe) {
            // ignore
          }

          try {
            // Delete original and copy bytes back:
            deleteFile(name, true);
          } catch (IOException ioe) {
            // ignore
          }

          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));
               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {
              out.copyBytes(ii, ii.length());
            } catch (IOException ioe) {
            // ignore
          }
          try {
            deleteFile(tempFileName, true);
          } catch (IOException ioe) {
            // ignore
          }
        }
        break;
      
      case 3:
        // The file survived intact:
        action = "didn't change";
        break;

      case 4:
        // Corrupt one bit randomly in the file:

        {

          String tempFileName = null;
          try (IndexOutput tempOut = in.createTempOutput("name", "mdw_corrupt", LuceneTestCase.newIOContext(randomState));
               IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState))) {
              tempFileName = tempOut.getName();
              if (ii.length() > 0) {
                // Copy first part unchanged:
                long byteToCorrupt = (long) (randomState.nextDouble() * ii.length());
                if (byteToCorrupt > 0) {
                  tempOut.copyBytes(ii, byteToCorrupt);
                }

                // Randomly flip one bit from this byte:
                byte b = ii.readByte();
                int bitToFlip = randomState.nextInt(8);
                b = (byte) (b ^ (1 << bitToFlip));
                tempOut.writeByte(b);

                action = "flip bit " + bitToFlip + " of byte " + byteToCorrupt + " out of " + ii.length() + " bytes";

                // Copy last part unchanged:
                long bytesLeft = ii.length() - byteToCorrupt - 1;
                if (bytesLeft > 0) {
                  tempOut.copyBytes(ii, bytesLeft);
                }
              } else {
                action = "didn't change";
              }
            } catch (IOException ioe) {
            // ignore
          }

          try {
            // Delete original and copy bytes back:
            deleteFile(name, true);
          } catch (IOException ioe) {
            // ignore
          }

          try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));
               IndexInput ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState))) {
              out.copyBytes(ii, ii.length());
            } catch (IOException ioe) {
            // ignore
          }
          try {
            deleteFile(tempFileName, true);
          } catch (IOException ioe) {
            // ignore
          }
        }
        break;
        
      case 5:
        action = "fully truncated";
        // Totally truncate the file to zero bytes
        try {
          deleteFile(name, true);
        } catch (IOException ioe) {
          // ignore
        }

        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {
        } catch (IOException ioe) {
          // ignore
        }
        break;

      default:
        throw new AssertionError();
      }

      if (true || LuceneTestCase.VERBOSE) {
        System.out.println("MockDirectoryWrapper: " + action + " unsynced file: " + name);
      }
    }
  }

