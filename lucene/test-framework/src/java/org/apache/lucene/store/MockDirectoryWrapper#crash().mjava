  /** Simulates a crash of OS or machine by overwriting
   *  unsynced files. */
  public synchronized void crash() throws IOException {
    openFiles = new HashMap<>();
    openFilesForWrite = new HashSet<>();
    openFilesDeleted = new HashSet<>();
    Iterator<String> it = unSyncedFiles.iterator();
    unSyncedFiles = new HashSet<>();
    // first force-close all files, so we can corrupt on windows etc.
    // clone the file map, as these guys want to remove themselves on close.
    Map<Closeable,Exception> m = new IdentityHashMap<>(openFileHandles);
    for (Closeable f : m.keySet()) {
      try {
        f.close();
      } catch (Exception ignored) {}
    }
    
    while(it.hasNext()) {
      String name = it.next();
      int damage = randomState.nextInt(5);
      String action = null;

      if (damage == 0) {
        action = "deleted";
        deleteFile(name);
      } else if (damage == 1) {
        action = "zeroed";
        // Zero out file entirely
        long length = fileLength(name);
        byte[] zeroes = new byte[256];
        long upto = 0;
        IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState));
        while(upto < length) {
          final int limit = (int) Math.min(length-upto, zeroes.length);
          out.writeBytes(zeroes, 0, limit);
          upto += limit;
        }
        out.close();
      } else if (damage == 2) {
        action = "partially truncated";
        // Partially Truncate the file:

        // First, make temp file and copy only half this
        // file over:
        String tempFileName;
        while (true) {
          tempFileName = ""+randomState.nextInt();
          if (!LuceneTestCase.slowFileExists(in, tempFileName)) {
            break;
          }
        }
        final IndexOutput tempOut = in.createOutput(tempFileName, LuceneTestCase.newIOContext(randomState));
        IndexInput ii = in.openInput(name, LuceneTestCase.newIOContext(randomState));
        tempOut.copyBytes(ii, ii.length()/2);
        tempOut.close();
        ii.close();

        // Delete original and copy bytes back:
        deleteFile(name);
        
        try(IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {
          ii = in.openInput(tempFileName, LuceneTestCase.newIOContext(randomState));
          out.copyBytes(ii, ii.length());
          ii.close();
        } catch (IOException ioe) {
          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here
          if (ioe.getMessage().equals("file \"" + name + "\" is pending delete and cannot be overwritten")) {
            // OK
            action = "deleted";
          } else {
            throw ioe;
          }
        }
        deleteFile(tempFileName);
      } else if (damage == 3) {
        // The file survived intact:
        action = "didn't change";
      } else {
        action = "fully truncated";
        // Totally truncate the file to zero bytes
        deleteFile(name);
        try (IndexOutput out = in.createOutput(name, LuceneTestCase.newIOContext(randomState))) {
        } catch (IOException ioe) {
          // VirusCheckingFS may have blocked the delete, at which point FSDir cannot overwrite here
          if (ioe.getMessage().equals("file \"" + name + "\" is pending delete and cannot be overwritten")) {
            // OK
            action = "deleted";
          } else {
            throw ioe;
          }
        }
      }
      if (LuceneTestCase.VERBOSE) {
        System.out.println("MockDirectoryWrapper: " + action + " unsynced file: " + name);
      }
    }
    crashed = true;
  }

