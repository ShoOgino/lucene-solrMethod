  // LUCENE-3541
  public void testCopyBytesWithThreads() throws Exception {
    try (Directory d = getDirectory(createTempDir("testCopyBytesWithThreads"))) {
      byte data[] = RandomBytes.randomBytesOfLengthBetween(random(), 101, 10000);

      IndexOutput output = d.createOutput("data", IOContext.DEFAULT);
      output.writeBytes(data, 0, data.length);
      output.close();

      IndexInput input = d.openInput("data", IOContext.DEFAULT);
      IndexOutput outputHeader = d.createOutput("header", IOContext.DEFAULT);
      // copy our 100-byte header
      outputHeader.copyBytes(input, 100);
      outputHeader.close();

      // now make N copies of the remaining bytes
      int threads = 10;
      CyclicBarrier start = new CyclicBarrier(threads);
      Thread copies [] = IntStream.range(0, threads)
          .mapToObj((i) -> {
            IndexInput src = input.clone();
            Thread t = new Thread(() -> {
              try {
                start.await();
                IndexOutput dst = d.createOutput("copy" + i, IOContext.DEFAULT);
                dst.copyBytes(src, src.length() - 100);
                dst.close();
              } catch (Exception e) {
                throw new RuntimeException(e);
              }
            });
            t.start();
            return t;
          })
          .toArray(Thread[]::new);

      for (Thread t : copies) {
        t.join();
      }

      for (int i = 0; i < threads; i++) {
        try (IndexInput copiedData = d.openInput("copy" + i, IOContext.DEFAULT)) {
          byte[] dataCopy = new byte[data.length];
          System.arraycopy(data, 0, dataCopy, 0, 100);
          copiedData.readBytes(dataCopy, 100, data.length - 100);
          assertArrayEquals(data, dataCopy);
        }
      }
      input.close();
    }
  }

