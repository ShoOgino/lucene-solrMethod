  /** Sometimes wrap the IndexReader as slow, parallel or filter reader (or combinations of that) */
  public static IndexReader maybeWrapReader(IndexReader r) throws IOException {
    // TODO: remove this, and fix those tests to wrap before putting slow around:
    final boolean wasOriginallyAtomic = r instanceof AtomicReader;
    
    if (wasOriginallyAtomic) {
      // TODO: investigate purging etc of tests making top-level fieldcaches,
      // something is up if they get a crazy hierarchy
      return r;
    }

    if (rarely()) {
      for (int i = 0, c = random.nextInt(6)+1; i < c; i++) {
        switch(random.nextInt(4)) {
          case 0:
            r = SlowCompositeReaderWrapper.wrap(r);
            break;
          case 1:
            r = (r instanceof AtomicReader) ?
              new ParallelAtomicReader((AtomicReader) r) :
              new ParallelCompositeReader((CompositeReader) r);
            break;
          case 2:
            if (!wasOriginallyAtomic) { // dont wrap originally atomic readers to be composite (some tests don't like)
              r = new MultiReader(r);
            }
            break;
          case 3:
            if (r instanceof AtomicReader) {
              r = new FilterAtomicReader((AtomicReader) r) {
                @Override
                public Fields fields() throws IOException {
                  return new FilterFields(super.fields());
                }
              };
            }
            break;
          default:
            fail("should not get here");
        }
      }
    }
    //System.out.println(r);
    return r;
  }

