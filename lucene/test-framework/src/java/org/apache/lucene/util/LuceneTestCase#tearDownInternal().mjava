  /**
   * Clean up after tests.
   */
  private final void tearDownInternal() throws Exception {
    Throwable problem = null;
    BooleanQuery.setMaxClauseCount(savedBoolMaxClauseCount);

    // this won't throw any exceptions or fail the test
    // if we change this, then change this logic
    checkRogueThreadsAfter();
    // restore the default uncaught exception handler
    Thread.setDefaultUncaughtExceptionHandler(savedUncaughtExceptionHandler);
    
    try {
      checkUncaughtExceptionsAfter();
    } catch (Throwable t) {
      if (problem == null) problem = t;
    }
    
    try {
      // calling assertSaneFieldCaches here isn't as useful as having test
      // classes call it directly from the scope where the index readers
      // are used, because they could be gc'ed just before this tearDown
      // method is called.
      //
      // But it's better then nothing.
      //
      // If you are testing functionality that you know for a fact
      // "violates" FieldCache sanity, then you should either explicitly
      // call purgeFieldCache at the end of your test method, or refactor
      // your Test class so that the inconsistant FieldCache usages are
      // isolated in distinct test methods
      assertSaneFieldCaches(getTestLabel());
    } catch (Throwable t) {
      if (problem == null) problem = t;
    }
    
    purgeFieldCache(FieldCache.DEFAULT);
    
    if (problem != null) {
      reportAdditionalFailureInfo();
      // TODO: simply rethrow problem, without wrapping?
      throw new RuntimeException(problem);
    }
  }

