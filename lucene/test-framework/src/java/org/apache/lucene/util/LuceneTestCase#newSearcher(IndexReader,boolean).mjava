  /** create a new searcher over the reader.
   * This searcher might randomly use threads.
   * if <code>maybeWrap</code> is true, this searcher might wrap the reader
   * with one that returns null for getSequentialSubReaders.
   */
  public static IndexSearcher newSearcher(IndexReader r, boolean maybeWrap) throws IOException {
    if (usually()) {
      if (maybeWrap && rarely()) {
        r = SlowCompositeReaderWrapper.wrap(r);
      }
      if (maybeWrap && rarely()) {
        // just wrap as MultiReader/ParallelXReader with one subreader
        if (random.nextBoolean()) {
          r = (r instanceof AtomicReader) ?
            new ParallelAtomicReader((AtomicReader) r) :
            new ParallelCompositeReader((CompositeReader) r);
        } else if (r instanceof CompositeReader) { // only wrap if not already atomic (some tests may fail)
          r = new MultiReader(r);
        }
      }
      IndexSearcher ret = random.nextBoolean() ? new AssertingIndexSearcher(random, r) : new AssertingIndexSearcher(random, r.getTopReaderContext());
      ret.setSimilarity(similarity);
      return ret;
    } else {
      int threads = 0;
      final ExecutorService ex = (random.nextBoolean()) ? null
          : Executors.newFixedThreadPool(threads = _TestUtil.nextInt(random, 1, 8),
                      new NamedThreadFactory("LuceneTestCase"));
      if (ex != null) {
       if (VERBOSE) {
        System.out.println("NOTE: newSearcher using ExecutorService with " + threads + " threads");
       }
       r.addReaderClosedListener(new ReaderClosedListener() {
         @Override
         public void onClose(IndexReader reader) {
           shutdownExecutorService(ex);
         }
       });
      }
      IndexSearcher ret = random.nextBoolean() 
          ? new AssertingIndexSearcher(random, r, ex)
          : new AssertingIndexSearcher(random, r.getTopReaderContext(), ex);
      ret.setSimilarity(similarity);
      return ret;
    }
  }

