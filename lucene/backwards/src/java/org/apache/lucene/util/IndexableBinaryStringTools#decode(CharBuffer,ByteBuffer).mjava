  /**
   * Decodes the input char sequence into the output byte sequence.  Before
   * calling this method, ensure that the output ByteBuffer has sufficient
   * capacity by calling {@link #getDecodedLength(java.nio.CharBuffer)}.
   * 
   * @param input The char sequence to decode
   * @param output Where the byte sequence decoding result will go.  The limit
   *  is set to one past the position of the final char.
   * @throws IllegalArgumentException If either the input or the output buffer
   *  is not backed by an array
   */
  public static void decode(CharBuffer input, ByteBuffer output) {
    if (input.hasArray() && output.hasArray()) {
      int numInputChars = input.limit() - input.arrayOffset() - 1;
      int numOutputBytes = getDecodedLength(input);
      output.limit(numOutputBytes + output.arrayOffset()); // Set output final pos + 1
      output.position(0);
      byte[] outputArray = output.array();
      char[] inputArray = input.array();
      if (numOutputBytes > 0) {
        int caseNum = 0;
        int outputByteNum = output.arrayOffset();
        int inputCharNum = input.arrayOffset();
        short inputChar;
        CodingCase codingCase;
        for ( ; inputCharNum < numInputChars - 1 ; ++inputCharNum) {
          codingCase = CODING_CASES[caseNum];
          inputChar = (short)inputArray[inputCharNum];
          if (2 == codingCase.numBytes) {
            if (0 == caseNum) {
              outputArray[outputByteNum] = (byte)(inputChar >>> codingCase.initialShift);
            } else {
              outputArray[outputByteNum] += (byte)(inputChar >>> codingCase.initialShift);
            }
            outputArray[outputByteNum + 1] = (byte)((inputChar & codingCase.finalMask) 
                                                    << codingCase.finalShift);
          } else { // numBytes is 3
            outputArray[outputByteNum] += (byte)(inputChar >>> codingCase.initialShift);
            outputArray[outputByteNum + 1] = (byte)((inputChar & codingCase.middleMask)
                                                    >>> codingCase.middleShift);
            outputArray[outputByteNum + 2] = (byte)((inputChar & codingCase.finalMask) 
                                                    << codingCase.finalShift);
          }
          outputByteNum += codingCase.advanceBytes;
          if (++caseNum == CODING_CASES.length) {
            caseNum = 0;
          }
        }
        // Handle final char
        inputChar = (short)inputArray[inputCharNum];
        codingCase = CODING_CASES[caseNum];
        if (0 == caseNum) {
          outputArray[outputByteNum] = 0;
        }
        outputArray[outputByteNum] += (byte)(inputChar >>> codingCase.initialShift);
        int bytesLeft = numOutputBytes - outputByteNum;
        if (bytesLeft > 1) {
          if (2 == codingCase.numBytes) {
            outputArray[outputByteNum + 1] = (byte)((inputChar & codingCase.finalMask) 
                                                    >>> codingCase.finalShift);
          } else { // numBytes is 3
            outputArray[outputByteNum + 1] = (byte)((inputChar & codingCase.middleMask)
                                                    >>> codingCase.middleShift);
            if (bytesLeft > 2) {
              outputArray[outputByteNum + 2] = (byte)((inputChar & codingCase.finalMask) 
                                                      << codingCase.finalShift);
            }
          }
        }
      }
    } else {
      throw new IllegalArgumentException("Arguments must have backing arrays");
    }
  }

