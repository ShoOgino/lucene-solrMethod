  @Override
  public Query rewrite(IndexReader reader) throws IOException {
    if(!termLongEnough) {  // can only match if it's exact
      return new TermQuery(term);
    }

    int maxSize = BooleanQuery.getMaxClauseCount();
    PriorityQueue<ScoreTerm> stQueue = new PriorityQueue<ScoreTerm>(1024);
    FilteredTermEnum enumerator = getEnum(reader);
    try {
      ScoreTerm bottomSt = null;
      do {
        final Term t = enumerator.term();
        if (t == null) break;
        ScoreTerm st = new ScoreTerm(t, enumerator.difference());
        if (stQueue.size() < maxSize) {
          // record the current bottom item
          if (bottomSt == null || st.compareTo(bottomSt) > 0) {
            bottomSt = st;
          }
          // add to PQ, as it is not yet filled up
          stQueue.offer(st);
        } else {
          assert bottomSt != null;
          // only add to PQ, if the ScoreTerm is greater than the current bottom,
          // as all entries will be enqueued after the current bottom and will never be visible
          if (st.compareTo(bottomSt) < 0) {
            stQueue.offer(st);
          }
        }
        //System.out.println("current: "+st.term+"("+st.score+"), bottom: "+bottomSt.term+"("+bottomSt.score+")");
      } while (enumerator.next());
    } finally {
      enumerator.close();
    }
    
    BooleanQuery query = new BooleanQuery(true);
    int size = Math.min(stQueue.size(), maxSize);
    for(int i = 0; i < size; i++){
      ScoreTerm st = stQueue.poll();
      TermQuery tq = new TermQuery(st.term);      // found a match
      tq.setBoost(getBoost() * st.score); // set the boost
      query.add(tq, BooleanClause.Occur.SHOULD);          // add to query
    }

    return query;
  }

