  @Override
  public Spans getSpans(final IndexReader reader) throws IOException {
    return new Spans() {
        private Spans spans = match.getSpans(reader);

        @Override
        public boolean next() throws IOException {
          while (spans.next()) {                  // scan to next match
            if (end() <= end)
              return true;
          }
          return false;
        }

        @Override
        public boolean skipTo(int target) throws IOException {
          if (!spans.skipTo(target))
            return false;

          return spans.end() <= end || next();

        }

        @Override
        public int doc() { return spans.doc(); }
        @Override
        public int start() { return spans.start(); }
        @Override
        public int end() { return spans.end(); }

      // TODO: Remove warning after API has been finalized
      @Override
      public Collection<byte[]> getPayload() throws IOException {
        ArrayList<byte[]> result = null;
        if (spans.isPayloadAvailable()) {
          result = new ArrayList<byte[]>(spans.getPayload());
        }
        return result;//TODO: any way to avoid the new construction?
      }

      // TODO: Remove warning after API has been finalized
      @Override
      public boolean isPayloadAvailable() {
        return spans.isPayloadAvailable();
      }

      @Override
      public String toString() {
          return "spans(" + SpanFirstQuery.this.toString() + ")";
        }

      };
  }

