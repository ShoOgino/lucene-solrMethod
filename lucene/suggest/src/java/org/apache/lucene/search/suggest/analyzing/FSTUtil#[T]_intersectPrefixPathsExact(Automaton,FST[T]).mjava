  /** Enumerates all paths in the automaton that also
   *  intersect the FST, accumulating the FST end node and
   *  output for each path. */
  public static<T> List<Path<T>> intersectPrefixPathsExact(Automaton a, FST<T> fst) throws IOException {
    final List<Path<T>> queue = new ArrayList<Path<T>>();
    final List<Path<T>> endNodes = new ArrayList<Path<T>>();

    queue.add(new Path<T>(a.getInitialState(),
                          fst.getFirstArc(new FST.Arc<T>()),       
                          fst.outputs.getNoOutput(),
                          new IntsRef()));

    final FST.Arc<T> scratchArc = new FST.Arc<T>();
    final FST.BytesReader fstReader = fst.getBytesReader(0);

    //System.out.println("fst/a intersect");

    while (queue.size() != 0) {
      final Path<T> path = queue.remove(queue.size()-1);
      //System.out.println("  cycle path=" + path);
      if (path.state.isAccept()) {
        endNodes.add(path);
      }

      IntsRef currentInput = path.input;
      for(Transition t : path.state.getTransitions()) {
        // TODO: we can fix this if necessary:
        if (t.getMin() != t.getMax()) {
          throw new IllegalStateException("can only handle Transitions that match one character");
        }

        //System.out.println("    t=" + (char) t.getMin());

        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);
        if (nextArc != null) {
          //System.out.println("      fst matches");
          // Path continues:
          IntsRef newInput = new IntsRef(currentInput.length + 1);
          newInput.copyInts(currentInput);
          newInput.ints[currentInput.length] = t.getMin();
          newInput.length = currentInput.length + 1;

          queue.add(new Path<T>(t.getDest(),
                                new FST.Arc<T>().copyFrom(nextArc),
                                fst.outputs.add(path.output, nextArc.output),
                                newInput));
        }
      }
    }

    return endNodes;
  }

