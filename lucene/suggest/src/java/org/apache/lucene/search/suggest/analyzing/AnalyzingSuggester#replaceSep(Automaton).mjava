  // Replaces SEP with epsilon or remaps them if
  // we were asked to preserve them:
  private void replaceSep(Automaton a) {

    State[] states = a.getNumberedStates();

    // Go in reverse topo sort so we know we only have to
    // make one pass:
    for(int stateNumber=states.length-1;stateNumber >=0;stateNumber--) {
      final State state = states[stateNumber];
      List<Transition> newTransitions = new ArrayList<Transition>();
      for(Transition t : state.getTransitions()) {
        assert t.getMin() == t.getMax();
        if (t.getMin() == TokenStreamToAutomaton.POS_SEP) {
          if (preserveSep) {
            // Remap to SEP_LABEL:
            t = new Transition(SEP_LABEL, t.getDest());
          } else {
            // NOTE: sort of weird because this will grow
            // the transition array we are iterating over,
            // but because we are going in reverse topo sort
            // it will not add any SEP/HOLE transitions:
            state.addEpsilon(t.getDest());
            t = null;
          }
        } else if (t.getMin() == TokenStreamToAutomaton.HOLE) {

          // Just remove the hole: there will then be two
          // SEP tokens next to each other, which will only
          // match another hole at search time.  Note that
          // it will also match an empty-string token ... if
          // that's somehow a problem we can always map HOLE
          // to a dedicated byte (and escape it in the
          // input).

          // NOTE: sort of weird because this will grow
          // the transition array we are iterating over,
          // but because we are going in reverse topo sort
          // it will not add any SEP/HOLE transitions:
          state.addEpsilon(t.getDest());
          t = null;
        }
        if (t != null) {
          newTransitions.add(t);
        }
      }
      state.resetTransitions();
      state.setTransitions(newTransitions.toArray(new Transition[newTransitions.size()]));
    }
  }

