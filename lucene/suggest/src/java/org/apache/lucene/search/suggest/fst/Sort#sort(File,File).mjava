  /** 
   * Sort input to output, explicit hint for the buffer size. The amount of allocated
   * memory may deviate from the hint (may be smaller or larger).  
   */
  public SortInfo sort(File input, File output) throws IOException {
    sortInfo = new SortInfo();
    sortInfo.totalTime = System.currentTimeMillis();

    output.delete();

    ArrayList<File> merges = new ArrayList<File>();
    ByteSequencesReader is = new ByteSequencesReader(input);
    boolean success = false;
    try {
      int lines = 0;
      while ((lines = readPartition(is)) > 0) {                    
        merges.add(sortPartition(lines));
        sortInfo.tempMergeFiles++;
        sortInfo.lines += lines;

        // Handle intermediate merges.
        if (merges.size() == maxTempFiles) {
          File intermediate = File.createTempFile("sort", "intermediate", tempDirectory);
          mergePartitions(merges, intermediate);
          for (File file : merges) {
            file.delete();
          }
          merges.clear();
          merges.add(intermediate);
          sortInfo.tempMergeFiles++;
        }
      }
      success = true;
    } finally {
      if (success)
        IOUtils.close(is);
      else
        IOUtils.closeWhileHandlingException(is);
    }

    // One partition, try to rename or copy if unsuccessful.
    if (merges.size() == 1) {     
      // If simple rename doesn't work this means the output is
      // on a different volume or something. Copy the input then.
      if (!merges.get(0).renameTo(output)) {
        copy(merges.get(0), output);
      }
    } else { 
      // otherwise merge the partitions with a priority queue.                  
      mergePartitions(merges, output);                            
      for (File file : merges) {
        file.delete();
      }
    }

    sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); 
    return sortInfo;
  }

