    @Override
    protected void setNextMatch(IntsRef pathPrefix) {
      IntsRef ref = pathPrefix.clone();

      // check if the pathPrefix matches any
      // defined context, longer context first
      for (int contextLength : contextLengths) {
        if (contextLength > pathPrefix.length) {
          continue;
        }
        ref.length = contextLength;
        if (contextMap.containsKey(ref)) {
          currentBoost = contextMap.get(ref);
          ref.length = pathPrefix.length;
          ref.offset = contextLength;
          while (ref.ints[ref.offset] != ContextSuggestField.CONTEXT_SEPARATOR) {
            ref.offset++;
            assert ref.offset < ref.length;
          }
          assert ref.ints[ref.offset] == ContextSuggestField.CONTEXT_SEPARATOR : "expected CONTEXT_SEPARATOR at offset=" + ref.offset;
          if (ref.offset > pathPrefix.offset) {
            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, ref.offset), scratch).utf8ToString();
          } else {
            currentContext = null;
          }
          ref.offset++;
          if (ref.ints[ref.offset] == CompletionAnalyzer.SEP_LABEL) {
            ref.offset++;
          }
          innerWeight.setNextMatch(ref);
          return;
        }
      }
      // unknown context
      ref.length = pathPrefix.length;
      currentBoost = contexts.get("*").boost;
      for (int i = pathPrefix.offset; i < pathPrefix.length; i++) {
        if (pathPrefix.ints[i] == ContextSuggestField.CONTEXT_SEPARATOR) {
          if (i > pathPrefix.offset) {
            currentContext = Util.toBytesRef(new IntsRef(pathPrefix.ints, pathPrefix.offset, i), scratch).utf8ToString();
          } else {
            currentContext = null;
          }
          ref.offset = ++i;
          assert ref.offset < ref.length : "input should not end with the context separator";
          if (pathPrefix.ints[i] == CompletionAnalyzer.SEP_LABEL) {
            ref.offset++;
            assert ref.offset < ref.length : "input should not end with a context separator followed by SEP_LABEL";
          }
          ref.length -= ref.offset;
          innerWeight.setNextMatch(ref);
        }
      }
    }

