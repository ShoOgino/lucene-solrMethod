  /** Retrieve suggestions, specifying whether all terms
   *  must match ({@code allTermsRequired}) and whether the hits
   *  should be highlighted ({@code doHighlight}). */
  public List<LookupResult> lookup(CharSequence key, int num, boolean allTermsRequired, boolean doHighlight) {

    if (searcher == null) {
      throw new IllegalStateException("suggester was not built");
    }

    final BooleanClause.Occur occur;
    if (allTermsRequired) {
      occur = BooleanClause.Occur.MUST;
    } else {
      occur = BooleanClause.Occur.SHOULD;
    }

    try {
      //long t0 = System.currentTimeMillis();
      TokenStream ts = queryAnalyzer.tokenStream("", new StringReader(key.toString()));
      ts.reset();
      final CharTermAttribute termAtt = ts.addAttribute(CharTermAttribute.class);
      final OffsetAttribute offsetAtt = ts.addAttribute(OffsetAttribute.class);
      String lastToken = null;
      BooleanQuery query = new BooleanQuery();
      int maxEndOffset = -1;
      final Set<String> matchedTokens = new HashSet<String>();
      while (ts.incrementToken()) {
        if (lastToken != null) {  
          matchedTokens.add(lastToken);
          query.add(new TermQuery(new Term(TEXT_FIELD_NAME, lastToken)), occur);
        }
        lastToken = termAtt.toString();
        if (lastToken != null) {
          maxEndOffset = Math.max(maxEndOffset, offsetAtt.endOffset());
        }
      }
      ts.end();

      String prefixToken = null;
      if (lastToken != null) {
        Query lastQuery;
        if (maxEndOffset == offsetAtt.endOffset()) {
          // Use PrefixQuery (or the ngram equivalent) when
          // there was no trailing discarded chars in the
          // string (e.g. whitespace), so that if query does
          // not end with a space we show prefix matches for
          // that token:
          lastQuery = getLastTokenQuery(lastToken);
          prefixToken = lastToken;
        } else {
          // Use TermQuery for an exact match if there were
          // trailing discarded chars (e.g. whitespace), so
          // that if query ends with a space we only show
          // exact matches for that term:
          matchedTokens.add(lastToken);
          lastQuery = new TermQuery(new Term(TEXT_FIELD_NAME, lastToken));
        }
        if (lastQuery != null) {
          query.add(lastQuery, occur);
        }
      }
      ts.close();

      // TODO: we could allow blended sort here, combining
      // weight w/ score.  Now we ignore score and sort only
      // by weight:

      //System.out.println("INFIX query=" + query);

      Query finalQuery = finishQuery(query, allTermsRequired);

      // We sorted postings by weight during indexing, so we
      // only retrieve the first num hits now:
      FirstNDocsCollector c = new FirstNDocsCollector(num);
      try {
        searcher.search(finalQuery, c);
      } catch (FirstNDocsCollector.DoneException done) {
      }
      TopDocs hits = c.getHits();

      // Slower way if postings are not pre-sorted by weight:
      // hits = searcher.search(query, null, num, new Sort(new SortField("weight", SortField.Type.LONG, true)));

      List<LookupResult> results = new ArrayList<LookupResult>();
      BytesRef scratch = new BytesRef();
      for (int i=0;i<hits.scoreDocs.length;i++) {
        ScoreDoc sd = hits.scoreDocs[i];
        textDV.get(sd.doc, scratch);
        String text = scratch.utf8ToString();
        if (doHighlight) {
          text = highlight(text, matchedTokens, prefixToken);
        }
        long score = weightsDV.get(sd.doc);

        BytesRef payload;
        if (payloadsDV != null) {
          payload = new BytesRef();
          payloadsDV.get(sd.doc, payload);
        } else {
          payload = null;
        }

        results.add(new LookupResult(text, score, payload));
      }
      //System.out.println((System.currentTimeMillis() - t0) + " msec for infix suggest");
      //System.out.println(results);
      return results;
    } catch (IOException ioe) {
      throw new RuntimeException(ioe);
    }
  }

