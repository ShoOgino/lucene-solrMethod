  /** Carefully determine if the file on the primary, identified by its {@code String fileName} along with the {@link FileMetaData}
   * "summarizing" its contents, is precisely the same file that we have locally.  If the file does not exist locally, or if its its header
   * (inclues the segment id), length, footer (including checksum) differ, then this returns false, else true. */
  private boolean fileIsIdentical(String fileName, FileMetaData srcMetaData) throws IOException {

    if (deleter.isPending(fileName)) {
      // This was a file we had wanted to delete yet a virus checker prevented us, and now we need to overwrite it.
      // Such files are in an unknown state, and even if their header and footer and length all
      // match, since they may not have been fsync'd by the previous node instance on this directory,
      // they could in theory have corruption internally.  So we always force ourselves to copy them here:
      if (Node.VERBOSE_FILES) {
        message("file " + fileName + ": will copy [we had wanted to delete this file on init, but failed]");
      }
      return false;
    }

    FileMetaData destMetaData = readLocalFileMetaData(fileName);
    if (destMetaData == null) {
      // Something went wrong in reading the file (it's corrupt, truncated, does not exist, etc.):
      return false;
    }

    if (Arrays.equals(destMetaData.header, srcMetaData.header) == false ||
        Arrays.equals(destMetaData.footer, srcMetaData.footer) == false) {
      // Segment name was reused!  This is rare but possible and otherwise devastating:
      if (Node.VERBOSE_FILES) {
        message("file " + fileName + ": will copy [header/footer is different]");
      }
      return false;
    } else {
      return true;
    }
  }

