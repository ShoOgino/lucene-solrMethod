  public synchronized void deletePending() {
    if (Node.VERBOSE_FILES) {
      node.message("now deletePending: " + pending.size() + " files to try: " + pending);
    }

    // Clone the set because it will change as we iterate:
    List<String> toDelete = new ArrayList<>(pending);

    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed
    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files
    // undeleted so index is never in a corrupt state:
    for (String fileName : toDelete) {
      Integer rc = refCounts.get(fileName);
      if (rc != null && rc > 0) {
        // Should never happen!  This means we are about to pending-delete a referenced index file
        throw new IllegalStateException("file \"" + fileName + "\" is in pending delete set but has non-zero refCount=" + rc);
      } else if (fileName.startsWith(IndexFileNames.SEGMENTS)) {
        if (delete(fileName) == false) {
          if (Node.VERBOSE_FILES) {
            node.message("failed to remove commit point \"" + fileName + "\"; skipping deletion of all other pending files");
          }
          return;
        }
      }
    }

    // Only delete other files if we were able to remove the segments_N files; this way we never
    // leave a corrupt commit in the index even in the presense of virus checkers:
    for(String fileName : toDelete) {
      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {
        delete(fileName);
      }
    }

    Set<String> copy = new HashSet<String>(pending);
    pending.clear();
    for(String fileName : copy) {
      delete(fileName);
    }
  }

