  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
    final Map valueSourceContext = ValueSource.newContext(searcher);

    return new ConstantScoreWeight(this) {
      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        // Compute approx & exact
        final IntersectsDifferentiatingFilter.IntersectsDifferentiatingVisitor result =
            intersectsDiffFilter.compute(context, null);
        if (result.approxDocIdSet == null) {
          return null;
        }
        final DocIdSetIterator approxDISI = result.approxDocIdSet.iterator();
        if (approxDISI == null) {
          return null;
        }
        final Bits exactDocBits;
        if (result.exactDocIdSet != null) {
          // If both sets are the same, there's nothing to verify; we needn't return a TwoPhaseIterator
          if (result.approxDocIdSet.equals(result.exactDocIdSet)) {
            return new ConstantScoreScorer(this, score(), approxDISI);
          }
          exactDocBits = result.exactDocIdSet.bits();
          assert exactDocBits != null;
        } else {
          exactDocBits = null;
        }

        final FunctionValues predFuncValues = predicateValueSource.getValues(valueSourceContext, context);

        final TwoPhaseIterator twoPhaseIterator = new TwoPhaseIterator(approxDISI) {
          @Override
          public boolean matches() throws IOException {
            if (exactDocBits != null && exactDocBits.get(approxDISI.docID())) {
              return true;
            }

            return predFuncValues.boolVal(approxDISI.docID());
          }
        };

        return new ConstantScoreScorer(this, score(), twoPhaseIterator);
      }
    };
  }

