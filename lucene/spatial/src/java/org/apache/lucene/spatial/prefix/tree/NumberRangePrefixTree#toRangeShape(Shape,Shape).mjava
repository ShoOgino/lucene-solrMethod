  /** Returns a shape that represents the continuous range between {@code start} and {@code end}. It will
   * be optimized.
   * @throws IllegalArgumentException if the arguments are in the wrong order, or if either contains the other.
   */
  public Shape toRangeShape(Shape start, Shape end) {
    if (!(start instanceof LevelledValue && end instanceof LevelledValue))
      throw new IllegalArgumentException("Must pass "+LevelledValue.class+" but got "+start.getClass());
    LevelledValue startLV = (LevelledValue) start;
    LevelledValue endLV = (LevelledValue) end;
    //note: this normalization/optimization process is actually REQUIRED based on assumptions elsewhere.
    //Normalize start & end
    startLV = startLV.getLVAtLevel(truncateStartVals(startLV, 0)); // chops off trailing min-vals (zeroes)
    endLV = endLV.getLVAtLevel(truncateEndVals(endLV, 0)); // chops off trailing max-vals
    //Optimize to just start or end if it's equivalent, e.g. April to April 1st is April 1st.
    int cmp = comparePrefixLV(startLV, endLV);
    if (cmp > 0) {
      throw new IllegalArgumentException("Wrong order: "+start+" TO "+end);
    }
    if (cmp == 0) {//one is a prefix of the other
      if (startLV.getLevel() == endLV.getLevel()) {
        //same
        return startLV;
      } else if (endLV.getLevel() > startLV.getLevel()) {
        // e.g. April to April 1st
        if (truncateStartVals(endLV, startLV.getLevel()) == startLV.getLevel()) {
          return endLV;
  }
      } else {//minLV level > maxLV level
        // e.g. April 30 to April
        if (truncateEndVals(startLV, endLV.getLevel()) == endLV.getLevel()) {
          return startLV;
        }
      }
    }
    return new NRShape(startLV, endLV);
  }

