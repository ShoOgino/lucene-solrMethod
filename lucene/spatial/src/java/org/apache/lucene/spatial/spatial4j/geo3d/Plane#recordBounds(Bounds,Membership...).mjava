  /**
   * Accumulate bounds information for this plane, intersected with the unit sphere.
   * Updates both latitude and longitude information, using max/min points found
   * within the specified bounds.
   *
   * @param boundsInfo is the info to update with additional bounding information.
   * @param bounds     are the surfaces delineating what's inside the shape.
   */
  public void recordBounds(final Bounds boundsInfo, final Membership... bounds) {
    // For clarity, load local variables with good names
    final double A = this.x;
    final double B = this.y;
    final double C = this.z;

    // Now compute latitude min/max points
    if (!boundsInfo.checkNoTopLatitudeBound() || !boundsInfo.checkNoBottomLatitudeBound()) {
      //System.err.println("Looking at latitude for plane "+this);
      if ((Math.abs(A) >= MINIMUM_RESOLUTION || Math.abs(B) >= MINIMUM_RESOLUTION)) {
        //System.out.println("A = "+A+" B = "+B+" C = "+C+" D = "+D);
        // sin (phi) = z
        // cos (theta - phi) = D
        // sin (theta) = C  (the dot product of (0,0,1) and (A,B,C) )
        // Q: what is z?
        //
        // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D

        if (Math.abs(C) < MINIMUM_RESOLUTION) {
          // Special case: circle is vertical.
          //System.err.println(" Degenerate case; it's vertical circle");
          // cos(phi) = D, and we want sin(phi) = z
          // There are two solutions for phi given cos(phi) = D: a positive solution and a negative solution.
          // So, when we compute z = sqrt(1-D^2), it's really z = +/- sqrt(1-D^2) .

          double z;
          double x;
          double y;

          final double denom = 1.0 / (A * A + B * B);

          z = Math.sqrt(1.0 - D * D);
          y = -B * D * denom;
          x = -A * D * denom;
          addPoint(boundsInfo, bounds, x, y, z);

          z = -z;
          addPoint(boundsInfo, bounds, x, y, z);
        } else if (Math.abs(D) < MINIMUM_RESOLUTION) {
          //System.err.println(" Plane through origin case");
          // The general case is degenerate when the plane goes through the origin.
          // Luckily there's a pretty good way to figure out the max and min for that case though.
          // We find the two z values by computing the angle of the plane's inclination with the normal.
          // E.g., if this.z == 1, then our z value is 0, and if this.z == 0, our z value is 1.
          // Also if this.z == -1, then z value is 0 again.
          // Another way of putting this is that our z = sqrt(this.x^2 + this.y^2).
          //
          // The only tricky part is computing x and y.
          double z;
          double x;
          double y;

          final double denom = 1.0 / (A * A + B * B);

          z = Math.sqrt((A * A + B * B) / (A * A + B * B + C * C));
          y = -B * (C * z) * denom;
          x = -A * (C * z) * denom;
          addPoint(boundsInfo, bounds, x, y, z);

          z = -z;
          y = -B * (C * z) * denom;
          x = -A * (C * z) * denom;
          addPoint(boundsInfo, bounds, x, y, z);

        } else {
          //System.err.println(" General latitude case");
          // We might be able to identify a specific new latitude maximum or minimum.
          //
          // cos (theta-phi) = cos(theta)cos(phi) + sin(theta)sin(phi) = D
          //
          // This is tricky.  If cos(phi) = something, and we want to figure out
          // what sin(phi) is, in order to capture all solutions we need to recognize
          // that sin(phi) = +/- sqrt(1 - cos(phi)^2).  Basically, this means that
          // whatever solution we find we have to mirror it across the x-y plane,
          // and include both +z and -z solutions.
          //
          // cos (phi) = +/- sqrt(1-sin(phi)^2) = +/- sqrt(1-z^2)
          // cos (theta) = +/- sqrt(1-sin(theta)^2) = +/- sqrt(1-C^2)
          //
          // D = cos(theta)cos(phi) + sin(theta)sin(phi)
          // Substitute:
          // D = sqrt(1-C^2) * sqrt(1-z^2) -/+ C * z
          // Solve for z...
          // D +/- Cz = sqrt(1-C^2)*sqrt(1-z^2) = sqrt(1 - z^2 - C^2 + z^2*C^2)
          // Square both sides.
          // (D +/- Cz)^2 = 1 - z^2 - C^2 + z^2*C^2
          // D^2 +/- 2DCz + C^2*z^2 = 1 - z^2 - C^2 + z^2*C^2
          // D^2 +/- 2DCz  = 1 - C^2 - z^2
          // 0 = z^2 +/- 2DCz + (C^2 +D^2-1) = 0
          //
          // z = (+/- 2DC +/- sqrt(4*D^2*C^2 - 4*(C^2+D^2-1))) / (2)
          // z  = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2 )
          //    = +/- DC +/- sqrt(D^2*C^2 + 1 - C^2 - D^2)
          //
          // NOTE WELL: The above is clearly degenerate when D = 0.  So we'll have to
          // code a different solution for that case!

          // To get x and y, we need to plug z into the equations, as follows:
          //
          // Ax + By = -Cz - D
          // x^2 + y^2 = 1 - z^2
          //
          // x = (-Cz -D -By) /A
          // y = (-Cz -D -Ax) /B
          //
          // [(-Cz -D -By) /A]^2 + y^2 = 1 - z^2
          // [-Cz -D -By]^2 + A^2*y^2 = A^2 - A^2*z^2
          // C^2*z^2 + D^2 + B^2*y^2 + 2CDz + 2CBzy + 2DBy + A^2*y^2 - A^2 + A^2*z^2 = 0
          // y^2 [A^2 + B^2]  + y [2DB + 2CBz] + [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = 0
          //
          //
          // Use quadratic formula, where:
          // a = [A^2 + B^2]
          // b = [2BD + 2CBz]
          // c = [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]
          //
          // y = (-[2BD + 2CBz] +/- sqrt([2BD + 2CBz]^2 - 4 * [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / (2 * [A^2 + B^2])
          // Take out a 2:
          // y = (-[DB +CBz] +/- sqrt([DB + CBz]^2 - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2]) ) / [A^2 + B^2]
          //
          // The sqrt term simplifies:
          //
          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 + B^2] * [C^2*z^2 + D^2 + 2CDz - A^2 + A^2*z^2] = ?
          // B^2*D^2 + C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2
          //                  + B^2 * C^2 * z^2 + B^2 * D^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?
          // C^2*B^2*z^2 + 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2
          //                  + B^2 * C^2 * z^2 + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?
          // 2C*D*B^2*z - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2
          //                  + 2 * B^2 * CDz - A^2 * B^2 + B^2 * A^2 * z^2] =?
          // - [A^2 * C^2 * z^2 + A^2 * D^2 + 2 * A^2 * CDz - A^4 + A^4*z^2
          //                  - A^2 * B^2 + B^2 * A^2 * z^2] =?
          // - A^2 * [C^2 * z^2 + D^2 + 2 * CDz - A^2 + A^2*z^2
          //                  - B^2 + B^2 * z^2] =?
          // - A^2 * [z^2[A^2 + B^2 + C^2] - [A^2 + B^2 - D^2] + 2CDz] =?
          // - A^2 * [z^2 - [A^2 + B^2 - D^2] + 2CDz] =?
          //
          // y = (-[DB +CBz] +/- A*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]
          //
          // correspondingly:
          // x = (-[DA +CAz] +/- B*sqrt([A^2 + B^2 - D^2] - z^2 - 2CDz) ) / [A^2 + B^2]
          //
          // However, for the maximum or minimum we seek, the clause inside the sqrt should be zero.  If
          // it is NOT zero, then we aren't looking at the right z value.

          double z;
          double x;
          double y;

          double sqrtValue = D * D * C * C + 1.0 - C * C - D * D;
          double denom = 1.0 / (A * A + B * B);
          if (Math.abs(sqrtValue) < MINIMUM_RESOLUTION_SQUARED) {
            //System.err.println(" One latitude solution");
            double insideValue;
            double sqrtTerm;

            z = D * C;
            // Since we squared both sides of the equation, we may have introduced spurious solutions, so we have to check.
            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
            // Check the solution on the other side of the x-y plane
            z = -z;
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
          } else if (sqrtValue > 0.0) {
            //System.err.println(" Two latitude solutions");
            double sqrtResult = Math.sqrt(sqrtValue);

            double insideValue;
            double sqrtTerm;

            z = D * C + sqrtResult;
            //System.out.println("z= "+z+" D-C*z = " + (D-C*z) + " Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            //System.err.println(" z="+z+" C="+C+" D="+D+" inside value "+insideValue);
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
            // Check the solution on the other side of the x-y plane
            z = -z;
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            //System.err.println(" z="+z+" C="+C+" D="+D+" inside value "+insideValue);
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
            z = D * C - sqrtResult;
            //System.out.println("z= "+z+" D-C*z = " + (D-C*z) + " Math.sqrt(1.0 - z*z - C*C + z*z*C*C) = "+(Math.sqrt(1.0 - z*z - C*C + z*z*C*C)));
            // Since we squared both sides of the equation, we may have introduced spurios solutions, so we have to check.
            // But the same check applies to BOTH solutions -- the +z one as well as the -z one.
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            //System.err.println(" z="+z+" C="+C+" D="+D+" inside value "+insideValue);
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
            // Check the solution on the other side of the x-y plane
            z = -z;
            insideValue = A * A + B * B - D * D - z * z - 2.0 * C * D * z;
            //System.err.println(" z="+z+" C="+C+" D="+D+" inside value "+insideValue);
            if (Math.abs(insideValue) < MINIMUM_RESOLUTION) {
              y = -B * (D + C * z) * denom;
              x = -A * (D + C * z) * denom;
              if (evaluateIsZero(x, y, z)) {
                addPoint(boundsInfo, bounds, x, y, z);
              }
            }
          }
        }
      } else {
        // Horizontal circle.
        // Since the recordBounds() method will be called ONLY for planes that constitute edges of a shape,
        // we can be sure that some part of the horizontal circle will be part of the boundary, so we don't need
        // to check Membership objects.
        boundsInfo.addHorizontalCircle(-D * C);
      }
      //System.err.println("Done latitude bounds");
    }

    // First, figure out our longitude bounds, unless we no longer need to consider that
    if (!boundsInfo.checkNoLongitudeBound()) {
      //System.err.println("Computing longitude bounds for "+this);
      //System.out.println("A = "+A+" B = "+B+" C = "+C+" D = "+D);
      // Compute longitude bounds

      double a;
      double b;
      double c;

      if (Math.abs(C) < MINIMUM_RESOLUTION) {
        // Degenerate; the equation describes a line
        //System.out.println("It's a zero-width ellipse");
        // Ax + By + D = 0
        if (Math.abs(D) >= MINIMUM_RESOLUTION) {
          if (Math.abs(A) > Math.abs(B)) {
            // Use equation suitable for A != 0
            // We need to find the endpoints of the zero-width ellipse.
            // Geometrically, we have a line segment in x-y space.  We need to locate the endpoints
            // of that line.  But luckily, we know some things: specifically, since it is a
            // degenerate situation in projection, the C value had to have been 0.  That
            // means that our line's endpoints will coincide with the unit circle.  All we
            // need to do then is to find the intersection of the unit circle and the line
            // equation:
            //
            // A x + B y + D = 0
            //
            // Since A != 0:
            // x = (-By - D)/A
            //
            // The unit circle:
            // x^2 + y^2 - 1 = 0
            // Substitute:
            // [(-By-D)/A]^2 + y^2 -1 = 0
            // Multiply through by A^2:
            // [-By - D]^2 + A^2*y^2 - A^2 = 0
            // Multiply out:
            // B^2*y^2 + 2BDy + D^2 + A^2*y^2 - A^2 = 0
            // Group:
            // y^2 * [B^2 + A^2] + y [2BD] + [D^2-A^2] = 0

            a = B * B + A * A;
            b = 2.0 * B * D;
            c = D * D - A * A;

            double sqrtClause = b * b - 4.0 * a * c;

            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
              double y0 = -b / (2.0 * a);
              double x0 = (-D - B * y0) / A;
              double z0 = 0.0;
              addPoint(boundsInfo, bounds, x0, y0, z0);
            } else if (sqrtClause > 0.0) {
              double sqrtResult = Math.sqrt(sqrtClause);
              double denom = 1.0 / (2.0 * a);
              double Hdenom = 1.0 / A;

              double y0a = (-b + sqrtResult) * denom;
              double y0b = (-b - sqrtResult) * denom;

              double x0a = (-D - B * y0a) * Hdenom;
              double x0b = (-D - B * y0b) * Hdenom;

              double z0a = 0.0;
              double z0b = 0.0;

              addPoint(boundsInfo, bounds, x0a, y0a, z0a);
              addPoint(boundsInfo, bounds, x0b, y0b, z0b);
            }

          } else {
            // Use equation suitable for B != 0
            // Since I != 0, we rewrite:
            // y = (-Ax - D)/B
            a = B * B + A * A;
            b = 2.0 * A * D;
            c = D * D - B * B;

            double sqrtClause = b * b - 4.0 * a * c;

            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
              double x0 = -b / (2.0 * a);
              double y0 = (-D - A * x0) / B;
              double z0 = 0.0;
              addPoint(boundsInfo, bounds, x0, y0, z0);
            } else if (sqrtClause > 0.0) {
              double sqrtResult = Math.sqrt(sqrtClause);
              double denom = 1.0 / (2.0 * a);
              double Idenom = 1.0 / B;

              double x0a = (-b + sqrtResult) * denom;
              double x0b = (-b - sqrtResult) * denom;
              double y0a = (-D - A * x0a) * Idenom;
              double y0b = (-D - A * x0b) * Idenom;
              double z0a = 0.0;
              double z0b = 0.0;

              addPoint(boundsInfo, bounds, x0a, y0a, z0a);
              addPoint(boundsInfo, bounds, x0b, y0b, z0b);
            }
          }
        }

      } else {
        //System.err.println("General longitude bounds...");

        // NOTE WELL: The x,y,z values generated here are NOT on the unit sphere.
        // They are for lat/lon calculation purposes only.  x-y is meant to be used for longitude determination,
        // and z for latitude, and that's all the values are good for.

        // (1) Intersect the plane and the unit sphere, and project the results into the x-y plane:
        // From plane:
        // z = (-Ax - By - D) / C
        // From unit sphere:
        // x^2 + y^2 + [(-Ax - By - D) / C]^2 = 1
        // Simplify/expand:
        // C^2*x^2 + C^2*y^2 + (-Ax - By - D)^2 = C^2
        //
        // x^2 * C^2 + y^2 * C^2 + x^2 * (A^2 + ABxy + ADx) + (ABxy + y^2 * B^2 + BDy) + (ADx + BDy + D^2) = C^2
        // Group:
        // [A^2 + C^2] x^2 + [B^2 + C^2] y^2 + [2AB]xy + [2AD]x + [2BD]y + [D^2-C^2] = 0
        // For convenience, introduce post-projection coefficient variables to make life easier.
        // E x^2 + F y^2 + G xy + H x + I y + J = 0
        double E = A * A + C * C;
        double F = B * B + C * C;
        double G = 2.0 * A * B;
        double H = 2.0 * A * D;
        double I = 2.0 * B * D;
        double J = D * D - C * C;

        //System.err.println("E = " + E + " F = " + F + " G = " + G + " H = "+ H + " I = " + I + " J = " + J);

        double trialX = 2.0;
        double trialY = 2.0;

        //System.err.println("Trial point evaluates to: "+(E*trialX*trialX + F*trialY*trialY + G*trialX*trialY + H*trialX + I*trialY + J));

        // Check if the origin is within, by substituting x = 0, y = 0 and seeing if less than zero
        if (Math.abs(J) >= MINIMUM_RESOLUTION && J > 0.0) {
          // The derivative of the curve above is:
          // 2Exdx + 2Fydy + G(xdy+ydx) + Hdx + Idy = 0
          // (2Ex + Gy + H)dx + (2Fy + Gx + I)dy = 0
          // dy/dx = - (2Ex + Gy + H) / (2Fy + Gx + I)
          //
          // The equation of a line going through the origin with the slope dy/dx is:
          // y = dy/dx x
          // y = - (2Ex + Gy + H) / (2Fy + Gx + I)  x
          // Rearrange:
          // (2Fy + Gx + I) y + (2Ex + Gy + H) x = 0
          // 2Fy^2 + Gxy + Iy + 2Ex^2 + Gxy + Hx = 0
          // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0
          //
          // Multiply the original equation by 2:
          // 2E x^2 + 2F y^2 + 2G xy + 2H x + 2I y + 2J = 0
          // Subtract one from the other, to remove the high-order terms:
          // Hx + Iy + 2J = 0
          // Now, we can substitute either x = or y = into the derivative equation, or into the original equation.
          // But we will need to base this on which coefficient is non-zero

          if (Math.abs(H) > Math.abs(I)) {
            //System.err.println(" Using the y quadratic");
            // x = (-2J - Iy)/H

            // Plug into the original equation:
            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y + H [(-2J - Iy)/H] + I y + J = 0
            // E [(-2J - Iy)/H]^2 + F y^2 + G [(-2J - Iy)/H]y - J = 0
            // Same equation as derivative equation, except for a factor of 2!  So it doesn't matter which we pick.

            // Plug into derivative equation:
            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y + H[(-2J - Iy)/H] + Iy = 0
            // 2E[(-2J - Iy)/H]^2 + 2Fy^2 + 2G[(-2J - Iy)/H]y - 2J = 0
            // E[(-2J - Iy)/H]^2 + Fy^2 + G[(-2J - Iy)/H]y - J = 0

            // Multiply by H^2 to make manipulation easier
            // E[(-2J - Iy)]^2 + F*H^2*y^2 + GH[(-2J - Iy)]y - J*H^2 = 0
            // Do the square
            // E[4J^2 + 4IJy + I^2*y^2] + F*H^2*y^2 + GH(-2Jy - I*y^2) - J*H^2 = 0

            // Multiply it out
            // 4E*J^2 + 4EIJy + E*I^2*y^2 + H^2*Fy^2 - 2GHJy - GH*I*y^2 - J*H^2 = 0
            // Group:
            // y^2 [E*I^2 - GH*I + F*H^2] + y [4EIJ - 2GHJ] + [4E*J^2 - J*H^2] = 0

            a = E * I * I - G * H * I + F * H * H;
            b = 4.0 * E * I * J - 2.0 * G * H * J;
            c = 4.0 * E * J * J - J * H * H;

            //System.out.println("a="+a+" b="+b+" c="+c);
            double sqrtClause = b * b - 4.0 * a * c;
            //System.out.println("sqrtClause="+sqrtClause);

            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
              //System.err.println(" One solution");
              double y0 = -b / (2.0 * a);
              double x0 = (-2.0 * J - I * y0) / H;
              double z0 = (-A * x0 - B * y0 - D) / C;

              addPoint(boundsInfo, bounds, x0, y0, z0);
            } else if (sqrtClause > 0.0) {
              //System.err.println(" Two solutions");
              double sqrtResult = Math.sqrt(sqrtClause);
              double denom = 1.0 / (2.0 * a);
              double Hdenom = 1.0 / H;
              double Cdenom = 1.0 / C;

              double y0a = (-b + sqrtResult) * denom;
              double y0b = (-b - sqrtResult) * denom;
              double x0a = (-2.0 * J - I * y0a) * Hdenom;
              double x0b = (-2.0 * J - I * y0b) * Hdenom;
              double z0a = (-A * x0a - B * y0a - D) * Cdenom;
              double z0b = (-A * x0b - B * y0b - D) * Cdenom;

              addPoint(boundsInfo, bounds, x0a, y0a, z0a);
              addPoint(boundsInfo, bounds, x0b, y0b, z0b);
            }

          } else {
            //System.err.println(" Using the x quadratic");
            // y = (-2J - Hx)/I

            // Plug into the original equation:
            // E x^2 + F [(-2J - Hx)/I]^2 + G x[(-2J - Hx)/I] - J = 0

            // Multiply by I^2 to make manipulation easier
            // E * I^2 * x^2 + F [(-2J - Hx)]^2 + GIx[(-2J - Hx)] - J * I^2 = 0
            // Do the square
            // E * I^2 * x^2 + F [ 4J^2 + 4JHx + H^2*x^2] + GI[(-2Jx - H*x^2)] - J * I^2 = 0

            // Multiply it out
            // E * I^2 * x^2 + 4FJ^2 + 4FJHx + F*H^2*x^2 - 2GIJx - HGI*x^2 - J * I^2 = 0
            // Group:
            // x^2 [E*I^2 - GHI + F*H^2] + x [4FJH - 2GIJ] + [4FJ^2 - J*I^2] = 0

            // E x^2 + F y^2 + G xy + H x + I y + J = 0

            a = E * I * I - G * H * I + F * H * H;
            b = 4.0 * F * H * J - 2.0 * G * I * J;
            c = 4.0 * F * J * J - J * I * I;

            //System.out.println("a="+a+" b="+b+" c="+c);
            double sqrtClause = b * b - 4.0 * a * c;
            //System.out.println("sqrtClause="+sqrtClause);
            if (Math.abs(sqrtClause) < MINIMUM_RESOLUTION_SQUARED) {
              //System.err.println(" One solution; sqrt clause was "+sqrtClause);
              double x0 = -b / (2.0 * a);
              double y0 = (-2.0 * J - H * x0) / I;
              double z0 = (-A * x0 - B * y0 - D) / C;
              // Verify that x&y fulfill the equation
              // 2Ex^2 + 2Fy^2 + 2Gxy + Hx + Iy = 0
              addPoint(boundsInfo, bounds, x0, y0, z0);
            } else if (sqrtClause > 0.0) {
              //System.err.println(" Two solutions");
              double sqrtResult = Math.sqrt(sqrtClause);
              double denom = 1.0 / (2.0 * a);
              double Idenom = 1.0 / I;
              double Cdenom = 1.0 / C;

              double x0a = (-b + sqrtResult) * denom;
              double x0b = (-b - sqrtResult) * denom;
              double y0a = (-2.0 * J - H * x0a) * Idenom;
              double y0b = (-2.0 * J - H * x0b) * Idenom;
              double z0a = (-A * x0a - B * y0a - D) * Cdenom;
              double z0b = (-A * x0b - B * y0b - D) * Cdenom;

              addPoint(boundsInfo, bounds, x0a, y0a, z0a);
              addPoint(boundsInfo, bounds, x0b, y0b, z0b);
            }
          }
        }
      }
    }

  }

