    @Override
    protected PointValues.Relation relate(final double minLat, final double maxLat, final double minLon, final double maxLon) {
      // bounding box check
      if (cellIntersectsMBR(minLat, maxLat, minLon, maxLon) == false) {
        return PointValues.Relation.CELL_OUTSIDE_QUERY;
      }
      if ((centerLon < minLon || centerLon > maxLon) && (axisLat + Rectangle.AXISLAT_ERROR < minLat
          || axisLat- Rectangle.AXISLAT_ERROR > maxLat)) {
        if (SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, minLat, minLon) > distanceQuery.sortKey &&
            SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, minLat, maxLon) > distanceQuery.sortKey &&
            SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, maxLat, minLon) > distanceQuery.sortKey &&
            SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, maxLat, maxLon) > distanceQuery.sortKey) {
          return PointValues.Relation.CELL_OUTSIDE_QUERY;
        }
      }

      if (maxLon - centerLon < 90 && centerLon - minLon < 90 &&
          SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, minLat, minLon) <= distanceQuery.sortKey &&
          SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, minLat, maxLon) <= distanceQuery.sortKey &&
          SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, maxLat, minLon) <= distanceQuery.sortKey &&
          SloppyMath.haversinSortKey(distanceQuery.centerLat, centerLon, maxLat, maxLon) <= distanceQuery.sortKey) {
        // we are fully enclosed, collect everything within this subtree
        return PointValues.Relation.CELL_INSIDE_QUERY;
      }

      return PointValues.Relation.CELL_CROSSES_QUERY;
    }

