  @Override
  public DocIdSet getDocIdSet(AtomicReaderContext context, final Bits acceptDocs) throws IOException {
    Bits docsWithField;
    if (field == null) {
      docsWithField = null;//all docs
    } else {
      //NOTE By using the FieldCache we re-use a cache
      // which is nice but loading it in this way might be slower than say using an
      // intersects filter against the world bounds. So do we add a method to the
      // strategy, perhaps?  But the strategy can't cache it.
      docsWithField = DocValues.getDocsWithField(context.reader(), field);

      final int maxDoc = context.reader().maxDoc();
      if (docsWithField.length() != maxDoc )
        throw new IllegalStateException("Bits length should be maxDoc ("+maxDoc+") but wasn't: "+docsWithField);

      if (docsWithField instanceof Bits.MatchNoBits) {
        return null;//match nothing
      } else if (docsWithField instanceof Bits.MatchAllBits) {
        docsWithField = null;//all docs
      }
    }

    //not so much a chain but a way to conveniently invert the Filter
    DocIdSet docIdSet = new ChainedFilter(new Filter[]{intersectsFilter}, ChainedFilter.ANDNOT).getDocIdSet(context, acceptDocs);
    return BitsFilteredDocIdSet.wrap(docIdSet, docsWithField);
  }

