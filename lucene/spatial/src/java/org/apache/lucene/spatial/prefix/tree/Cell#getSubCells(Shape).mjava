  /**
   * Like {@link #getSubCells()} but with the results filtered by a shape. If
   * that shape is a {@link com.spatial4j.core.shape.Point} then it must call
   * {@link #getSubCell(com.spatial4j.core.shape.Point)}. The returned cells
   * should have {@link Cell#getShapeRel()} set to their relation with {@code
   * shapeFilter}. In addition, {@link Cell#isLeaf()}
   * must be true when that relation is WITHIN.
   * <p/>
   * Precondition: Never called when getLevel() == maxLevel.
   *
   * @param shapeFilter an optional filter for the returned cells.
   * @return A set of cells (no dups), sorted. Not Modifiable.
   */
  public Collection<Cell> getSubCells(Shape shapeFilter) {
    //Note: Higher-performing subclasses might override to consider the shape filter to generate fewer cells.
    if (shapeFilter instanceof Point) {
      Cell subCell = getSubCell((Point) shapeFilter);
      subCell.shapeRel = SpatialRelation.CONTAINS;
      return Collections.singletonList(subCell);
    }
    Collection<Cell> cells = getSubCells();

    if (shapeFilter == null) {
      return cells;
    }

    //TODO change API to return a filtering iterator
    List<Cell> copy = new ArrayList<>(cells.size());
    for (Cell cell : cells) {
      SpatialRelation rel = cell.getShape().relate(shapeFilter);
      if (rel == SpatialRelation.DISJOINT)
        continue;
      cell.shapeRel = rel;
      if (rel == SpatialRelation.WITHIN)
        cell.setLeaf();
      copy.add(cell);
    }
    return copy;
  }

