  /**
   * Compute whether the rectangle (defined by min/max Lon/Lat) crosses a potentially oblate circle
   *
   * TODO benchmark for replacing existing rectCrossesCircle.
   */
  public static boolean rectCrossesOblateCircle(double centerLon, double centerLat, double radiusMeters, double rMinLon, double rMinLat, double  rMaxLon, double rMaxLat) {
    double w = Math.abs(rMaxLon - rMinLon);
    final int segs = (int)Math.ceil(w / 45.0);
    w /= segs;
    short i = 1;
    double p1 = rMinLon;
    double maxLon, midLon;
    double[] pt = new double[2];

    do {
      maxLon = (i == segs) ? rMaxLon : p1 + w;

      final double d1, d2;
      // short-circuit if we find a corner outside the circle
      if ( (d1 = GeoDistanceUtils.haversin(centerLat, centerLon, rMinLat, p1)) > radiusMeters
          || (d2 = GeoDistanceUtils.haversin(centerLat, centerLon, rMinLat, maxLon)) > radiusMeters
          || GeoDistanceUtils.haversin(centerLat, centerLon, rMaxLat, p1) > radiusMeters
          || GeoDistanceUtils.haversin(centerLat, centerLon, rMaxLat, maxLon) > radiusMeters) {
        return true;
      }

      // else we treat as an oblate circle by slicing the longitude space and checking the azimuthal range
      // OPTIMIZATION: this is only executed for latitude values "closeTo" the poles (e.g., 88.0 > lat < -88.0)
      if ( (rMaxLat > 88.0 || rMinLat < -88.0)
          && (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(p1, rMinLat,
          GeoProjectionUtils.bearingGreatCircle(p1, rMinLat, p1, rMaxLat), radiusMeters - d1, pt))[1] < rMinLat || pt[1] < rMaxLat
          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, maxLon, rMaxLat), radiusMeters - d2, pt))[1] < rMinLat || pt[1] < rMaxLat
          || (pt = GeoProjectionUtils.pointFromLonLatBearingGreatCircle(maxLon, rMinLat,
          GeoProjectionUtils.bearingGreatCircle(maxLon, rMinLat, (midLon = p1 + 0.5*(maxLon - p1)), rMaxLat),
          radiusMeters - GeoDistanceUtils.haversin(centerLat, centerLon, rMinLat, midLon), pt))[1] < rMinLat
          || pt[1] < rMaxLat == false ) {
        return true;
      }
      p1 += w;
    } while (++i <= segs);
    return false;
  }

