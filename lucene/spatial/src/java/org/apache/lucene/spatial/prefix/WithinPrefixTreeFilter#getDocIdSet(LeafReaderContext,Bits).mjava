  @Override
  public DocIdSet getDocIdSet(LeafReaderContext context, Bits acceptDocs) throws IOException {
    return new VisitorTemplate(context, acceptDocs) {
      private FixedBitSet inside;
      private FixedBitSet outside;
      private SpatialRelation visitRelation;

      @Override
      protected void start() {
        inside = new FixedBitSet(maxDoc);
        outside = new FixedBitSet(maxDoc);
      }

      @Override
      protected DocIdSet finish() {
        inside.andNot(outside);
        return new BitDocIdSet(inside);
      }

      @Override
      protected CellIterator findSubCellsToVisit(Cell cell) {
        //use buffered query shape instead of orig.  Works with null too.
        return cell.getNextLevelCells(bufferedQueryShape);
      }

      @Override
      protected boolean visit(Cell cell) throws IOException {
        //cell.relate is based on the bufferedQueryShape; we need to examine what
        // the relation is against the queryShape
        visitRelation = cell.getShape().relate(queryShape);
        if (visitRelation == SpatialRelation.WITHIN) {
          collectDocs(inside);
          return false;
        } else if (visitRelation == SpatialRelation.DISJOINT) {
          collectDocs(outside);
          return false;
        } else if (cell.getLevel() == detailLevel) {
          collectDocs(inside);
          return false;
        }
        return true;
      }

      @Override
      protected void visitLeaf(Cell cell) throws IOException {
        //visitRelation is declared as a field, populated by visit() so we don't recompute it.
        // We have a specialized visitScanned() which doesn't call this. If we didn't, we would
        // not be able to assume visitRelation is from a prior visit() call since in scanning,
        // parent cells aren't visited.
        assert detailLevel != cell.getLevel();
        assert visitRelation == cell.getShape().relate(queryShape);
        if (allCellsIntersectQuery(cell, visitRelation))
          collectDocs(inside);
        else
          collectDocs(outside);
      }

      /** Returns true if the provided cell, and all its sub-cells down to
       * detailLevel all intersect the queryShape.
       */
      private boolean allCellsIntersectQuery(Cell cell, SpatialRelation relate/*cell to query*/) {
        if (relate == null)
          relate = cell.getShape().relate(queryShape);
        if (cell.getLevel() == detailLevel)
          return relate.intersects();
        if (relate == SpatialRelation.WITHIN)
          return true;
        if (relate == SpatialRelation.DISJOINT)
          return false;
        // Note: Generating all these cells just to determine intersection is not ideal.
        // The real solution is LUCENE-4869.
        CellIterator subCells = cell.getNextLevelCells(null);
        while (subCells.hasNext()) {
          Cell subCell = subCells.next();
          if (!allCellsIntersectQuery(subCell, null))//recursion
            return false;
        }
        return true;
      }

      @Override
      protected void visitScanned(Cell cell) throws IOException {
        //slightly optimize over default impl; required for our 'visitRelation' field re-use above
        if (allCellsIntersectQuery(cell, null)) {
          collectDocs(inside);
        } else {
          collectDocs(outside);
        }
      }

    }.getDocIdSet();
  }

