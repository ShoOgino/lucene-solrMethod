  @Override
  public DocIdSet getDocIdSet(AtomicReaderContext ctx, Bits acceptDocs) throws IOException {
    AtomicReader reader = ctx.reader();
    OpenBitSet bits = new OpenBitSet(reader.maxDoc());
    Terms terms = reader.terms(fieldName);
    if (terms == null)
      return null;
    TermsEnum termsEnum = terms.iterator(null);
    DocsEnum docsEnum = null;//cached for termsEnum.docs() calls
    Node scanCell = null;

    //cells is treated like a stack. LinkedList conveniently has bulk add to beginning. It's in sorted order so that we
    //  always advance forward through the termsEnum index.
    LinkedList<Node> cells = new LinkedList<Node>(
        grid.getWorldNode().getSubCells(queryShape) );

    //This is a recursive algorithm that starts with one or more "big" cells, and then recursively dives down into the
    // first such cell that intersects with the query shape.  It's a depth first traversal because we don't move onto
    // the next big cell (breadth) until we're completely done considering all smaller cells beneath it. For a given
    // cell, if it's *within* the query shape then we can conveniently short-circuit the depth traversal and
    // grab all documents assigned to this cell/term.  For an intersection of the cell and query shape, we either
    // recursively step down another grid level or we decide heuristically (via prefixGridScanLevel) that there aren't
    // that many points, and so we scan through all terms within this cell (i.e. the term starts with the cell's term),
    // seeing which ones are within the query shape.
    while(!cells.isEmpty()) {
      final Node cell = cells.removeFirst();
      final BytesRef cellTerm = new BytesRef(cell.getTokenBytes());
      TermsEnum.SeekStatus seekStat = termsEnum.seekCeil(cellTerm);
      if (seekStat == TermsEnum.SeekStatus.END)
        break;
      if (seekStat == TermsEnum.SeekStatus.NOT_FOUND)
        continue;
      if (cell.getLevel() == detailLevel || cell.isLeaf()) {
        docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);
        addDocs(docsEnum,bits);
      } else {//any other intersection
        //If the next indexed term is the leaf marker, then add all of them
        BytesRef nextCellTerm = termsEnum.next();
        assert StringHelper.startsWith(nextCellTerm, cellTerm);
        scanCell = grid.getNode(nextCellTerm.bytes, nextCellTerm.offset, nextCellTerm.length, scanCell);
        if (scanCell.isLeaf()) {
          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);
          addDocs(docsEnum,bits);
          termsEnum.next();//move pointer to avoid potential redundant addDocs() below
        }

        //Decide whether to continue to divide & conquer, or whether it's time to scan through terms beneath this cell.
        // Scanning is a performance optimization trade-off.
        boolean scan = cell.getLevel() >= prefixGridScanLevel;//simple heuristic

        if (!scan) {
          //Divide & conquer
          cells.addAll(0, cell.getSubCells(queryShape));//add to beginning
        } else {
          //Scan through all terms within this cell to see if they are within the queryShape. No seek()s.
          for(BytesRef term = termsEnum.term(); term != null && StringHelper.startsWith(term,cellTerm); term = termsEnum.next()) {
            scanCell = grid.getNode(term.bytes, term.offset, term.length, scanCell);
            int termLevel = scanCell.getLevel();
            if (termLevel > detailLevel)
              continue;
            if (termLevel == detailLevel || scanCell.isLeaf()) {
              //TODO should put more thought into implications of box vs point
              Shape cShape = termLevel == grid.getMaxLevels() ? scanCell.getCenter() : scanCell.getShape();
              if(queryShape.relate(cShape, grid.getSpatialContext()) == SpatialRelation.DISJOINT)
                continue;

              docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);
              addDocs(docsEnum,bits);
            }
          }//term loop
        }
      }
    }//cell loop

    return bits;
  }

