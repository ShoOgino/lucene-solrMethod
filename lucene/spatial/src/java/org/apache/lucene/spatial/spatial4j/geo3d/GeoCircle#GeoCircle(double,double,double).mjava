    public GeoCircle(final double lat, final double lon, final double cutoffAngle)
    {
        super();
        if (lat < -Math.PI * 0.5 || lat > Math.PI * 0.5)
            throw new IllegalArgumentException("Latitude out of bounds");
        if (lon < -Math.PI || lon > Math.PI)
            throw new IllegalArgumentException("Longitude out of bounds");
        if (cutoffAngle <= 0.0 || cutoffAngle > Math.PI)
            throw new IllegalArgumentException("Cutoff angle out of bounds");
        final double sinAngle = Math.sin(cutoffAngle);
        final double cosAngle = Math.cos(cutoffAngle);
        this.center = new GeoPoint(lat,lon);
        this.cutoffNormalDistance = sinAngle;
        // Need the chord distance.  This is just the chord distance: sqrt((1 - cos(angle))^2 + (sin(angle))^2).
        final double xDiff = 1.0 - cosAngle;
        this.cutoffLinearDistance = Math.sqrt(xDiff * xDiff + sinAngle * sinAngle);
        this.cutoffAngle = cutoffAngle;
        this.circlePlane = new SidedPlane(center, center, -cosAngle);
        
        // Compute a point on the circle boundary. 
        if (cutoffAngle == Math.PI)
            this.edgePoints = new GeoPoint[0];
        else {
            // Move from center only in latitude.  Then, if we go past the north pole, adjust the longitude also.
            double newLat = lat + cutoffAngle;
            double newLon = lon;
            if (newLat > Math.PI * 0.5) {
                newLat = Math.PI - newLat;
                newLon += Math.PI;
            }
            while (newLon > Math.PI) {
                newLon -= Math.PI * 2.0;
            }
            final GeoPoint edgePoint = new GeoPoint(newLat,newLon);
            //if (Math.abs(circlePlane.evaluate(edgePoint)) > 1e-10)
            //    throw new RuntimeException("Computed an edge point that does not satisfy circlePlane equation! "+circlePlane.evaluate(edgePoint));
            this.edgePoints = new GeoPoint[]{edgePoint};
        }
    }

