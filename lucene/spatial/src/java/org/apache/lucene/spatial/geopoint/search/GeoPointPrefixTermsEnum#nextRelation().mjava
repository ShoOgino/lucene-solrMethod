  private void nextRelation() {
    double minLon = mortonUnhashLon(currStart);
    double minLat = mortonUnhashLat(currStart);
    double maxLon;
    double maxLat;
    boolean isWithin;
    do {
      maxLon = mortonUnhashLon(currEnd);
      maxLat = mortonUnhashLat(currEnd);

      // within or a boundary
      if ((isWithin = within(minLon, minLat, maxLon, maxLat) == true) || boundary(minLon, minLat, maxLon, maxLat) == true) {
        final int m;
        if (isWithin == false || (m = shift % GeoPointField.PRECISION_STEP) == 0) {
          setNextRange(isWithin == false);
          advanceVariables();
          break;
        } else if (shift < 54) {
          withinOnly = true;
          shift = (short)(shift - m);
          lastWithin = currEnd & ~((1L << shift) - 1);
          setNextRange(false);
          break;
        }
      }

      // within cell but not at a depth factor of PRECISION_STEP
      if (isWithin == true || (relationImpl.cellIntersectsMBR(minLon, minLat, maxLon , maxLat) == true && shift != maxShift)) {
        // descend: currStart need not change since shift handles end of range
        currEnd = currStart | (1L<<--shift) - 1;
      } else {
        advanceVariables();
        minLon = mortonUnhashLon(currStart);
        minLat = mortonUnhashLat(currStart);
      }
    } while(shift < 63);
  }

