  @Test
  public void geohashRecursiveRandom() throws IOException {
    init(12);

    //1. Iterate test with the cluster at some worldly point of interest
    Point[] clusterCenters = new Point[]{ctx.makePoint(-180,0), ctx.makePoint(0,90), ctx.makePoint(0,-90)};
    for (Point clusterCenter : clusterCenters) {
      //2. Iterate on size of cluster (a really small one and a large one)
      String hashCenter = GeohashUtils.encodeLatLon(clusterCenter.getY(), clusterCenter.getX(), maxLength);
      //calculate the number of degrees in the smallest grid box size (use for both lat & lon)
      String smallBox = hashCenter.substring(0,hashCenter.length()-1);//chop off leaf precision
      Rectangle clusterDims = GeohashUtils.decodeBoundary(smallBox,ctx);
      double smallRadius = Math.max(clusterDims.getMaxX()-clusterDims.getMinX(),clusterDims.getMaxY()-clusterDims.getMinY());
      assert smallRadius < 1;
      double largeRadius = 20d;//good large size; don't use >=45 for this test code to work
      double[] radiusDegs = {largeRadius,smallRadius};
      for (double radiusDeg : radiusDegs) {
        //3. Index random points in this cluster circle
        deleteAll();
        List<Point> points = new ArrayList<Point>();
        for(int i = 0; i < 20; i++) {
          //Note that this will not result in randomly distributed points in the
          // circle, they will be concentrated towards the center a little. But
          // it's good enough.
          Point pt = ctx.getDistCalc().pointOnBearing(clusterCenter,
              random().nextDouble() * radiusDeg, random().nextInt() * 360, ctx, null);
          pt = alignGeohash(pt);
          points.add(pt);
          addDocument(newDoc("" + i, pt));
        }
        commit();

        //3. Use some query centers. Each is twice the cluster's radius away.
        for(int ri = 0; ri < 4; ri++) {
          Point queryCenter = ctx.getDistCalc().pointOnBearing(clusterCenter,
              radiusDeg*2, random().nextInt(360), ctx, null);
          queryCenter = alignGeohash(queryCenter);
          //4.1 Query a small box getting nothing
          checkHits(q(queryCenter, radiusDeg - smallRadius/2), 0, null);
          //4.2 Query a large box enclosing the cluster, getting everything
          checkHits(q(queryCenter, radiusDeg*3 + smallRadius/2), points.size(), null);
          //4.3 Query a medium box getting some (calculate the correct solution and verify)
          double queryDist = radiusDeg * 2;

          //Find matching points.  Put into int[] of doc ids which is the same thing as the index into points list.
          int[] ids = new int[points.size()];
          int ids_sz = 0;
          for (int i = 0; i < points.size(); i++) {
            Point point = points.get(i);
            if (ctx.getDistCalc().distance(queryCenter, point) <= queryDist)
              ids[ids_sz++] = i;
          }
          ids = Arrays.copyOf(ids, ids_sz);
          //assert ids_sz > 0 (can't because randomness keeps us from being able to)

          checkHits(q(queryCenter, queryDist), ids.length, ids);
        }

      }//for radiusDeg

    }//for clusterCenter

  }//randomTest()

