  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {
    IndexWriterConfig iwc = newIndexWriterConfig();
    // Else we can get O(N^2) merging:
    int mbd = iwc.getMaxBufferedDocs();
    if (mbd != -1 && mbd < lats.length/100) {
      iwc.setMaxBufferedDocs(lats.length/100);
    }
    Directory dir;
    if (lats.length > 100000) {
      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));
    } else {
      dir = newDirectory();
    }

    Set<Integer> deleted = new HashSet<>();
    // RandomIndexWriter is too slow here:
    IndexWriter w = new IndexWriter(dir, iwc);
    for(int id=0;id<lats.length;id++) {
      Document doc = new Document();
      doc.add(newStringField("id", ""+id, Field.Store.NO));
      doc.add(new NumericDocValuesField("id", id));
      if (Double.isNaN(lats[id]) == false) {
        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);
      }
      w.addDocument(doc);
      if (id > 0 && random().nextInt(100) == 42) {
        int idToDelete = random().nextInt(id);
        w.deleteDocuments(new Term("id", ""+idToDelete));
        deleted.add(idToDelete);
        if (VERBOSE) {
          System.out.println("  delete id=" + idToDelete);
        }
      }
    }

    if (random().nextBoolean()) {
      w.forceMerge(1);
    }
    final IndexReader r = DirectoryReader.open(w);
    w.close();

    // We can't wrap with "exotic" readers because the BKD query must see the BKDDVFormat:
    IndexSearcher s = newSearcher(r, false);

    final int iters = atLeast(75);

    final AtomicBoolean failed = new AtomicBoolean();

    NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, "id");

    for (int iter=0;iter<iters && failed.get() == false;iter++) {

      if (VERBOSE) {
        System.out.println("\n" + Thread.currentThread().getName() + ": TEST: iter=" + iter + " s=" + s);
      }
      Query query;
      VerifyHits verifyHits;

      if (random().nextBoolean()) {
        // Rect: don't allow dateline crossing when testing small:
        final GeoRect rect = randomRect(small, small == false);

        query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);

        verifyHits = new VerifyHits() {
          @Override
          protected boolean shouldMatch(double pointLat, double pointLon) {
            return rectContainsPoint(rect, pointLat, pointLon);
          }
          @Override
          protected void describe(int docID, double lat, double lon) {
          }
        };

      } else if (random().nextBoolean()) {
        // Distance
        final boolean rangeQuery = random().nextBoolean();
        final double centerLat = randomLat(small);
        final double centerLon = randomLon(small);

        double radiusMeters;
        double minRadiusMeters;

        if (small) {
          // Approx 3 degrees lon at the equator:
          radiusMeters = random().nextDouble() * 333000 + 1.0;
        } else {
          // So the query can cover at most 50% of the earth's surface:
          radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;
        }

        // generate a random minimum radius between 1% and 95% the max radius
        minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;

        if (VERBOSE) {
          final DecimalFormat df = new DecimalFormat("#,###.00", DecimalFormatSymbols.getInstance(Locale.ENGLISH));
          System.out.println("  radiusMeters = " + df.format(radiusMeters)
          + ((rangeQuery == true) ? " minRadiusMeters = " + df.format(minRadiusMeters) : ""));
        }

        try {
          if (rangeQuery == true) {
            query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);
          } else {
            query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);
          }
        } catch (IllegalArgumentException e) {
          if (e.getMessage().contains("exceeds maxRadius")) {
            continue;
          }
          throw e;
        }

        verifyHits = new VerifyHits() {
          @Override
          protected boolean shouldMatch(double pointLat, double pointLon) {
            if (rangeQuery == false) {
              return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);
            } else {
              return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);
            }
          }

          @Override
          protected void describe(int docID, double pointLat, double pointLon) {
            double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);
            System.out.println("  docID=" + docID + " centerLat=" + centerLat + " centerLon=" + centerLon
                + " pointLat=" + pointLat + " pointLon=" + pointLon + " distanceMeters=" + distanceMeters
                + " vs" + ((rangeQuery == true) ? " minRadiusMeters=" + minRadiusMeters : "") + " radiusMeters=" + radiusMeters);
          }
        };

        // TODO: get poly query working with dateline crossing too (how?)!
      } else {

        // TODO: poly query can't handle dateline crossing yet:
        final GeoRect bbox = randomRect(small, false);

        // Polygon
        final double[] polyLats;
        final double[] polyLons;
        // TODO: factor this out, maybe if we add Polygon class?
        switch (random().nextInt(3)) {
          case 0:
            // box
            polyLats = new double[5];
            polyLons = new double[5];
            polyLats[0] = bbox.minLat;
            polyLons[0] = bbox.minLon;
            polyLats[1] = bbox.maxLat;
            polyLons[1] = bbox.minLon;
            polyLats[2] = bbox.maxLat;
            polyLons[2] = bbox.maxLon;
            polyLats[3] = bbox.minLat;
            polyLons[3] = bbox.maxLon;
            polyLats[4] = bbox.minLat;
            polyLons[4] = bbox.minLon;
            break;
          case 1:
            // right triangle
            polyLats = new double[4];
            polyLons = new double[4];
            polyLats[0] = bbox.minLat;
            polyLons[0] = bbox.minLon;
            polyLats[1] = bbox.maxLat;
            polyLons[1] = bbox.minLon;
            polyLats[2] = bbox.maxLat;
            polyLons[2] = bbox.maxLon;
            polyLats[3] = bbox.minLat;
            polyLons[3] = bbox.minLon;
            break;
          default:
            // surprise me!
            double[][] res = surpriseMePolygon();
            polyLats = res[0];
            polyLons = res[1];
            break;
        }
        query = newPolygonQuery(FIELD_NAME, polyLats, polyLons);

        verifyHits = new VerifyHits() {
          @Override
          protected boolean shouldMatch(double pointLat, double pointLon) {
            return polygonContainsPoint(polyLats, polyLons, pointLat, pointLon);
          }

          @Override
          protected void describe(int docID, double lat, double lon) {
          }
        };
      }

      if (query != null) {

        if (VERBOSE) {
          System.out.println("  query=" + query);
        }

        verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);
      }
    }

    IOUtils.close(r, dir);
  }

