  @Override
  protected Shape randomIndexedShape() {
    Rectangle world = ctx.getWorldBounds();
    if (random().nextInt(10) == 0) // increased chance of getting one of these
      return world;

    int worldWidth = (int) Math.round(world.getWidth());
    int deltaLeft = nextIntInclusive(worldWidth);
    int deltaRight = nextIntInclusive(worldWidth - deltaLeft);
    int worldHeight = (int) Math.round(world.getHeight());
    int deltaTop = nextIntInclusive(worldHeight);
    int deltaBottom = nextIntInclusive(worldHeight - deltaTop);

    double rectMinX = world.getMinX() + deltaLeft;
    double rectMaxX = world.getMaxX() - deltaRight;
    if (ctx.isGeo()) {
      int shift = 0;
      if ((deltaLeft != 0 || deltaRight != 0)) {
        //if geo & doesn't world-wrap, we shift randomly to potentially cross dateline
        shift = nextIntInclusive(360);
      }
      rectMinX = DistanceUtils.normLonDEG(rectMinX + shift);
      rectMaxX = DistanceUtils.normLonDEG(rectMaxX + shift);
      if (rectMinX == 180 && rectMaxX == 180) {
        // Work-around for https://github.com/spatial4j/spatial4j/issues/85
        rectMinX = -180;
        rectMaxX = -180;
      }
    }
    return ctx.makeRectangle(
        rectMinX,
        rectMaxX,
        world.getMinY() + deltaBottom, world.getMaxY() - deltaTop);
  }

