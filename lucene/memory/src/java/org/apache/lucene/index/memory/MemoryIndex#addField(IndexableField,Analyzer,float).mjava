  /**
   * Adds a lucene {@link IndexableField} to the MemoryIndex using the provided analyzer.
   * Also stores doc values based on {@link IndexableFieldType#docValuesType()} if set.
   *
   * @param field the field to add
   * @param analyzer the analyzer to use for term analysis
   * @param boost a field boost
   * @throws IllegalArgumentException if the field is a DocValues or Point field, as these
   *                                  structures are not supported by MemoryIndex
   */
  public void addField(IndexableField field, Analyzer analyzer, float boost) {
    int offsetGap;
    TokenStream tokenStream;
    int positionIncrementGap;
    if (analyzer != null) {
      offsetGap = analyzer.getOffsetGap(field.name());
      tokenStream = field.tokenStream(analyzer, null);
      positionIncrementGap = analyzer.getPositionIncrementGap(field.name());
    } else {
      offsetGap = 1;
      tokenStream = field.tokenStream(null, null);
      positionIncrementGap = 0;
    }

    DocValuesType docValuesType = field.fieldType().docValuesType();
    Object docValuesValue;
    switch (docValuesType) {
      case NONE:
        docValuesValue = null;
        break;
      case BINARY:
      case SORTED:
      case SORTED_SET:
        docValuesValue = field.binaryValue();
        break;
      case NUMERIC:
      case SORTED_NUMERIC:
        docValuesValue = field.numericValue();
        break;
      default:
        throw new UnsupportedOperationException("unknown doc values type [" + docValuesType + "]");
    }
    BytesRef pointValue = null;
    if (field.fieldType().pointDimensionCount() > 0) {
      pointValue = field.binaryValue();
    }
    addField(field.name(), tokenStream, boost, positionIncrementGap, offsetGap, docValuesType, docValuesValue,
        field.fieldType().pointDimensionCount(), field.fieldType().pointNumBytes(), pointValue);
  }

