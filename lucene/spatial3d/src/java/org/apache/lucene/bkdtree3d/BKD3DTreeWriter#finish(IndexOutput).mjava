  /** Writes the BKD tree to the provided {@link IndexOutput} and returns the file offset where index was written. */
  public long finish(IndexOutput out) throws IOException {
    //System.out.println("\nBKDTreeWriter.finish pointCount=" + pointCount + " out=" + out + " heapWriter=" + heapWriter + " maxPointsInLeafNode=" + maxPointsInLeafNode);

    if (writer != null) {
      writer.close();
    }

    LongBitSet bitSet = new LongBitSet(pointCount);

    long countPerLeaf = pointCount;
    long innerNodeCount = 1;

    while (countPerLeaf > maxPointsInLeafNode) {
      countPerLeaf = (countPerLeaf+1)/2;
      innerNodeCount *= 2;
    }

    //System.out.println("innerNodeCount=" + innerNodeCount + " countPerLeaf=" + countPerLeaf);

    if (1+2*innerNodeCount >= Integer.MAX_VALUE) {
      throw new IllegalStateException("too many nodes; increase maxPointsInLeafNode (currently " + maxPointsInLeafNode + ") and reindex");
    }

    innerNodeCount--;

    int numLeaves = (int) (innerNodeCount+1);
    //System.out.println("  numLeaves=" + numLeaves);

    // Indexed by nodeID, but first (root) nodeID is 1
    int[] splitValues = new int[numLeaves];

    // +1 because leaf count is power of 2 (e.g. 8), and innerNodeCount is power of 2 minus 1 (e.g. 7)
    long[] leafBlockFPs = new long[numLeaves];

    // Make sure the math above "worked":
    assert pointCount / splitValues.length <= maxPointsInLeafNode: "pointCount=" + pointCount + " splitValues.length=" + splitValues.length + " maxPointsInLeafNode=" + maxPointsInLeafNode;
    //System.out.println("  avg pointsPerLeaf=" + (pointCount/splitValues.length));

    // Sort all docs once by x, once by y, once by z:
    Writer xSortedWriter = null;
    Writer ySortedWriter = null;
    Writer zSortedWriter = null;

    boolean success = false;
    try {
      xSortedWriter = sort(0);
      ySortedWriter = sort(1);
      zSortedWriter = sort(2);
      heapWriter = null;

      build(1, numLeaves,
            new PathSlice(xSortedWriter, 0, pointCount),
            new PathSlice(ySortedWriter, 0, pointCount),
            new PathSlice(zSortedWriter, 0, pointCount),
            bitSet, out,
            Integer.MIN_VALUE, Integer.MAX_VALUE,
            Integer.MIN_VALUE, Integer.MAX_VALUE,
            Integer.MIN_VALUE, Integer.MAX_VALUE,
            splitValues,
            leafBlockFPs);
      success = true;
    } finally {
      if (success) {
        xSortedWriter.destroy();
        ySortedWriter.destroy();
        zSortedWriter.destroy();
        IOUtils.rm(tempInput);
      } else {
        try {
          xSortedWriter.destroy();
        } catch (Throwable t) {
          // Suppress to keep throwing original exc
        }
        try {
          ySortedWriter.destroy();
        } catch (Throwable t) {
          // Suppress to keep throwing original exc
        }
        try {
          zSortedWriter.destroy();
        } catch (Throwable t) {
          // Suppress to keep throwing original exc
        }
        IOUtils.deleteFilesIgnoringExceptions(tempInput);
      }
    }

    //System.out.println("Total nodes: " + innerNodeCount);

    // Write index:
    long indexFP = out.getFilePointer();
    //System.out.println("indexFP=" + indexFP);
    out.writeVInt(numLeaves);

    // NOTE: splitValues[0] is unused, because nodeID is 1-based:
    for (int i=0;i<splitValues.length;i++) {
      out.writeInt(splitValues[i]);
    }
    for (int i=0;i<leafBlockFPs.length;i++) {
      out.writeVLong(leafBlockFPs[i]);
    }

    return indexFP;
  }

