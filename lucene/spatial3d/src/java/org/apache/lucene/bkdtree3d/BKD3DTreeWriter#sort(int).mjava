  /** dim: 0=x, 1=y, 2=z */
  private Writer sort(int dim) throws IOException {
    if (heapWriter != null) {

      assert pointCount < Integer.MAX_VALUE;

      // All buffered points are still in heap
      new InPlaceMergeSorter() {
        @Override
        protected void swap(int i, int j) {
          int docID = heapWriter.docIDs[i];
          heapWriter.docIDs[i] = heapWriter.docIDs[j];
          heapWriter.docIDs[j] = docID;

          long ord = heapWriter.ords[i];
          heapWriter.ords[i] = heapWriter.ords[j];
          heapWriter.ords[j] = ord;

          int x = heapWriter.xs[i];
          heapWriter.xs[i] = heapWriter.xs[j];
          heapWriter.xs[j] = x;

          int y = heapWriter.ys[i];
          heapWriter.ys[i] = heapWriter.ys[j];
          heapWriter.ys[j] = y;

          int z = heapWriter.zs[i];
          heapWriter.zs[i] = heapWriter.zs[j];
          heapWriter.zs[j] = z;
        }

        @Override
        protected int compare(int i, int j) {
          int cmp;
          if (dim == 0) {
            cmp = Integer.compare(heapWriter.xs[i], heapWriter.xs[j]);
          } else if (dim == 1) {
            cmp = Integer.compare(heapWriter.ys[i], heapWriter.ys[j]);
          } else {
            cmp = Integer.compare(heapWriter.zs[i], heapWriter.zs[j]);
          }
          if (cmp != 0) {
            return cmp;
          }

          // Tie-break
          cmp = Integer.compare(heapWriter.docIDs[i], heapWriter.docIDs[j]);
          if (cmp != 0) {
            return cmp;
          }

          return Long.compare(heapWriter.ords[i], heapWriter.ords[j]);
        }
      }.sort(0, (int) pointCount);

      HeapWriter sorted = new HeapWriter((int) pointCount);
      //System.out.println("sorted dim=" + dim);
      for(int i=0;i<pointCount;i++) {
        /*
        System.out.println("  docID=" + heapWriter.docIDs[i] + 
                           " x=" + heapWriter.xs[i] +
                           " y=" + heapWriter.ys[i] +
                           " z=" + heapWriter.zs[i]);
        */
        sorted.append(heapWriter.xs[i],
                      heapWriter.ys[i],
                      heapWriter.zs[i],
                      heapWriter.ords[i],
                      heapWriter.docIDs[i]);
      }
      sorted.close();

      return sorted;
    } else {

      // Offline sort:
      assert tempDir != null;

      final ByteArrayDataInput reader = new ByteArrayDataInput();
      Comparator<BytesRef> cmp = new Comparator<BytesRef>() {
        private final ByteArrayDataInput readerB = new ByteArrayDataInput();

        @Override
        public int compare(BytesRef a, BytesRef b) {
          reader.reset(a.bytes, a.offset, a.length);
          final int xa = reader.readInt();
          final int ya = reader.readInt();
          final int za = reader.readInt();
          final int docIDA = reader.readVInt();
          final long ordA = reader.readVLong();

          reader.reset(b.bytes, b.offset, b.length);
          final int xb = reader.readInt();
          final int yb = reader.readInt();
          final int zb = reader.readInt();
          final int docIDB = reader.readVInt();
          final long ordB = reader.readVLong();

          int cmp;
          if (dim == 0) {
            cmp = Integer.compare(xa, xb);
          } else if (dim == 1) {
            cmp = Integer.compare(ya, yb);
          } else {
            cmp = Integer.compare(za, zb);
          }
          if (cmp != 0) {
            return cmp;
          }

          // Tie-break
          cmp = Integer.compare(docIDA, docIDB);
          if (cmp != 0) {
            return cmp;
          }

          return Long.compare(ordA, ordB);
        }
      };

      Path sorted = tempDir.resolve("sorted");
      boolean success = false;
      try {
        OfflineSorter sorter = new OfflineSorter(cmp, OfflineSorter.BufferSize.automatic(), tempDir, OfflineSorter.MAX_TEMPFILES);
        sorter.sort(tempInput, sorted);
        Writer writer = convertToFixedWidth(sorted);
        success = true;
        return writer;
      } finally {
        if (success) {
          IOUtils.rm(sorted);
        } else {
          IOUtils.deleteFilesIgnoringExceptions(sorted);
        }
      }
    }
  }

