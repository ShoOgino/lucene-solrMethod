  /** Marks bits for the ords (points) that belong in the left sub tree. */
  private int markLeftTree(int splitDim, PathSlice source, LongBitSet bitSet,
                           int minX, int maxX,
                           int minY, int maxY,
                           int minZ, int maxZ) throws IOException {

    // This is the size of our left tree
    long leftCount = source.count / 2;

    // Read the split value:
    //if (DEBUG) System.out.println("  leftCount=" + leftCount + " vs " + source.count);
    Reader reader = source.writer.getReader(source.start + leftCount);
    boolean success = false;
    int splitValue;
    try {
      boolean result = reader.next();
      assert result;

      int x = reader.x();
      assert x >= minX && x <= maxX: "x=" + x + " minX=" + minX + " maxX=" + maxX;

      int y = reader.y();
      assert y >= minY && y <= maxY: "y=" + y + " minY=" + minY + " maxY=" + maxY;

      int z = reader.z();
      assert z >= minZ && z <= maxZ: "z=" + z + " minZ=" + minZ + " maxZ=" + maxZ;

      if (splitDim == 0) {
        splitValue = x;
      } else if (splitDim == 1) {
        splitValue = y;
      } else {
        splitValue = z;
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(reader);
      } else {
        IOUtils.closeWhileHandlingException(reader);
      }
    }

    // Mark ords that fall into the left half, and also handle the == boundary case:
    assert bitSet.cardinality() == 0: "cardinality=" + bitSet.cardinality();

    success = false;
    reader = source.writer.getReader(source.start);
    try {
      int lastValue = Integer.MIN_VALUE;
      for (int i=0;i<leftCount;i++) {
        boolean result = reader.next();
        assert result;
        int x = reader.x();
        int y = reader.y();
        int z = reader.z();

        int value;
        if (splitDim == 0) {
          value = x;
        } else if (splitDim == 1) {
          value = y;
        } else {
          value = z;
        }

        // Our input source is supposed to be sorted on the incoming dimension:
        assert value >= lastValue;
        lastValue = value;

        assert value <= splitValue: "i=" + i + " value=" + value + " vs splitValue=" + splitValue;
        long ord = reader.ord();
        int docID = reader.docID();
        assert docID >= 0: "docID=" + docID + " reader=" + reader;

        // We should never see dup ords:
        assert bitSet.get(ord) == false;
        bitSet.set(ord);
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(reader);
      } else {
        IOUtils.closeWhileHandlingException(reader);
      }
    }

    assert leftCount == bitSet.cardinality(): "leftCount=" + leftCount + " cardinality=" + bitSet.cardinality();

    return splitValue;
  }

