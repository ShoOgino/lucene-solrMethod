  private int intersect(QueryState state,
                        int nodeID,
                        int cellXMin, int cellXMax,
                        int cellYMin, int cellYMax,
                        int cellZMin, int cellZMax)
    throws IOException {

    //System.out.println("BKD3D.intersect nodeID=" + nodeID + " cellX=" + cellXMin + " TO " + cellXMax + ", cellY=" + cellYMin + " TO " + cellYMax + ", cellZ=" + cellZMin + " TO " + cellZMax);

    if (cellXMin >= state.xMin ||
        cellXMax <= state.xMax ||
        cellYMin >= state.yMin ||
        cellYMax <= state.yMax ||
        cellZMin >= state.zMin ||
        cellZMax <= state.zMax) {

      // Only call the filter when the current cell does not fully contain the bbox:
      Relation r = state.valueFilter.compare(cellXMin, cellXMax,
                                             cellYMin, cellYMax,
                                             cellZMin, cellZMax);
      //System.out.println("  relation: " + r);

      if (r == Relation.SHAPE_OUTSIDE_CELL) {
        // This cell is fully outside of the query shape: stop recursing
        return 0;
      } else if (r == Relation.CELL_INSIDE_SHAPE) {
        // This cell is fully inside of the query shape: recursively add all points in this cell without filtering
        
        /*
        System.out.println(Thread.currentThread() + ": switch to addAll at cell" +
                           " x=" + Geo3DDocValuesFormat.decodeValue(cellXMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellXMax) +
                           " y=" + Geo3DDocValuesFormat.decodeValue(cellYMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellYMax) +
                           " z=" + Geo3DDocValuesFormat.decodeValue(cellZMin) + " to " + Geo3DDocValuesFormat.decodeValue(cellZMax));
        */
        return addAll(state, nodeID);
      } else {
        // The cell crosses the shape boundary, so we fall through and do full filtering
      }
    } else {
      // The whole point of the incoming bbox (state.xMin/xMax/etc.) is that it is
      // supposed to fully enclose the shape, so this cell we are visiting, which
      // fully contains the query's bbox, better in turn fully contain the shape!
      assert state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax) == Relation.SHAPE_INSIDE_CELL: "got " + state.valueFilter.compare(cellXMin, cellXMax, cellYMin, cellYMax, cellZMin, cellZMax);
    }

    //System.out.println("\nintersect node=" + nodeID + " vs " + leafNodeOffset);

    if (nodeID >= leafNodeOffset) {
      //System.out.println("  leaf");
      // Leaf node; scan and filter all points in this block:
      //System.out.println("    intersect leaf nodeID=" + nodeID + " vs leafNodeOffset=" + leafNodeOffset + " fp=" + leafBlockFPs[nodeID-leafNodeOffset]);
      int hitCount = 0;

      long fp = leafBlockFPs[nodeID-leafNodeOffset];

      /*
      System.out.println("I: " + BKDTreeWriter.decodeLat(cellLatMinEnc)
                         + " " + BKDTreeWriter.decodeLat(cellLatMaxEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMinEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMaxEnc));
      */

      state.in.seek(fp);

      // How many points are stored in this leaf cell:
      int count = state.in.readVInt();

      state.docs.grow(count);
      //System.out.println("  count=" + count);
      for(int i=0;i<count;i++) {
        int docID = state.in.readInt();
        //System.out.println("  check docID=" + docID);
        if (state.valueFilter.accept(docID)) {
          state.docs.add(docID);
          hitCount++;
        }
      }

      return hitCount;

    } else {

      //System.out.println("  non-leaf");

      int splitDim = BKD3DTreeWriter.getSplitDim(cellXMin, cellXMax,
                                                 cellYMin, cellYMax,
                                                 cellZMin, cellZMax);

      int splitValue = splitValues[nodeID];

      int count = 0;

      if (splitDim == 0) {

        //System.out.println("  split on lat=" + splitValue);

        // Inner node split on x:

        // Left node:
        if (state.xMin <= splitValue) {
          //System.out.println("  recurse left");
          count += intersect(state,
                             2*nodeID,
                             cellXMin, splitValue,
                             cellYMin, cellYMax,
                             cellZMin, cellZMax);
        }

        // Right node:
        if (state.xMax >= splitValue) {
          //System.out.println("  recurse right");
          count += intersect(state,
                             2*nodeID+1,
                             splitValue, cellXMax,
                             cellYMin, cellYMax,
                             cellZMin, cellZMax);
        }

      } else if (splitDim == 1) {
        // Inner node split on y:

        // System.out.println("  split on lon=" + splitValue);

        // Left node:
        if (state.yMin <= splitValue) {
          // System.out.println("  recurse left");
          count += intersect(state,
                             2*nodeID,
                             cellXMin, cellXMax,
                             cellYMin, splitValue,
                             cellZMin, cellZMax);
        }

        // Right node:
        if (state.yMax >= splitValue) {
          // System.out.println("  recurse right");
          count += intersect(state,
                             2*nodeID+1,
                             cellXMin, cellXMax,
                             splitValue, cellYMax,
                             cellZMin, cellZMax);
        }
      } else {
        // Inner node split on z:

        // System.out.println("  split on lon=" + splitValue);

        // Left node:
        if (state.zMin <= splitValue) {
          // System.out.println("  recurse left");
          count += intersect(state,
                             2*nodeID,
                             cellXMin, cellXMax,
                             cellYMin, cellYMax,
                             cellZMin, splitValue);
        }

        // Right node:
        if (state.zMax >= splitValue) {
          // System.out.println("  recurse right");
          count += intersect(state,
                             2*nodeID+1,
                             cellXMin, cellXMax,
                             cellYMin, cellYMax,
                             splitValue, cellZMax);
        }
      }

      return count;
    }
  }

