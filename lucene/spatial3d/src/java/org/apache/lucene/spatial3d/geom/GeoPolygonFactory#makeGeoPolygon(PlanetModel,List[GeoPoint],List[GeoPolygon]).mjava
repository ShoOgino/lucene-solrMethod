  /** Create a GeoPolygon using the specified points and holes, using order to determine 
   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space
   * on the same side of the shape as being inside, and counter-clockwise to indicate the
   * space on the opposite side as being inside.
   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go
   *  clockwise from a given pole, then that pole should be within the polygon.  If points go
   *  counter-clockwise, then that pole should be outside the polygon.
   * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.
   * @return a GeoPolygon corresponding to what was specified.
   */
  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,
    final List<GeoPoint> pointList,
    final List<GeoPolygon> holes) {
    //System.err.println("points="+pointList);
    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence
    // of points to use for poles.
    final Random generator = new Random(1234);
    for (int counter = 0; counter < 10000; counter++) {
      //counter++;
      // Pick the next random pole
      final GeoPoint pole = pickPole(generator, planetModel, pointList);
      // Is it inside or outside?
      final Boolean isPoleInside = isInsidePolygon(pole, pointList);
      if (isPoleInside != null) {
        // Legal pole
        //System.out.println("Took "+counter+" iterations to find pole");
        //System.out.println("Pole = "+pole+"; isInside="+isPoleInside+"; pointList = "+pointList);
        return makeGeoPolygon(planetModel, pointList, holes, pole, isPoleInside);
      }
      // If pole choice was illegal, try another one
    }
    throw new IllegalArgumentException("cannot find a point that is inside the polygon");
  }

