    /** Traverse the tree, finding all edges that intersect the provided value.
     * @param edgeIterator provides the method to call for any encountered matching edge.
     * @param value is the value to match.
     * @return false if the traversal was aborted before completion.
     */
    public boolean traverse(final EdgeIterator edgeIterator, final double value) {
      //System.err.println("Traversing tree, value = "+value);
      // Since there is one distinct value we are looking for, we can just do a straight descent through the nodes.
      Node currentNode = rootNode;
      while (currentNode != null) {
        if (value < currentNode.minimumValue) {
          //System.err.println(" value is less than "+currentNode.minimumValue);
          currentNode = currentNode.lesser;
        } else if (value > currentNode.maximumValue) {
          //System.err.println(" value is greater than "+currentNode.maximumValue);
          currentNode = currentNode.greater;
        } else {
          //System.err.println(" value within "+currentNode.minimumValue+" to "+currentNode.maximumValue);
          // We're within the bounds of the node.  Call the iterator, and descend
          if (!edgeIterator.matches(currentNode.edge)) {
            return false;
          }
          currentNode = currentNode.within;
        }
      }
      //System.err.println("Done with tree");
      return true;
    }

