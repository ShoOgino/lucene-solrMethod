  /** Create a GeoPolygon using the specified points and holes, using order to determine 
   * siding of the polygon.  Much like ESRI, this method uses clockwise to indicate the space
   * on the same side of the shape as being inside, and counter-clockwise to indicate the
   * space on the opposite side as being inside.
   * @param pointList is a list of the GeoPoints to build an arbitrary polygon out of.  If points go
   *  clockwise from a given pole, then that pole should be within the polygon.  If points go
   *  counter-clockwise, then that pole should be outside the polygon.
   * @param holes is a list of polygons representing "holes" in the outside polygon.  Null == none.
   * @param leniencyValue is the maximum distance (in units) that a point can be from the plane and still be considered as
   *  belonging to the plane.  Any value greater than zero may cause some of the provided points that are in fact outside
   *  the strict definition of co-planarity, but are within this distance, to be discarded for the purposes of creating a
   *  "safe" polygon.
   * @return a GeoPolygon corresponding to what was specified, or null if a valid polygon cannot be generated
   *  from this input.
   */
  public static GeoPolygon makeGeoPolygon(final PlanetModel planetModel,
    final List<GeoPoint> pointList,
    final List<GeoPolygon> holes,
    final double leniencyValue) {
    // First, exercise a sanity filter on the provided pointList, and remove identical points, linear points, and backtracks
    //System.err.println(" filtering "+pointList.size()+" points...");
    //final long startTime = System.currentTimeMillis();
    final List<GeoPoint> filteredPointList = filterEdges(filterPoints(pointList), leniencyValue);
    //System.err.println("  ...done in "+(System.currentTimeMillis()-startTime)+"ms ("+((filteredPointList==null)?"degenerate":(filteredPointList.size()+" points"))+")");
    if (filteredPointList == null) {
      return null;
    }
    //System.err.println("points="+pointList);
    // Create a random number generator.  Effectively this furnishes us with a repeatable sequence
    // of points to use for poles.
    final Random generator = new Random(1234);
    for (int counter = 0; counter < 1000000; counter++) {
      //counter++;
      // Pick the next random pole
      final GeoPoint pole = pickPole(generator, planetModel, filteredPointList);
      // Is it inside or outside?
      final Boolean isPoleInside = isInsidePolygon(pole, filteredPointList);
      if (isPoleInside != null) {
        // Legal pole
        //System.out.println("Took "+counter+" iterations to find pole");
        //System.out.println("Pole = "+pole+"; isInside="+isPoleInside+"; pointList = "+pointList);
        return generateGeoPolygon(planetModel, filteredPointList, holes, pole, isPoleInside);
      }
      // If pole choice was illegal, try another one
    }
    throw new IllegalArgumentException("cannot find a point that is inside the polygon "+filteredPointList);
  }

