    /** Constructor for case (3).
     * Generate an endpoint for an intersection, given four points.
     *@param point is the center.
     *@param prevCutoffPlane is the previous adjoining segment cutoff plane.
     *@param nextCutoffPlane is the next path segment cutoff plane.
     *@param notCand2Point is a point NOT on candidate2.
     *@param notCand1Point is a point NOT on candidate1.
     *@param notCand3Point is a point NOT on candidate3.
     *@param notCand4Point is a point NOT on candidate4.
     *@param candidate1 one of four candidate circle planes.
     *@param candidate2 one of four candidate circle planes.
     *@param candidate3 one of four candidate circle planes.
     *@param candidate4 one of four candidate circle planes.
     */
    public CutoffDualCircleSegmentEndpoint(final GeoPoint point,
      final SidedPlane prevCutoffPlane, final SidedPlane nextCutoffPlane,
      final GeoPoint notCand2Point, final GeoPoint notCand1Point,
      final GeoPoint notCand3Point, final GeoPoint notCand4Point,
      final SidedPlane candidate1, final SidedPlane candidate2, final SidedPlane candidate3, final SidedPlane candidate4) {
      // Note: What we really need is a single plane that goes through all four points.
      // Since that's not possible in the ellipsoid case (because three points determine a plane, not four), we
      // need an approximation that at least creates a boundary that has no interruptions.
      // There are three obvious choices for the third point: either (a) one of the two remaining points, or (b) the top or bottom edge
      // intersection point.  (a) has no guarantee of continuity, while (b) is capable of producing something very far from a circle if
      // the angle between segments is acute.
      // The solution is to look for the side (top or bottom) that has an intersection within the shape.  We use the two points from
      // the opposite side to determine the plane, AND we pick the third to be either of the two points on the intersecting side
      // PROVIDED that the other point is within the final circle we come up with.
      super(point);

      // We construct four separate planes, and evaluate which one includes all interior points with least overlap
      // (Constructed beforehand because we need them for degeneracy check)

      final boolean cand1IsOtherWithin = candidate1!=null?candidate1.isWithin(notCand1Point):false;
      final boolean cand2IsOtherWithin = candidate2!=null?candidate2.isWithin(notCand2Point):false;
      final boolean cand3IsOtherWithin = candidate3!=null?candidate3.isWithin(notCand3Point):false;
      final boolean cand4IsOtherWithin = candidate4!=null?candidate4.isWithin(notCand4Point):false;
      
      if (cand1IsOtherWithin && cand2IsOtherWithin && cand3IsOtherWithin && cand4IsOtherWithin) {
        // The only way we should see both within is if all four points are coplanar.  In that case, we default to the simplest treatment.
        this.circlePlane = candidate1;  // doesn't matter which
        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand1Point, notCand4Point};
        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane), new SidedPlane(nextCutoffPlane)};
      } else if (cand1IsOtherWithin) {
        // Use candidate1, and DON'T include prevCutoffPlane in the cutoff planes list
        this.circlePlane = candidate1;
        this.notablePoints = new GeoPoint[]{notCand2Point, notCand3Point, notCand4Point};
        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};
      } else if (cand2IsOtherWithin) {
        // Use candidate2
        this.circlePlane = candidate2;
        this.notablePoints = new GeoPoint[]{notCand3Point, notCand4Point, notCand1Point};
        this.cutoffPlanes = new Membership[]{new SidedPlane(nextCutoffPlane)};
      } else if (cand3IsOtherWithin) {
        circlePlane = candidate3;
        this.notablePoints = new GeoPoint[]{notCand4Point, notCand1Point, notCand2Point};
        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};
      } else if (cand4IsOtherWithin) {
        this.circlePlane = candidate4;
        this.notablePoints = new GeoPoint[]{notCand1Point, notCand2Point, notCand3Point};
        this.cutoffPlanes = new Membership[]{new SidedPlane(prevCutoffPlane)};
      } else {
        // dunno what happened
        throw new RuntimeException("Couldn't come up with a plane through three points that included the fourth");
      }
    }

