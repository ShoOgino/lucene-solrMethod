    @Override
    public boolean matches(final Edge edge) {
      // Early exit if the point is on the edge.
      if (edge.plane.evaluateIsZero(thePointX, thePointY, thePointZ) && edge.startPlane.isWithin(thePointX, thePointY, thePointZ) && edge.endPlane.isWithin(thePointX, thePointY, thePointZ)) {
        return false;
      }
      
      // This should precisely mirror what is in DualCrossingIterator, but without the dual crossings.
      // Some edges are going to be given to us even when there's no real intersection, so do that as a sanity check, first.
      final GeoPoint[] planeCrossings = plane.findIntersections(planetModel, edge.plane, bound, edge.startPlane, edge.endPlane);
      if (planeCrossings != null && planeCrossings.length == 0) {
        // Sometimes on the hairy edge an intersection will be missed.  This check finds those.
        if (!plane.evaluateIsZero(edge.startPoint) && !plane.evaluateIsZero(edge.endPoint)) {
          return true;
        }
      }
      
      // Determine crossings of this edge against all inside/outside planes.  There's no further need to look at the actual travel plane itself.
      final GeoPoint[] aboveCrossings = computeCrossings(abovePlane, edge, bound);
      final GeoPoint[] belowCrossings = computeCrossings(belowPlane, edge, bound);
      
      if (aboveCrossings != null) {
        aboveCrossingCount += aboveCrossings.length;
      }
      if (belowCrossings != null) {
        belowCrossingCount += belowCrossings.length;
      }

      return true;
    }

