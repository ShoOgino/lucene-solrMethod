  /** Filter coplanar points.
   * @param noIdenticalPoints with input list of points
   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons
   * @return the filtered list, or null if we can't get a legit polygon from the input.
   */
  static List<GeoPoint> filterEdges(final List<GeoPoint> noIdenticalPoints, final double leniencyValue) {
  
    // Now, do the depth-first search needed to find a path that has no coplanarities in it.
    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.
    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.
    // But we have to produce a polygon that is safe no matter which way it is looked at.
    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.
    // This algorithmically awful in the worst case, but luckily we can presume that real-life data
    // does not require more than a couple of iterations.
    
    for  (int i = 0; i < noIdenticalPoints.size(); i++) {
      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);
      // Search, with this as the start path.
      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);
      if (resultPath != null && resultPath.previous != null) {
        // Read out result, maintaining ordering
        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());
        resultPath.fillInList(rval);
        return rval;
      }
    }
    // No path found.  This means that everything was coplanar.
    return null;
  }

