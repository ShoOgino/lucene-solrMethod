  @Override
  public boolean isWithin(final Vector thePoint) {
    // If we're right on top of the point, we know the answer.
    if (testPoint.isNumericallyIdentical(thePoint)) {
      return testPointInSet;
    }
    
    // If we're right on top of any of the test planes, we navigate solely on that plane.
    if (testPointFixedYPlane.evaluateIsZero(thePoint)) {
      // Use the XZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointFixedXPlane.evaluateIsZero(thePoint)) {
      // Use the YZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointFixedZPlane.evaluateIsZero(thePoint)) {
      // Use the XY plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else {
      
      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);
      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);
      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);

      // Find the intersection points for each one of these and the complementary test point planes.
      final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);
      final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);
      final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);
      final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);
      final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);
      final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);

      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
      double bestDistance = Double.MAX_VALUE;
      double firstLegValue = 0.0;
      double secondLegValue = 0.0;
      Plane firstLegPlane = null;
      Plane firstLegAbovePlane = null;
      Plane firstLegBelowPlane = null;
      Plane secondLegPlane = null;
      Tree firstLegTree = null;
      Tree secondLegTree = null;
      GeoPoint intersectionPoint = null;
      
      for (final GeoPoint p : XIntersectionsY) {
        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.y;
          secondLegValue = thePoint.x;
          firstLegPlane = testPointFixedYPlane;
          firstLegAbovePlane = testPointFixedYAbovePlane;
          firstLegBelowPlane = testPointFixedYBelowPlane;
          secondLegPlane = travelPlaneFixedX;
          firstLegTree = yTree;
          secondLegTree = xTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : XIntersectionsZ) {
        // Travel would be in YZ plane (fixed x) then in XY (fixed z)
        final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.z;
          secondLegValue = thePoint.x;
          firstLegPlane = testPointFixedZPlane;
          firstLegAbovePlane = testPointFixedZAbovePlane;
          firstLegBelowPlane = testPointFixedZBelowPlane;
          secondLegPlane = travelPlaneFixedX;
          firstLegTree = zTree;
          secondLegTree = xTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : YIntersectionsX) {
        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.x;
          secondLegValue = thePoint.y;
          firstLegPlane = testPointFixedXPlane;
          firstLegAbovePlane = testPointFixedXAbovePlane;
          firstLegBelowPlane = testPointFixedXBelowPlane;
          secondLegPlane = travelPlaneFixedY;
          firstLegTree = xTree;
          secondLegTree = yTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : YIntersectionsZ) {
        // Travel would be in XZ plane (fixed y) then in XY (fixed z)
        final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.z;
          secondLegValue = thePoint.y;
          firstLegPlane = testPointFixedZPlane;
          firstLegAbovePlane = testPointFixedZAbovePlane;
          firstLegBelowPlane = testPointFixedZBelowPlane;
          secondLegPlane = travelPlaneFixedY;
          firstLegTree = zTree;
          secondLegTree = yTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : ZIntersectionsX) {
        // Travel would be in XY plane (fixed z) then in YZ (fixed x)
        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.x;
          secondLegValue = thePoint.z;
          firstLegPlane = testPointFixedXPlane;
          firstLegAbovePlane = testPointFixedXAbovePlane;
          firstLegBelowPlane = testPointFixedXBelowPlane;
          secondLegPlane = travelPlaneFixedZ;
          firstLegTree = xTree;
          secondLegTree = zTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : ZIntersectionsY) {
        // Travel would be in XY plane (fixed z) then in XZ (fixed y)
        final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.y;
          secondLegValue = thePoint.z;
          firstLegPlane = testPointFixedYPlane;
          firstLegAbovePlane = testPointFixedYAbovePlane;
          firstLegBelowPlane = testPointFixedYBelowPlane;
          secondLegPlane = travelPlaneFixedZ;
          firstLegTree = yTree;
          secondLegTree = zTree;
          intersectionPoint = p;
        }
      }

      assert bestDistance > 0.0 : "Best distance should not be zero unless on single plane";
      assert bestDistance < Double.MAX_VALUE : "Couldn't find an intersection point of any kind";
      
      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);
      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {
        return true;
      }
      edgeIterator.setSecondLeg();
      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {
        return true;
      }
      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;

    }
  }

