  @Override
  public boolean isWithin(final Vector thePoint) {
    // If we're right on top of the point, we know the answer.
    if (testPoint.isNumericallyIdentical(thePoint)) {
      return testPointInSet;
    }
    
    // If we're right on top of any of the test planes, we navigate solely on that plane.
    if (testPointXZPlane.evaluateIsZero(thePoint)) {
      // Use the XZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {
      // Use the YZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {
      // Use the XY plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else {
      
      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -thePoint.x);
      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -thePoint.y);
      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -thePoint.z);

      // Find the intersection points for each one of these and the complementary test point planes.
      final GeoPoint[] XZIntersectionsYZ = travelPlaneFixedX.findIntersections(planetModel, testPointYZPlane);
      final GeoPoint[] XZIntersectionsXY = travelPlaneFixedX.findIntersections(planetModel, testPointXYPlane);
      final GeoPoint[] YZIntersectionsXZ = travelPlaneFixedY.findIntersections(planetModel, testPointXZPlane);
      final GeoPoint[] YZIntersectionsXY = travelPlaneFixedY.findIntersections(planetModel, testPointXYPlane);
      final GeoPoint[] XYIntersectionsYZ = travelPlaneFixedZ.findIntersections(planetModel, testPointYZPlane);
      final GeoPoint[] XYIntersectionsXZ = travelPlaneFixedZ.findIntersections(planetModel, testPointXZPlane);

      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
      double bestDistance = Double.MAX_VALUE;
      double firstLegValue = 0.0;
      double secondLegValue = 0.0;
      Plane firstLegPlane = null;
      Plane firstLegAbovePlane = null;
      Plane firstLegBelowPlane = null;
      Plane secondLegPlane = null;
      Tree firstLegTree = null;
      Tree secondLegTree = null;
      GeoPoint intersectionPoint = null;
      
      for (final GeoPoint p : XZIntersectionsYZ) {
        // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.y - p.y);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.y;
          secondLegValue = thePoint.x;
          firstLegPlane = testPointYZPlane;
          firstLegAbovePlane = testPointYZAbovePlane;
          firstLegBelowPlane = testPointYZBelowPlane;
          secondLegPlane = travelPlaneFixedX;
          firstLegTree = xTree;
          secondLegTree = yTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : XZIntersectionsXY) {
        // Travel would be in XZ plane (fixed y) then in XY (fixed z)
        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.y - p.y);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.y;
          secondLegValue = thePoint.z;
          firstLegPlane = testPointXYPlane;
          firstLegAbovePlane = testPointXYAbovePlane;
          firstLegBelowPlane = testPointXYBelowPlane;
          secondLegPlane = travelPlaneFixedX;
          firstLegTree = yTree;
          secondLegTree = zTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : YZIntersectionsXZ) {
        // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.x - p.x);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.x;
          secondLegValue = thePoint.y;
          firstLegPlane = testPointXZPlane;
          firstLegAbovePlane = testPointXZAbovePlane;
          firstLegBelowPlane = testPointXZBelowPlane;
          secondLegPlane = travelPlaneFixedY;
          firstLegTree = xTree;
          secondLegTree = yTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : YZIntersectionsXY) {
        // Travel would be in YZ plane (fixed x) then in XY (fixed z)
        final double newDistance = Math.abs(thePoint.z - p.z) + Math.abs(testPoint.x - p.x);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.x;
          secondLegValue = thePoint.z;
          firstLegPlane = testPointXYPlane;
          firstLegAbovePlane = testPointXYAbovePlane;
          firstLegBelowPlane = testPointXYBelowPlane;
          secondLegPlane = travelPlaneFixedX;
          firstLegTree = xTree;
          secondLegTree = zTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : XYIntersectionsYZ) {
        // Travel would be in XY plane (fixed z) then in YZ (fixed x)
        final double newDistance = Math.abs(thePoint.x - p.x) + Math.abs(testPoint.z - p.z);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.z;
          secondLegValue = thePoint.x;
          firstLegPlane = testPointYZPlane;
          firstLegAbovePlane = testPointYZAbovePlane;
          firstLegBelowPlane = testPointYZBelowPlane;
          secondLegPlane = travelPlaneFixedZ;
          firstLegTree = zTree;
          secondLegTree = xTree;
          intersectionPoint = p;
        }
      }
      for (final GeoPoint p : XYIntersectionsXZ) {
        // Travel would be in XY plane (fixed z) then in XZ (fixed y)
        final double newDistance = Math.abs(thePoint.y - p.y) + Math.abs(testPoint.z - p.z);
        if (newDistance < bestDistance) {
          bestDistance = newDistance;
          firstLegValue = testPoint.z;
          secondLegValue = thePoint.y;
          firstLegPlane = testPointXZPlane;
          firstLegAbovePlane = testPointXZAbovePlane;
          firstLegBelowPlane = testPointXZBelowPlane;
          secondLegPlane = travelPlaneFixedZ;
          firstLegTree = zTree;
          secondLegTree = yTree;
          intersectionPoint = p;
        }
      }

      assert bestDistance < Double.MAX_VALUE : "Couldn't find an intersection point of any kind";
      
      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, testPoint, thePoint, intersectionPoint);
      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {
        return true;
      }
      edgeIterator.setSecondLeg();
      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {
        return true;
      }
      return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;

    }
  }

