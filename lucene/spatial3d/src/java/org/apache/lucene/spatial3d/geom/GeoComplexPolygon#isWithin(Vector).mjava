  @Override
  public boolean isWithin(final Vector thePoint) {
    // If we're right on top of the point, we know the answer.
    if (testPoint.isNumericallyIdentical(thePoint)) {
      return testPointInSet;
    }
    
    // Choose our navigation route!
    final double xDelta = Math.abs(thePoint.x - testPoint.x);
    final double yDelta = Math.abs(thePoint.y - testPoint.y);
    final double zDelta = Math.abs(thePoint.z - testPoint.z);
    
    // If we're right on top of any of the test planes, we navigate solely on that plane.
    if (testPointXZPlane.evaluateIsZero(thePoint)) {
      // Use the XZ plane exclusively.
      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXZPlane, testPoint);
      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXZPlane, thePoint);
      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);
      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {
      // Use the YZ plane exclusively.
      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointYZPlane, testPoint);
      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointYZPlane, thePoint);
      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoff, checkPointCutoff, thePoint);
      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {
      // Use the XY plane exclusively.
      final SidedPlane testPointCutoff =  new SidedPlane(thePoint, testPointXYPlane, testPoint);
      final SidedPlane checkPointCutoff = new SidedPlane(testPoint, testPointXYPlane, thePoint);
      final CrossingEdgeIterator crossingEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoff, checkPointCutoff, thePoint);
      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else {
      
      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.
      // The best to pick are the ones with the shortest overall distance.
      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {
        // Travel in X and Y
        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.
        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);
        final Plane travelAbovePlane = new Plane(travelPlane, true);
        final Plane travelBelowPlane = new Plane(travelPlane, false);
        // We need cutoff planes for both legs.
        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointYZPlane, testPoint);
        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);
        // Now, find the intersection of the check and test point planes.
        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointYZPlane, testPointCutoffPlane, checkPointCutoffPlane);
        assert intersectionPoints != null : "couldn't find any intersections";
        assert intersectionPoints.length != 1 : "wrong number of intersection points";
        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointYZPlane, intersectionPoints[0]);
        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);
        // Note: we need to handle the cases where end point of the leg sits on an edge!
        // MHL
        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);
        xTree.traverse(testPointEdgeIterator, testPoint.x, testPoint.x);
        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);
        if (!yTree.traverse(checkPointEdgeIterator, thePoint.y, thePoint.y)) {
          // Endpoint is on edge
          return true;
        }
        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;
      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {
        // Travel in X and Z
        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.
        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);
        final Plane travelAbovePlane = new Plane(travelPlane, true);
        final Plane travelBelowPlane = new Plane(travelPlane, false);
        // We need cutoff planes for both legs.
        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXYPlane, testPoint);
        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);
        // Now, find the intersection of the check and test point planes.
        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXYPlane, testPointCutoffPlane, checkPointCutoffPlane);
        assert intersectionPoints != null : "couldn't find any intersections";
        assert intersectionPoints.length != 1 : "wrong number of intersection points";
        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXYPlane, intersectionPoints[0]);
        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);
        // Note: we need to handle the cases where end point of the leg sits on an edge!
        // MHL
        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);
        zTree.traverse(testPointEdgeIterator, testPoint.z, testPoint.z);
        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);
        if (!xTree.traverse(checkPointEdgeIterator, thePoint.x, thePoint.x)) {
          // Endpoint is on edge
          return true;
        }
        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;
      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {
        // Travel in Y and Z
        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.
        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);
        final Plane travelAbovePlane = new Plane(travelPlane, true);
        final Plane travelBelowPlane = new Plane(travelPlane, false);
        // We need cutoff planes for both legs.
        final SidedPlane testPointCutoffPlane = new SidedPlane(thePoint, testPointXZPlane, testPoint);
        final SidedPlane checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);
        // Now, find the intersection of the check and test point planes.
        final GeoPoint[] intersectionPoints = travelPlane.findIntersections(planetModel, testPointXZPlane, testPointCutoffPlane, checkPointCutoffPlane);
        assert intersectionPoints != null : "couldn't find any intersections";
        assert intersectionPoints.length != 1 : "wrong number of intersection points";
        final SidedPlane testPointOtherCutoffPlane = new SidedPlane(testPoint, testPointXZPlane, intersectionPoints[0]);
        final SidedPlane checkPointOtherCutoffPlane = new SidedPlane(thePoint, travelPlane, intersectionPoints[0]);
        // Note: we need to handle the cases where end point of the first leg sits on an edge!
        // MHL
        final CrossingEdgeIterator testPointEdgeIterator = new CrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, null);
        yTree.traverse(testPointEdgeIterator, testPoint.y, testPoint.y);
        final CrossingEdgeIterator checkPointEdgeIterator = new CrossingEdgeIterator(travelPlane, travelAbovePlane, travelBelowPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane, thePoint);
        if (!zTree.traverse(checkPointEdgeIterator, thePoint.z, thePoint.z)) {
          // Endpoint is on edge
          return true;
        }
        return (((testPointEdgeIterator.crossingCount + checkPointEdgeIterator.crossingCount) & 1) == 0)?testPointInSet:!testPointInSet;
      }
    }
    return false;
  }

