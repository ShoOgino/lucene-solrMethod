  @Override
  public boolean isWithin(final Vector thePoint) {
    // If we're right on top of the point, we know the answer.
    if (testPoint.isNumericallyIdentical(thePoint)) {
      return testPointInSet;
    }
    
    // Choose our navigation route!
    final double xDelta = Math.abs(thePoint.x - testPoint.x);
    final double yDelta = Math.abs(thePoint.y - testPoint.y);
    final double zDelta = Math.abs(thePoint.z - testPoint.z);
    
    // If we're right on top of any of the test planes, we navigate solely on that plane.
    if (testPointXZPlane.evaluateIsZero(thePoint)) {
      // Use the XZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
      if (!yTree.traverse(crossingEdgeIterator, testPoint.y, testPoint.y)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointYZPlane.evaluateIsZero(thePoint)) {
      // Use the YZ plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
      if (!xTree.traverse(crossingEdgeIterator, testPoint.x, testPoint.x)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointXYPlane.evaluateIsZero(thePoint)) {
      // Use the XY plane exclusively.
      final LinearCrossingEdgeIterator crossingEdgeIterator = new LinearCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, testPoint, thePoint);
      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
      if (!zTree.traverse(crossingEdgeIterator, testPoint.z, testPoint.z)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
    } else {
      
      // We need to use two planes to get there.  We can use any two planes, and order doesn't matter.
      // The best to pick are the ones with the shortest overall distance.
      if (xDelta + yDelta <= xDelta + zDelta && xDelta + yDelta <= yDelta + zDelta) {
        // Travel in X and Y
        // We'll do this using the testPointYZPlane, and create a travel plane for the right XZ plane.
        final Plane travelPlane = new Plane(0.0, 1.0, 0.0, -thePoint.y);
        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointYZPlane, testPointYZAbovePlane, testPointYZBelowPlane, travelPlane, testPoint, thePoint);
        if (!xTree.traverse(edgeIterator, testPoint.x, testPoint.x)) {
          return true;
        }
        edgeIterator.setSecondLeg();
        if (!yTree.traverse(edgeIterator, thePoint.y, thePoint.y)) {
          return true;
        }
        return ((edgeIterator.crossingCount  & 1) == 0)?testPointInSet:!testPointInSet;
      } else if (xDelta + zDelta <= xDelta + yDelta && xDelta + zDelta <= zDelta + yDelta) {
        // Travel in X and Z
        // We'll do this using the testPointXYPlane, and create a travel plane for the right YZ plane.
        final Plane travelPlane = new Plane(1.0, 0.0, 0.0, -thePoint.x);
        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXYPlane, testPointXYAbovePlane, testPointXYBelowPlane, travelPlane, testPoint, thePoint);
        if (!zTree.traverse(edgeIterator, testPoint.z, testPoint.z)) {
          return true;
        }
        edgeIterator.setSecondLeg();
        if (!xTree.traverse(edgeIterator, thePoint.x, thePoint.x)) {
          return true;
        }
        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
      } else if (yDelta + zDelta <= xDelta + yDelta && yDelta + zDelta <= xDelta + zDelta) {
        // Travel in Y and Z
        // We'll do this using the testPointXZPlane, and create a travel plane for the right XY plane.
        final Plane travelPlane = new Plane(0.0, 0.0, 1.0, -thePoint.z);
        final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(testPointXZPlane, testPointXZAbovePlane, testPointXZBelowPlane, travelPlane, testPoint, thePoint);
        if (!yTree.traverse(edgeIterator, testPoint.y, testPoint.y)) {
          return true;
        }
        edgeIterator.setSecondLeg();
        if (!zTree.traverse(edgeIterator, thePoint.z, thePoint.z)) {
          return true;
        }
        return ((edgeIterator.crossingCount & 1) == 0)?testPointInSet:!testPointInSet;
      }
    }
    return false;
  }

