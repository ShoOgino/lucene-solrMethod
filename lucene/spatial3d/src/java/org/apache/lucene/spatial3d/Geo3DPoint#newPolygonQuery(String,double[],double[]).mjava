  /** 
   * Create a query for matching a polygon.
   * <p>
   * The supplied {@code polyLatitudes}/{@code polyLongitudes} must be clockwise or counter-clockwise.
   * @param field field name. must not be null.
   * @param polyLatitudes latitude values for points of the polygon: must be within standard +/-90 coordinate bounds.
   * @param polyLongitudes longitude values for points of the polygon: must be within standard +/-180 coordinate bounds.
   * @return query matching points within this polygon
   */
  public static Query newPolygonQuery(final String field, final double[] polyLatitudes, final double[] polyLongitudes) {
    if (polyLatitudes.length != polyLongitudes.length) {
      throw new IllegalArgumentException("same number of latitudes and longitudes required");
    }
    if (polyLatitudes.length < 4) {
      throw new IllegalArgumentException("need three or more points");
    }
    if (polyLatitudes[0] != polyLatitudes[polyLatitudes.length-1] || polyLongitudes[0] != polyLongitudes[polyLongitudes.length-1]) {
      throw new IllegalArgumentException("last point must equal first point");
    }
    
    final List<GeoPoint> polyPoints = new ArrayList<>(polyLatitudes.length-1);
    for (int i = 0; i < polyLatitudes.length-1; i++) {
      final double latitude = polyLatitudes[i];
      final double longitude = polyLongitudes[i];
      checkLatitude(latitude);
      checkLongitude(longitude);
      polyPoints.add(new GeoPoint(PlanetModel.WGS84, fromDegrees(latitude), fromDegrees(longitude)));
    }
    // We don't know what the sense of the polygon is without providing the index of one vertex we know to be convex.
    // Since that doesn't fit with the "super-simple API" requirements, we just use the index of the first one, and people have to just
    // know to do it that way.
    final int convexPointIndex = 0;
    final GeoShape shape = GeoPolygonFactory.makeGeoPolygon(PlanetModel.WGS84, polyPoints, convexPointIndex);
    return newShapeQuery(field, shape);
  }

