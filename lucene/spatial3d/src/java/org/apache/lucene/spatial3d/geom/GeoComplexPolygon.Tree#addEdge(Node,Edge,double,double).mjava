    /** Worker method for adding an edge.
     * @param node is the node to add into.
     * @param newEdge is the new edge to add.
     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.
     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.
     * @return the updated node reference.
     */
    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {
      if (node == null) {
        // Create and return a new node
        final Node rval = new Node(newEdge, minimumValue, maximumValue);
        //System.err.println("Creating new node "+rval+" for edge "+newEdge+" in tree "+this);
        return rval;
      }
      //System.err.println("Adding edge "+newEdge+" into node "+node+" in tree "+this);
      // Compare with what's here
      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);
      switch (result) {
      case CONTAINED:
       {
          final double lesserMaximum = Math.nextDown(node.minimumValue);
          final double greaterMinimum = Math.nextUp(node.maximumValue);
          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);
          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);
          return addEdge(node, newEdge, node.minimumValue, node.maximumValue);
       }
      case EXACT:
        // The node is exactly equal to the range provided.  We need to create a new node and insert
        // it into the "within" chain.
        final Node rval = new Node(newEdge, minimumValue, maximumValue);
        //System.err.println(" Inserting new node "+rval+" at head of current 'within' chain in tree "+this);
        rval.within = node;
        rval.lesser = node.lesser;
        rval.greater = node.greater;
        node.lesser = null;
        node.greater = null;
        return rval;
      case WITHIN:
        // The new edge is within the node provided
        //System.err.println(" Adding edge into 'within' chain in tree "+this);
        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);
        return node;
      case OVERLAPS_MINIMUM:
        {
          // The new edge overlaps the minimum value, but not the maximum value.
          // Here we need to create TWO entries: one for the lesser side, and one for the within chain.
          //System.err.println(" Inserting edge into BOTH lesser chain and within chain in tree "+this);
          final double lesserMaximum = Math.nextDown(node.minimumValue);
          node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);
          return addEdge(node, newEdge, node.minimumValue, maximumValue);
        }
      case OVERLAPS_MAXIMUM:
        {
          // The new edge overlaps the maximum value, but not the minimum value.
          // Need to create two entries, one on the greater side, and one back into the current node.
          //System.err.println(" Inserting edge into BOTH greater chain and within chain in tree "+this);
          final double greaterMinimum = Math.nextUp(node.maximumValue);
          node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);
          return addEdge(node, newEdge, minimumValue, node.maximumValue);
        }
      case LESS:
        // The new edge is clearly less than the current node.
        //System.err.println(" Edge goes into the lesser chain in tree "+this);
        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);
        return node;
      case GREATER:
        // The new edge is clearly greater than the current node.
        //System.err.println(" Edge goes into the greater chain in tree "+this);
        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);
        return node;
      default:
        throw new RuntimeException("Unexpected comparison result: "+result);
      }
      
    }

