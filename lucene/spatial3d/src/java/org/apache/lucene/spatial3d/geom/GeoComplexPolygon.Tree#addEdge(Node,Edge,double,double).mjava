    /** Worker method for adding an edge.
     * @param node is the node to add into.
     * @param newEdge is the new edge to add.
     * @param minimumValue is the minimum limit of the subrange of the edge we'll be adding.
     * @param maximumValue is the maximum limit of the subrange of the edge we'll be adding.
     * @return the updated node reference.
     */
    protected Node addEdge(final Node node, final Edge newEdge, final double minimumValue, final double maximumValue) {
      if (node == null) {
        // Create and return a new node
        return new Node(newEdge, minimumValue, maximumValue);
      }
      // Compare with what's here
      int result = compareForAdd(node.minimumValue, node.maximumValue, minimumValue, maximumValue);
      switch (result) {
      case CONTAINED:
        // The node is contained in the range provided.  We need to create a new node and insert
        // it into the "within" chain.
        final Node rval = new Node(newEdge, minimumValue, maximumValue);
        rval.within = node.within;
        return rval;
      case WITHIN:
        // The new edge is within the node provided
        node.within = addEdge(node.within, newEdge, minimumValue, maximumValue);
        return node;
      case OVERLAPS_MINIMUM:
        // The new edge overlaps the minimum value, but not the maximum value.
        // Here we need to create TWO entries: one for the lesser side, and one for the within chain.
        final double lesserMaximum = Math.nextDown(node.minimumValue);
        node.lesser = addEdge(node.lesser, newEdge, minimumValue, lesserMaximum);
        return addEdge(node, newEdge, node.minimumValue, maximumValue);
      case OVERLAPS_MAXIMUM:
        // The new edge overlaps the maximum value, but not the minimum value.
        // Need to create two entries, one on the greater side, and one back into the current node.
        final double greaterMinimum = Math.nextUp(node.maximumValue);
        node.greater = addEdge(node.greater, newEdge, greaterMinimum, maximumValue);
        return addEdge(node, newEdge, minimumValue, node.maximumValue);
      case LESS:
        // The new edge is clearly less than the current node.
        node.lesser = addEdge(node.lesser, newEdge, minimumValue, maximumValue);
        return node;
      case GREATER:
        // The new edge is clearly greater than the current node.
        node.greater = addEdge(node.greater, newEdge, minimumValue, maximumValue);
        return node;
      default:
        throw new RuntimeException("Unexpected comparison result: "+result);
      }
      
    }

