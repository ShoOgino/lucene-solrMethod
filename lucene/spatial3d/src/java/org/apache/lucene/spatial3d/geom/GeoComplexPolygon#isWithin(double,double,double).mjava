  @Override
  public boolean isWithin(final double x, final double y, final double z) {
    //System.out.println("\nIswithin called for ["+x+","+y+","+z+"]");
    // If we're right on top of the point, we know the answer.
    if (testPoint.isNumericallyIdentical(x, y, z)) {
      return testPointInSet;
    }
    
    // If we're right on top of any of the test planes, we navigate solely on that plane.
    if (testPointFixedYPlane.evaluateIsZero(x, y, z)) {
      // Use the XZ plane exclusively.
      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedYPlane, testPointFixedYAbovePlane, testPointFixedYBelowPlane, x, y, z);
      // Traverse our way from the test point to the check point.  Use the y tree because that's fixed.
      if (!yTree.traverse(crossingEdgeIterator, testPoint.y)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointFixedXPlane.evaluateIsZero(x, y, z)) {
      // Use the YZ plane exclusively.
      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedXPlane, testPointFixedXAbovePlane, testPointFixedXBelowPlane, x, y, z);
      // Traverse our way from the test point to the check point.  Use the x tree because that's fixed.
      if (!xTree.traverse(crossingEdgeIterator, testPoint.x)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
    } else if (testPointFixedZPlane.evaluateIsZero(x, y, z)) {
      final CountingEdgeIterator crossingEdgeIterator = createLinearCrossingEdgeIterator(testPointFixedZPlane, testPointFixedZAbovePlane, testPointFixedZBelowPlane, x, y, z);
      // Traverse our way from the test point to the check point.  Use the z tree because that's fixed.
      if (!zTree.traverse(crossingEdgeIterator, testPoint.z)) {
        // Endpoint is on edge
        return true;
      }
      return ((crossingEdgeIterator.getCrossingCount() & 1) == 0)?testPointInSet:!testPointInSet;
    } else {

      // This is the expensive part!!
      // Changing the code below has an enormous impact on the queries per second we see with the benchmark.
      
      // We need to use two planes to get there.  We don't know which two planes will do it but we can figure it out.
      final Plane travelPlaneFixedX = new Plane(1.0, 0.0, 0.0, -x);
      final Plane travelPlaneFixedY = new Plane(0.0, 1.0, 0.0, -y);
      final Plane travelPlaneFixedZ = new Plane(0.0, 0.0, 1.0, -z);

      Plane fixedYAbovePlane = new Plane(travelPlaneFixedY, true);
      if (fixedYAbovePlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedYAbovePlane = null;
      }
      
      Plane fixedYBelowPlane = new Plane(travelPlaneFixedY, false);
      if (fixedYBelowPlane.D - planetModel.getMaximumYValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumYValue() - fixedYBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedYBelowPlane = null;
      }
      
      Plane fixedXAbovePlane = new Plane(travelPlaneFixedX, true);
      if (fixedXAbovePlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedXAbovePlane = null;
      }
      
      Plane fixedXBelowPlane = new Plane(travelPlaneFixedX, false);
      if (fixedXBelowPlane.D - planetModel.getMaximumXValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumXValue() - fixedXBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedXBelowPlane = null;
      }
      
      Plane fixedZAbovePlane = new Plane(travelPlaneFixedZ, true);
      if (fixedZAbovePlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZAbovePlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedZAbovePlane = null;
      }
      
      Plane fixedZBelowPlane = new Plane(travelPlaneFixedZ, false);
      if (fixedZBelowPlane.D - planetModel.getMaximumZValue() >= Vector.MINIMUM_RESOLUTION || planetModel.getMinimumZValue() - fixedZBelowPlane.D >= Vector.MINIMUM_RESOLUTION) {
          fixedZBelowPlane = null;
      }

      // Find the intersection points for each one of these and the complementary test point planes.

      // There will be multiple intersection points found.  We choose the one that has the lowest total distance, as measured in delta X, delta Y, and delta Z.
      double bestDistance = Double.POSITIVE_INFINITY;
      double firstLegValue = 0.0;
      double secondLegValue = 0.0;
      Plane firstLegPlane = null;
      Plane firstLegAbovePlane = null;
      Plane firstLegBelowPlane = null;
      Plane secondLegPlane = null;
      Plane secondLegAbovePlane = null;
      Plane secondLegBelowPlane = null;
      Tree firstLegTree = null;
      Tree secondLegTree = null;
      GeoPoint intersectionPoint = null;

      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {
        final GeoPoint[] XIntersectionsY = travelPlaneFixedX.findIntersections(planetModel, testPointFixedYPlane);
        for (final GeoPoint p : XIntersectionsY) {
          // Travel would be in YZ plane (fixed x) then in XZ (fixed y)
          // We compute distance we need to travel as a placeholder for the number of intersections we might encounter.
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.x - p.x;
          final double tpDelta2 = testPoint.z - p.z;
          final double cpDelta1 = y - p.y;
          final double cpDelta2 = z - p.z;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.y - p.y);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.y;
            secondLegValue = x;
            firstLegPlane = testPointFixedYPlane;
            firstLegAbovePlane = testPointFixedYAbovePlane;
            firstLegBelowPlane = testPointFixedYBelowPlane;
            secondLegPlane = travelPlaneFixedX;
            secondLegAbovePlane = fixedXAbovePlane;
            secondLegBelowPlane = fixedXBelowPlane;
            firstLegTree = yTree;
            secondLegTree = xTree;
            intersectionPoint = p;
          }
        }
      }
      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedXAbovePlane != null && fixedXBelowPlane != null) {
        final GeoPoint[] XIntersectionsZ = travelPlaneFixedX.findIntersections(planetModel, testPointFixedZPlane);
        for (final GeoPoint p : XIntersectionsZ) {
          // Travel would be in YZ plane (fixed x) then in XY (fixed z)
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.x - p.x;
          final double tpDelta2 = testPoint.y - p.y;
          final double cpDelta1 = y - p.y;
          final double cpDelta2 = z - p.z;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.z - p.z) * (thePoint.z - p.z);
          //final double newDistance = Math.abs(testPoint.x - p.x) + Math.abs(thePoint.z - p.z);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.z;
            secondLegValue = x;
            firstLegPlane = testPointFixedZPlane;
            firstLegAbovePlane = testPointFixedZAbovePlane;
            firstLegBelowPlane = testPointFixedZBelowPlane;
            secondLegPlane = travelPlaneFixedX;
            secondLegAbovePlane = fixedXAbovePlane;
            secondLegBelowPlane = fixedXBelowPlane;
            firstLegTree = zTree;
            secondLegTree = xTree;
            intersectionPoint = p;
          }
        }
      }
      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {
        final GeoPoint[] YIntersectionsX = travelPlaneFixedY.findIntersections(planetModel, testPointFixedXPlane);
        for (final GeoPoint p : YIntersectionsX) {
          // Travel would be in XZ plane (fixed y) then in YZ (fixed x)
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.y - p.y;
          final double tpDelta2 = testPoint.z - p.z;
          final double cpDelta1 = x - p.x;
          final double cpDelta2 = z - p.z;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.x - p.x);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.x;
            secondLegValue = y;
            firstLegPlane = testPointFixedXPlane;
            firstLegAbovePlane = testPointFixedXAbovePlane;
            firstLegBelowPlane = testPointFixedXBelowPlane;
            secondLegPlane = travelPlaneFixedY;
            secondLegAbovePlane = fixedYAbovePlane;
            secondLegBelowPlane = fixedYBelowPlane;
            firstLegTree = xTree;
            secondLegTree = yTree;
            intersectionPoint = p;
          }
        }
      }
      if (testPointFixedZAbovePlane != null && testPointFixedZBelowPlane != null && fixedYAbovePlane != null && fixedYBelowPlane != null) {
        final GeoPoint[] YIntersectionsZ = travelPlaneFixedY.findIntersections(planetModel, testPointFixedZPlane);
        for (final GeoPoint p : YIntersectionsZ) {
          // Travel would be in XZ plane (fixed y) then in XY (fixed z)
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.x - p.x;
          final double tpDelta2 = testPoint.y - p.y;
          final double cpDelta1 = x - p.x;
          final double cpDelta2 = z - p.z;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.y - p.y) * (testPoint.y - p.y)  + (thePoint.x - p.x) * (thePoint.x - p.x) + (thePoint.z - p.z) * (thePoint.z - p.z);
          //final double newDistance = Math.abs(testPoint.y - p.y) + Math.abs(thePoint.z - p.z);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.z;
            secondLegValue = y;
            firstLegPlane = testPointFixedZPlane;
            firstLegAbovePlane = testPointFixedZAbovePlane;
            firstLegBelowPlane = testPointFixedZBelowPlane;
            secondLegPlane = travelPlaneFixedY;
            secondLegAbovePlane = fixedYAbovePlane;
            secondLegBelowPlane = fixedYBelowPlane;
            firstLegTree = zTree;
            secondLegTree = yTree;
            intersectionPoint = p;
          }
        }
      }
      if (testPointFixedXAbovePlane != null && testPointFixedXBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {
        final GeoPoint[] ZIntersectionsX = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedXPlane);
        for (final GeoPoint p : ZIntersectionsX) {
          // Travel would be in XY plane (fixed z) then in YZ (fixed x)
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.y - p.y;
          final double tpDelta2 = testPoint.z - p.z;
          final double cpDelta1 = y - p.y;
          final double cpDelta2 = x - p.x;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.y - p.y) * (testPoint.y - p.y) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.x - p.x);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.x;
            secondLegValue = z;
            firstLegPlane = testPointFixedXPlane;
            firstLegAbovePlane = testPointFixedXAbovePlane;
            firstLegBelowPlane = testPointFixedXBelowPlane;
            secondLegPlane = travelPlaneFixedZ;
            secondLegAbovePlane = fixedZAbovePlane;
            secondLegBelowPlane = fixedZBelowPlane;
            firstLegTree = xTree;
            secondLegTree = zTree;
            intersectionPoint = p;
          }
        }
      }
      if (testPointFixedYAbovePlane != null && testPointFixedYBelowPlane != null && fixedZAbovePlane != null && fixedZBelowPlane != null) {
        final GeoPoint[] ZIntersectionsY = travelPlaneFixedZ.findIntersections(planetModel, testPointFixedYPlane);
        for (final GeoPoint p : ZIntersectionsY) {
          // Travel would be in XY plane (fixed z) then in XZ (fixed y)
          //final double newDistance = p.arcDistance(testPoint) + p.arcDistance(thePoint);
          final double tpDelta1 = testPoint.x - p.x;
          final double tpDelta2 = testPoint.z - p.z;
          final double cpDelta1 = y - p.y;
          final double cpDelta2 = x - p.x;
          final double newDistance = tpDelta1 * tpDelta1 + tpDelta2 * tpDelta2 + cpDelta1 * cpDelta1 + cpDelta2 * cpDelta2;
          //final double newDistance = (testPoint.x - p.x) * (testPoint.x - p.x) + (testPoint.z - p.z) * (testPoint.z - p.z)  + (thePoint.y - p.y) * (thePoint.y - p.y) + (thePoint.x - p.x) * (thePoint.x - p.x);
          //final double newDistance = Math.abs(testPoint.z - p.z) + Math.abs(thePoint.y - p.y);
          if (newDistance < bestDistance) {
            bestDistance = newDistance;
            firstLegValue = testPoint.y;
            secondLegValue = z;
            firstLegPlane = testPointFixedYPlane;
            firstLegAbovePlane = testPointFixedYAbovePlane;
            firstLegBelowPlane = testPointFixedYBelowPlane;
            secondLegPlane = travelPlaneFixedZ;
            secondLegAbovePlane = fixedZAbovePlane;
            secondLegBelowPlane = fixedZBelowPlane;
            firstLegTree = yTree;
            secondLegTree = zTree;
            intersectionPoint = p;
          }
        }
      }

      assert bestDistance > 0.0 : "Best distance should not be zero unless on single plane";
      assert bestDistance < Double.POSITIVE_INFINITY : "Couldn't find an intersection point of any kind";
      
      final DualCrossingEdgeIterator edgeIterator = new DualCrossingEdgeIterator(firstLegPlane, firstLegAbovePlane, firstLegBelowPlane, secondLegPlane, secondLegAbovePlane, secondLegBelowPlane, x, y, z, intersectionPoint);
      if (!firstLegTree.traverse(edgeIterator, firstLegValue)) {
        return true;
      }
      //edgeIterator.setSecondLeg();
      if (!secondLegTree.traverse(edgeIterator, secondLegValue)) {
        return true;
      }
      //System.out.println("Polarity vs. test point: "+(((edgeIterator.getCrossingCount()  & 1) == 0)?"same":"different")+"; testPointInSet: "+testPointInSet);
      return ((edgeIterator.getCrossingCount()  & 1) == 0)?testPointInSet:!testPointInSet;

    }
  }

