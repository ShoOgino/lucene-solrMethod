    protected boolean traverseEdges(final Node node, final EdgeIterator edgeIterator, final double minValue, final double maxValue, final Set<Edge> edgeSet) {
      if (node == null) {
        return true;
      }
      if (maxValue < node.minimumValue) {
        return traverseEdges(node.lesser, edgeIterator, minValue, maxValue, edgeSet);
      } else if (minValue > node.maximumValue) {
        return traverseEdges(node.greater, edgeIterator, minValue, maxValue, edgeSet);
      } else {
        // There's overlap with the current node, and there may also be overlap with the lesser side and greater side
        if (minValue < node.minimumValue) {
          if (!traverseEdges(node.lesser, edgeIterator, minValue, maxValue, edgeSet)) {
            return false;
          }
        }
        if (!edgeSet.contains(node.edge)) {
          if (!edgeIterator.matches(node.edge)) {
            return false;
          }
          edgeSet.add(node.edge);
        }
        if (maxValue > node.maximumValue) {
          if (!traverseEdges(node.greater, edgeIterator, minValue, maxValue, edgeSet)) {
            return false;
          }
        }
        return traverseEdges(node.within, edgeIterator, minValue, maxValue, edgeSet);
      }
    }

