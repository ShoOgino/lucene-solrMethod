    public DualCrossingEdgeIterator(final Plane testPointPlane, final Plane testPointAbovePlane, final Plane testPointBelowPlane,
      final Plane travelPlane, final Vector testPoint, final Vector thePoint, final GeoPoint intersectionPoint) {
      this.testPointPlane = testPointPlane;
      this.travelPlane = travelPlane;
      this.thePoint = thePoint;
      this.intersectionPoint = intersectionPoint;
        
      this.testPointCutoffPlane = new SidedPlane(thePoint, testPointPlane, testPoint);
      this.checkPointCutoffPlane = new SidedPlane(testPoint, travelPlane, thePoint);

      this.testPointOtherCutoffPlane = new SidedPlane(testPoint, travelPlane, -(travelPlane.x * intersectionPoint.x + travelPlane.y * intersectionPoint.y + travelPlane.z * intersectionPoint.z));
      this.checkPointOtherCutoffPlane = new SidedPlane(thePoint, testPointPlane, -(testPointPlane.x * intersectionPoint.x + testPointPlane.y * intersectionPoint.y + testPointPlane.z * intersectionPoint.z));
        
      // Figure out which of the above/below planes are inside vs. outside.  To do this,
      // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside
      // borders.
      final Plane travelAbovePlane = new Plane(travelPlane, true);
      final Plane travelBelowPlane = new Plane(travelPlane, false);
      final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);
      assert aboveAbove != null : "Above + above should not be coplanar";
      final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);
      assert aboveBelow != null : "Above + below should not be coplanar";
      final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);
      assert belowBelow != null : "Below + below should not be coplanar";
      final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, testPointCutoffPlane, testPointOtherCutoffPlane, checkPointCutoffPlane, checkPointOtherCutoffPlane);
      assert belowAbove != null : "Below + above should not be coplanar";
      
      assert aboveAbove.length + aboveBelow.length + belowBelow.length + belowAbove.length == 1 : "Can be exactly one inside point, instead was: aa="+aboveAbove.length+" ab=" + aboveBelow.length+" bb="+ belowBelow.length+" ba=" + belowAbove.length;
      
      final GeoPoint insideIntersection;
      if (aboveAbove.length > 0) {
        travelInsidePlane = travelAbovePlane;
        testPointInsidePlane = testPointAbovePlane;
        travelOutsidePlane = travelBelowPlane;
        testPointOutsidePlane = testPointBelowPlane;
        insideIntersection = aboveAbove[0];
      } else if (aboveBelow.length > 0) {
        travelInsidePlane = travelAbovePlane;
        testPointInsidePlane = testPointBelowPlane;
        travelOutsidePlane = travelBelowPlane;
        testPointOutsidePlane = testPointAbovePlane;
        insideIntersection = aboveBelow[0];
      } else if (belowBelow.length > 0) {
        travelInsidePlane = travelBelowPlane;
        testPointInsidePlane = testPointBelowPlane;
        travelOutsidePlane = travelAbovePlane;
        testPointOutsidePlane = testPointAbovePlane;
        insideIntersection = belowBelow[0];
      } else {
        travelInsidePlane = travelBelowPlane;
        testPointInsidePlane = testPointAbovePlane;
        travelOutsidePlane = travelAbovePlane;
        testPointOutsidePlane = testPointBelowPlane;
        insideIntersection = belowAbove[0];
      }
      
      insideTravelCutoffPlane = new SidedPlane(thePoint, travelInsidePlane, insideIntersection);
      insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideIntersection);

    }

