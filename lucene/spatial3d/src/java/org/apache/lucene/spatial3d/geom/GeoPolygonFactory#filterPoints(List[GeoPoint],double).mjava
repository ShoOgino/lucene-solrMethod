  /** Filter duplicate points and coplanar points.
   * @param input with input list of points
   * @param leniencyValue is the allowed distance of a point from the plane for cleanup of overly detailed polygons
   * @return the filtered list, or null if we can't get a legit polygon from the input.
   */
  static List<GeoPoint> filterPoints(final List<GeoPoint> input, final double leniencyValue) {
    
    final List<GeoPoint> noIdenticalPoints = new ArrayList<>(input.size());
    
    // Backtrack to find something different from the first point
    int startIndex = -1;
    final GeoPoint comparePoint = input.get(0);
    for (int i = 0; i < input.size()-1; i++) {
      final GeoPoint thePoint = input.get(getLegalIndex(- i - 1, input.size()));
      if (!thePoint.isNumericallyIdentical(comparePoint)) {
        startIndex = getLegalIndex(-i, input.size());
        break;
      }
    }
    if (startIndex == -1) {
      return null;
    }
    
    // Now we can start the process of walking around, removing duplicate points.
    int currentIndex = startIndex;
    while (true) {
      final GeoPoint currentPoint = input.get(currentIndex);
      noIdenticalPoints.add(currentPoint);
      while (true) {
        currentIndex = getLegalIndex(currentIndex + 1, input.size());
        if (currentIndex == startIndex) {
          break;
        }
        final GeoPoint nextNonIdenticalPoint = input.get(currentIndex);
        if (!nextNonIdenticalPoint.isNumericallyIdentical(currentPoint)) {
          break;
        }
      }
      if (currentIndex == startIndex) {
        break;
      }
    }
    
    if (noIdenticalPoints.size() < 3) {
      return null;
    }
    
    // Now, do the depth-first search needed to find a path that has no coplanarities in it.
    // This is, unfortunately, not easy, because coplanarity is not transitive as you walk around the polygon.
    // If point C is not coplanar with edge A-B, there is no guarantee that A is not coplanar with B-C.
    // But we have to produce a polygon that is safe no matter which way it is looked at.
    // The approach I'm taking therefore is to do a depth-first search until we find a valid polygon.
    // This algorithmically awful in the worst case, but luckily we can presume that real-life data
    // does not require more than a couple of iterations.
    
    for  (int i = 0; i < noIdenticalPoints.size(); i++) {
      final SafePath startPath = new SafePath(null, noIdenticalPoints.get(i), i, null);
      // Search, with this as the start path.
      final SafePath resultPath = findSafePath(startPath, noIdenticalPoints, getLegalIndex(i+1, noIdenticalPoints.size()), i, leniencyValue);
      if (resultPath != null && resultPath.previous != null) {
        // Read out result, maintaining ordering
        final List<GeoPoint> rval = new ArrayList<>(noIdenticalPoints.size());
        resultPath.fillInList(rval);
        return rval;
      }
    }
    // No path found.  This means that everything was coplanar.
    return null;
  }

