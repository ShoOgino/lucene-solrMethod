  /** Compute crossings of an envelope plane by an edge.
  */
  private GeoPoint[] computeCrossings(final Plane envelopePlane, final Edge edge, final Membership... envelopeBounds) {
    // Note: there is a possibility that one or both endpoints of the edge actually lies in the inside/outside planes.  If this is the case, those endpoints may or may not show up as crossings.
    // And yet, we absolutely cannot count each crossing more than once.  So, how do we proceed?
    // The solution is to recognize that excluded crossings will be excluded for two reasons: (1) bounds, and (2) because there's only one solution to the intersection equation, which means
    // we never actually crossed the envelope plane.  So, the way we proceed is to look for intersections, but NOT do edge bounds at all.  Then, we consider the results in the context of
    // the plane we're trying to assess.
    //System.out.println(" Computing crossings between "+envelopePlane+" and ["+edge.startPoint+"->"+edge.endPoint+"]");
    
    final GeoPoint[] unboundedIntersectionPoints = envelopePlane.findIntersections(planetModel, edge.plane);
    if (unboundedIntersectionPoints == null) {
      return null;
    }
    // Go through the intersection points one at a time.  Notes:
    // (1) So that we don't double-count, we can only include at most one point in the result per intersection.
    // (2) Single-solution results imply that the plane was not crossed.  The only time we consider them is if the edge ends on the plane, in which case we count it as a crossing.
    // (3) We tried to detect the case where the edge ends on the envelope plane by seeing if the intersection point was numerically identical to an endpoint, but that
    //    was still too strict.
    // (4) The intersection points will be on both planes, for sure.  The question is whether an intersection point "lines up" with an edge endpoint.  If the edge endpoint
    //    lies in the envelope plane, then we have the possibility of a detection.  The detection is confirmed if the distance "is small" between the edge endpoint and
    //    the intersection point.  I see squared linear distance numbers of about 1.35e-24, which is still barely outside of the 1e-12 envelope, so a straight distance
    //    check won't work.  So this is what I think we need to do:
    //    (a) Check if endpoint is on envelope plane; if not, we keep going.
    //    (b) If on envelope plane, we confirm that entire section of plane between intersection point and endpoint lies within envelope plane.  (How??)
    
    // If no points, just return.  (I'm not even sure this can happen)
    if (unboundedIntersectionPoints.length == 0) {
      //System.out.println("  None found.");
      return unboundedIntersectionPoints;
    }

    // Single solution has special logic
    if (unboundedIntersectionPoints.length == 1) {
      //System.out.println("  One found.");
      final GeoPoint thePoint = unboundedIntersectionPoints[0];
      if (withinBounds(thePoint, envelopeBounds) &&
        (pointMatches(envelopePlane, thePoint, edge.startPoint) || pointMatches(envelopePlane, thePoint, edge.endPoint) ||
          (edge.startPlane.isWithin(thePoint) && edge.endPlane.isWithin(thePoint)))) {
        return unboundedIntersectionPoints;
      }
      return NO_POINTS;
    }
      
    // Two solutions: we could return none, one, the other one, or both.
    //System.out.println("  Two found.");

    final GeoPoint firstPoint = unboundedIntersectionPoints[0];
    final GeoPoint secondPoint = unboundedIntersectionPoints[1];
    
    final boolean useFirstPoint;
    if (withinBounds(firstPoint, envelopeBounds) &&
        (pointMatches(envelopePlane, firstPoint, edge.startPoint) || pointMatches(envelopePlane, firstPoint, edge.endPoint) ||
          (edge.startPlane.isWithin(firstPoint) && edge.endPlane.isWithin(firstPoint)))) {
      //System.out.println("  Point "+firstPoint+" accepted.");
      useFirstPoint = true;
    } else {
      /*System.out.println("  Point "+firstPoint+" rejected; withinBounds="+withinBounds(firstPoint, envelopeBounds)+
        "; edgeBounds="+(edge.startPlane.isWithin(firstPoint) && edge.endPlane.isWithin(firstPoint))+
        "; startPointDist="+edge.startPoint.linearDistanceSquared(firstPoint)+"; endPointDist="+edge.endPoint.linearDistanceSquared(firstPoint)); */
      useFirstPoint = false;
    }
    
    final boolean useSecondPoint;
    if (withinBounds(secondPoint, envelopeBounds) &&
        (pointMatches(envelopePlane, secondPoint, edge.startPoint) || pointMatches(envelopePlane, secondPoint, edge.endPoint) ||
          (edge.startPlane.isWithin(secondPoint) && edge.endPlane.isWithin(secondPoint)))) {
      //System.out.println("  Point "+secondPoint+" accepted.");
      useSecondPoint = true;
    } else {
      /*System.out.println("  Point "+secondPoint+" rejected; withinBounds="+withinBounds(secondPoint, envelopeBounds)+
        "; edgeBounds="+(edge.startPlane.isWithin(secondPoint) && edge.endPlane.isWithin(secondPoint))+
        "; startPointDist="+edge.startPoint.linearDistanceSquared(secondPoint)+"; endPointDist="+edge.endPoint.linearDistanceSquared(secondPoint)); */
      useSecondPoint = false;
    }
    
    if (useFirstPoint && useSecondPoint) {
      return unboundedIntersectionPoints;
    }
    
    if (useFirstPoint) {
      return new GeoPoint[]{firstPoint};
    }
    
    if (useSecondPoint) {
      return new GeoPoint[]{secondPoint};
    }
    
    return NO_POINTS;
  }

