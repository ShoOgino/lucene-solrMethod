  /**
   * Method that returns a random generated a concave GeoPolygon with holes under given constraints. Returns
   * NULL if it cannot build the GeoPolygon under the given constraints. Note that the final GeoPolygon is
   * convex as the hole wraps the convex GeoPolygon.
   *
   * @param planetModel The planet model.
   * @param constraints The given constraints.
   * @return The random generated GeoPolygon.
   */
  private GeoPolygon concavePolygonWithHoles(PlanetModel planetModel, Constraints constraints) {
    int vertexCount = random().nextInt(4) + 3;
    int iterations = 0;
    while (iterations < MAX_SHAPE_ITERATIONS) {
      iterations++;
      //we first build the hole. We consider all constraints except
      // disjoint as we have a hole
      Constraints holeConstraints = new Constraints();
      holeConstraints.putAll(constraints.getContains());
      holeConstraints.putAll(constraints.getWithin());
      holeConstraints.putAll(constraints.getOverlaps());
      GeoPolygon hole = convexPolygon(planetModel, holeConstraints);
      if (hole == null){
        continue;
      }
      // Now we get points for polygon. Must we with in the hole
      // and we add contain constraints
      Constraints pointConstraints = new Constraints();
      pointConstraints.put(hole, GeoArea.WITHIN);
      pointConstraints.putAll(constraints.getContains());
      List<GeoPoint> geoPoints = points(vertexCount,planetModel, pointConstraints);
      List<GeoPoint> orderedGeoPoints = orderPoints(geoPoints);
      Collections.reverse(orderedGeoPoints);
      try {
        GeoPolygon polygon = GeoPolygonFactory.makeGeoPolygon(planetModel, orderedGeoPoints, Collections.singletonList(hole));
        //final polygon must be convex
        if (!constraints.valid(polygon) || isConcave(planetModel,polygon)) {
          continue;
        }
        return polygon;
      } catch (IllegalArgumentException e) {
        continue;
      }
    }
    return null;
  }

