  /**
   * a constructor.
   * 
   * @param reader IndexReader of the index
   * @param docId document id to be highlighted
   * @param fieldName field of the document to be highlighted
   * @param fieldQuery FieldQuery object
   * @throws IOException
   */
  public FieldTermStack( IndexReader reader, int docId, String fieldName, final FieldQuery fieldQuery ) throws IOException {
    this.fieldName = fieldName;

    TermFreqVector tfv = reader.getTermFreqVector( docId, fieldName );
    if( tfv == null ) return; // just return to make null snippets
    TermPositionVector tpv = null;
    try{
      tpv = (TermPositionVector)tfv;
    }
    catch( ClassCastException e ){
      return; // just return to make null snippets
    }
    
    Set<String> termSet = fieldQuery.getTermSet( fieldName );
    // just return to make null snippet if un-matched fieldName specified when fieldMatch == true
    if( termSet == null ) return;
    final CharsRef spare = new CharsRef();
    for( BytesRef term : tpv.getTerms() ){
      if( !termSet.contains( term.utf8ToChars(spare).toString() ) ) continue;
      int index = tpv.indexOf( term );
      TermVectorOffsetInfo[] tvois = tpv.getOffsets( index );
      if( tvois == null ) return; // just return to make null snippets
      int[] poss = tpv.getTermPositions( index );
      if( poss == null ) return; // just return to make null snippets
      for( int i = 0; i < tvois.length; i++ )
        termList.add( new TermInfo( term.utf8ToChars(spare).toString(), tvois[i].getStartOffset(), tvois[i].getEndOffset(), poss[i] ) );
    }
    
    // sort by position
    Collections.sort( termList );
  }

