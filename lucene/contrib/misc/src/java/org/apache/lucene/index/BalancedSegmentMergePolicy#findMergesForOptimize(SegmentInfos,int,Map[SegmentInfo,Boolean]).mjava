  @Override
  public MergeSpecification findMergesForOptimize(SegmentInfos infos, int maxNumSegments, Map<SegmentInfo,Boolean> segmentsToOptimize) throws IOException {
    
    assert maxNumSegments > 0;

    MergeSpecification spec = null;

    if (!isOptimized(infos, maxNumSegments, segmentsToOptimize)) {

      // Find the newest (rightmost) segment that needs to
      // be optimized (other segments may have been flushed
      // since optimize started):
      int last = infos.size();
      while(last > 0) {

        final SegmentInfo info = infos.info(--last);
        if (segmentsToOptimize.containsKey(info)) {
          last++;
          break;
        }
      }

      if (last > 0) {

        if (maxNumSegments == 1) {

          // Since we must optimize down to 1 segment, the
          // choice is simple:
          if (last > 1 || !isOptimized(infos.info(0))) {

            spec = new MergeSpecification();
            spec.add(new OneMerge(infos.asList().subList(0, last)));
          }
        } else if (last > maxNumSegments) {

          // find most balanced merges
          spec = findBalancedMerges(infos, last, maxNumSegments, _partialExpunge);
        }
      }
    }
    return spec;
  }

