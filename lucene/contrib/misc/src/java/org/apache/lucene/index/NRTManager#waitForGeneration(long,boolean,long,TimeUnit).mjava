  /**
   * Waits for a given {@link SearcherManager} target generation to be available
   * via {@link #getSearcherManager(boolean)}. If the current generation is less
   * than the given target generation this method will block until the
   * correspondent {@link SearcherManager} is reopened by another thread via
   * {@link #maybeReopen(boolean)}, the given waiting time has elapsed, or until
   * the {@link NRTManager} is closed.
   * <p>
   * NOTE: if the waiting time elapses before the requested target generation is
   * available the latest {@link SearcherManager} is returned instead.
   * 
   * @param targetGen
   *          the generation to wait for
   * @param requireDeletes
   *          <code>true</code> iff the generation requires deletes to be
   *          applied otherwise <code>false</code>
   * @param time
   *          the time to wait for the target generation
   * @param unit
   *          the waiting time's time unit
   * @return the {@link SearcherManager} with the given target generation or the
   *         latest {@link SearcherManager} if the waiting time elapsed before
   *         the requested generation is available.
   */
  public SearcherManager waitForGeneration(long targetGen, boolean requireDeletes, long time, TimeUnit unit) {
    try {
      reopenLock.lockInterruptibly();
      try {
        if (targetGen > getCurrentSearchingGen(requireDeletes)) {
          for (WaitingListener listener : waitingListeners) {
            listener.waiting(requireDeletes, targetGen);
          }
          while (targetGen > getCurrentSearchingGen(requireDeletes)) {
            if (!waitOnGenCondition(time, unit)) {
              return getSearcherManager(requireDeletes);
            }
          }
        }

      } finally {
        reopenLock.unlock();
      }
    } catch (InterruptedException ie) {
      throw new ThreadInterruptedException(ie);
    }
    return getSearcherManager(requireDeletes);
  }

