  /**
   * Evaluates the new shingle token weight.
   *
   * for (shingle part token in shingle)
   * weight +=  shingle part token weight * (1 / sqrt(all shingle part token weights summed))
   *
   * This algorithm gives a slightly greater score for longer shingles
   * and is rather penalising to great shingle token part weights.
   *
   * @param shingleToken token returned to consumer
   * @param shingle tokens the tokens used to produce the shingle token.
   * @param currentPermutationStartOffset start offset in parameter currentPermutationRows and currentPermutationTokens.
   * @param currentPermutationRows an index to what matrix row a token in parameter currentPermutationTokens exist.
   * @param currentPermuationTokens all tokens in the current row permutation of the matrix. A sub list (parameter offset, parameter shingle.size) equals parameter shingle.
   * @return weight to be set for parameter shingleToken
   */
  public float calculateShingleWeight(Token shingleToken, List<Token> shingle, int currentPermutationStartOffset, List<Row> currentPermutationRows, List<Token> currentPermuationTokens) {
    double[] weights = new double[shingle.size()];

    double total = 0f;
    double top = 0d;


    for (int i=0; i<weights.length; i++) {
      weights[i] = settingsCodec.getWeight(shingle.get(i));

      double tmp = weights[i];
      if (tmp > top) {
        top = tmp;
      }
      total += tmp;
    }

    double factor = 1d / Math.sqrt(total);

    double weight = 0d;
    for (double partWeight : weights) {
      weight += partWeight * factor;
    }

    return (float) weight;
  }

