  /**
   * Collect external dependencies from the given ivy.xml file, constructing
   * property values containing &lt;dependency&gt; snippets, which will be
   * filtered (substituted) when copying the POM for the module corresponding
   * to the given ivy.xml file.
   */
  private void collectExternalDependenciesFromIvyXmlFile(File ivyXmlFile)
      throws XPathExpressionException, IOException, SAXException {
    String module = getModuleName(ivyXmlFile);
    log("Collecting external dependencies from: " + ivyXmlFile.getPath(), verboseLevel);
    Document document = documentBuilder.parse(ivyXmlFile);
    // Exclude the 'start' configuration in solr/server/ivy.xml
    String dependencyPath = "/ivy-module/dependencies/dependency[not(starts-with(@conf,'start'))]";
    NodeList dependencies = (NodeList)xpath.evaluate(dependencyPath, document, XPathConstants.NODESET);
    for (int depNum = 0 ; depNum < dependencies.getLength() ; ++depNum) {
      Element dependency = (Element)dependencies.item(depNum);
      String groupId = dependency.getAttribute("org");
      String artifactId = dependency.getAttribute("name");
      String dependencyCoordinate = groupId + ':' + artifactId;
      Set<String> classifiers = dependencyClassifiers.get(dependencyCoordinate);
      if (null == classifiers) {
        classifiers = new HashSet<>();
        dependencyClassifiers.put(dependencyCoordinate, classifiers);
      }
      String conf = dependency.getAttribute("conf");
      boolean confContainsTest = conf.contains("test");
      boolean isOptional = globalOptionalExternalDependencies.contains(dependencyCoordinate)
          || ( perModuleOptionalExternalDependencies.containsKey(module)
              && perModuleOptionalExternalDependencies.get(module).contains(dependencyCoordinate));
      SortedSet<ExternalDependency> deps = allExternalDependencies.get(module);
      if (null == deps) {
        deps = new TreeSet<>();
        allExternalDependencies.put(module, deps);
      }
      NodeList artifacts = null;
      if (dependency.hasChildNodes()) {
        artifacts = (NodeList)xpath.evaluate("artifact", dependency, XPathConstants.NODESET);
      }
      if (null != artifacts && artifacts.getLength() > 0) {
        for (int artifactNum = 0 ; artifactNum < artifacts.getLength() ; ++artifactNum) {
          Element artifact = (Element)artifacts.item(artifactNum);
          String type = artifact.getAttribute("type");
          String ext = artifact.getAttribute("ext");
          // When conf contains BOTH "test" and "compile", and type != "test", this is NOT a test dependency
          boolean isTestDependency = confContainsTest && (type.equals("test") || ! conf.contains("compile"));
          if ((type.isEmpty() && ext.isEmpty()) || type.equals("jar") || ext.equals("jar")) {
            String classifier = artifact.getAttribute("maven:classifier");
            if (classifier.isEmpty()) {
              classifier = null;
            }
            classifiers.add(classifier);
            deps.add(new ExternalDependency(groupId, artifactId, classifier, isTestDependency, isOptional));
          } else { // not a jar
            nonJarDependencies.add(dependencyCoordinate);
          }
        }
      } else {
        classifiers.add(null);
        deps.add(new ExternalDependency(groupId, artifactId, null, confContainsTest, isOptional));
      }
    }
  }

