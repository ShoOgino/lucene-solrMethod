  /** Adds the method signature to the list of disallowed methods. The Signature is checked against the given ClassLoader. */
  private void addSignature(final ClassLoader loader, final String signature) throws BuildException {
    final String clazz, field;
    final Method method;
    int p = signature.indexOf('#');
    if (p >= 0) {
      clazz = signature.substring(0, p);
      final String s = signature.substring(p + 1);
      p = s.indexOf('(');
      if (p >= 0) {
        if (p == 0) {
          throw new BuildException("Invalid method signature (method name missing): " + signature);
        }
        // we ignore the return type, its just to match easier (so return type is void):
        try {
          method = Method.getMethod("void " + s, true);
        } catch (IllegalArgumentException iae) {
          throw new BuildException("Invalid method signature: " + signature);
        }
        field = null;
      } else {
        field = s;
        method = null;
      }
    } else {
      clazz = signature;
      method = null;
      field = null;
    }
    // check class & method/field signature, if it is really existent (in classpath), but we don't really load the class into JVM:
    ClassNode c = classCache.get(clazz);
    if (c == null) {
      readClass(loader, clazz).accept(c = new ClassNode(Opcodes.ASM4), ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
      classCache.put(clazz, c);
    }
    if (method != null) {
      assert field == null;
      // list all methods with this signature:
      boolean found = false;
      for (final MethodNode mn : c.methods) {
        if (mn.name.equals(method.getName()) && Arrays.equals(Type.getArgumentTypes(mn.desc), method.getArgumentTypes())) {
          found = true;
          forbiddenMethods.put(c.name + '\000' + new Method(mn.name, mn.desc), signature);
          // don't break when found, as there may be more covariant overrides!
        }
      }
      if (!found) {
        throw new BuildException("No method found with following signature: " + signature);
      }
    } else if (field != null) {
      assert method == null;
      // list all fields to find the right one:
      boolean found = false;
      for (final FieldNode fld : c.fields) {
        if (fld.name.equals(field)) {
          found = true;
          forbiddenFields.put(c.name + '\000' + fld.name, signature);
          break;
        }
      }
      if (!found) {
        throw new BuildException("No field found with following name: " + signature);
      }
    } else {
      assert field == null && method == null;
      // only add the signature as class name
      forbiddenClasses.put(c.name, signature);
    }
  }

