  /** Adds the method signature to the list of disallowed methods. The Signature is checked against the given ClassLoader. */
  private void addSignature(ClassLoader loader, String signature) throws BuildException {
    final int p = signature.indexOf('#');
    final String clazz;
    final Method dummy;
    if (p >= 0) {
      clazz = signature.substring(0, p);
      // we ignore the return type, its just to match easier (so return type is void):
      dummy = Method.getMethod("void " + signature.substring(p+1), true);
    } else {
      clazz = signature;
      dummy = null;
    }
    // check class & method signature, if it is really existent (in classpath), but we don't really load the class into JVM:
    try {
      ClassNode c = classCache.get(clazz);
      if (c == null) {
        final ClassReader reader;
        if (loader != null) {
          final InputStream in = loader.getResourceAsStream(clazz.replace('.', '/') + ".class");
          if (in == null) {
            throw new BuildException("Loading of class " + clazz + " failed: Not found");
          }
          try {
            reader = new ClassReader(in);
          } finally {
            in.close();
          }
        } else {
          // load from build classpath
          reader = new ClassReader(clazz);
        }
        reader.accept(c = new ClassNode(Opcodes.ASM4), ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES);
        classCache.put(clazz, c);
      }
      if (dummy != null) {
        // list all methods with this signature:
        boolean found = false;
        for (final MethodNode mn : c.methods) {
          if (mn.name.equals(dummy.getName()) && Arrays.equals(Type.getArgumentTypes(mn.desc), dummy.getArgumentTypes())) {
            found = true;
            forbiddenMethods.put(c.name + '\000' + new Method(mn.name, mn.desc), signature);
            // don't break when found, as there may be more covariant overrides!
          }
        }
        if (!found)
          throw new BuildException("No method found with following signature: " + signature);
      } else {
        // only add the signature as class name
        forbiddenClasses.put(c.name, signature);
      }
    } catch (IOException e) {
      throw new BuildException("Loading of class " + clazz + " failed.", e);
    }
  }

