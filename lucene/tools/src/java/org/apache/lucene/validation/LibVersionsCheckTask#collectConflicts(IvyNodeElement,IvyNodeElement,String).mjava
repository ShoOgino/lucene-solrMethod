  /**
   * Recursively finds indirect dependencies that have a version conflict with a direct dependency.
   * Returns true if one or more conflicts are found, false otherwise
   */
  private boolean collectConflicts(IvyNodeElement root, IvyNodeElement parent, String moduleName) {
    boolean conflicts = false;
    for (IvyNodeElement child : parent.getDependencies()) {
      String coordinate = "/" + child.getOrganization() + "/" + child.getName();
      Dependency dependency = directDependencies.get(coordinate);
      if (null != dependency) { // Ignore this indirect dependency if it's not also a direct dependency
        String indirectVersion = child.getRevision();
        if (isConflict(coordinate, dependency.directVersion, indirectVersion)) {
          conflicts = true;
          Set<String> moduleNames = dependency.conflictLocations.get(root);
          if (null == moduleNames) {
            moduleNames = new HashSet<>();
            dependency.conflictLocations.put(root, moduleNames);
          }
          moduleNames.add(moduleName);
        }
        conflicts |= collectConflicts(root, child, moduleName);
      }
    }
    return conflicts;
  }

