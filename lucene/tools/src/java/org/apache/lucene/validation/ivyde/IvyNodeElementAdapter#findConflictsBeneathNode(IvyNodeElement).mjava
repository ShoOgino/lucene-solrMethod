  /**
   * Derives configuration conflicts that exist between node and all of its descendant dependencies.
   */
  private static void findConflictsBeneathNode(IvyNodeElement node) {
    // Derive conflicts
    Map<ModuleId,Collection<IvyNodeElement>> moduleRevisionMap = new HashMap<>();
    IvyNodeElement[] deepDependencies = node.getDeepDependencies();
    for (int i = 0; i < deepDependencies.length; i++) {
      if (deepDependencies[i].isEvicted())
        continue;

      ModuleId moduleId = deepDependencies[i].getModuleRevisionId().getModuleId();
      if (moduleRevisionMap.containsKey(moduleId)) {
        Collection<IvyNodeElement> conflicts = moduleRevisionMap.get(moduleId);
        conflicts.add(deepDependencies[i]);
        for (Iterator<IvyNodeElement> iter = conflicts.iterator(); iter.hasNext();) {
          IvyNodeElement conflict = iter.next();
          conflict.setConflicts(conflicts);
        }
      } else {
        List<IvyNodeElement> immutableMatchingSet = Arrays.asList(deepDependencies[i]);
        moduleRevisionMap.put(moduleId, new HashSet<>(immutableMatchingSet));
      }
    }
  }

