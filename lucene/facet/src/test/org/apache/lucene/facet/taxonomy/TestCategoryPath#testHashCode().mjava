  @Test 
  public void testHashCode() {
    // Note: in this test, we assume that if two paths are not equal,
    // their hash codes should come out differently. This is *not*
    // always the case, but in the examples we use below, it comes out
    // fine, and unless we have some really bad luck in changing our
    // hash function, this should also remain true in the future.
    
    // check that two empty paths are equal, even if they have different
    // capacities:
    CategoryPath p1 = new CategoryPath(0,0);
    CategoryPath p2 = new CategoryPath(1000,300);
    assertEquals(p1.hashCode(), p2.hashCode());
    // If we make p2 different, it is no longer equals:
    p2.add("hi");
    assertEquals(false, p1.hashCode()==p2.hashCode());
    // Build two paths separately, and compare them
    p1.clear();
    p1.add("hello");
    p1.add("world");
    p2.clear();
    p2.add("hello");
    p2.add("world");
    assertEquals(p1.hashCode(), p2.hashCode());
    // Check that comparison really don't look at old data which might
    // be stored in the array
    p1.clear();
    p1.add("averylongcategoryname");
    p1.clear();
    p1.add("hi");
    p2.clear();
    p2.add("hi");
    assertEquals(p1.hashCode(), p2.hashCode());
    // Being of the same length is obviously not enough to be equal
    p1.clear();
    p1.add("hi");
    p2.clear();
    p2.add("hello");
    assertEquals(false, p1.hashCode()==p2.hashCode());
    p1.clear();
    p1.add("hi");
    p2.clear();
    p2.add("ho");
    assertEquals(false, p1.hashCode()==p2.hashCode());
  }

