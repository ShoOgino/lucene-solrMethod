  /**
   * like {@link #toString(char)}, but takes only a part of the path, rather
   * than the whole path.
   * <P>
   * <code>start</code> specifies the first component in the subpath, and
   * <code>end</code> is one past the last component. If <code>start</code> is
   * negative, 0 is assumed, and if <code>end</code> is negative or past the
   * end of the path, the path is taken until the end. Otherwise, if
   * <code>end<=start</code>, an empty string is returned. An emptry string is
   * returned also in the case that the path is empty.
   */
  public String toString(char delimiter, int start, int end) {
    if (start < 0) {
      start = 0;
    }
    if (end < 0 || end > ncomponents) {
      end = ncomponents;
    }
    if (end <= start) {
      return "";
    }
    int startchar = (start == 0) ? 0 : ends[start - 1];
    StringBuilder sb = new StringBuilder(ends[end - 1] - startchar
        + (end - start) - 1);
    try {
      this.appendTo(sb, delimiter, start, end);
    } catch (IOException e) {
      // can't happen, because sb.append() never actually throws an
      // exception
    }
    return sb.toString();
  }

