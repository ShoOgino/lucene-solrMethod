  /**
   * Wraps a given {@link Query} by a drill-down query over the given
   * categories. {@link Occur} defines the relationship between the cateories
   * (e.g. {@code OR} or {@code AND}. If you need to construct a more
   * complicated relationship, e.g. {@code AND} of {@code ORs}), call this
   * method with every group of categories with the same relationship and then
   * construct a {@link BooleanQuery} which will wrap all returned queries. It
   * is advised to construct that boolean query with coord disabled, and also
   * wrap the final query with {@link ConstantScoreQuery} and set its boost to
   * {@code 0.0f}.
   * <p>
   * <b>NOTE:</b> {@link Occur} only makes sense when there is more than one
   * {@link CategoryPath} given.
   * <p>
   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the
   * {@link Query} over the categories will is returned.
   */
  public static final Query query(FacetIndexingParams iParams, Query baseQuery, Occur occur, CategoryPath... paths) {
    if (paths == null || paths.length == 0) {
      throw new IllegalArgumentException("Empty category path not allowed for drill down query!");
    }
    
    final Query q;
    if (paths.length == 1) {
      q = new TermQuery(term(iParams, paths[0]));
    } else {
      BooleanQuery bq = new BooleanQuery(true); // disable coord
      for (CategoryPath cp : paths) {
        bq.add(new TermQuery(term(iParams, cp)), occur);
      }
      q = bq;
    }

    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);
    drillDownQuery.setBoost(0.0f);

    if (baseQuery == null) {
      return drillDownQuery;
    } else {
      BooleanQuery res = new BooleanQuery(true);
      res.add(baseQuery, Occur.MUST);
      res.add(drillDownQuery, Occur.MUST);
      return res;
    }
  }

