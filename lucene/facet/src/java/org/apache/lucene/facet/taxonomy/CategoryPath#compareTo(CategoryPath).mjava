  /**
   * Compares this CategoryPath with the other CategoryPath for lexicographic
   * order. 
   * Returns a negative integer, zero, or a positive integer as this
   * CategoryPath lexicographically precedes, equals to, or lexicographically follows 
   * the other CategoryPath.
   */
  @Override
  public int compareTo(CategoryPath other) {
    int minlength = (this.length() < other.length()) ? this.length() : other.length();
    int ch = 0;
    for (int co = 0 ; co < minlength; co++) {
      if (this.ends[co] <= other.ends[co]) {
        for ( ; ch < this.ends[co] ; ch++) {
          if (this.chars[ch] != other.chars[ch]) {
            return this.chars[ch] - other.chars[ch];
          }
        }
        if (this.ends[co] < other.ends[co]) {
          return -1;
        }
      } else /* this.ends[co] > other.ends[co] */ {
        for ( ; ch < other.ends[co] ; ch++) {
          if (this.chars[ch] != other.chars[ch]) {
            return this.chars[ch] - other.chars[ch];
          }
        }
        return +1;
      }
    }
    // one is a prefix of the other
    return this.length() - other.length();
  }  

