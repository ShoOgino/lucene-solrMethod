  /** Adds the needed facet fields to the document. */
  public void addFields(Document doc, Iterable<CategoryPath> categories) throws IOException {
    if (categories == null) {
      throw new IllegalArgumentException("categories should not be null");
    }

    // TODO: add reuse capabilities to this class, per CLP objects:
    // - drill-down field
    // - counting list field
    // - DrillDownStream
    // - CountingListStream

    final Map<CategoryListParams,Iterable<CategoryPath>> categoryLists = createCategoryListMapping(categories);

    // for each CLP we add a different field for drill-down terms as well as for
    // counting list data.
    IntsRef ordinals = new IntsRef(32); // should be enough for most common applications
    for (Entry<CategoryListParams, Iterable<CategoryPath>> e : categoryLists.entrySet()) {
      final CategoryListParams clp = e.getKey();
      final String field = clp.getTerm().field();

      // build category list data
      ordinals.length = 0; // reset
      int maxNumOrds = 0;
      for (CategoryPath cp : e.getValue()) {
        int ordinal = taxonomyWriter.addCategory(cp);
        maxNumOrds += cp.length; // ordinal and potentially all parents
        if (ordinals.ints.length < maxNumOrds) {
          ordinals.grow(maxNumOrds);
        }
        ordinals.ints[ordinals.length++] = ordinal;
      }
      Map<String,BytesRef> categoriesData = getCategoryListData(clp, ordinals, e.getValue());
      
      // add the counting list data
      CountingListStream ts = new CountingListStream();
      ts.setCategoriesData(categoriesData);
      doc.add(new Field(field, ts, COUNTING_LIST_PAYLOAD_TYPE));
      
      // add the drill-down field
      DrillDownStream drillDownStream = getDrillDownStream(e.getValue());
      Field drillDown = new Field(field, drillDownStream, fieldType());
      doc.add(drillDown);
    }
  }

