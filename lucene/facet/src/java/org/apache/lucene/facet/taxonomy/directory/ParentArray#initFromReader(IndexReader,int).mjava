  // Read the parents of the new categories
  private void initFromReader(IndexReader reader, int first) throws IOException {
    if (reader.maxDoc() == first) {
      return;
    }
    
    TermsEnum termsEnum = null;
    DocsAndPositionsEnum positions = null;
    int idx = 0;
    for (AtomicReaderContext context : reader.leaves()) {
      if (context.docBase < first) {
        continue;
      }

      // in general we could call readerCtx.reader().termPositionsEnum(), but that
      // passes the liveDocs. Since we know there are no deletions, the code
      // below may save some CPU cycles.
      termsEnum = context.reader().fields().terms(Consts.FIELD_PAYLOADS).iterator(termsEnum);
      if (!termsEnum.seekExact(Consts.PAYLOAD_PARENT_BYTES_REF, true)) {
        throw new CorruptIndexException("Missing parent stream data for segment " + context.reader());
      }
      positions = termsEnum.docsAndPositions(null /* no deletes in taxonomy */, positions);
      if (positions == null) {
        throw new CorruptIndexException("Missing parent stream data for segment " + context.reader());
      }

      idx = context.docBase;
      int doc;
      while ((doc = positions.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
        doc += context.docBase;
        if (doc == idx) {
          if (positions.freq() == 0) { // shouldn't happen
            throw new CorruptIndexException("Missing parent data for category " + idx);
          }
          
          parentOrdinals[idx++] = positions.nextPosition();
        } else { // this shouldn't happen
          throw new CorruptIndexException("Missing parent data for category " + idx);
        }
      }
      if (idx + 1 < context.reader().maxDoc()) {
        throw new CorruptIndexException("Missing parent data for category " + (idx + 1));
      }
    }
    
    if (idx != reader.maxDoc()) {
      throw new CorruptIndexException("Missing parent data for category " + idx);
    }
  }

