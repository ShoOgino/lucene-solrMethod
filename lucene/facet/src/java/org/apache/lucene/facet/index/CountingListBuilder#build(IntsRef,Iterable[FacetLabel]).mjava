  /**
   * Every returned {@link BytesRef} corresponds to a single partition (as
   * defined by {@link FacetIndexingParams#getPartitionSize()}) and the key
   * denotes the partition ID. When no partitions are defined, the returned map
   * contains only one value.
   * <p>
   * <b>NOTE:</b> the {@code ordinals} array is modified by adding parent
   * ordinals to it. Also, some encoders may sort the array and remove duplicate
   * ordinals. Therefore you may want to invoke this method after you finished
   * processing the array for other purposes.
   */
  @Override
  public Map<String,BytesRef> build(IntsRef ordinals, Iterable<FacetLabel> categories) throws IOException {
    int upto = ordinals.length; // since we may add ordinals to IntsRef, iterate upto original length

    Iterator<FacetLabel> iter = categories.iterator();
    for (int i = 0; i < upto; i++) {
      int ordinal = ordinals.ints[i];
      FacetLabel cp = iter.next();
      OrdinalPolicy op = clp.getOrdinalPolicy(cp.components[0]);
      if (op != OrdinalPolicy.NO_PARENTS) {
        // need to add parents too
        int parent = taxoWriter.getParent(ordinal);
        if (parent > 0) {
          // only do this if the category is not a dimension itself, otherwise, it was just discarded by the 'if' below
          while (parent > 0) {
            ordinals.ints[ordinals.length++] = parent;
            parent = taxoWriter.getParent(parent);
          }
          if (op == OrdinalPolicy.ALL_BUT_DIMENSION) { // discard the last added parent, which is the dimension
            ordinals.length--;
          }
        }
      }
    }
    return ordinalsEncoder.encode(ordinals);
  }

