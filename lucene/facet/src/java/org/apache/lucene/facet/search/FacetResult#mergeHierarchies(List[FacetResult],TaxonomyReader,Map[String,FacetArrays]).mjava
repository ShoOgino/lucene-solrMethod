  /**
   * A utility for merging multiple {@link FacetResult} of the same
   * (hierarchical) dimension into a single {@link FacetResult}, to reconstruct
   * the hierarchy. The results are merged according to the following rules:
   * <ul>
   * <li>If two results share the same dimension (first component in their
   * {@link CategoryPath}), they are merged.
   * <li>If a result is missing ancestors in the other results, e.g. A/B/C but
   * no corresponding A or A/B, these nodes are 'filled' with their label,
   * ordinal and value (obtained from the respective {@link FacetArrays}).
   * <li>If a result does not share a dimension with other results, it is
   * returned as is.
   * </ul>
   * <p>
   * <b>NOTE:</b> the returned results are not guaranteed to be in the same
   * order of the input ones.
   * 
   * @param results
   *          the results to merge
   * @param taxoReader
   *          the {@link TaxonomyReader} to use when creating missing ancestor
   *          nodes
   * @param dimArrays
   *          a mapping from a dimension to the respective {@link FacetArrays}
   *          from which to pull the nodes values
   */
  public static List<FacetResult> mergeHierarchies(List<FacetResult> results, TaxonomyReader taxoReader,
      Map<String, FacetArrays> dimArrays) throws IOException {
    final Map<String, List<FacetResult>> dims = new HashMap<>();
    for (FacetResult fr : results) {
      String dim = fr.getFacetRequest().categoryPath.components[0];
      List<FacetResult> frs = dims.get(dim);
      if (frs == null) {
        frs = new ArrayList<>();
        dims.put(dim, frs);
      }
      frs.add(fr);
    }

    final List<FacetResult> res = new ArrayList<>();
    for (List<FacetResult> frs : dims.values()) {
      FacetResult mergedResult = frs.get(0);
      if (frs.size() > 1) {
        CollectionUtil.introSort(frs, new Comparator<FacetResult>() {
          @Override
          public int compare(FacetResult fr1, FacetResult fr2) {
            return fr1.getFacetRequest().categoryPath.compareTo(fr2.getFacetRequest().categoryPath);
          }
        });
        Map<CategoryPath, FacetResultNode> mergedNodes = new HashMap<>();
        FacetArrays arrays = dimArrays != null ? dimArrays.get(frs.get(0).getFacetRequest().categoryPath.components[0]) : null;
        for (FacetResult fr : frs) {
          FacetResultNode frn = fr.getFacetResultNode();
          FacetResultNode merged = mergedNodes.get(frn.label);
          if (merged == null) {
            CategoryPath parent = frn.label.subpath(frn.label.length - 1);
            FacetResultNode childNode = frn;
            FacetResultNode parentNode = null;
            while (parent.length > 0 && (parentNode = mergedNodes.get(parent)) == null) {
              int parentOrd = taxoReader.getOrdinal(parent);
              double parentValue = arrays != null ? fr.getFacetRequest().getValueOf(arrays, parentOrd) : -1;
              parentNode = new FacetResultNode(parentOrd, parentValue);
              parentNode.label = parent;
              parentNode.subResults = new ArrayList<>();
              parentNode.subResults.add(childNode);
              mergedNodes.put(parent, parentNode);
              childNode = parentNode;
              parent = parent.subpath(parent.length - 1);
            }

            // at least one parent was added, so link the final (existing)
            // parent with the child
            if (parent.length > 0) {
              if (!(parentNode.subResults instanceof ArrayList)) {
                parentNode.subResults = new ArrayList<>(parentNode.subResults);
              }
              parentNode.subResults.add(childNode);
            }

            // for missing FRNs, add new ones with label and value=-1
            // first time encountered this label, add it and all its children to
            // the map.
            mergedNodes.put(frn.label, frn);
            for (FacetResultNode child : frn.subResults) {
              addIfNotExist(mergedNodes, child);
            }
          } else {
            if (!(merged.subResults instanceof ArrayList)) {
              merged.subResults = new ArrayList<>(merged.subResults);
            }
            for (FacetResultNode sub : frn.subResults) {
              // make sure sub wasn't already added
              sub = addIfNotExist(mergedNodes, sub);
              if (!merged.subResults.contains(sub)) {
                merged.subResults.add(sub);
              }
            }
          }
        }
        
        // find the 'first' node to put on the FacetResult root
        CategoryPath min = null;
        for (CategoryPath cp : mergedNodes.keySet()) {
          if (min == null || cp.compareTo(min) < 0) {
            min = cp;
          }
        }
        FacetRequest dummy = new FacetRequest(min, frs.get(0).getFacetRequest().numResults) {
          @Override
          public double getValueOf(FacetArrays arrays, int idx) {
            throw new UnsupportedOperationException("not supported by this request");
          }
          
          @Override
          public FacetArraysSource getFacetArraysSource() {
            throw new UnsupportedOperationException("not supported by this request");
          }
        };
        mergedResult = new FacetResult(dummy, mergedNodes.get(min), -1);
      }
      res.add(mergedResult);
    }
    return res;
  }

