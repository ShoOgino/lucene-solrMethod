  /**
   * Search, sorting by {@link Sort}, and computing
   * drill down and sideways counts.
   */
  public DrillSidewaysResult search(DrillDownQuery query, Query filter, FieldDoc after, int topN, Sort sort,
          boolean doDocScores, boolean doMaxScore) throws IOException {
    if (filter != null) {
      query = new DrillDownQuery(config, filter, query);
    }
    if (sort != null) {
      int limit = searcher.getIndexReader().maxDoc();
      if (limit == 0) {
        limit = 1; // the collector does not alow numHits = 0
      }
      final int fTopN = Math.min(topN, limit);

      if (executor != null) { // We have an executor, let use the multi-threaded version

        final CollectorManager<TopFieldCollector, TopDocs> collectorManager =
                new CollectorManager<TopFieldCollector, TopDocs>() {

                  @Override
                  public TopFieldCollector newCollector() throws IOException {
                    return TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);
                  }

                  @Override
                  public TopDocs reduce(Collection<TopFieldCollector> collectors) throws IOException {
                    final TopDocs[] topDocs = new TopDocs[collectors.size()];
                    int pos = 0;
                    for (TopFieldCollector collector : collectors)
                      topDocs[pos++] = collector.topDocs();
                    return TopDocs.merge(topN, topDocs);
                  }

                };
        ConcurrentDrillSidewaysResult<TopDocs> r = search(query, collectorManager);
        return new DrillSidewaysResult(r.facets, r.collectorResult);

      } else {

        final TopFieldCollector hitCollector =
                TopFieldCollector.create(sort, fTopN, after, true, doDocScores, doMaxScore);
        DrillSidewaysResult r = search(query, hitCollector);
        return new DrillSidewaysResult(r.facets, hitCollector.topDocs());
      }
    } else {
      return search(after, query, topN);
    }
  }

