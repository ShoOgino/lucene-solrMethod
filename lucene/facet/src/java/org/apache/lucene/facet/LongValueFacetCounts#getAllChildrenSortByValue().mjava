  /** Returns all unique values seen, sorted by value.  */
  public FacetResult getAllChildrenSortByValue() {
    List<LabelAndValue> labelValues = new ArrayList<>();

    // compact & sort hash table's arrays by value
    int upto = 0;
    for (int i = 0; i < hashCounts.values.length; i++) {
      if (hashCounts.counts[i] != 0) {
        hashCounts.counts[upto] = hashCounts.counts[i];
        hashCounts.values[upto] = hashCounts.values[i];
        upto++;
      }
    }

    // zero fill all remaining counts so if we are called again we don't mistake these as real values
    Arrays.fill(hashCounts.counts, upto, hashCounts.counts.length, 0);

    assert upto == hashCounts.size : "upto=" + upto + " hashCounts.size=" + hashCounts.size;

    new InPlaceMergeSorter() {
      @Override
      public int compare(int i, int j) {
        return Long.compare(hashCounts.values[i], hashCounts.values[j]);
      }

      @Override
      public void swap(int i, int j) {
        int x = hashCounts.counts[i];
        hashCounts.counts[i] = hashCounts.counts[j];
        hashCounts.counts[j] = x;

        long y = hashCounts.values[j];
        hashCounts.values[j] = hashCounts.values[i];
        hashCounts.values[i] = y;
      }
    }.sort(0, upto);

    boolean countsAdded = false;
    for (int i = 0; i < upto; i++) {
      /*
      if (countsAdded == false && hashCounts.values[i] >= counts.length) {
        countsAdded = true;
        appendCounts(labelValues);
      }
      */

      labelValues.add(new LabelAndValue(Long.toString(hashCounts.values[i]),
                                        hashCounts.counts[i]));
    }

    /*
    if (countsAdded == false) {
      appendCounts(labelValues);
    }
    */

    return new FacetResult(field, new String[0], totCount, labelValues.toArray(new LabelAndValue[0]), labelValues.size());
  }

