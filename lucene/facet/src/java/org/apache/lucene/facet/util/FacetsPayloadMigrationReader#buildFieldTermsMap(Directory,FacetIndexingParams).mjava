  /**
   * A utility method for building the field-to-Term map, given the
   * {@link FacetIndexingParams} and the directory of the index to migrate. The
   * map that will be built will correspond to partitions as well as multiple
   * {@link CategoryListParams}.
   * <p>
   * <b>NOTE:</b> since {@link CategoryListParams} no longer define a
   * {@link Term}, this method assumes that the term used by the different
   * {@link CategoryListParams} is {@link #PAYLOAD_TERM_TEXT}. If this is not
   * the case, then you should build the map yourself, using the terms in your
   * index.
   */
  public static Map<String,Term> buildFieldTermsMap(Directory dir, FacetIndexingParams fip) throws IOException {
    // only add field-Term mapping that will actually have DocValues in the end.
    // therefore traverse the index terms and add what exists. this pertains to
    // multiple CLPs, as well as partitions
    DirectoryReader reader = DirectoryReader.open(dir);
    final Map<String,Term> fieldTerms = new HashMap<String,Term>();
    for (AtomicReaderContext context : reader.leaves()) {
      for (CategoryListParams clp : fip.getAllCategoryListParams()) {
        Terms terms = context.reader().terms(clp.field);
        if (terms != null) {
          TermsEnum te = terms.iterator(null);
          BytesRef termBytes = null;
          while ((termBytes = te.next()) != null) {
            String term = termBytes.utf8ToString();
            if (term.startsWith(PAYLOAD_TERM_TEXT )) {
              if (term.equals(PAYLOAD_TERM_TEXT)) {
                fieldTerms.put(clp.field, new Term(clp.field, term));
              } else {
                fieldTerms.put(clp.field + term.substring(PAYLOAD_TERM_TEXT.length()), new Term(clp.field, term));
              }
            }
          }
        }        
      }
    }
    reader.close();
    return fieldTerms;
  }

