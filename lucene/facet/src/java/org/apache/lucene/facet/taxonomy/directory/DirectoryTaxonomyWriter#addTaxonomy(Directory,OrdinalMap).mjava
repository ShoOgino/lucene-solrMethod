  /**
   * Takes the categories from the given taxonomy directory, and adds the
   * missing ones to this taxonomy. Additionally, it fills the given
   * {@link OrdinalMap} with a mapping from the original ordinal to the new
   * ordinal.
   */
  public void addTaxonomy(Directory taxoDir, OrdinalMap map) throws IOException {
    ensureOpen();
    IndexReader r = DirectoryReader.open(taxoDir);
    try {
      final int size = r.numDocs();
      final OrdinalMap ordinalMap = map;
      ordinalMap.setSize(size);
      CategoryPath cp = new CategoryPath();
      Terms terms = MultiFields.getTerms(r, Consts.FULL);
      TermsEnum te = terms.iterator(null);
      Bits liveDocs = MultiFields.getLiveDocs(r);
      DocsEnum docs = null;
      // we call next() first, to skip the root category which always exists.
      while (te.next() != null) {
        String value = te.term().utf8ToString();
        cp.clear();
        cp.add(value, Consts.DEFAULT_DELIMITER);
        int ordinal = findCategory(cp);
        if (ordinal < 0) {
          // NOTE: call addCategory so that it works well in a multi-threaded
          // environment, in case e.g. a thread just added the category, after
          // the findCategory() call above failed to find it.
          ordinal = addCategory(cp);
        }
        docs = te.docs(liveDocs, docs, false);
        ordinalMap.addMapping(docs.nextDoc(), ordinal);
      }
      // we must add the root ordinal map, so that the map will be complete
      // (otherwise e.g. DiskOrdinalMap may fail because it expects more
      // categories to exist in the file).
      ordinalMap.addMapping(0, 0);
      ordinalMap.addDone();
    } finally {
      r.close();
    }
  }

