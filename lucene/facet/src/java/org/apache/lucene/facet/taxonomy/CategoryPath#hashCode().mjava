  /**
   * Calculate a hashCode for this path, used when a CategoryPath serves as a
   * hash-table key. If two objects are equal(), their hashCodes need to be
   * equal, so like in equal(), hashCode does not consider unused portions of
   * the internal buffers in its calculation.
   * <P>
   * The hash function used is modeled after Java's String.hashCode() - a
   * simple multiplicative hash function with the multiplier 31. The same hash
   * function also appeared in Kernighan & Ritchie's second edition of
   * "The C Programming Language" (1988).
   */
  @Override
  public int hashCode() {
    if (ncomponents == 0) {
      return 0;
    }
    int hash = ncomponents;
    // Unfortunately, Arrays.hashCode() can only calculate a hash code
    // for an entire arrays, and in our case we potentially have unused
    // parts of the arrays that must be ignored, so must use our own loop
    // over the characters. I wish that some future version of Java will
    // add offset and length parameters to Arrays.hashCode (sort of like
    // System.arraycopy()'s parameters).
    for (int i = 0; i < ncomponents; i++) {
      hash = hash * 31 + ends[i];
    }
    int len = ends[ncomponents - 1];
    for (int i = 0; i < len; i++) {
      hash = hash * 31 + chars[i];
    }
    return hash;
  }

