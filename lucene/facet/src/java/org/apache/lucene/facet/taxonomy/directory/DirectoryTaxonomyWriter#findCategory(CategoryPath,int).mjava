  /**
   * Look up the given prefix of the given category in the cache and/or the
   * on-disk storage, returning that prefix's ordinal, or a negative number in
   * case the category does not yet exist in the taxonomy.
   */
  private int findCategory(CategoryPath categoryPath, int prefixLen)
      throws IOException {
    int res = cache.get(categoryPath, prefixLen);
    if (res >= 0 || cacheIsComplete) {
      return res;
    }
    
    cacheMisses.incrementAndGet();
    perhapsFillCache();
    res = cache.get(categoryPath, prefixLen);
    if (res >= 0 || cacheIsComplete) {
      return res;
    }

    initReaderManager();
    
    int doc = -1;
    DirectoryReader reader = readerManager.acquire();
    try {
      TermsEnum termsEnum = null; // reuse
      DocsEnum docs = null; // reuse
      final BytesRef catTerm = new BytesRef(categoryPath.toString(delimiter, prefixLen));
      for (AtomicReaderContext ctx : reader.leaves()) {
        Terms terms = ctx.reader().terms(Consts.FULL);
        if (terms != null) {
          termsEnum = terms.iterator(termsEnum);
          if (termsEnum.seekExact(catTerm, true)) {
            // liveDocs=null because the taxonomy has no deletes
            docs = termsEnum.docs(null, docs, 0 /* freqs not required */);
            // if the term was found, we know it has exactly one document.
            doc = docs.nextDoc() + ctx.docBase;
            break;
          }
        }
      }
    } finally {
      readerManager.release(reader);
    }
    
    if (doc > 0) {
      addToCache(categoryPath, prefixLen, doc);
    }
    return doc;
  }

