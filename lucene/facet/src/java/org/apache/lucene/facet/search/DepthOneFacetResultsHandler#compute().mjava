  @Override
  public final FacetResult compute() throws IOException {
    ParallelTaxonomyArrays arrays = taxonomyReader.getParallelTaxonomyArrays();
    final int[] children = arrays.children();
    final int[] siblings = arrays.siblings();
    
    int rootOrd = taxonomyReader.getOrdinal(facetRequest.categoryPath);
        
    FacetResultNode root = new FacetResultNode(rootOrd, valueOf(rootOrd));
    root.label = facetRequest.categoryPath;
    if (facetRequest.numResults > taxonomyReader.getSize()) {
      // specialize this case, user is interested in all available results
      ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();
      int child = children[rootOrd];
      addSiblings(child, siblings, nodes);
      Collections.sort(nodes, new Comparator<FacetResultNode>() {
        @Override
        public int compare(FacetResultNode o1, FacetResultNode o2) {
          int value = (int) (o2.value - o1.value);
          if (value == 0) {
            value = o2.ordinal - o1.ordinal;
          }
          return value;
        }
      });
      
      root.subResults = nodes;
      return new FacetResult(facetRequest, root, nodes.size());
    }
    
    // since we use sentinel objects, we cannot reuse PQ. but that's ok because it's not big
    PriorityQueue<FacetResultNode> pq = new FacetResultNodeQueue(facetRequest.numResults, true);
    int numSiblings = addSiblings(children[rootOrd], siblings, pq);

    // pop() the least (sentinel) elements
    int pqsize = pq.size();
    int size = numSiblings < pqsize ? numSiblings : pqsize;
    for (int i = pqsize - size; i > 0; i--) { pq.pop(); }

    // create the FacetResultNodes.
    FacetResultNode[] subResults = new FacetResultNode[size];
    for (int i = size - 1; i >= 0; i--) {
      FacetResultNode node = pq.pop();
      node.label = taxonomyReader.getPath(node.ordinal);
      subResults[i] = node;
    }
    root.subResults = Arrays.asList(subResults);
    return new FacetResult(facetRequest, root, numSiblings);
  }

