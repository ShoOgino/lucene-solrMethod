  @Override
  public final FacetResult compute() throws IOException {
    ParallelTaxonomyArrays arrays = taxonomyReader.getParallelTaxonomyArrays();
    final int[] children = arrays.children();
    final int[] siblings = arrays.siblings();
    
    int rootOrd = taxonomyReader.getOrdinal(facetRequest.categoryPath);
        
    FacetResultNode root = new FacetResultNode(rootOrd, resolver.valueOf(rootOrd));
    root.label = facetRequest.categoryPath;
    if (facetRequest.numResults > taxonomyReader.getSize()) {
      // specialize this case, user is interested in all available results
      ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();
      int ordinal = children[rootOrd];
      while (ordinal != TaxonomyReader.INVALID_ORDINAL) {
        double value = resolver.valueOf(ordinal);
        if (value > 0) {
          FacetResultNode node = new FacetResultNode(ordinal, value);
          node.label = taxonomyReader.getPath(ordinal);
          nodes.add(node);
        }
        ordinal = siblings[ordinal];
      }

      CollectionUtil.introSort(nodes, Collections.reverseOrder(new Comparator<FacetResultNode>() {
        @Override
        public int compare(FacetResultNode o1, FacetResultNode o2) {
          return o1.compareTo(o2);
        }
      }));
      
      root.subResults = nodes;
      return new FacetResult(facetRequest, root, nodes.size());
    }
    
    // since we use sentinel objects, we cannot reuse PQ. but that's ok because it's not big
    PriorityQueue<FacetResultNode> pq = new FacetResultNodeQueue(facetRequest.numResults, true);
    int ordinal = children[rootOrd];
    FacetResultNode top = pq.top();
    int numSiblings = 0;
    while (ordinal != TaxonomyReader.INVALID_ORDINAL) {
      double value = resolver.valueOf(ordinal);
      if (value > 0) {
        ++numSiblings;
        if (value > top.value) {
          top.value = value;
          top.ordinal = ordinal;
          top = pq.updateTop();
        }
      }
      ordinal = siblings[ordinal];
    }

    // pop() the least (sentinel) elements
    int pqsize = pq.size();
    int size = numSiblings < pqsize ? numSiblings : pqsize;
    for (int i = pqsize - size; i > 0; i--) { pq.pop(); }

    // create the FacetResultNodes.
    FacetResultNode[] subResults = new FacetResultNode[size];
    for (int i = size - 1; i >= 0; i--) {
      FacetResultNode node = pq.pop();
      node.label = taxonomyReader.getPath(node.ordinal);
      subResults[i] = node;
    }
    root.subResults = Arrays.asList(subResults);
    return new FacetResult(facetRequest, root, numSiblings);
  }

