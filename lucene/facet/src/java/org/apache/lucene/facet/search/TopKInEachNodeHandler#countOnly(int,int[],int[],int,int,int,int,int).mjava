  /**
   * Recursively count <code>ordinal</code>, whose depth is <code>currentDepth</code>, 
   * and all its descendants down to <code>maxDepth</code> (including), 
   * descendants whose value in the count arrays, <code>arrays</code>, is != 0. 
   * The count arrays only includes the current partition, from <code>offset</code>, to (exclusive) 
   * <code>endOffset</code>.
   * It is assumed that <code>ordinal</code> < <code>endOffset</code>, 
   * otherwise, not <code>ordinal</code>, and none of its descendants, reside in
   * the current partition. <code>ordinal</code> < <code>offset</code> is allowed, 
   * as ordinal's descendants might be >= <code>offeset</code>.
   * 
   * @param ordinal a facet ordinal. 
   * @param youngestChild mapping a given ordinal to its youngest child in the taxonomy (of largest ordinal number),
   * or to -1 if has no children.  
   * @param olderSibling  mapping a given ordinal to its older sibling, or to -1
   * @param partitionSize  number of ordinals in the given partition
   * @param offset  the first (smallest) ordinal in the given partition
   * @param endOffset one larger than the largest ordinal that belong to this partition
   * @param currentDepth the depth or ordinal in the TaxonomyTree (relative to rootnode of the facetRequest)
   * @param maxDepth maximal depth of descendants to be considered here (measured relative to rootnode of the 
   * facetRequest).
   * @return the number of nodes, from ordinal down its descendants, of depth <= maxDepth,
   * which reside in the current partition, and whose value != 0
   */
  private int countOnly(int ordinal, int[] youngestChild, int[] olderSibling, int partitionSize, int offset, 
      int endOffset, int currentDepth, int maxDepth) {
    int ret = 0;
    if (offset <= ordinal) {
      // ordinal belongs to the current partition
      if (0 != resolver.valueOf(ordinal % partitionSize)) {
        ret++;
      }
    }
    // now consider children of ordinal, if not too deep
    if (currentDepth >= maxDepth) {
      return ret;
    }

    int yc = youngestChild[ordinal];
    while (yc >= endOffset) {
      yc = olderSibling[yc];
    }
    while (yc > TaxonomyReader.INVALID_ORDINAL) { // assuming this is -1, smaller than any legal ordinal
      ret += countOnly (yc, youngestChild, olderSibling, partitionSize, 
          offset, endOffset, currentDepth+1, maxDepth);
      yc = olderSibling[yc];
    }
    return ret;
  }

