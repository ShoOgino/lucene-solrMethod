  /**
   * Calculate a 64-bit hash function for this path. Unlike
   * {@link #hashCode()}, this method is not part of the Java standard, and is
   * only used if explicitly called by the user.
   * <P>
   * If two objects are equal(), their hash codes need to be equal, so like in
   * {@link #equals(Object)}, longHashCode does not consider unused portions
   * of the internal buffers in its calculation.
   * <P>
   * The hash function used is a simple multiplicative hash function, with the
   * multiplier 65599. While Java's standard multiplier 31 (used in
   * {@link #hashCode()}) gives a good distribution for ASCII strings, it
   * turns out that for foreign-language strings (with 16-bit characters) it
   * gives too many collisions, and a bigger multiplier produces fewer
   * collisions in this case.
   */
  public long longHashCode() {
    if (ncomponents == 0) {
      return 0;
    }
    long hash = ncomponents;
    for (int i = 0; i < ncomponents; i++) {
      hash = hash * 65599 + ends[i];
    }
    int len = ends[ncomponents - 1];
    for (int i = 0; i < len; i++) {
      hash = hash * 65599 + chars[i];
    }
    return hash;
  }

