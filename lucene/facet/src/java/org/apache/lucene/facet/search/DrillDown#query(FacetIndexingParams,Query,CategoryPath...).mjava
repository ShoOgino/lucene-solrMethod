  /**
   * Wraps a given {@link Query} as a drill-down query over the given
   * categories, assuming all are required (e.g. {@code AND}). You can construct
   * a query with different modes (such as {@code OR} or {@code AND} of
   * {@code ORs}) by creating a {@link BooleanQuery} and call this method
   * several times. Make sure to wrap the query in that case by
   * {@link ConstantScoreQuery} and set the boost to 0.0f, so that it doesn't
   * affect scoring.
   * <p>
   * <b>NOTE:</b> {@code baseQuery} can be {@code null}, in which case only the
   * {@link Query} over the categories will is returned.
   */
  public static final Query query(FacetIndexingParams iParams, Query baseQuery, CategoryPath... paths) {
    if (paths == null || paths.length == 0) {
      throw new IllegalArgumentException("Empty category path not allowed for drill down query!");
    }
    
    final Query q;
    if (paths.length == 1) {
      q = new TermQuery(term(iParams, paths[0]));
    } else {
      BooleanQuery bq = new BooleanQuery(true); // disable coord
      for (CategoryPath cp : paths) {
        bq.add(new TermQuery(term(iParams, cp)), Occur.MUST);
      }
      q = bq;
    }

    final ConstantScoreQuery drillDownQuery = new ConstantScoreQuery(q);
    drillDownQuery.setBoost(0.0f);

    if (baseQuery == null) {
      return drillDownQuery;
    } else {
      BooleanQuery res = new BooleanQuery();
      res.add(baseQuery, Occur.MUST);
      res.add(drillDownQuery, Occur.MUST);
      return res;
    }
  }

