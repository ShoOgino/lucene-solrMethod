  @Override
  public synchronized List<FacetResult> getFacetResults() throws IOException {
    try {
      // first, count matching documents' facets
      countFacets();
      
      ParallelTaxonomyArrays arrays = taxoReader.getParallelTaxonomyArrays();

      // compute top-K
      final int[] children = arrays.children();
      final int[] siblings = arrays.siblings();
      List<FacetResult> res = new ArrayList<FacetResult>();
      for (FacetRequest fr : fsp.facetRequests) {
        int rootOrd = taxoReader.getOrdinal(fr.categoryPath);
        if (rootOrd == TaxonomyReader.INVALID_ORDINAL) { // category does not exist
          continue;
        }
        OrdinalPolicy ordinalPolicy = clp.getOrdinalPolicy(fr.categoryPath.components[0]);
        if (ordinalPolicy == OrdinalPolicy.NO_PARENTS) {
          // need to count parents
          counts[rootOrd] += rollupCounts(children[rootOrd], children, siblings);
        }
        
        FacetResultNode root = new FacetResultNode();
        root.ordinal = rootOrd;
        root.label = fr.categoryPath;
        root.value = counts[rootOrd];
        if (fr.getNumResults() > taxoReader.getSize()) {
          // specialize this case, user is interested in all available results
          ArrayList<FacetResultNode> nodes = new ArrayList<FacetResultNode>();
          int child = children[rootOrd];
          while (child != TaxonomyReader.INVALID_ORDINAL) {
            int count = counts[child];
            if (count > 0) {
              FacetResultNode node = new FacetResultNode();
              node.label = taxoReader.getPath(child);
              node.value = count;
              nodes.add(node);
            }
            child = siblings[child];
          }
          Collections.sort(nodes, new Comparator<FacetResultNode>() {
            @Override
            public int compare(FacetResultNode o1, FacetResultNode o2) {
              int value = (int) (o2.value - o1.value);
              if (value == 0) {
                value = o2.ordinal - o1.ordinal;
              }
              return value;
            }
          });
          
          root.subResults = nodes;
          res.add(new FacetResult(fr, root, nodes.size()));
          continue;
        }
        
        // since we use sentinel objects, we cannot reuse PQ. but that's ok because it's not big
        FacetResultNodeQueue pq = new FacetResultNodeQueue(fr.getNumResults(), true);
        FacetResultNode top = pq.top();
        int child = children[rootOrd];
        int numResults = 0; // count the number of results
        while (child != TaxonomyReader.INVALID_ORDINAL) {
          int count = counts[child];
          if (count > top.value) {
            top.value = count;
            top.ordinal = child;
            top = pq.updateTop();
            ++numResults;
          }
          child = siblings[child];
        }

        // pop() the least (sentinel) elements
        int pqsize = pq.size();
        int size = numResults < pqsize ? numResults : pqsize;
        for (int i = pqsize - size; i > 0; i--) { pq.pop(); }

        // create the FacetResultNodes.
        FacetResultNode[] subResults = new FacetResultNode[size];
        for (int i = size - 1; i >= 0; i--) {
          FacetResultNode node = pq.pop();
          node.label = taxoReader.getPath(node.ordinal);
          subResults[i] = node;
        }
        root.subResults = Arrays.asList(subResults);
        res.add(new FacetResult(fr, root, size));
      }
      return res;
    } finally {
      facetArrays.free();
    }
  }

