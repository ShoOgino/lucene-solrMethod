  /**
   * Creates a {@link FacetsAccumulator} for the given facet requests. This
   * method supports {@link RangeAccumulator} and
   * {@link SortedSetDocValuesAccumulator} by dividing the facet requests into
   * {@link RangeFacetRequest} and the rest.
   * <p>
   * If both types of facet requests are used, it returns a
   * {@link MultiFacetsAccumulator} and the facet results returned from
   * {@link #accumulate(List)} may not be in the same order as the given facet
   * requests.
   * 
   * @param fsp
   *          the search params define the facet requests and the
   *          {@link FacetIndexingParams}
   * @param state
   *          the {@link SortedSetDocValuesReaderState} needed for accumulating
   *          the categories
   * @param arrays
   *          the {@link FacetArrays} which the accumulator should use to
   *          store the categories weights in. Can be {@code null}.
   */
  public static FacetsAccumulator create(FacetSearchParams fsp, SortedSetDocValuesReaderState state, FacetArrays arrays) throws IOException {
    if (fsp.indexingParams.getPartitionSize() != Integer.MAX_VALUE) {
      throw new IllegalArgumentException("only default partition size is supported by this method: " + fsp.indexingParams.getPartitionSize());
    }
    
    List<FacetRequest> rangeRequests = new ArrayList<FacetRequest>();
    List<FacetRequest> nonRangeRequests = new ArrayList<FacetRequest>();
    for (FacetRequest fr : fsp.facetRequests) {
      if (fr instanceof RangeFacetRequest) {
        rangeRequests.add(fr);
      } else {
        nonRangeRequests.add(fr);
      }
    }
    
    if (rangeRequests.isEmpty()) {
      return new SortedSetDocValuesAccumulator(state, fsp, arrays);
    } else if (nonRangeRequests.isEmpty()) {
      return new RangeAccumulator(rangeRequests);
    } else {
      FacetSearchParams searchParams = new FacetSearchParams(fsp.indexingParams, nonRangeRequests);
      FacetsAccumulator accumulator = new SortedSetDocValuesAccumulator(state, searchParams, arrays);
      RangeAccumulator rangeAccumulator = new RangeAccumulator(rangeRequests);
      return MultiFacetsAccumulator.wrap(accumulator, rangeAccumulator);
    }
  }

