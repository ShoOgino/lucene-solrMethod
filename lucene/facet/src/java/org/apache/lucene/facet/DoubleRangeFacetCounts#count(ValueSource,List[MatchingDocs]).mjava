  private void count(ValueSource valueSource, List<MatchingDocs> matchingDocs) throws IOException {

    DoubleRange[] ranges = (DoubleRange[]) this.ranges;

    // Compute min & max over all ranges:
    double minIncl = Double.POSITIVE_INFINITY;
    double maxIncl = Double.NEGATIVE_INFINITY;
    for(DoubleRange range : ranges) {
      minIncl = Math.min(minIncl, range.minIncl);
      maxIncl = Math.max(maxIncl, range.maxIncl);
    }

    // TODO: test if this is faster (in the past it was
    // faster to do MatchingDocs on the inside) ... see
    // patches on LUCENE-4965):
    for (MatchingDocs hits : matchingDocs) {
      FunctionValues fv = valueSource.getValues(Collections.emptyMap(), hits.context);
      final int length = hits.bits.length();
      int doc = 0;
      totCount += hits.totalHits;
      while (doc < length && (doc = hits.bits.nextSetBit(doc)) != -1) {
        // Skip missing docs:
        if (fv.exists(doc)) {
          
          double v = fv.doubleVal(doc);
          if (v < minIncl || v > maxIncl) {
            doc++;
            continue;
          }

          // TODO: if all ranges are non-overlapping, we
          // should instead do a bin-search up front
          // (really, a specialized case of the interval
          // tree)
          // TODO: use interval tree instead of linear search:
          for (int j = 0; j < ranges.length; j++) {
            if (ranges[j].accept(v)) {
              counts[j]++;
            }
          }
        }

        doc++;
      }
    }
  }

