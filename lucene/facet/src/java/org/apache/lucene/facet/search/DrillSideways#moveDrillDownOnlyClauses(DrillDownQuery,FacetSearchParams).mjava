  /** Moves any drill-downs that don't have a corresponding
   *  facet request into the baseQuery.  This is unusual,
   *  yet allowed, because typically the added drill-downs are because
   *  the user has clicked on previously presented facets,
   *  and those same facets would be computed this time
   *  around. */
  private static DrillDownQuery moveDrillDownOnlyClauses(DrillDownQuery in, FacetSearchParams fsp) {
    Set<String> facetDims = new HashSet<String>();
    for(FacetRequest fr : fsp.facetRequests) {
      if (fr.categoryPath.length == 0) {
        throw new IllegalArgumentException("all FacetRequests must have CategoryPath with length > 0");
      }
      facetDims.add(fr.categoryPath.components[0]);
    }

    BooleanClause[] clauses = in.getBooleanQuery().getClauses();
    Map<String,Integer> drillDownDims = in.getDims();

    int startClause;
    if (clauses.length == drillDownDims.size()) {
      startClause = 0;
    } else {
      assert clauses.length == 1+drillDownDims.size();
      startClause = 1;
    }

    // Break out drill-down clauses that have no
    // corresponding facet request and move them inside the
    // baseQuery:
    List<Query> nonFacetClauses = new ArrayList<Query>();
    List<Query> facetClauses = new ArrayList<Query>();
    for(int i=startClause;i<clauses.length;i++) {
      Query q = clauses[i].getQuery();
      String dim = in.getDim(q);
      if (!facetDims.contains(dim)) {
        nonFacetClauses.add(q);
      } else {
        facetClauses.add(q);
      }
    }

    if (!nonFacetClauses.isEmpty()) {
      BooleanQuery newBaseQuery = new BooleanQuery(true);
      if (startClause == 1) {
        // Add original basaeQuery:
        newBaseQuery.add(clauses[0].getQuery(), BooleanClause.Occur.MUST);
      }
      for(Query q : nonFacetClauses) {
        newBaseQuery.add(q, BooleanClause.Occur.MUST);
      }

      return new DrillDownQuery(fsp.indexingParams, newBaseQuery, facetClauses);
    } else {
      // No change:
      return in;
    }
  }

