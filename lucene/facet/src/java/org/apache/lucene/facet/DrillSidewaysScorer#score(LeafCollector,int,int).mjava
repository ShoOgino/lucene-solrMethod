  @Override
  public int score(LeafCollector collector, int min, int maxDoc) throws IOException {
    if (min != 0) {
      throw new IllegalArgumentException("min must be 0, got " + min);
    }
    if (maxDoc != Integer.MAX_VALUE) {
      throw new IllegalArgumentException("maxDoc must be Integer.MAX_VALUE");
    }
    //if (DEBUG) {
    //  System.out.println("\nscore: reader=" + context.reader());
    //}
    //System.out.println("score r=" + context.reader());
    FakeScorer scorer = new FakeScorer();
    collector.setScorer(scorer);
    if (drillDownCollector != null) {
      drillDownLeafCollector = drillDownCollector.getLeafCollector(context);
      drillDownLeafCollector.setScorer(scorer);
    } else {
      drillDownLeafCollector = null;
    }
    for (DocsAndCost dim : dims) {
      dim.sidewaysLeafCollector = dim.sidewaysCollector.getLeafCollector(context);
      dim.sidewaysLeafCollector.setScorer(scorer);
    }

    // TODO: if we ever allow null baseScorer ... it will
    // mean we DO score docs out of order ... hmm, or if we
    // change up the order of the conjuntions below
    assert baseScorer != null;

    // Position all scorers to their first matching doc:
    baseScorer.nextDoc();
    int numBits = 0;
    for (DocsAndCost dim : dims) {
      if (dim.disi != null) {
        dim.disi.nextDoc();
      } else if (dim.bits != null) {
        numBits++;
      }
    }

    final int numDims = dims.length;

    Bits[] bits = new Bits[numBits];
    LeafCollector[] bitsSidewaysCollectors = new LeafCollector[numBits];

    DocIdSetIterator[] disis = new DocIdSetIterator[numDims-numBits];
    LeafCollector[] sidewaysCollectors = new LeafCollector[numDims-numBits];
    long drillDownCost = 0;
    int disiUpto = 0;
    int bitsUpto = 0;
    for (int dim=0;dim<numDims;dim++) {
      DocIdSetIterator disi = dims[dim].disi;
      if (dims[dim].bits == null) {
        disis[disiUpto] = disi;
        sidewaysCollectors[disiUpto] = dims[dim].sidewaysLeafCollector;
        disiUpto++;
        if (disi != null) {
          drillDownCost += disi.cost();
        }
      } else {
        bits[bitsUpto] = dims[dim].bits;
        bitsSidewaysCollectors[bitsUpto] = dims[dim].sidewaysLeafCollector;
        bitsUpto++;
      }
    }

    long baseQueryCost = baseScorer.cost();

    /*
    System.out.println("\nbaseDocID=" + baseScorer.docID() + " est=" + estBaseHitCount);
    System.out.println("  maxDoc=" + context.reader().maxDoc());
    System.out.println("  maxCost=" + maxCost);
    System.out.println("  dims[0].freq=" + dims[0].freq);
    if (numDims > 1) {
      System.out.println("  dims[1].freq=" + dims[1].freq);
    }
    */

    if (bitsUpto > 0 || scoreSubDocsAtOnce || baseQueryCost < drillDownCost/10) {
      //System.out.println("queryFirst: baseScorer=" + baseScorer + " disis.length=" + disis.length + " bits.length=" + bits.length);
      doQueryFirstScoring(collector, disis, sidewaysCollectors, bits, bitsSidewaysCollectors);
    } else if (numDims > 1 && (dims[1].disi == null || dims[1].disi.cost() < baseQueryCost/10)) {
      //System.out.println("drillDownAdvance");
      doDrillDownAdvanceScoring(collector, disis, sidewaysCollectors);
    } else {
      //System.out.println("union");
      doUnionScoring(collector, disis, sidewaysCollectors);
    }

    return Integer.MAX_VALUE;
  }

