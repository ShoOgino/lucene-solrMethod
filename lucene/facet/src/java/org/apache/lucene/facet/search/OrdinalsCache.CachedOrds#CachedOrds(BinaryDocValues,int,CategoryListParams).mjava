    /**
     * Creates a new {@link CachedOrds} from the {@link BinaryDocValues}.
     * Assumes that the {@link BinaryDocValues} is not {@code null}.
     */
    public CachedOrds(BinaryDocValues dv, int maxDoc, CategoryListParams clp) {
      final BytesRef buf = new BytesRef();

      offsets = new int[maxDoc + 1];
      int[] ords = new int[maxDoc]; // let's assume one ordinal per-document as an initial size

      // this aggregator is limited to Integer.MAX_VALUE total ordinals.
      int totOrds = 0;
      final IntDecoder decoder = clp.createEncoder().createMatchingDecoder();
      final IntsRef values = new IntsRef(32);
      for (int docID = 0; docID < maxDoc; docID++) {
        offsets[docID] = totOrds;
        dv.get(docID, buf);
        if (buf.length > 0) {
          // this document has facets
          decoder.decode(buf, values);
          if (totOrds + values.length >= ords.length) {
            ords = ArrayUtil.grow(ords, totOrds + values.length + 1);
          }
          for (int i = 0; i < values.length; i++) {
            ords[totOrds++] = values.ints[i];
          }
        }
      }
      offsets[maxDoc] = totOrds;
      
      // if ords array is bigger by more than 10% of what we really need, shrink it
      if ((double) totOrds / ords.length < 0.9) { 
        this.ordinals = new int[totOrds];
        System.arraycopy(ords, 0, this.ordinals, 0, totOrds);
      } else {
        this.ordinals = ords;
      }
    }

