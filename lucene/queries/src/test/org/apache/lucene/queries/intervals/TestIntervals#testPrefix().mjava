  public void testPrefix() throws IOException {
    for (IntervalsSource source : List.of(Intervals.prefix(new BytesRef("p")),
        Intervals.multiterm(PrefixQuery.toAutomaton(new BytesRef("p")), "p*" ) )) {
      checkIntervals(source, "field1", 5, new int[][]{
          {},
          { 0, 0, 1, 1, 3, 3, 4, 4, 6, 6, 7, 7, 10, 10, 27, 27 },
          { 0, 0, 1, 1, 3, 3, 4, 4, 6, 6, 7, 7, 10, 10 },
          { 7, 7 },
          { 0, 0, 1, 1, 3, 3, 4, 4, 6, 6, 7, 7, 10, 10 },
          { 0, 0 }
      });
      MatchesIterator mi = getMatches(source, 1, "field1");
      assertNotNull(mi);
      assertMatch(mi, 0, 0, 0, 5);
      assertMatch(mi, 1, 1, 6, 14);
    }

    for (IntervalsSource noSuch : List.of(Intervals.prefix(new BytesRef("qqq")),
        Intervals.multiterm(PrefixQuery.toAutomaton(new BytesRef("qqq")), "qqq*" ))) {
      checkIntervals(noSuch, "field1", 0, new int[][]{});
    }

    for (IntervalsSource source : List.of(Intervals.prefix(new BytesRef("p"), 1), 
        Intervals.multiterm(PrefixQuery.toAutomaton(new BytesRef("p")), 1, "p*")) ) {
      IllegalStateException e = expectThrows(IllegalStateException.class, () -> {
        for (LeafReaderContext ctx : searcher.getIndexReader().leaves()) {
          source.intervals("field1", ctx);
        }
      });
      assertEquals("Automaton [p*] expanded to too many terms (limit 1)", e.getMessage());
    }
  }

