  static IntervalIterator wrapMatches(MatchesIterator mi, int doc) {
    return new IntervalIterator() {

      State state = State.UNPOSITIONED;

      @Override
      public int start() {
        assert state == State.ITERATING;
        return mi.startPosition();
      }

      @Override
      public int end() {
        assert state == State.ITERATING;
        return mi.endPosition();
      }

      @Override
      public int gaps() {
        assert state == State.ITERATING;
        if (mi instanceof IntervalMatchesIterator) {
          return ((IntervalMatchesIterator)mi).gaps();
        }
        return 0;
      }

      @Override
      public int nextInterval() throws IOException {
        assert state == State.ITERATING;
        if (mi.next()) {
          return mi.startPosition();
        }
        return NO_MORE_INTERVALS;
      }

      @Override
      public float matchCost() {
        return 1;
      }

      @Override
      public int docID() {
        switch (state) {
          case UNPOSITIONED:
            return -1;
          case ITERATING:
            return doc;
          case EXHAUSTED:
        }
        return NO_MORE_DOCS;
      }

      @Override
      public int nextDoc() {
        switch (state) {
          case UNPOSITIONED:
            state = State.ITERATING;
            return doc;
          case ITERATING:
            state = State.EXHAUSTED;
          case EXHAUSTED:
        }
        return NO_MORE_DOCS;
      }

      @Override
      public int advance(int target) {
        if (target == doc) {
          state = State.ITERATING;
          return doc;
        }
        state = State.EXHAUSTED;
        return NO_MORE_DOCS;
      }

      @Override
      public long cost() {
        return 1;
      }
    };
  }

