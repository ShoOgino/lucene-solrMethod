  @Override
  public ValueFiller getValueFiller() {
    //
    // TODO: if we want to support more than one value-filler or a value-filler in conjunction with
    // the FunctionValues, then members like "scorer" should be per ValueFiller instance.
    // Or we can say that the user should just instantiate multiple FunctionValues.
    //
    return new ValueFiller() {
      private final MutableValueFloat mval = new MutableValueFloat();

      @Override
      public MutableValue getValue() {
        return mval;
      }

      @Override
      public void fillValue(int doc) {
        try {
          if (noMatches) {
            mval.value = defVal;
            mval.exists = false;
            return;
          }
          scorer = weight.scorer(readerContext);
          scorerDoc = -1;
          if (scorer==null) {
            noMatches = true;
            mval.value = defVal;
            mval.exists = false;
            return;
          }
          it = scorer.iterator();
          lastDocRequested = doc;

          if (scorerDoc < doc) {
            scorerDoc = it.advance(doc);
          }

          if (scorerDoc > doc) {
            // query doesn't match this document... either because we hit the
            // end, or because the next doc is after this doc.
            mval.value = defVal;
            mval.exists = false;
            return;
          }

          // a match!
          mval.value = scorer.score();
          mval.exists = true;
        } catch (IOException e) {
          throw new RuntimeException("caught exception in QueryDocVals("+q+") doc="+doc, e);
        }
      }
    };
  }

