  @Override
  public synchronized SortedSetDocValues getSortedSet(FieldInfo field) throws IOException {
    SortedSetRawValues instance = sortedSetInstances.get(field.name);
    final SortedSetEntry entry = sortedSets.get(field.name);
    if (instance == null) {
      // Lazy load
      instance = loadSortedSet(entry);
      sortedSetInstances.put(field.name, instance);
    }

    if (instance.docToOrdAddress == null) {
      SortedDocValues sorted = newSortedInstance(instance.ords.numerics, getBinary(field), entry.values.count);
      return DocValues.singleton(sorted);
    } else {
      final NumericDocValues docToOrdAddress = instance.docToOrdAddress.numerics;
      final NumericDocValues ords = instance.ords.numerics;
      final BinaryDocValues values = getBinary(field);
      
      // Must make a new instance since the iterator has state:
      return new RandomAccessOrds() {
        int ordStart;
        int ordUpto;
        int ordLimit;
        
        @Override
        public long nextOrd() {
          if (ordUpto == ordLimit) {
            return NO_MORE_ORDS;
          } else {
            return ords.get(ordUpto++);
          }
        }
        
        @Override
        public void setDocument(int docID) {
          ordStart = ordUpto = (int) docToOrdAddress.get(docID);
          ordLimit = (int) docToOrdAddress.get(docID+1);
        }
        
        @Override
        public BytesRef lookupOrd(long ord) {
          return values.get((int) ord);
        }
        
        @Override
        public long getValueCount() {
          return entry.values.count;
        }
        
        @Override
        public long ordAt(int index) {
          return ords.get(ordStart + index);
        }
        
        @Override
        public int cardinality() {
          return ordLimit - ordStart;
        }
        
        // Leave lookupTerm to super's binary search
        
        // Leave termsEnum to super
      };
    }
  }

