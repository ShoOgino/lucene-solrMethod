  @Override
  public BlockTermState writeTerm(BytesRef term, TermsEnum termsEnum, FixedBitSet docsSeen) throws IOException {

    // First pass: figure out whether we should pulse this term
    long posCount = 0;

    if (fieldHasPositions == false) {
      // No positions:
      docsEnum = termsEnum.docs(null, docsEnum, enumFlags);
      assert docsEnum != null;
      while (posCount <= maxPositions) {
        if (docsEnum.nextDoc() == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        posCount++;
      }
    } else {
      posEnum = termsEnum.docsAndPositions(null, posEnum, enumFlags);
      assert posEnum != null;
      while (posCount <= maxPositions) {
        if (posEnum.nextDoc() == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        posCount += posEnum.freq();
      }
    }

    if (posCount == 0) {
      // All docs were deleted
      return null;
    }

    // Second pass: write postings
    if (posCount > maxPositions) {
      // Too many positions; do not pulse.  Just lset
      // wrapped postingsWriter encode the postings:

      PulsingTermState state = new PulsingTermState();
      state.wrappedState = wrappedPostingsWriter.writeTerm(term, termsEnum, docsSeen);
      state.docFreq = state.wrappedState.docFreq;
      state.totalTermFreq = state.wrappedState.totalTermFreq;
      return state;
    } else {
      // Pulsed:
      if (fieldHasPositions == false) {
        docsEnum = termsEnum.docs(null, docsEnum, enumFlags);
      } else {
        posEnum = termsEnum.docsAndPositions(null, posEnum, enumFlags);
        docsEnum = posEnum;
      }
      assert docsEnum != null;

      // There were few enough total occurrences for this
      // term, so we fully inline our postings data into
      // terms dict, now:

      // TODO: it'd be better to share this encoding logic
      // in some inner codec that knows how to write a
      // single doc / single position, etc.  This way if a
      // given codec wants to store other interesting
      // stuff, it could use this pulsing codec to do so

      int lastDocID = 0;
      int lastPayloadLength = -1;
      int lastOffsetLength = -1;

      int docFreq = 0;
      long totalTermFreq = 0;
      while (true) {
        int docID = docsEnum.nextDoc();
        if (docID == DocsEnum.NO_MORE_DOCS) {
          break;
        }
        docsSeen.set(docID);

        int delta = docID - lastDocID;
        lastDocID = docID;

        docFreq++;

        if (fieldHasFreqs) {
          int freq = docsEnum.freq();
          totalTermFreq += freq;

          if (freq == 1) {
            buffer.writeVInt((delta << 1) | 1);
          } else {
            buffer.writeVInt(delta << 1);
            buffer.writeVInt(freq);
          }

          if (fieldHasPositions) {
            int lastPos = 0;
            int lastOffset = 0;
            for(int posIDX=0;posIDX<freq;posIDX++) {
              int pos = posEnum.nextPosition();
              int posDelta = pos - lastPos;
              lastPos = pos;
              int payloadLength;
              BytesRef payload;
              if (fieldHasPayloads) {
                payload = posEnum.getPayload();
                payloadLength = payload == null ? 0 : payload.length;
                if (payloadLength != lastPayloadLength) {
                  buffer.writeVInt((posDelta << 1)|1);
                  buffer.writeVInt(payloadLength);
                  lastPayloadLength = payloadLength;
                } else {
                  buffer.writeVInt(posDelta << 1);
                }
              } else {
                payloadLength = 0;
                payload = null;
                buffer.writeVInt(posDelta);
              }

              if (fieldHasOffsets) {
                int startOffset = posEnum.startOffset();
                int endOffset = posEnum.endOffset();
                int offsetDelta = startOffset - lastOffset;
                int offsetLength = endOffset - startOffset;
                if (offsetLength != lastOffsetLength) {
                  buffer.writeVInt(offsetDelta << 1 | 1);
                  buffer.writeVInt(offsetLength);
                } else {
                  buffer.writeVInt(offsetDelta << 1);
                }
                lastOffset = startOffset;
                lastOffsetLength = offsetLength;             
              }
            
              if (payloadLength > 0) {
                assert fieldHasPayloads;
                assert payload != null;
                buffer.writeBytes(payload.bytes, payload.offset, payload.length);
              }
            }
          }
        } else {
          buffer.writeVInt(delta);
        }
      }
      
      PulsingTermState state = new PulsingTermState();
      state.bytes = new byte[(int) buffer.getFilePointer()];
      state.docFreq = docFreq;
      state.totalTermFreq = fieldHasFreqs ? totalTermFreq : -1;
      buffer.writeTo(state.bytes, 0);
      buffer.reset();
      return state;
    }
  }

