  // note: this might not be the most efficient... but its fairly simple
  @Override
  public void addSortedSetField(FieldInfo field, Iterable<BytesRef> values, final Iterable<Number> docToOrdCount, final Iterable<Number> ords) throws IOException {
    meta.writeVInt(field.number);
    meta.writeByte(SORTED_SET);

    // First write docToOrdCounts, except we "aggregate" the
    // counts so they turn into addresses, and add a final
    // value = the total aggregate:
    addNumericFieldValues(field, new Iterable<Number>() {

        // Just aggregates the count values so they become
        // "addresses", and adds one more value in the end
        // (the final sum):

        @Override
        public Iterator<Number> iterator() {
          final Iterator<Number> iter = docToOrdCount.iterator();

          return new Iterator<Number>() {

            long sum;
            boolean ended;

            @Override
            public boolean hasNext() {
              return iter.hasNext() || !ended;
            }

            @Override
            public Number next() {
              long toReturn = sum;

              if (iter.hasNext()) {
                Number n = iter.next();
                if (n != null) {
                  sum += n.longValue();
                }
              } else if (!ended) {
                ended = true;
              } else {
                assert false;
              }

              return toReturn;
            }

            @Override
            public void remove() {
              throw new UnsupportedOperationException();
            }
          };
        }
      });

    // Write ordinals for all docs, appended into one big
    // numerics:
    addNumericFieldValues(field, ords);
      
    // write the values as binary
    addBinaryFieldValues(field, values);
  }

