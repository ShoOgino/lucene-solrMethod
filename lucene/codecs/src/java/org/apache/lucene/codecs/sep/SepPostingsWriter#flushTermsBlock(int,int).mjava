  @Override
  public void flushTermsBlock(int start, int count) throws IOException {
    //System.out.println("SEPW: flushTermsBlock: start=" + start + " count=" + count + " pendingTerms.size()=" + pendingTerms.size() + " termsOut.fp=" + termsOut.getFilePointer());
    assert indexBytesWriter.getFilePointer() == 0;
    final int absStart = pendingTerms.size() - start;
    final List<PendingTerm> slice = pendingTerms.subList(absStart, absStart+count);

    if (count == 0) {
      termsOut.writeByte((byte) 0);
      return;
    }

    long lastSkipFP = 0;
    long lastPayloadFP = 0;

    boolean isFirstTerm = true;

    for(int idx=0;idx<slice.size();idx++) {
      if (isFirstTerm) {
        lastState = slice.get(idx);
      }
      final PendingTerm t = slice.get(idx);
      //System.out.println(" last(pure): doc="+lastState.docIndex +" frq=" + lastState.freqIndex+" pos="+lastState.posIndex);
      lastState.docIndex.copyFrom(t.docIndex, false);
      lastState.docIndex.write(indexBytesWriter, isFirstTerm);
      //System.out.print(" doc=" + lastState.docIndex + " 1FP=" + indexBytesWriter.getFilePointer());
      if (indexOptions != IndexOptions.DOCS_ONLY) {
        lastState.freqIndex.copyFrom(t.freqIndex, false);
        lastState.freqIndex.write(indexBytesWriter, isFirstTerm);
        //System.out.print(" frq=" + lastState.freqIndex + " 2FP=" + indexBytesWriter.getFilePointer());
        if (indexOptions == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) {
          lastState.posIndex.copyFrom(t.posIndex, false);
          lastState.posIndex.write(indexBytesWriter, isFirstTerm);
          //System.out.print(" pos=" + lastState.posIndex + " 3FP=" + indexBytesWriter.getFilePointer());
          if (storePayloads) {
            if (isFirstTerm) {
              //System.out.print(" payFP=" + (t.payloadFP));
              indexBytesWriter.writeVLong(t.payloadFP);
            } else {
              //System.out.print(" payFP=" + (t.payloadFP - lastPayloadFP));
              indexBytesWriter.writeVLong(t.payloadFP - lastPayloadFP);
            }
            lastPayloadFP = t.payloadFP;
          }
        }
      }
      if (t.skipFP != -1) {
        if (isFirstTerm) {
          //System.out.print(" a.skipFP=" + (t.skipFP));
          indexBytesWriter.writeVLong(t.skipFP);
        } else {
          //System.out.print(" b.skipFP=" + (t.skipFP - lastSkipFP));
          indexBytesWriter.writeVLong(t.skipFP - lastSkipFP);
        }
        lastSkipFP = t.skipFP;
      }
      //System.out.println();
      //System.out.println(" last(copy): doc="+lastState.docIndex +" frq=" + lastState.freqIndex+" pos="+lastState.posIndex);
      isFirstTerm = false;
    }

    termsOut.writeVLong((int) indexBytesWriter.getFilePointer());
    indexBytesWriter.writeTo(termsOut);
    indexBytesWriter.reset();
    slice.clear();
  }

