      @Override
      public Source loadDirectSource() throws IOException {
        DocValues.Type dvType = field.fieldInfo.getDocValuesType();
        final IndexInput in = data.clone();
        final BytesRef scratch = new BytesRef();
        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));
        final ParsePosition pos = new ParsePosition(0);

        if (DocValues.isNumber(dvType)) {
          return new Source(dvType) {
            @Override
            public long getInt(int docID) {
              try {
                // nocommit bounds check docID?  spooky
                // because if we don't you can maybe get
                // value from the wrong field ...
                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);
                SimpleTextUtil.readLine(in, scratch);
                return decoder.parse(scratch.utf8ToString(), pos).longValue();
              } catch (IOException ioe) {
                throw new RuntimeException(ioe);
              }
            }
          };
        } else if (DocValues.isBytes(dvType)) {
          return new Source(dvType) {
            @Override
            public BytesRef getBytes(int docID, BytesRef bytesIn) {
              try {
                // nocommit bounds check docID?  spooky
                // because if we don't you can maybe get
                // value from the wrong field ...
                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);
                SimpleTextUtil.readLine(in, scratch);
                assert StringHelper.startsWith(scratch, LENGTH);
                int len;
                try {
                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
                } catch (ParseException pe) {
                  throw new RuntimeException(pe);
                }
                byte[] bytes = new byte[len];
                in.readBytes(bytes, 0, bytes.length);
                // nocommit MUST i reuse the incoming
                // arg....?  we should clarify semantics
                return new BytesRef(bytes);
              } catch (IOException ioe) {
                throw new RuntimeException(ioe);
              }
            }
          };
        } else if (DocValues.isSortedBytes(dvType)) {
          // nocommit
          return null;
        }
        // nocommit
        return null;
      }

