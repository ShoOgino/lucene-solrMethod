      @Override
      public Source loadDirectSource() throws IOException {
        DocValues.Type dvType = field.fieldInfo.getDocValuesType();
        final IndexInput in = data.clone();
        final BytesRef scratch = new BytesRef();
        final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));

        if (DocValues.isNumber(dvType)) {
          decoder.setParseBigDecimal(true);
          return new Source(dvType) {
            @Override
            public long getInt(int docID) {
              try {
                // nocommit bounds check docID?  spooky
                // because if we don't you can maybe get
                // value from the wrong field ...
                in.seek(field.dataStartFilePointer + (1+field.pattern.length())*docID);
                SimpleTextUtil.readLine(in, scratch);
                //System.out.println("parsing delta: " + scratch.utf8ToString());
                BigDecimal bd;
                try {
                  bd = (BigDecimal) decoder.parse(scratch.utf8ToString());
                } catch (ParseException pe) {
                  CorruptIndexException e = new CorruptIndexException("failed to parse BigDecimal value");
                  e.initCause(pe);
                  throw e;
                }
                return BigInteger.valueOf(field.minValue).add(bd.toBigIntegerExact()).longValue();
              } catch (IOException ioe) {
                throw new RuntimeException(ioe);
              }
            }
          };
        } else if (DocValues.isBytes(dvType)) {
          return new Source(dvType) {
            @Override
            public BytesRef getBytes(int docID, BytesRef result) {
              try {
                // nocommit bounds check docID?  spooky
                // because if we don't you can maybe get
                // value from the wrong field ...
                in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);
                SimpleTextUtil.readLine(in, scratch);
                assert StringHelper.startsWith(scratch, LENGTH);
                int len;
                try {
                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
                } catch (ParseException pe) {
                  // nocommit add message
                  CorruptIndexException e = new CorruptIndexException("failed to parse int length");
                  e.initCause(pe);
                  throw e;
                }
                result.bytes = new byte[len];
                result.offset = 0;
                result.length = len;
                in.readBytes(result.bytes, 0, len);
                return result;
              } catch (IOException ioe) {
                // nocommit should .get() just throw IOE...
                throw new RuntimeException(ioe);
              }
            }
          };
        } else if (DocValues.isSortedBytes(dvType)) {

          final DecimalFormat ordDecoder = new DecimalFormat(field.ordPattern, new DecimalFormatSymbols(Locale.ROOT));

          return new SortedSource(dvType, BytesRef.getUTF8SortedAsUnicodeComparator()) {
            @Override
            public int ord(int docID) {
              try {
                in.seek(field.dataStartFilePointer + field.numValues * (9 + field.pattern.length() + field.maxLength) + (1 + field.ordPattern.length()) * docID);
                SimpleTextUtil.readLine(in, scratch);
                try {
                  return ordDecoder.parse(scratch.utf8ToString()).intValue();
                } catch (ParseException pe) {
                  CorruptIndexException e = new CorruptIndexException("failed to parse ord");
                  e.initCause(pe);
                  throw e;
                }
              } catch (IOException ioe) {
                // nocommit should .get() just throw IOE...
                throw new RuntimeException(ioe);
              }
            }

            @Override
            public BytesRef getByOrd(int ord, BytesRef result) {
              try {
                in.seek(field.dataStartFilePointer + ord * (9 + field.pattern.length() + field.maxLength));
                SimpleTextUtil.readLine(in, scratch);
                assert StringHelper.startsWith(scratch, LENGTH);
                int len;
                try {
                  len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
                } catch (ParseException pe) {
                  CorruptIndexException e = new CorruptIndexException("failed to parse int length");
                  e.initCause(pe);
                  throw e;
                }
                result.bytes = new byte[len];
                result.offset = 0;
                result.length = len;
                in.readBytes(result.bytes, 0, len);
                return result;
              } catch (IOException ioe) {
                // nocommit should .get() just throw IOE...
                throw new RuntimeException(ioe);
              }
            }

            @Override
            public int getValueCount() {
              return field.numValues;
            }

            @Override
            public PackedInts.Reader getDocToOrd() {
              return null;
            }
          };
        } else if (DocValues.isFloat(dvType)) {
          // nocommit
          return null;
        } else {
          throw new AssertionError();
        }
      }

