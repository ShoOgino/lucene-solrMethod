    @Override
    public BinaryDocValuesConsumer addBinaryField(FieldInfo field, boolean fixedLength, final int maxLength) throws IOException {
      assert fieldSeen(field.name);
      assert DocValues.isBytes(field.getDocValuesType());
      assert !isNorms;
      writeFieldEntry(field);
      // write fixedlength
      SimpleTextUtil.write(data, FIXEDLENGTH);
      SimpleTextUtil.write(data, Boolean.toString(fixedLength), scratch);
      SimpleTextUtil.writeNewline(data);
      // write maxLength
      SimpleTextUtil.write(data, MAXLENGTH);
      SimpleTextUtil.write(data, Integer.toString(maxLength), scratch);
      SimpleTextUtil.writeNewline(data);
      
      int maxBytesLength = Long.toString(maxLength).length();
      StringBuilder sb = new StringBuilder();
      for (int i = 0; i < maxBytesLength; i++) {
        sb.append('0');
      }
      // write our pattern for encoding lengths
      SimpleTextUtil.write(data, PATTERN);
      SimpleTextUtil.write(data, sb.toString(), scratch);
      SimpleTextUtil.writeNewline(data);
      final DecimalFormat encoder = new DecimalFormat(sb.toString(), new DecimalFormatSymbols(Locale.ROOT));
      
      return new BinaryDocValuesConsumer() {
        int numDocsWritten = 0;
        
        @Override
        public void add(BytesRef value) throws IOException {
          // write length
          SimpleTextUtil.write(data, LENGTH);
          SimpleTextUtil.write(data, encoder.format(value.length), scratch);
          SimpleTextUtil.writeNewline(data);
          
          // write bytes -- don't use SimpleText.write
          // because it escapes:
          data.writeBytes(value.bytes, value.offset, value.length);

          // pad to fit
          for (int i = value.length; i < maxLength; i++) {
            data.writeByte((byte)' ');
          }
          SimpleTextUtil.writeNewline(data);
          numDocsWritten++;
        }

        @Override
        public void finish() throws IOException {
          assert numDocs == numDocsWritten;
        }
      };
    }

