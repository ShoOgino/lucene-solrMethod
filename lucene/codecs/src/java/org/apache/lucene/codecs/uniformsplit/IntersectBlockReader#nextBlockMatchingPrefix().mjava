  /**
   * Find the next block that appears to contain terms that could match the automata.
   * The prefix is the primary clue.  Returns true if at one, or false for no more (EOF).
   */
  protected boolean nextBlockMatchingPrefix() throws IOException {
    if (beyondCommonPrefix) {
      return false; // EOF
    }

    IndexDictionary.Browser browser = getOrCreateDictionaryBrowser();

    do {

      // Get next block key (becomes in effect the current blockKey)
      BytesRef blockKey = browser.nextKey();
      if (blockKey == null) {
        return false; // EOF
      }

      blockPrefixLen = browser.getBlockPrefixLen();
      blockPrefixRunAutomatonState = runAutomatonForState(blockKey.bytes, blockKey.offset, blockPrefixLen, 0);

      // We may have passed commonPrefix  (a short-circuit optimization).
      if (isBeyondCommonPrefix(blockKey)) {
        return false; // EOF
      }

      if (blockPrefixRunAutomatonState >= 0) {
        break; // a match
      }

      //
      // This block doesn't match.
      //

      seekTerm = null; // we're moving on to another block, and seekTerm is before it.

      // Should we simply get the next key (linear mode) or try to seek?
      if (nextStringCalculator.isLinearState(blockKey)) {
        continue;
      }

      // Maybe the next block's key matches?  We have to check this before calling nextStringCalculator.
      BytesRef peekKey = browser.peekKey();
      if (peekKey == null) {
        return false; // EOF
      }
      if (runAutomatonForState(peekKey.bytes, peekKey.offset, peekKey.length, 0) >= 0) {
        continue; // yay; it matched.  Continue to actually advance to it.  This is rare?
      }

      // Seek to a block by calculating the next term to match the automata *following* peekKey.
      this.seekTerm = nextStringCalculator.nextSeekTerm(browser.peekKey());
      if (seekTerm == null) {
        return false; // EOF
      }
      browser.seekBlock(seekTerm);
      //continue

    } while (true); // while not a match

    // A match!

    //NOTE: we could determine if this automata has a prefix for this specific block (longer than the commonPrefix).
    //  If we see it, we could set it as the seekTerm and we could also exit the block early if we get past this prefix
    //  and runAutomatonFromPrefix would start from this prefix.  Smiley tried but benchmarks were not favorable to it.

    initializeHeader(null, browser.getBlockFilePointer());

    return true;
  }

