    @Override
    public BinaryDocValues getBinary(FieldInfo fieldInfo) throws IOException {
      final OneField field = fields.get(fieldInfo.name);

      // SegmentCoreReaders already verifies this field is
      // valid:
      assert field != null;

      final IndexInput in = data;
      final BytesRef scratch = new BytesRef();
      final DecimalFormat decoder = new DecimalFormat(field.pattern, new DecimalFormatSymbols(Locale.ROOT));

      return new BinaryDocValues() {
        @Override
        public void get(int docID, BytesRef result) {
          try {
            if (docID < 0 || docID >= maxDoc) {
              throw new IndexOutOfBoundsException("docID must be 0 .. " + (maxDoc-1) + "; got " + docID);
            }
            in.seek(field.dataStartFilePointer + (9+field.pattern.length() + field.maxLength)*docID);
            SimpleTextUtil.readLine(in, scratch);
            assert StringHelper.startsWith(scratch, LENGTH);
            int len;
            try {
              len = decoder.parse(new String(scratch.bytes, scratch.offset + LENGTH.length, scratch.length - LENGTH.length, "UTF-8")).intValue();
            } catch (ParseException pe) {
              CorruptIndexException e = new CorruptIndexException("failed to parse int length");
              e.initCause(pe);
              throw e;
            }
            result.bytes = new byte[len];
            result.offset = 0;
            result.length = len;
            in.readBytes(result.bytes, 0, len);
          } catch (IOException ioe) {
            throw new RuntimeException(ioe);
          }
        }

        @Override
        public int size() {
          return maxDoc;
        }

        @Override
        public boolean isFixedLength() {
          return field.fixedLength;
        }

        @Override
        public int maxLength() {
          return field.maxLength;
        }
      };
    }

