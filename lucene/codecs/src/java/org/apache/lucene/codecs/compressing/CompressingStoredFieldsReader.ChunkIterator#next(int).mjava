    /**
     * Go to the chunk containing the provided doc ID.
     */
    void next(int doc) throws IOException {
      assert doc >= docBase + chunkDocs : doc + " " + docBase + " " + chunkDocs;
      // try next chunk
      int bitsPerValue = readHeader();
      if (docBase + chunkDocs <= doc) {
        // doc is not in the next chunk, use seek to skip to the next document chunk
        fieldsStream.seek(indexReader.getStartPointer(doc));
        bitsPerValue = readHeader();
      }
      if (doc < docBase
          || doc >= docBase + chunkDocs) {
        throw new CorruptIndexException("Corrupted: docID=" + doc
            + ", docBase=" + docBase + ", chunkDocs=" + chunkDocs);
      }

      // decode lengths
      if (lengths.length < chunkDocs) {
        lengths = new int[ArrayUtil.oversize(chunkDocs, 4)];
      }
      final PackedInts.ReaderIterator iterator = PackedInts.getReaderIteratorNoHeader(fieldsStream, PackedInts.Format.PACKED, packedIntsVersion, chunkDocs, bitsPerValue, 0);
      for (int i = 0; i < chunkDocs; ++i) {
        lengths[i] = (int) iterator.next();
      }
    }

