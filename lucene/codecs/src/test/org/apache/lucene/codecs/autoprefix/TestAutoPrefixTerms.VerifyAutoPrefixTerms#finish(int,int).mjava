    public void finish(int expectedNumHits, int maxPrefixCount) {

      if (maxPrefixCount != -1) {
        // Auto-prefix terms were used in this test
        long allowedMaxTerms;

        if (bounds.length == 1) {
          // Simple prefix query: we should never see more than maxPrefixCount terms, except for the empty string:
          if (bounds[0].length == 0) {
            allowedMaxTerms = Integer.MAX_VALUE;
          } else {
            allowedMaxTerms = maxPrefixCount;
          }
        } else {
          // Trickier: we need to allow for maxPrefixTerms for each different leading byte in the min and max:
          assert bounds.length == 2;
          BytesRef minTerm = bounds[0];
          BytesRef maxTerm = bounds[1];

          int commonPrefix = 0;
          for(int i=0;i<minTerm.length && i<maxTerm.length;i++) {
            if (minTerm.bytes[minTerm.offset+i] != maxTerm.bytes[maxTerm.offset+i]) {
              commonPrefix = i;
              break;
            }
          }

          allowedMaxTerms = maxPrefixCount * (long) ((minTerm.length-commonPrefix) + (maxTerm.length-commonPrefix));
          if (commonPrefix == 0) {
            int min;
            if (minTerm.length == 0) {
              min = 0;
            } else {
              min = minTerm.bytes[minTerm.offset] & 0xff;
            }
            int max;
            if (maxTerm.length == 0) {
              max = 0;
            } else {
              max = maxTerm.bytes[maxTerm.offset] & 0xff;
            }
            if (max > min) {
              // When maxPrefixCount is small (< 16), each byte of the term can require more than one "level" of auto-prefixing:
              // NOTE: this is still only approximate ... it's tricky to get a closed form max bound that's "tight"
              allowedMaxTerms += MathUtil.log(max-min, maxPrefixCount);
            }
          }
        }

        assertTrue("totTermCount=" + totTermCount + " is > allowedMaxTerms=" + allowedMaxTerms, totTermCount <= allowedMaxTerms);
      }

      assertEquals(expectedNumHits, allHits.cardinality());
      int sum = 0;
      for(Map.Entry<BytesRef,Integer> ent : prefixCounts.entrySet()) {

        BytesRef prefix = ent.getKey();
        if (VERBOSE) {
          System.out.println("  verify prefix=" + TestUtil.bytesRefToString(prefix) + " count=" + ent.getValue());
        }

        if (maxPrefixCount != -1) {
          // Auto-prefix terms were used in this test

          int sumLeftoverSuffix = 0;
          for(BytesRef bound : bounds) {

            int minSharedLength = Math.min(bound.length, prefix.length);
            int commonPrefix = minSharedLength;
            for(int i=0;i<minSharedLength;i++) {
              if (bound.bytes[bound.offset+i] != prefix.bytes[prefix.offset+i]) {
                commonPrefix = i;
                break;
              }
            }
            sumLeftoverSuffix += bound.length - commonPrefix;
          }

          long limit = (1+sumLeftoverSuffix) * (long) maxPrefixCount;

          assertTrue("maxPrefixCount=" + maxPrefixCount + " prefix=" + prefix + " sumLeftoverSuffix=" + sumLeftoverSuffix + " limit=" + limit + " vs actual=" +ent.getValue(),
                     ent.getValue() <= limit);
        }

        sum += ent.getValue();
      }

      // Make sure no test bug:
      assertEquals(totPrefixCount, sum);
    }

