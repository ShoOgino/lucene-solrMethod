  // Numbers in a restricted range, encoded in decimal, left-0-padded:
  public void testBasicNumericRanges() throws Exception {
    Directory dir = newDirectory();
    IndexWriterConfig iwc = new IndexWriterConfig(new MockAnalyzer(random()));
    iwc.setCodec(codec);
    IndexWriter w = new IndexWriter(dir, iwc);
    int numTerms = TestUtil.nextInt(random(), 3000, 50000);
    Set<String> terms = new HashSet<>();
    int digits = TestUtil.nextInt(random(), 5, 10);
    int maxValue = 1;
    for(int i=0;i<digits;i++) {
      maxValue *= 10;
    }
    String format = "%0" + digits + "d";
    while (terms.size() < numTerms) {
      terms.add(String.format(Locale.ROOT, format, random().nextInt(maxValue)));
    }

    for(String term : terms) {
      Document doc = new Document();
      doc.add(new StringField("field", term, Field.Store.NO));
      doc.add(new NumericDocValuesField("field", Long.parseLong(term)));
      w.addDocument(doc);
    }

    if (VERBOSE) System.out.println("\nTEST: now optimize");
    if (random().nextBoolean()) {
      w.forceMerge(1);
    }

    if (VERBOSE) System.out.println("\nTEST: now done");
    IndexReader r = DirectoryReader.open(w);

    List<String> sortedTerms = new ArrayList<>(terms);
    Collections.sort(sortedTerms);

    if (VERBOSE) {
      System.out.println("TEST: sorted terms:");
      int idx = 0;
      for(String term : sortedTerms) {
        System.out.println(idx + ": " + term);
        idx++;
      }
    }

    int iters = atLeast(100);
    for(int iter=0;iter<iters;iter++) {
      int min, max;
      while (true) {
        min = random().nextInt(maxValue);
        max = random().nextInt(maxValue);
        if (min == max) {
          continue;
        } else if (min > max) {
          int x = min;
          min = max;
          max = x;
        }
        break;
      }
      
      if (VERBOSE) {
        System.out.println("\nTEST: iter=" + iter + " min=" + min + " max=" + max);
      }

      boolean minInclusive = random().nextBoolean();
      boolean maxInclusive = random().nextBoolean();
      BytesRef minTerm = new BytesRef(String.format(Locale.ROOT, format, min));
      BytesRef maxTerm = new BytesRef(String.format(Locale.ROOT, format, max));
      CompiledAutomaton ca = new CompiledAutomaton(Automata.makeBinaryInterval(minTerm, minInclusive, maxTerm, maxInclusive),
                                                   true, false, Integer.MAX_VALUE, true);

      TermsEnum te = ca.getTermsEnum(MultiFields.getTerms(r, "field"));
      NumericDocValues docValues = MultiDocValues.getNumericValues(r, "field");
      PostingsEnum postingsEnum = null;

      VerifyAutoPrefixTerms verifier = new VerifyAutoPrefixTerms(r.maxDoc(), minTerm, maxTerm);

      while (te.next() != null) {
        if (VERBOSE) {
          System.out.println("  got term=" + te.term().utf8ToString());
        }
        verifier.sawTerm(te.term());
        postingsEnum = te.postings(postingsEnum);
        int docID;
        while ((docID = postingsEnum.nextDoc()) != PostingsEnum.NO_MORE_DOCS) {
          long v = docValues.get(docID);
          assert v >= min && v <= max: "docID=" + docID + " v=" + v;
          // The auto-prefix terms should never "overlap" one another, so we should only ever see a given docID one time:
          if (VERBOSE) {
            System.out.println("    got docID=" + docID + " v=" + v);
          }
          verifier.sawDoc(docID);
        }
      }
      
      int startLoc = Collections.binarySearch(sortedTerms, String.format(Locale.ROOT, format, min));
      if (startLoc < 0) {
        startLoc = -startLoc-1;
      } else if (minInclusive == false) {
        startLoc++;
      }
      int endLoc = Collections.binarySearch(sortedTerms, String.format(Locale.ROOT, format, max));
      if (endLoc < 0) {
        endLoc = -endLoc-2;
      } else if (maxInclusive == false) {
        endLoc--;
      }
      verifier.finish(endLoc-startLoc+1, maxTermsAutoPrefix);
    }

    r.close();
    w.close();
    dir.close();
  }

