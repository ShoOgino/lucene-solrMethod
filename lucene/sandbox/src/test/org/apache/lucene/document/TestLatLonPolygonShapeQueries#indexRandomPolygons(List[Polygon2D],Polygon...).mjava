  protected IndexWriter indexRandomPolygons(List<Polygon2D> poly2d, Polygon... polygons) throws Exception {
    IndexWriterConfig iwc = newIndexWriterConfig();
    iwc.setMergeScheduler(new SerialMergeScheduler());
    int mbd = iwc.getMaxBufferedDocs();
    if (mbd != -1 && mbd < polygons.length / 100) {
      iwc.setMaxBufferedDocs(polygons.length / 100);
    }
    Directory dir;
    if (polygons.length > 1000) {
      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));
    } else {
      dir = newDirectory();
    }

    Set<Integer> deleted = new HashSet<>();
    IndexWriter w = new IndexWriter(dir, iwc);
    for (int id = 0; id < polygons.length; ++id) {
      Document doc = new Document();
      doc.add(newStringField("id", "" + id, Field.Store.NO));
      doc.add(new NumericDocValuesField("id", id));
      if (polygons[id] != null) {
        try {
          addPolygonsToDoc(FIELD_NAME, doc, polygons[id]);
        } catch (IllegalArgumentException e) {
          // GeoTestUtil will occassionally create invalid polygons
          // invalid polygons will not tessellate
          // we skip those polygons that will not tessellate, relying on the TestTessellator class
          // to ensure the Tessellator correctly identified a malformed shape and its not a bug
          if (VERBOSE) {
            System.out.println("  id=" + id + " could not tessellate. Malformed shape " + polygons[id] + " detected");
          }
          // remove and skip the malformed shape
          polygons[id] = null;
          poly2d.add(id, null);
          continue;
        }
        poly2d.add(id, Polygon2D.create(quantizePolygon(polygons[id])));
      } else {
        poly2d.add(id, null);
      }
      w.addDocument(doc);
      if (id > 0 && random().nextInt(100) == 42) {
        int idToDelete = random().nextInt(id);
        w.deleteDocuments(new Term("id", ""+idToDelete));
        deleted.add(idToDelete);
        if (VERBOSE) {
          System.out.println("   delete id=" + idToDelete);
        }
      }
    }

    if (random().nextBoolean()) {
      w.forceMerge(1);
    }

    return w;
  }

