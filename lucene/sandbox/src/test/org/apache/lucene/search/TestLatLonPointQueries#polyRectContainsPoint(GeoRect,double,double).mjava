  @Override
  protected Boolean polyRectContainsPoint(GeoRect rect, double pointLat, double pointLon) {
    // TODO write better random polygon tests

    assert Double.isNaN(pointLat) == false;

    // TODO: this comment is wrong!  we have fixed the quantization error (we now pre-quantize all randomly generated test points) yet the test
    // still fails if we remove this evil "return null":
    
    // false positive/negatives due to quantization error exist for both rectangles and polygons
    if (compare(pointLat, rect.minLat) == 0
        || compare(pointLat, rect.maxLat) == 0
        || compare(pointLon, rect.minLon) == 0
        || compare(pointLon, rect.maxLon) == 0) {
      return null;
    }

    int rectLatMinEnc = LatLonPoint.encodeLatitude(rect.minLat);
    int rectLatMaxEnc = LatLonPoint.encodeLatitude(rect.maxLat);
    int rectLonMinEnc = LatLonPoint.encodeLongitude(rect.minLon);
    int rectLonMaxEnc = LatLonPoint.encodeLongitude(rect.maxLon);

    int pointLatEnc = LatLonPoint.encodeLatitude(pointLat);
    int pointLonEnc = LatLonPoint.encodeLongitude(pointLon);

    if (rect.minLon < rect.maxLon) {
      return pointLatEnc >= rectLatMinEnc &&
        pointLatEnc <= rectLatMaxEnc &&
        pointLonEnc >= rectLonMinEnc &&
        pointLonEnc <= rectLonMaxEnc;
    } else {
      // Rect crosses dateline:
      return pointLatEnc >= rectLatMinEnc &&
        pointLatEnc <= rectLatMaxEnc &&
        (pointLonEnc >= rectLonMinEnc ||
         pointLonEnc <= rectLonMaxEnc);
    }
  }

