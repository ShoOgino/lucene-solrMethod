  /** Tests consistency of GeoUtils.rectWithinCircle, .rectCrossesCircle, .rectWithin and SloppyMath.haversine distance check */
  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/LUCENE-6846")
  public void testGeoRelations() throws Exception {

    int numDocs = atLeast(1000);
    
    // boolean useSmallRanges = random().nextBoolean();

    // TODO: the GeoUtils APIs have bugs if you use large distances:
    boolean useSmallRanges = true;

    if (VERBOSE) {
      System.out.println("TEST: " + numDocs + " docs useSmallRanges=" + useSmallRanges);
    }

    double[] docLons = new double[numDocs];
    double[] docLats = new double[numDocs];
    for(int docID=0;docID<numDocs;docID++) {
      docLons[docID] = randomLon(useSmallRanges);
      docLats[docID] = randomLat(useSmallRanges);
      if (VERBOSE) {
        System.out.println("  doc=" + docID + ": lon=" + docLons[docID] + " lat=" + docLats[docID]);
      }
    }

    int iters = atLeast(10);

    iters = atLeast(50);
    
    for(int iter=0;iter<iters;iter++) {

      Cell.nextCellID = 0;

      double centerLon = randomLon(useSmallRanges);
      double centerLat = randomLat(useSmallRanges);

      // So the circle covers at most 50% of the earth's surface:

      double radiusMeters;

      // TODO: GeoUtils APIs are still buggy for large distances:
      if (true || useSmallRanges) {
        // Approx 3 degrees lon at the equator:
        radiusMeters = random().nextDouble() * 333000;
      } else {
        radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0;
      }

      StringWriter sw = new StringWriter();
      PrintWriter log = new PrintWriter(sw, true);

      if (VERBOSE) {
        log.println("\nTEST: iter=" + iter + " radiusMeters=" + radiusMeters + " centerLon=" + centerLon + " centerLat=" + centerLat);
      }

      GeoRect bbox = GeoUtils.circleToBBox(centerLon, centerLat, radiusMeters);
      
      Set<Integer> hits = new HashSet<>();

      if (bbox.maxLon < bbox.minLon) {
        // Crosses dateline
        log.println("  circle crosses dateline; first right query");
        findMatches(hits, log,
                    new Cell(null,
                             -180, bbox.minLat,
                             bbox.maxLon, bbox.maxLat,
                             0),
                    centerLon, centerLat, radiusMeters,
                    docLons, docLats);
        log.println("  circle crosses dateline; now left query");
        findMatches(hits, log,
                    new Cell(null,
                             bbox.minLon, bbox.minLat,
                             180, bbox.maxLat,
                             0),
                    centerLon, centerLat, radiusMeters,
                    docLons, docLats);
      } else {
        // Start with the root cell that fully contains the shape:
        findMatches(hits, log,
                    new Cell(null,
                             bbox.minLon, bbox.minLat,
                             bbox.maxLon, bbox.maxLat,
                             0),
                    centerLon, centerLat, radiusMeters,
                    docLons, docLats);
      }

      if (VERBOSE) {
        log.println("  " + hits.size() + " hits");
      }

      int failCount = 0;

      // Done matching, now verify:
      for(int docID=0;docID<numDocs;docID++) {
        double distanceMeters = SloppyMath.haversin(centerLat, centerLon, docLats[docID], docLons[docID]) * 1000.0;
        boolean expected = distanceMeters <= radiusMeters;

        boolean actual = hits.contains(docID);
        if (actual != expected) {
          if (actual) {
            log.println("doc=" + docID + " matched but should not");
          } else {
            log.println("doc=" + docID + " did not match but should");
          }
          log.println("  lon=" + docLons[docID] + " lat=" + docLats[docID] + " distanceMeters=" + distanceMeters + " vs radiusMeters=" + radiusMeters);
          failCount++;
        }
      }

      if (failCount != 0) {
        System.out.print(sw.toString());
        fail(failCount + " incorrect hits (see above)");
      }
    }
  }

