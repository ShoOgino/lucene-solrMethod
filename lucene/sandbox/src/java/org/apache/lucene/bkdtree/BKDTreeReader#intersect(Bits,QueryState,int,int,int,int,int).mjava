  private int intersect(Bits acceptDocs, QueryState state,
                        int nodeID,
                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)
    throws IOException {

    // 2.06 sec -> 1.52 sec for 225 OSM London queries:
    if (state.latLonFilter != null) {
      if (cellLatMinEnc > state.latMinEnc ||
          cellLatMaxEnc < state.latMaxEnc ||
          cellLonMinEnc > state.lonMinEnc ||
          cellLonMaxEnc < state.lonMaxEnc) {
        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),
                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),
                                                BKDTreeWriter.decodeLon(cellLonMinEnc),
                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));
        //System.out.println("BKD.intersect cellLat=" + BKDTreeWriter.decodeLat(cellLatMinEnc) + " TO " + BKDTreeWriter.decodeLat(cellLatMaxEnc) + ", cellLon=" + BKDTreeWriter.decodeLon(cellLonMinEnc) + " TO " + BKDTreeWriter.decodeLon(cellLonMaxEnc) + " compare=" + r);
        if (r == Relation.OUTSIDE) {
          // This cell is fully outside of the query shape: stop recursing
          return 0;
        } else if (r == Relation.INSIDE) {
          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering
          return addAll(acceptDocs, state, nodeID);
        } else {
          // The cell crosses the shape boundary, so we fall through and do full filtering
        }
      }
    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {
      // Optimize the case when the query fully contains this cell: we can
      // recursively add all points without checking if they match the query:
      return addAll(acceptDocs, state, nodeID);
    }

    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;
    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;

    int dim;
    if (latRange >= lonRange) {
      dim = 0;
    } else {
      dim = 1;
    }

    //System.out.println("\nintersect node=" + nodeID + " vs " + leafNodeOffset);

    if (nodeID >= leafNodeOffset) {
      // Leaf node; scan and filter all points in this block:
      //System.out.println("    intersect leaf nodeID=" + nodeID + " vs leafNodeOffset=" + leafNodeOffset + " fp=" + leafBlockFPs[nodeID-leafNodeOffset]);
      int hitCount = 0;

      //IndexInput in = leafDISI.in;
      long fp = leafBlockFPs[nodeID-leafNodeOffset];
      if (fp == 0) {
        // Dead end node (adversary case):
        //System.out.println("    dead-end leaf");
        return 0;
      }

      /*
      System.out.println("I: " + BKDTreeWriter.decodeLat(cellLatMinEnc)
                         + " " + BKDTreeWriter.decodeLat(cellLatMaxEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMinEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMaxEnc));
      */

      state.in.seek(fp);

      // How many points are stored in this leaf cell:
      int count = state.in.readVInt();

      for(int i=0;i<count;i++) {
        int docID = state.in.readInt();
        if (acceptDocs == null || acceptDocs.get(docID)) {
          state.sndv.setDocument(docID);
          // How many values this doc has:
          int docValueCount = state.sndv.count();
          for(int j=0;j<docValueCount;j++) {
            long enc = state.sndv.valueAt(j);

            int latEnc = (int) ((enc>>32) & 0xffffffffL);
            int lonEnc = (int) (enc & 0xffffffffL);

            if (latEnc >= state.latMinEnc &&
                latEnc < state.latMaxEnc &&
                lonEnc >= state.lonMinEnc &&
                lonEnc < state.lonMaxEnc &&
                (state.latLonFilter == null ||
                 state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {
              state.bits.set(docID);
              hitCount++;

              // Stop processing values for this doc:
              break;
            }
          }
        }
      }

      return hitCount;

      // this (using BitDocIdSet.Builder) is 3.4X slower!
      /*
      //bits.or(leafDISI);
      //return leafDISI.getHitCount();
      */

    } else {

      int splitValue = splitValues[nodeID];

      if (splitValue == Integer.MAX_VALUE) {
        // Dead end node (adversary case):
        //System.out.println("    dead-end sub-tree");
        return 0;
      }

      //System.out.println("  splitValue=" + splitValue);

      int count = 0;

      if (dim == 0) {

        //System.out.println("  split on lat=" + splitValue);

        // Inner node split on lat:

        // Left node:
        if (state.latMinEnc < splitValue) {
          //System.out.println("  recurse left");
          count += intersect(acceptDocs, state,
                             2*nodeID,
                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);
        }

        // Right node:
        if (state.latMaxEnc >= splitValue) {
          //System.out.println("  recurse right");
          count += intersect(acceptDocs, state,
                             2*nodeID+1,
                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);
        }

      } else {
        // Inner node split on lon:
        assert dim == 1;

        // System.out.println("  split on lon=" + splitValue);

        // Left node:
        if (state.lonMinEnc < splitValue) {
          // System.out.println("  recurse left");
          count += intersect(acceptDocs, state,
                             2*nodeID,
                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);
        }

        // Right node:
        if (state.lonMaxEnc >= splitValue) {
          // System.out.println("  recurse right");
          count += intersect(acceptDocs, state,
                             2*nodeID+1,
                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);
        }
      }

      return count;
    }
  }

