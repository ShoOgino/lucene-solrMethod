  private int intersect(QueryState state,
                        int nodeID,
                        int cellLatMinEnc, int cellLatMaxEnc, int cellLonMinEnc, int cellLonMaxEnc)
    throws IOException {

    // 2.06 sec -> 1.52 sec for 225 OSM London queries:
    if (state.latLonFilter != null) {

      // Only call the filter when the current cell does not fully contain the bbox:
      if (cellLatMinEnc > state.latMinEnc || cellLatMaxEnc < state.latMaxEnc ||
          cellLonMinEnc > state.lonMinEnc || cellLonMaxEnc < state.lonMaxEnc) {

        Relation r = state.latLonFilter.compare(BKDTreeWriter.decodeLat(cellLatMinEnc),
                                                BKDTreeWriter.decodeLat(cellLatMaxEnc),
                                                BKDTreeWriter.decodeLon(cellLonMinEnc),
                                                BKDTreeWriter.decodeLon(cellLonMaxEnc));
        // System.out.println("BKD.intersect cellLat=" + BKDTreeWriter.decodeLat(cellLatMinEnc) + " TO " + BKDTreeWriter.decodeLat(cellLatMaxEnc) + ", cellLon=" + BKDTreeWriter.decodeLon(cellLonMinEnc) + " TO " + BKDTreeWriter.decodeLon(cellLonMaxEnc) + " compare=" + r);
        if (r == Relation.SHAPE_OUTSIDE_CELL) {
          // This cell is fully outside of the query shape: stop recursing
          return 0;
        } else if (r == Relation.CELL_INSIDE_SHAPE) {
          // This cell is fully inside of the query shape: recursively add all points in this cell without filtering
          return addAll(state, nodeID);
        } else {
          // The cell crosses the shape boundary, so we fall through and do full filtering
        }
      }
    // TODO: clean this up: the bbox case should also just be a filter, and we should assert filter != null at the start
    } else if (state.latMinEnc <= cellLatMinEnc && state.latMaxEnc >= cellLatMaxEnc && state.lonMinEnc <= cellLonMinEnc && state.lonMaxEnc >= cellLonMaxEnc) {
      // Bbox query: optimize the case when the query fully contains this cell: we can
      // recursively add all points without checking if they match the query:
      return addAll(state, nodeID);
    }

    long latRange = (long) cellLatMaxEnc - (long) cellLatMinEnc;
    long lonRange = (long) cellLonMaxEnc - (long) cellLonMinEnc;

    int dim;
    if (latRange >= lonRange) {
      dim = 0;
    } else {
      dim = 1;
    }

    //System.out.println("\nintersect node=" + nodeID + " vs " + leafNodeOffset);

    if (nodeID >= leafNodeOffset) {
      // Leaf node; scan and filter all points in this block:
      //System.out.println("    intersect leaf nodeID=" + nodeID + " vs leafNodeOffset=" + leafNodeOffset + " fp=" + leafBlockFPs[nodeID-leafNodeOffset]);
      int hitCount = 0;

      long fp = leafBlockFPs[nodeID-leafNodeOffset];
      if (fp == 0) {
        // Dead end node (adversary case):
        //System.out.println("    dead-end leaf");
        return 0;
      }

      /*
      System.out.println("I: " + BKDTreeWriter.decodeLat(cellLatMinEnc)
                         + " " + BKDTreeWriter.decodeLat(cellLatMaxEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMinEnc)
                         + " " + BKDTreeWriter.decodeLon(cellLonMaxEnc));
      */

      state.in.seek(fp);

      // How many points are stored in this leaf cell:
      int count = state.in.readVInt();

      state.docs.grow(count);
      for(int i=0;i<count;i++) {
        int docID = state.in.readInt();
        state.sndv.setDocument(docID);
        // How many values this doc has:
        int docValueCount = state.sndv.count();
        for(int j=0;j<docValueCount;j++) {
          long enc = state.sndv.valueAt(j);

          int latEnc = (int) ((enc>>32) & 0xffffffffL);
          int lonEnc = (int) (enc & 0xffffffffL);

          if (latEnc >= state.latMinEnc &&
              latEnc < state.latMaxEnc &&
              lonEnc >= state.lonMinEnc &&
              lonEnc < state.lonMaxEnc &&
              (state.latLonFilter == null ||
               state.latLonFilter.accept(BKDTreeWriter.decodeLat(latEnc), BKDTreeWriter.decodeLon(lonEnc)))) {
            state.docs.add(docID);
            hitCount++;

            // Stop processing values for this doc:
            break;
          }
        }
      }

      return hitCount;

    } else {

      int splitValue = splitValues[nodeID];

      if (splitValue == Integer.MAX_VALUE) {
        // Dead end node (adversary case):
        //System.out.println("    dead-end sub-tree");
        return 0;
      }

      //System.out.println("  splitValue=" + splitValue);

      int count = 0;

      if (dim == 0) {

        //System.out.println("  split on lat=" + splitValue);

        // Inner node split on lat:

        // Left node:
        if (state.latMinEnc < splitValue) {
          //System.out.println("  recurse left");
          count += intersect(state,
                             2*nodeID,
                             cellLatMinEnc, splitValue, cellLonMinEnc, cellLonMaxEnc);
        }

        // Right node:
        if (state.latMaxEnc >= splitValue) {
          //System.out.println("  recurse right");
          count += intersect(state,
                             2*nodeID+1,
                             splitValue, cellLatMaxEnc, cellLonMinEnc, cellLonMaxEnc);
        }

      } else {
        // Inner node split on lon:
        assert dim == 1;

        // System.out.println("  split on lon=" + splitValue);

        // Left node:
        if (state.lonMinEnc < splitValue) {
          // System.out.println("  recurse left");
          count += intersect(state,
                             2*nodeID,
                             cellLatMinEnc, cellLatMaxEnc, cellLonMinEnc, splitValue);
        }

        // Right node:
        if (state.lonMaxEnc >= splitValue) {
          // System.out.println("  recurse right");
          count += intersect(state,
                             2*nodeID+1,
                             cellLatMinEnc, cellLatMaxEnc, splitValue, cellLonMaxEnc);
        }
      }

      return count;
    }
  }

