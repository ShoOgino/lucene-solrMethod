  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {

    // I don't use RandomAccessWeight here: it's no good to approximate with "match all docs"; this is an inverted structure and should be
    // used in the first pass:

    // TODO: except that the polygon verify is costly!  The approximation should be all docs in all overlapping cells, and matches() should
    // then check the polygon

    return new ConstantScoreWeight(this) {

      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        LeafReader reader = context.reader();
        SortedNumericDocValues sdv = reader.getSortedNumericDocValues(field);
        if (sdv == null) {
          // No docs in this segment had this field
          return null;
        }

        if (sdv instanceof BKDTreeSortedNumericDocValues == false) {
          throw new IllegalStateException("field \"" + field + "\" was not indexed with BKDTreeDocValuesFormat: got: " + sdv);
        }
        BKDTreeSortedNumericDocValues treeDV = (BKDTreeSortedNumericDocValues) sdv;
        BKDTreeReader tree = treeDV.getBKDTreeReader();
        
        DocIdSet result = tree.intersect(minLat, maxLat, minLon, maxLon,
                                         new BKDTreeReader.LatLonFilter() {
                                           @Override
                                           public boolean accept(double lat, double lon) {
                                             return GeoUtils.pointInPolygon(polyLons, polyLats, lat, lon);
                                           }

                                           @Override
                                           public BKDTreeReader.Relation compare(double cellLatMin, double cellLatMax, double cellLonMin, double cellLonMax) {
                                             if (GeoUtils.rectWithinPoly(cellLonMin, cellLatMin, cellLonMax, cellLatMax,
                                                                         polyLons, polyLats,
                                                                         minLon, minLat, maxLon, maxLat)) {
                                               return BKDTreeReader.Relation.CELL_INSIDE_SHAPE;
                                             } else if (GeoUtils.rectCrossesPoly(cellLonMin, cellLatMin, cellLonMax, cellLatMax,
                                                                                 polyLons, polyLats,
                                                                                 minLon, minLat, maxLon, maxLat)) {
                                               return BKDTreeReader.Relation.SHAPE_CROSSES_CELL;
                                             } else {
                                               return BKDTreeReader.Relation.SHAPE_OUTSIDE_CELL;
                                             }
                                           }
                                         }, treeDV.delegate);

        return new ConstantScoreScorer(this, score(), result.iterator());
      }
    };
  }

