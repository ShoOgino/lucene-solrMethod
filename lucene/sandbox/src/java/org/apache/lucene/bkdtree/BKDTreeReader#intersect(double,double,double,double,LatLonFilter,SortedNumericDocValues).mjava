  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {
    if (BKDTreeWriter.validLat(latMin) == false) {
      throw new IllegalArgumentException("invalid latMin: " + latMin);
    }
    if (BKDTreeWriter.validLat(latMax) == false) {
      throw new IllegalArgumentException("invalid latMax: " + latMax);
    }
    if (BKDTreeWriter.validLon(lonMin) == false) {
      throw new IllegalArgumentException("invalid lonMin: " + lonMin);
    }
    if (BKDTreeWriter.validLon(lonMax) == false) {
      throw new IllegalArgumentException("invalid lonMax: " + lonMax);
    }

    int latMinEnc = BKDTreeWriter.encodeLat(latMin);
    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);
    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);
    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);

    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.
    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's
    // small.

    QueryState state = new QueryState(in.clone(), maxDoc,
                                      latMinEnc, latMaxEnc,
                                      lonMinEnc, lonMaxEnc,
                                      filter,
                                      sndv);

    int hitCount = intersect(state, 1,
                             BKDTreeWriter.encodeLat(-90.0),
                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),
                             BKDTreeWriter.encodeLon(-180.0),
                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));

    // NOTE: hitCount is an over-estimate in the multi-valued case:
    return state.docs.build(hitCount);
  }

