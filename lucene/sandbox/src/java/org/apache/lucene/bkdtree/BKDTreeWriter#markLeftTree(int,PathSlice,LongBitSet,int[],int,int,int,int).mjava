  /** Marks bits for the ords (points) that belong in the left sub tree. */
  private long markLeftTree(int splitDim, PathSlice source, LongBitSet bitSet, int[] splitValueRet,
                            int minLatEnc, int maxLatEnc, int minLonEnc, int maxLonEnc) throws IOException {

    // This is the initital size of our left tree, but we may lower it below for == case:
    long leftCount = source.count / 2;

    // Read the split value:
    //if (DEBUG) System.out.println("  leftCount=" + leftCount + " vs " + source.count);
    LatLonReader reader = source.writer.getReader(source.start + leftCount);
    boolean success = false;
    int splitValue;
    try {
      boolean result = reader.next();
      assert result;

      int latSplitEnc = reader.latEnc();
      assert latSplitEnc >= minLatEnc && latSplitEnc < maxLatEnc: "latSplitEnc=" + latSplitEnc + " minLatEnc=" + minLatEnc + " maxLatEnc=" + maxLatEnc;

      int lonSplitEnc = reader.lonEnc();
      assert lonSplitEnc >= minLonEnc && lonSplitEnc < maxLonEnc: "lonSplitEnc=" + lonSplitEnc + " minLonEnc=" + minLonEnc + " maxLonEnc=" + maxLonEnc;

      if (splitDim == 0) {
        splitValue = latSplitEnc;
        //if (DEBUG) System.out.println("  splitValue=" + decodeLat(splitValue));
      } else {
        splitValue = lonSplitEnc;
        //if (DEBUG) System.out.println("  splitValue=" + decodeLon(splitValue));
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(reader);
      } else {
        IOUtils.closeWhileHandlingException(reader);
      }
    }

    splitValueRet[0] = splitValue;

    // Mark ords that fall into the left half, and also handle the == boundary case:
    assert bitSet.cardinality() == 0: "cardinality=" + bitSet.cardinality();

    success = false;
    reader = source.writer.getReader(source.start);
    try {
      int lastValue = Integer.MIN_VALUE;
      for (int i=0;i<leftCount;i++) {
        boolean result = reader.next();
        assert result;
        int latEnc = reader.latEnc();
        int lonEnc = reader.lonEnc();

        int value;
        if (splitDim == 0) {
          value = latEnc;
        } else {
          value = lonEnc;
        }

        // Our input source is supposed to be sorted on the incoming dimension:
        assert value >= lastValue;
        lastValue = value;

        if (value == splitValue) {
          // If we have identical points at the split, we move the count back to before the identical points:
          leftCount = i;
          break;
        }
        assert value < splitValue: "i=" + i + " value=" + value + " vs splitValue=" + splitValue;
        long ord = reader.ord();
        int docID = reader.docID();
        assert docID >= 0: "docID=" + docID + " reader=" + reader;

        // We should never see dup ords:
        assert bitSet.get(ord) == false;
        bitSet.set(ord);
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(reader);
      } else {
        IOUtils.closeWhileHandlingException(reader);
      }
    }

    assert leftCount == bitSet.cardinality(): "leftCount=" + leftCount + " cardinality=" + bitSet.cardinality();

    return leftCount;
  }

