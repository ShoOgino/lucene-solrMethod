  /** Uses morton code for speed to determine whether or a polygon node forms a valid ear w/ adjacent nodes */
  private static final boolean mortonIsEar(final Node ear) {
    double ax = ear.previous.x;
    double ay = ear.previous.y;
    double bx = ear.x;
    double by = ear.y;
    double cx = ear.next.x;
    double cy = ear.next.y;

    // now make sure we don't have other points inside the potential ear;
    Node node;
    int idx;

    // triangle bbox (flip the bits so negative encoded values are < positive encoded values)
    int minTX = StrictMath.min(StrictMath.min(ear.previous.x, ear.x), ear.next.x) ^ 0x80000000;
    int minTY = StrictMath.min(StrictMath.min(ear.previous.y, ear.y), ear.next.y) ^ 0x80000000;
    int maxTX = StrictMath.max(StrictMath.max(ear.previous.x, ear.x), ear.next.x) ^ 0x80000000;
    int maxTY = StrictMath.max(StrictMath.max(ear.previous.y, ear.y), ear.next.y) ^ 0x80000000;

    // z-order range for the current triangle bbox;
    long minZ = BitUtil.interleave(minTX, minTY);
    long maxZ = BitUtil.interleave(maxTX, maxTY);

    // first look for points inside the triangle in increasing z-order
    node = ear.nextZ;
    while (node != null && Long.compareUnsigned(node.morton, maxZ) <= 0) {
      if (Long.compareUnsigned(node.morton, maxZ) <= 0) {
        idx = node.idx;
        if (idx != ear.previous.idx && idx != ear.next.idx
            && pointInEar(node.x, node.y, ax, ay, bx, by, cx, cy)
            && area(node.previous.x, node.previous.y, node.x, node.y, node.next.x, node.next.y) >= 0) {
          return false;
        }
      }
      node = node.nextZ;
    }
    // then look for points in decreasing z-order
    node = ear.previousZ;
    while (node != null &&
        Long.compareUnsigned(node.morton, minZ) >= 0) {
      if (Long.compareUnsigned(node.morton, maxZ) <= 0) {
        idx = node.idx;
        if (idx != ear.previous.idx && idx != ear.next.idx
            && pointInEar(node.x, node.y, ax, ay, bx, by, cx, cy)
            && area(node.previous.x, node.previous.y, node.x, node.y, node.next.x, node.next.y) >= 0) {
          return false;
        }
      }
      node = node.previousZ;
    }
    return true;
  }

