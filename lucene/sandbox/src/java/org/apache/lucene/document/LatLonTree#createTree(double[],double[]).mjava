  /** 
   * Creates an edge interval tree from a set of polygon vertices.
   * @return root node of the tree.
   */
  private static Edge createTree(double polyLats[], double polyLons[]) {
    // edge order is deterministic and reproducible based on the double values.
    // TODO: make a real balanced tree instead :)
    List<Integer> list = new ArrayList<Integer>(polyLats.length - 1);
    for (int i = 1; i < polyLats.length; i++) {
      list.add(i);
    }
    Collections.shuffle(list, new Random(Arrays.hashCode(polyLats) ^ Arrays.hashCode(polyLons)));
    Edge root = null;
    for (int i : list) {
      double lat1 = polyLats[i-1];
      double lon1 = polyLons[i-1];
      double lat2 = polyLats[i];
      double lon2 = polyLons[i];
      Edge newNode = new Edge(lat1, lon1, lat2, lon2, Math.min(lat1, lat2), Math.max(lat1, lat2));
      if (root == null) {
        // add first node
        root = newNode;
      } else {
        // traverse tree to find home for new node, along the path updating all parent's max value along the way.
        Edge node = root;
        while (true) {
          node.max = Math.max(node.max, newNode.max);
          if (newNode.low < node.low) {
            if (node.left == null) {
              node.left = newNode;
              break;
            }
            node = node.left;
          } else {
            if (node.right == null) {
              node.right = newNode;
              break;
            }
            node = node.right;
          }
        }
      }
    }
    return root;
  }

