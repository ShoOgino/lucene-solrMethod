  /** fills a 2D range of grid cells [minLatIndex .. maxLatIndex) X [minLonIndex .. maxLonIndex) */
  void fill(int minLatIndex, int maxLatIndex, int minLonIndex, int maxLonIndex) {
    // grid cells at the edge of the bounding box are typically smaller than normal, because we spill over.
    long cellMinLat = minLat + (minLatIndex * latPerCell);
    long cellMaxLat = Math.min(maxLat, minLat + (maxLatIndex * latPerCell) - 1);
    long cellMinLon = minLon + (minLonIndex * lonPerCell);
    long cellMaxLon = Math.min(maxLon, minLon + (maxLonIndex * lonPerCell) - 1);

    assert cellMinLat <= maxLat && cellMinLon <= maxLon;
    assert cellMaxLat >= cellMinLat;
    assert cellMaxLon >= cellMinLon;

    Relation relation = LatLonTree.relate(tree, decodeLatitude((int) cellMinLat),
                                                decodeLatitude((int) cellMaxLat),
                                                decodeLongitude((int) cellMinLon),
                                                decodeLongitude((int) cellMaxLon));
    if (relation != Relation.CELL_CROSSES_QUERY) {
      // we know the answer for this region, fill the cell range
      for (int i = minLatIndex; i < maxLatIndex; i++) {
        for (int j = minLonIndex; j < maxLonIndex; j++) {
          int index = i * GRID_SIZE + j;
          assert haveAnswer.get(index) == false;
          haveAnswer.set(index);
          if (relation == Relation.CELL_INSIDE_QUERY) {
            answer.set(index);
          }
        }
      }
    } else if (minLatIndex == maxLatIndex - 1) {
      // nothing more to do: this is a single grid cell (leaf node) and
      // is an edge case for the polygon.
    } else {
      // grid range crosses our polygon, keep recursing.
      int midLatIndex = (minLatIndex + maxLatIndex) >>> 1;
      int midLonIndex = (minLonIndex + maxLonIndex) >>> 1;
      fill(minLatIndex, midLatIndex, minLonIndex, midLonIndex);
      fill(minLatIndex, midLatIndex, midLonIndex, maxLonIndex);
      fill(midLatIndex, maxLatIndex, minLonIndex, midLonIndex);
      fill(midLatIndex, maxLatIndex, midLonIndex, maxLonIndex);
    }
  }

