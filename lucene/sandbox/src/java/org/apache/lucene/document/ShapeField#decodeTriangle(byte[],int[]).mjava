  /**
   * Decode a triangle encoded by {@link ShapeField#encodeTriangle(byte[], int, int, int, int, int, int)}.
   */
  public static void decodeTriangle(byte[] t, int[] triangle) {
    assert triangle.length == 6;
    int bits = NumericUtils.sortableBytesToInt(t, 6 * BYTES);
    //extract the first three bits
    int tCode = (((1 << 3) - 1) & (bits >> 0));
    switch (tCode) {
      case MINY_MINX_MAXY_MAXX_Y_X:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        break;
      case MINY_MINX_Y_X_MAXY_MAXX:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        break;
      case MAXY_MINX_Y_X_MINY_MAXX:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        break;
      case MAXY_MINX_MINY_MAXX_Y_X:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        break;
      case Y_MINX_MINY_X_MAXY_MAXX:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        break;
      case Y_MINX_MINY_MAXX_MAXY_X:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        break;
      case MAXY_MINX_MINY_X_Y_MAXX:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        break;
      case MINY_MINX_Y_MAXX_MAXY_X:
        triangle[0] = NumericUtils.sortableBytesToInt(t, 0 * BYTES);
        triangle[1] = NumericUtils.sortableBytesToInt(t, 1 * BYTES);
        triangle[2] = NumericUtils.sortableBytesToInt(t, 4 * BYTES);
        triangle[3] = NumericUtils.sortableBytesToInt(t, 3 * BYTES);
        triangle[4] = NumericUtils.sortableBytesToInt(t, 2 * BYTES);
        triangle[5] = NumericUtils.sortableBytesToInt(t, 5 * BYTES);
        break;
      default:
        throw new IllegalArgumentException("Could not decode the provided triangle");
    }
    //Points of the decoded triangle must be co-planar or CCW oriented
    assert GeoUtils.orient(triangle[1], triangle[0], triangle[3], triangle[2], triangle[5], triangle[4]) >= 0;
  }

