  /** returns true if the query intersects the encoded triangle */
  protected boolean queryIntersects(byte[] t) {

    // 1. query contains any triangle points
    if (queryContains(t, 0) || queryContains(t, 1) || queryContains(t, 2)) {
      return true;
    }

    int aY = NumericUtils.sortableBytesToInt(t, 0);
    int aX = NumericUtils.sortableBytesToInt(t, LatLonPoint.BYTES);
    int bY = NumericUtils.sortableBytesToInt(t, 2 * LatLonPoint.BYTES);
    int bX = NumericUtils.sortableBytesToInt(t, 3 * LatLonPoint.BYTES);
    int cY = NumericUtils.sortableBytesToInt(t, 4 * LatLonPoint.BYTES);
    int cX = NumericUtils.sortableBytesToInt(t, 5 * LatLonPoint.BYTES);

    int tMinX = StrictMath.min(StrictMath.min(aX, bX), cX);
    int tMaxX = StrictMath.max(StrictMath.max(aX, bX), cX);
    int tMinY = StrictMath.min(StrictMath.min(aY, bY), cY);
    int tMaxY = StrictMath.max(StrictMath.max(aY, bY), cY);

    // 2. check bounding boxes are disjoint
    if (tMaxX < minX || tMinX > maxX || tMinY > maxY || tMaxY < minY) {
      return false;
    }

    // 3. check triangle contains any query points
    if (Tessellator.pointInTriangle(minX, minY, aX, aY, bX, bY, cX, cY)) {
      return true;
    } else if (Tessellator.pointInTriangle(maxX, minY, aX, aY, bX, bY, cX, cY)) {
      return true;
    } else if (Tessellator.pointInTriangle(maxX, maxY, aX, aY, bX, bY, cX, cY)) {
      return true;
    } else if (Tessellator.pointInTriangle(minX, maxY, aX, aY, bX, bY, cX, cY)) {
      return true;
    }


    // 4. last ditch effort: check crossings
    if (queryIntersects(aX, aY, bX, bY, cX, cY)) {
      return true;
    }
    return false;
  }

