  LatLonGrid(int minLat, int maxLat, int minLon, int maxLon, Polygon... polygons) {
    this.minLat = minLat;
    this.maxLat = maxLat;
    this.minLon = minLon;
    this.maxLon = maxLon;
    this.tree = LatLonTree.build(polygons);
    if (minLon > maxLon) {
      // maybe make 2 grids if you want this? 
      throw new IllegalArgumentException("Grid cannot cross the dateline");
    }
    if (minLat > maxLat) {
      throw new IllegalArgumentException("bogus grid");
    }
    long latitudeRange = maxLat - (long) minLat;
    long longitudeRange = maxLon - (long) minLon;

    // if the range is too small, we can't divide it up in our grid nicely.
    // in this case of a tiny polygon, we just make an empty grid instead of complicating/slowing down code.
    final long minRange = (GRID_SIZE - 1) * (GRID_SIZE - 1);
    if (latitudeRange < minRange || longitudeRange < minRange) {
      latPerCell = lonPerCell = Long.MAX_VALUE;
    } else {
      // we spill over the edge of the bounding box in each direction a bit,
      // but it prevents edge case bugs.
      latPerCell = latitudeRange / (GRID_SIZE - 1);
      lonPerCell = longitudeRange / (GRID_SIZE - 1);
      fill(0, GRID_SIZE, 0, GRID_SIZE);
    }
  }

