  /**
   * Create a query for matching a bounding box.
   * <p>
   * The box may cross over the dateline.
   */
  public static Query newBoxQuery(String field, double minLat, double maxLat, double minLon, double maxLon) {
    if (GeoUtils.isValidLat(minLat) == false) {
      throw new IllegalArgumentException("minLat=" + minLat + " is not a valid latitude");
    }
    if (GeoUtils.isValidLat(maxLat) == false) {
      throw new IllegalArgumentException("maxLat=" + maxLat + " is not a valid latitude");
    }
    if (GeoUtils.isValidLon(minLon) == false) {
      throw new IllegalArgumentException("minLon=" + minLon + " is not a valid longitude");
    }
    if (GeoUtils.isValidLon(maxLon) == false) {
      throw new IllegalArgumentException("maxLon=" + maxLon + " is not a valid longitude");
    }
    
    byte[][] lower = encode(minLat, minLon);
    byte[][] upper = encode(maxLat, maxLon);
    // Crosses date line: we just rewrite into OR of two bboxes, with longitude as an open range:
    if (maxLon < minLon) {
      // Disable coord here because a multi-valued doc could match both rects and get unfairly boosted:
      BooleanQuery.Builder q = new BooleanQuery.Builder();
      q.setDisableCoord(true);

      // E.g.: maxLon = -179, minLon = 179
      byte[][] leftOpen = new byte[2][];
      leftOpen[0] = lower[0];
      // leave longitude open (null)
      Query left = newBoxInternal(field, leftOpen, upper);
      q.add(new BooleanClause(left, BooleanClause.Occur.SHOULD));
      byte[][] rightOpen = new byte[2][];
      rightOpen[0] = upper[0];
      // leave longitude open (null)
      Query right = newBoxInternal(field, lower, rightOpen);
      q.add(new BooleanClause(right, BooleanClause.Occur.SHOULD));
      return new ConstantScoreQuery(q.build());
    } else {
      return newBoxInternal(field, lower, upper);
    }
  }

