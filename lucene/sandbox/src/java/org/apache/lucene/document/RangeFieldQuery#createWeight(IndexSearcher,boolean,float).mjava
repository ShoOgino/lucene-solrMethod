  @Override
  public final Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
    return new ConstantScoreWeight(this, boost) {
      final RangeFieldComparator comparator = new RangeFieldComparator();
      private DocIdSet buildMatchingDocIdSet(LeafReader reader, PointValues values) throws IOException {
        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc(), values, field);
        values.intersect(field,
            new IntersectVisitor() {
              DocIdSetBuilder.BulkAdder adder;
              @Override
              public void grow(int count) {
                adder = result.grow(count);
              }
              @Override
              public void visit(int docID) throws IOException {
                adder.add(docID);
              }
              @Override
              public void visit(int docID, byte[] leaf) throws IOException {
                // add the document iff:
                if (// target is within cell and queryType is INTERSECTS or CONTAINS:
                    (comparator.isWithin(leaf) && queryType != QueryType.WITHIN)
                    // target contains cell and queryType is INTERSECTS or WITHIN:
                    || (comparator.contains(leaf) && queryType != QueryType.CONTAINS)
                    // target is not disjoint (crosses) and queryType is INTERSECTS
                    || (comparator.isDisjoint(leaf) == false && queryType == QueryType.INTERSECTS)) {
                  adder.add(docID);
                }
              }
              @Override
              public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
                byte[] node = getInternalRange(minPackedValue, maxPackedValue);
                // compute range relation for BKD traversal
                if (comparator.isDisjoint(node)) {
                  return Relation.CELL_OUTSIDE_QUERY;
                } else if (comparator.contains(node)) {
                  // target contains cell; add iff queryType is not a CONTAINS query:
                  return (queryType == QueryType.CONTAINS) ? Relation.CELL_OUTSIDE_QUERY : Relation.CELL_INSIDE_QUERY;
                } else if (comparator.isWithin(node)) {
                  // target within cell; continue traversing:
                  return Relation.CELL_CROSSES_QUERY;
                }
                // target intersects cell; continue traversing:
                return Relation.CELL_CROSSES_QUERY;
              }
            });
        return result.build();
      }

      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        LeafReader reader = context.reader();
        PointValues values = reader.getPointValues();
        if (values == null) {
          // no docs in this segment indexed any ranges
          return null;
        }
        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);
        if (fieldInfo == null) {
          // no docs in this segment indexed this field
        }
        checkFieldInfo(fieldInfo);
        boolean allDocsMatch = true;
        if (values.getDocCount(field) == reader.maxDoc()) {
          // if query crosses, docs need to be further scrutinized
          byte[] range = getInternalRange(values.getMinPackedValue(field), values.getMaxPackedValue(field));
          // if the internal node is not contained by the query, all docs do not match
          if (((comparator.contains(range) && queryType == QueryType.CONTAINS)) == false) {
            allDocsMatch = false;
          }
        } else {
          allDocsMatch = false;
        }

        DocIdSetIterator iterator = allDocsMatch == true ?
            DocIdSetIterator.all(reader.maxDoc()) : buildMatchingDocIdSet(reader, values).iterator();
        return new ConstantScoreScorer(this, score(), iterator);
      }

      /** get an encoded byte representation of the internal node; this is
       *  the lower half of the min array and the upper half of the max array */
      private byte[] getInternalRange(byte[] min, byte[] max) {
        byte[] range = new byte[min.length];
        final int dimSize = numDims * bytesPerDim;
        System.arraycopy(min, 0, range, 0, dimSize);
        System.arraycopy(max, dimSize, range, dimSize, dimSize);
        return range;
      }
    };
  }

