  public static NearestHit[] nearest(double pointLat, double pointLon, List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int n) throws IOException {

    //System.out.println("NEAREST: r=" + r + " liveDocs=" + liveDocs);
    // Holds closest collected points seen so far:
    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:
    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(n, new Comparator<NearestHit>() {
        @Override
        public int compare(NearestHit a, NearestHit b) {
          // sort by opposite distanceMeters natural order
          int cmp = Double.compare(a.distanceMeters, b.distanceMeters);
          if (cmp != 0) {
            return -cmp;
          }

          // tie-break by higher docID:
          return b.docID - a.docID;
        }
      });

    // Holds all cells, sorted by closest to the point:
    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();

    NearestVisitor visitor = new NearestVisitor(hitQueue, n, pointLat, pointLon);
    List<BKDReader.IntersectState> states = new ArrayList<>();

    // Add root cell for each reader into the queue:
    for(int i=0;i<readers.size();i++) {
      BKDReader reader = readers.get(i);
      byte[] minPackedValue = reader.getMinPackedValue();
      double minLat = decodeLatitude(minPackedValue, 0);
      double minLon = decodeLongitude(minPackedValue, Integer.BYTES);

      byte[] maxPackedValue = reader.getMaxPackedValue();
      double maxLat = decodeLatitude(maxPackedValue, 0);
      double maxLon = decodeLongitude(maxPackedValue, Integer.BYTES);
      states.add(reader.getIntersectState(visitor));

      cellQueue.offer(new Cell(i, 1, reader.getMinPackedValue(), reader.getMaxPackedValue(),
                               approxBestDistance(minLat, maxLat, minLon, maxLon, pointLat, pointLon)));
    }

    while (cellQueue.size() > 0) {
      Cell cell = cellQueue.poll();
      //System.out.println("  visit " + cell);

      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this "best" cell is fully outside of the hitQueue bottom's radius:
      BKDReader reader = readers.get(cell.readerIndex);

      if (reader.isLeafNode(cell.nodeID)) {
        //System.out.println("    leaf");
        // Leaf block: visit all points and possibly collect them:
        visitor.curDocBase = docBases.get(cell.readerIndex);
        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);
        reader.visitLeafBlockValues(cell.nodeID, states.get(cell.readerIndex));
        //System.out.println("    now " + hitQueue.size() + " hits");
      } else {
        //System.out.println("    non-leaf");
        // Non-leaf block: split into two cells and put them back into the queue:

        double cellMinLat = decodeLatitude(cell.minPacked, 0);
        double cellMinLon = decodeLongitude(cell.minPacked, Integer.BYTES);
        double cellMaxLat = decodeLatitude(cell.maxPacked, 0);
        double cellMaxLon = decodeLongitude(cell.maxPacked, Integer.BYTES);

        if (cellMaxLat < visitor.minLat || visitor.maxLat < cellMinLat || ((cellMaxLon < visitor.minLon || visitor.maxLon < cellMinLon) && cellMaxLon < visitor.minLon2)) {
          // this cell is outside our search bbox; don't bother exploring any more
          continue;
        }
        
        byte[] splitPackedValue = cell.maxPacked.clone();
        reader.copySplitValue(cell.nodeID, splitPackedValue);
        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID, cell.minPacked, splitPackedValue,
                                 approxBestDistance(cell.minPacked, splitPackedValue, pointLat, pointLon)));

        splitPackedValue = cell.minPacked.clone();
        reader.copySplitValue(cell.nodeID, splitPackedValue);
        cellQueue.offer(new Cell(cell.readerIndex, 2*cell.nodeID+1, splitPackedValue, cell.maxPacked,
                                 approxBestDistance(splitPackedValue, cell.maxPacked, pointLat, pointLon)));
      }
    }

    NearestHit[] hits = new NearestHit[hitQueue.size()];
    int downTo = hitQueue.size()-1;
    while (hitQueue.size() != 0) {
      hits[downTo] = hitQueue.poll();
      downTo--;
    }

    return hits;
  }

