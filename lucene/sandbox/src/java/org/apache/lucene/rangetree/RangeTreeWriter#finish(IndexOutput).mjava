  /** Writes the 1d BKD tree to the provided {@link IndexOutput} and returns the file offset where index was written. */
  public long finish(IndexOutput out) throws IOException {

    if (offlineWriter != null) {
      offlineWriter.close();
    }

    if (valueCount == 0) {
      throw new IllegalStateException("at least one value must be indexed");
    }

    // TODO: we should use in-memory sort here, if number of points is small enough:

    long countPerLeaf = valueCount;
    long innerNodeCount = 1;

    while (countPerLeaf > maxValuesInLeafNode) {
      countPerLeaf = (countPerLeaf+1)/2;
      innerNodeCount *= 2;
    }

    //System.out.println("innerNodeCount=" + innerNodeCount);

    if (1+2*innerNodeCount >= Integer.MAX_VALUE) {
      throw new IllegalStateException("too many nodes; increase maxValuesInLeafNode (currently " + maxValuesInLeafNode + ") and reindex");
    }

    innerNodeCount--;

    int numLeaves = (int) (innerNodeCount+1);

    // Indexed by nodeID, but first (root) nodeID is 1
    long[] blockMinValues = new long[numLeaves];

    // +1 because leaf count is power of 2 (e.g. 8), and innerNodeCount is power of 2 minus 1 (e.g. 7)
    long[] leafBlockFPs = new long[numLeaves];

    // Make sure the math above "worked":
    assert valueCount / blockMinValues.length <= maxValuesInLeafNode: "valueCount=" + valueCount + " blockMinValues.length=" + blockMinValues.length + " maxValuesInLeafNode=" + maxValuesInLeafNode;
    //System.out.println("  avg pointsPerLeaf=" + (valueCount/blockMinValues.length));

    // Sort all docs by value:
    SliceWriter sortedWriter = null;

    boolean success = false;
    try {
      sortedWriter = sort();
      heapWriter = null;

      build(1, numLeaves,
            new PathSlice(sortedWriter, 0, valueCount),
            out,
            globalMinValue, globalMaxValue,
            blockMinValues,
            leafBlockFPs);
      success = true;
    } finally {
      if (success) {
        sortedWriter.destroy();
        if (tempInput != null) {
          tempDir.deleteFile(tempInput.getName());
        }
      } else {
        try {
          sortedWriter.destroy();
        } catch (Throwable t) {
          // Suppress to keep throwing original exc
        }
        if (tempInput != null) {
          IOUtils.deleteFilesIgnoringExceptions(tempDir, tempInput.getName());
        }
      }
    }

    //System.out.println("Total nodes: " + innerNodeCount);

    // Write index:
    long indexFP = out.getFilePointer();
    out.writeVInt(numLeaves);
    out.writeVInt((int) (valueCount / numLeaves));

    for (int i=0;i<blockMinValues.length;i++) {
      out.writeLong(blockMinValues[i]);
    }
    for (int i=0;i<leafBlockFPs.length;i++) {
      out.writeVLong(leafBlockFPs[i]);
    }
    out.writeLong(globalMaxValue);

    return indexFP;
  }

