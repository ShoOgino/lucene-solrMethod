  public void testNormMapRandom() {

    Set<Byte> uniqueValuesSet = new HashSet<>();
    int numUniqValues = TestUtil.nextInt(random(), 1, 256);
    for (int i = 0; i < numUniqValues; i++) {
      uniqueValuesSet.add(Byte.valueOf((byte)TestUtil.nextInt(random(), Byte.MIN_VALUE, Byte.MAX_VALUE)));
    }
    Byte uniqueValues[] = uniqueValuesSet.toArray(new Byte[uniqueValuesSet.size()]);

    Map<Byte,Integer> freqs = new HashMap<>();
    NormMap map = new NormMap();
    int numdocs = TestUtil.nextInt(random(), 1, 100000);
    for (int i = 0; i < numdocs; i++) {
      byte value = uniqueValues[random().nextInt(uniqueValues.length)];
      // now add to both expected and actual
      map.add(value);
      if (freqs.containsKey(value)) {
        freqs.put(value, freqs.get(value) + 1);
      } else {
        freqs.put(value, 1);
      }
    }

    assertEquals(freqs.size(), map.size);
    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {
      byte value = kv.getKey();
      int freq = kv.getValue();
      int ord = map.ord(value);
      assertEquals(freq, map.freqs[ord]);
      assertEquals(value, map.values[ord]);
    }

    // optimizing should reorder ordinals from greatest to least frequency
    map.optimizeOrdinals();
    // recheck consistency
    assertEquals(freqs.size(), map.size);
    for (Map.Entry<Byte,Integer> kv : freqs.entrySet()) {
      byte value = kv.getKey();
      int freq = kv.getValue();
      int ord = map.ord(value);
      assertEquals(freq, map.freqs[ord]);
      assertEquals(value, map.values[ord]);
    }
    // also check descending freq
    int prevFreq = map.freqs[0];
    for (int i = 1; i < map.size; ++i) {
      assertTrue(prevFreq >= map.freqs[i]);
      prevFreq = map.freqs[i];
    }
  }

