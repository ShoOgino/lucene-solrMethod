  @Override
  public void addSortedField(FieldInfo field, Iterable<BytesRef> values, Iterable<Number> docToOrd) throws IOException {
    if (field.getDocValuesGen() != -1) {
      throw new UnsupportedOperationException("4.0 does not support dv updates");
    }
    // examine the values to determine best type to use
    int minLength = Integer.MAX_VALUE;
    int maxLength = Integer.MIN_VALUE;
    for (BytesRef b : values) {
      minLength = Math.min(minLength, b.length);
      maxLength = Math.max(maxLength, b.length);
    }
    
    // but dont use fixed if there are missing values (we are simulating how lucene40 wrote dv...)
    boolean anyMissing = false;
    for (Number n : docToOrd) {
      if (n.longValue() == -1) {
        anyMissing = true;
        break;
      }
    }
    
    boolean success = false;
    IndexOutput data = null;
    IndexOutput index = null;
    String dataName = IndexFileNames.segmentFileName(state.segmentInfo.name + "_" + Integer.toString(field.number), segmentSuffix, "dat");
    String indexName = IndexFileNames.segmentFileName(state.segmentInfo.name + "_" + Integer.toString(field.number), segmentSuffix, "idx");
    
    try {
      data = dir.createOutput(dataName, state.context);
      index = dir.createOutput(indexName, state.context);
      if (minLength == maxLength && !anyMissing) {
        // fixed byte[]
        addFixedSortedBytesField(field, data, index, values, docToOrd, minLength);
      } else {
        // var byte[]
        // three cases for simulating the old writer:
        // 1. no missing
        // 2. missing (and empty string in use): remap ord=-1 -> ord=0
        // 3. missing (and empty string not in use): remap all ords +1, insert empty string into values
        if (!anyMissing) {
          addVarSortedBytesField(field, data, index, values, docToOrd);
        } else if (minLength == 0) {
          addVarSortedBytesField(field, data, index, values, MissingOrdRemapper.mapMissingToOrd0(docToOrd));
        } else {
          addVarSortedBytesField(field, data, index, MissingOrdRemapper.insertEmptyValue(values), MissingOrdRemapper.mapAllOrds(docToOrd));
        }
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(data, index);
      } else {
        IOUtils.closeWhileHandlingException(data, index);
      }
    }
  }

