// These changes were made to introduce operator precedence:
// - Clause() now returns a QueryNode. 
// - The modifiers are consumed by Clause() and returned as part of the QueryNode Object
// - Query does not consume conjunctions (AND, OR) anymore. 
// - This is now done by two new non-terminals: ConjClause and DisjClause
// The parse tree looks similar to this:
//       Query ::= DisjQuery ( DisjQuery )*
//   DisjQuery ::= ConjQuery ( OR ConjQuery )* 
//   ConjQuery ::= Clause ( AND Clause )*
//      Clause ::= [ Modifier ] ... 
  final public 

QueryNode Query(CharSequence field) throws ParseException {Vector<QueryNode> clauses = null;
  QueryNode c, first=null;
    first = DisjQuery(field);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk_f():jj_ntk) {
      case NOT:
      case PLUS:
      case MINUS:
      case LPAREN:
      case QUOTED:
      case TERM:
      case REGEXPTERM:
      case RANGEIN_START:
      case RANGEEX_START:
      case NUMBER:{
        ;
        break;
        }
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      c = DisjQuery(field);
if (clauses == null) {
           clauses = new Vector<QueryNode>();
           clauses.addElement(first);
        }
        clauses.addElement(c);
    }
if (clauses != null) {
        {if ("" != null) return new BooleanQueryNode(clauses);}
      } else {
          // Handle the case of a "pure" negation query which
          // needs to be wrapped as a boolean query, otherwise
          // the returned result drops the negation.
          if (first instanceof ModifierQueryNode) {
            ModifierQueryNode m = (ModifierQueryNode) first;
            if (m.getModifier() == ModifierQueryNode.Modifier.MOD_NOT) {
              {if ("" != null) return new BooleanQueryNode(Arrays.asList(m));}
            }
          }
          {if ("" != null) return first;}
      }
    throw new Error("Missing return statement in function");
}

