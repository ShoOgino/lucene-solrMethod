  /**
   * Creates a new Dictionary containing the information read from the provided InputStreams to hunspell affix
   * and dictionary files.
   * You have to close the provided InputStreams yourself.
   *
   * @param affix InputStream for reading the hunspell affix file (won't be closed).
   * @param dictionary InputStream for reading the hunspell dictionary file (won't be closed).
   * @throws IOException Can be thrown while reading from the InputStreams
   * @throws ParseException Can be thrown if the content of the files does not meet expected formats
   */
  public Dictionary(InputStream affix, InputStream dictionary) throws IOException, ParseException {
    BufferedInputStream buffered = new BufferedInputStream(affix, 8192);
    buffered.mark(8192);
    String encoding = getDictionaryEncoding(affix);
    buffered.reset();
    CharsetDecoder decoder = getJavaEncoding(encoding);
    readAffixFile(buffered, decoder);
    TreeMap<BytesRef,Integer> tempWords = new TreeMap<BytesRef,Integer>();
    flagLookup.add(new BytesRef()); // no flags -> ord 0
    readDictionaryFile(dictionary, decoder, tempWords);
    PositiveIntOutputs o = PositiveIntOutputs.getSingleton();
    Builder<Long> b = new Builder<Long>(FST.INPUT_TYPE.BYTE4, o); // nocommit: byte4
    IntsRef scratchInts = new IntsRef();
    for (Map.Entry<BytesRef,Integer> e : tempWords.entrySet()) {
      UnicodeUtil.UTF8toUTF32(e.getKey(), scratchInts);
      b.add(scratchInts, e.getValue().longValue());
    }
    words = b.finish();
  }

