  /**
   * Applies the affix rule to the given word, producing a list of stems if any are found
   *
   * @param strippedWord Word the affix has been removed and the strip added
   * @param affix HunspellAffix representing the affix rule itself
   * @param recursionDepth Level of recursion this stemming step is at
   * @return List of stems for the word, or an empty list if none are found
   */
  @SuppressWarnings("unchecked")
  public List<Stem> applyAffix(char strippedWord[], int length, HunspellAffix affix, int recursionDepth) {
    if(dictionary.isIgnoreCase()) {
      for(int i=0;i<strippedWord.length;){
        i += Character.toChars(
              Character.toLowerCase(charUtils.codePointAt(strippedWord, i)), strippedWord, i);
      }
    }
    segment.setLength(0);
    segment.append(strippedWord, 0, length);
    if (!affix.checkCondition(segment)) {
      return Collections.EMPTY_LIST;
    }

    List<Stem> stems = new ArrayList<Stem>();

    List<HunspellWord> words = dictionary.lookupWord(strippedWord, 0, length);
    if (words != null) {
      for (HunspellWord hunspellWord : words) {
        if (hunspellWord.hasFlag(affix.getFlag())) {
          stems.add(new Stem(strippedWord, length));
        }
      }
    }

    if (affix.isCrossProduct() && recursionDepth < RECURSION_CAP) {
      stems.addAll(stem(strippedWord, length, affix.getAppendFlags(), ++recursionDepth));
    }

    return stems;
  }

