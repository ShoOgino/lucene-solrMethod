  @Override
  public final boolean incrementToken() throws IOException {
    while (true) {
      if (curTermBuffer == null) {
        if (!input.incrementToken()) {
          return false;
        } else {
          curTermBuffer = termAtt.buffer().clone();
          curTermLength = termAtt.length();
          curGramSize = minGram;
          tokStart = offsetAtt.startOffset();
          tokEnd = offsetAtt.endOffset();
          if (version.onOrAfter(Version.LUCENE_44)) {
            // Never update offsets
            updateOffsets = false;
          } else {
            // if length by start + end offsets doesn't match the term text then assume
            // this is a synonym and don't adjust the offsets.
            updateOffsets = (tokStart + curTermLength) == tokEnd;
          }
          savePosIncr = posIncrAtt.getPositionIncrement();
        }
      }
      if (curGramSize <= maxGram) {         // if we have hit the end of our n-gram size range, quit
        if (curGramSize <= curTermLength) { // if the remaining input is too short, we can't generate any n-grams
          // grab gramSize chars from front or back
          int start = side == Side.FRONT ? 0 : curTermLength - curGramSize;
          int end = start + curGramSize;
          clearAttributes();
          if (updateOffsets) {
            offsetAtt.setOffset(tokStart + start, tokStart + end);
          } else {
            offsetAtt.setOffset(tokStart, tokEnd);
          }
          // first ngram gets increment, others don't
          if (curGramSize == minGram) {
            //  Leave the first token position increment at the cleared-attribute value of 1
            if ( ! isFirstToken) {
              posIncrAtt.setPositionIncrement(savePosIncr);
            }
          } else {
            posIncrAtt.setPositionIncrement(0);
          }
          termAtt.copyBuffer(curTermBuffer, start, curGramSize);
          curGramSize++;
          isFirstToken = false;
          return true;
        }
      }
      curTermBuffer = null;
    }
  }

