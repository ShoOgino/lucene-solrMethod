  /**
   * Reads the dictionary file through the provided InputStream, building up the words map
   *
   * @param dictionary InputStream to read the dictionary file through
   * @param decoder CharsetDecoder used to decode the contents of the file
   * @throws IOException Can be thrown while reading from the file
   */
  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, TreeMap<BytesRef,Integer> words) throws IOException {
    BytesRef flagsScratch = new BytesRef();
    BytesRef flagsScratch2 = new BytesRef();
    
    BufferedReader reader = new BufferedReader(new InputStreamReader(dictionary, decoder));
    // TODO: don't create millions of strings.
    String line = reader.readLine(); // first line is number of entries
    // sometimes the number of entries has a comment/copyright after it
    line = line.replaceFirst("\\s*\\#.*$", "");
    int numEntries = Integer.parseInt(line);
    
    // TODO: the flags themselves can be double-chars (long) or also numeric
    // either way the trick is to encode them as char... but they must be parsed differently
    while ((line = reader.readLine()) != null) {
      String entry;
      char wordForm[];
      
      int flagSep = line.lastIndexOf('/');
      if (flagSep == -1) {
        wordForm = NOFLAGS;
        entry = line;
      } else {
        // note, there can be comments (morph description) after a flag.
        // we should really look for any whitespace
        int end = line.indexOf('\t', flagSep);
        if (end == -1)
          end = line.length();
        
        String flagPart = line.substring(flagSep + 1, end);
        if (aliasCount > 0) {
          flagPart = getAliasValue(Integer.parseInt(flagPart));
        } 
        
        wordForm = flagParsingStrategy.parseFlags(flagPart);
        Arrays.sort(wordForm);
        entry = line.substring(0, flagSep);
      }

      BytesRef scratch = new BytesRef(entry);
      Integer existingOrd = words.get(scratch);
      final char mergedEntries[];
      if (existingOrd == null || existingOrd == 0) {
        mergedEntries = wordForm;
      } else {
        flagLookup.get(existingOrd, flagsScratch2);
        mergedEntries = merge(decodeFlags(flagsScratch2), wordForm);
      }

      final int hashCode = encodeFlagsWithHash(flagsScratch, mergedEntries);
      int ord = flagLookup.add(flagsScratch, hashCode);
      if (ord < 0) {
        // already exists in our hash
        ord = (-ord)-1;
      }
      
      words.put(scratch, ord);
    }
  }

