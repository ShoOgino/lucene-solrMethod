  /**
   * Reads the dictionary file through the provided InputStream, building up the words map
   *
   * @param dictionary InputStream to read the dictionary file through
   * @param decoder CharsetDecoder used to decode the contents of the file
   * @throws IOException Can be thrown while reading from the file
   */
  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, Builder<Long> words) throws IOException {
    BytesRef flagsScratch = new BytesRef();
    IntsRef scratchInts = new IntsRef();
    
    BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));
    String line = lines.readLine(); // first line is number of entries (approximately, sometimes)
    
    File unsorted = File.createTempFile("unsorted", "dat", tempDir);
    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {
      while ((line = lines.readLine()) != null) {
        writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));
      }
    }
    File sorted = File.createTempFile("sorted", "dat", tempDir);
    
    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {
      BytesRef scratch1 = new BytesRef();
      BytesRef scratch2 = new BytesRef();
      
      @Override
      public int compare(BytesRef o1, BytesRef o2) {
        scratch1.bytes = o1.bytes;
        scratch1.offset = o1.offset;
        scratch1.length = o1.length;
        
        for (int i = scratch1.length - 1; i >= 0; i--) {
          if (scratch1.bytes[scratch1.offset + i] == '/') {
            scratch1.length = i;
            break;
          }
        }
        
        scratch2.bytes = o2.bytes;
        scratch2.offset = o2.offset;
        scratch2.length = o2.length;
        
        for (int i = scratch2.length - 1; i >= 0; i--) {
          if (scratch2.bytes[scratch2.offset + i] == '/') {
            scratch2.length = i;
            break;
          }
        }
        
        return scratch1.compareTo(scratch2);
      }
    });
    sorter.sort(unsorted, sorted);
    unsorted.delete();
    
    ByteSequencesReader reader = new ByteSequencesReader(sorted);
    BytesRef scratchLine = new BytesRef();
    
    // TODO: the flags themselves can be double-chars (long) or also numeric
    // either way the trick is to encode them as char... but they must be parsed differently
    
    BytesRef currentEntry = new BytesRef();
    char currentFlags[] = new char[0];
    
    while (reader.read(scratchLine)) {
      line = scratchLine.utf8ToString();
      String entry;
      char wordForm[];
      
      int flagSep = line.lastIndexOf('/');
      if (flagSep == -1) {
        wordForm = NOFLAGS;
        entry = line;
      } else {
        // note, there can be comments (morph description) after a flag.
        // we should really look for any whitespace
        int end = line.indexOf('\t', flagSep);
        if (end == -1)
          end = line.length();
        
        String flagPart = line.substring(flagSep + 1, end);
        if (aliasCount > 0) {
          flagPart = getAliasValue(Integer.parseInt(flagPart));
        } 
        
        wordForm = flagParsingStrategy.parseFlags(flagPart);
        Arrays.sort(wordForm);
        entry = line.substring(0, flagSep);
      }

      BytesRef scratch = new BytesRef(entry);
      int cmp = scratch.compareTo(currentEntry);
      if (cmp < 0) {
        throw new IllegalArgumentException("out of order: " + scratch.utf8ToString() + " < " + currentEntry.utf8ToString());
      } else if (cmp == 0) {
        currentFlags = merge(currentFlags, wordForm);
      } else {
        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);
        int ord = flagLookup.add(flagsScratch, hashCode);
        if (ord < 0) {
          // already exists in our hash
          ord = (-ord)-1;
        }
        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);
        words.add(scratchInts, (long)ord);
        currentEntry = scratch;
        currentFlags = wordForm;
      }
    }
    
    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);
    int ord = flagLookup.add(flagsScratch, hashCode);
    if (ord < 0) {
      // already exists in our hash
      ord = (-ord)-1;
    }
    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);
    words.add(scratchInts, (long)ord);
    
    reader.close();
    sorted.delete();
  }

