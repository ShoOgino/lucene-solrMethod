  /**
   * Applies the affix rule to the given word, producing a list of stems if any are found
   *
   * @param strippedWord Word the affix has been removed and the strip added
   * @param affix HunspellAffix representing the affix rule itself
   * @param recursionDepth Level of recursion this stemming step is at
   * @return List of stems for the word, or an empty list if none are found
   */
  List<CharsRef> applyAffix(char strippedWord[], int length, int affix, int recursionDepth) {
    segment.setLength(0);
    segment.append(strippedWord, 0, length);
    
    affixReader.setPosition(8 * affix);
    char flag = (char) (affixReader.readShort() & 0xffff);
    affixReader.skipBytes(2); // strip
    int condition = (char) (affixReader.readShort() & 0xffff);
    boolean crossProduct = (condition & 1) == 1;
    condition >>>= 1;
    char append = (char) (affixReader.readShort() & 0xffff);

    Pattern pattern = dictionary.patterns.get(condition);
    if (!pattern.matcher(segment).matches()) {
      return Collections.emptyList();
    }

    List<CharsRef> stems = new ArrayList<CharsRef>();

    char wordFlags[] = dictionary.lookupWord(strippedWord, 0, length, scratch);
    if (wordFlags != null && Dictionary.hasFlag(wordFlags, flag)) {
      stems.add(new CharsRef(strippedWord, 0, length));
    }

    if (crossProduct && recursionDepth < recursionCap) {
      dictionary.flagLookup.get(append, scratch);
      char appendFlags[] = Dictionary.decodeFlags(scratch);
      stems.addAll(stem(strippedWord, length, appendFlags, ++recursionDepth));
    }

    return stems;
  }

