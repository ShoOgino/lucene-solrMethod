  private void popNextLemma() {
    if (multipleTagsPerLemma) {
      // One tag (concatenated) per lemma.
      final WordData lemma = lemmaList.get(lemmaListIndex++);
      termAtt.setEmpty().append(lemma.getStem());
      CharSequence tag = lemma.getTag();
      if (tag != null) {
        String[] tags = tag.toString().split("\\+");
        for (int i = 0; i < tags.length; i++) {
          if (tagsList.size() <= i) {
            tagsList.add(new StringBuilder());
          }
          StringBuilder buffer = tagsList.get(i);
          buffer.setLength(0);
          buffer.append(tags[i]);
        }
        tagsAtt.setTags(tagsList.subList(0, tags.length));
      } else {
        tagsAtt.setTags(Collections.<StringBuilder> emptyList());
      }
    } else {
      // One tag (concatenated) per stem (lemma repeated).
      CharSequence currentStem;
      int tags = 0;
      do {
        final WordData lemma = lemmaList.get(lemmaListIndex++);
        currentStem = lemma.getStem();
        final CharSequence tag = lemma.getTag();
        if (tag != null) {
          if (tagsList.size() <= tags) {
            tagsList.add(new StringBuilder());
          }
  
          final StringBuilder buffer = tagsList.get(tags++);  
          buffer.setLength(0);
          buffer.append(lemma.getTag());
        }
      } while (lemmaListIndex < lemmaList.size() &&
               equalCharSequences(lemmaList.get(lemmaListIndex).getStem(), currentStem));

      // Set the lemma's base form and tags as attributes.
      termAtt.setEmpty().append(currentStem);
      tagsAtt.setTags(tagsList.subList(0, tags));
    }
  }

