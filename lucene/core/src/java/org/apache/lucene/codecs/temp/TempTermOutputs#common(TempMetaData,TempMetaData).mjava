  @Override
  //
  // The return value will be the smaller one, when these two are 
  // 'comparable', i.e. every value in long[] fits the same ordering.
  //
  // NOTE: 
  // Only long[] part is 'shared' and pushed towards root.
  // byte[] and term stats will be on deeper arcs.
  //
  public TempMetaData common(TempMetaData t1, TempMetaData t2) {
    if (DEBUG) System.out.print("common("+t1+", "+t2+") = ");
    if (t1 == NO_OUTPUT || t2 == NO_OUTPUT) {
      if (DEBUG) System.out.println("ret:"+NO_OUTPUT);
      return NO_OUTPUT;
    }
    assert t1.longs.length == t2.longs.length;

    long[] min = t1.longs, max = t2.longs;
    int pos = 0;
    TempMetaData ret;

    while (pos < longsSize && min[pos] == max[pos]) {
      pos++;
    }
    if (pos < longsSize) {  // unequal long[]
      if (min[pos] > max[pos]) {
        min = t2.longs;
        max = t1.longs;
      }
      // check whether strictly smaller
      while (pos < longsSize && min[pos] <= max[pos]) {
        pos++;
      }
      if (pos < longsSize || allZero(min)) {  // not comparable or all-zero
        ret = NO_OUTPUT;
      } else {
        ret = new TempMetaData(min, null, 0, -1);
      }
    } else {  // equal long[]
      if (statsEqual(t1, t2) && (t1.bytes == null || bytesEqual(t1, t2))) {
        ret = t1;
      } else if (allZero(min)) {
        ret = NO_OUTPUT;
      } else {
        ret = new TempMetaData(min, null, 0, -1);
      }
    }
    if (DEBUG) System.out.println("ret:"+ret);
    return ret;
  }

