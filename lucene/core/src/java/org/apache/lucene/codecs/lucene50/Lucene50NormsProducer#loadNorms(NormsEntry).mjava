  private Norms loadNorms(NormsEntry entry) throws IOException {
    switch(entry.format) {
      case CONST_COMPRESSED: {
        final long v = entry.offset;
        return new Norms() {
          @Override
          public long get(int docID) {
            return v;
          }

          @Override
          public long ramBytesUsed() {
            return 8;
          }

          @Override
          public String toString() {
            return "constant";
          }
        };
      }
      case UNCOMPRESSED: {
        data.seek(entry.offset);
        final byte bytes[] = new byte[entry.count];
        data.readBytes(bytes, 0, bytes.length);
        return new Norms() {
          @Override
          public long get(int docID) {
            return bytes[docID];
          }

          @Override
          public long ramBytesUsed() {
            return RamUsageEstimator.sizeOf(bytes);
          }

          @Override
          public String toString() {
            return "byte array";
          }
        };
      }
      case DELTA_COMPRESSED: {
        data.seek(entry.offset);
        int packedIntsVersion = data.readVInt();
        int blockSize = data.readVInt();
        final BlockPackedReader reader = new BlockPackedReader(data, packedIntsVersion, blockSize, entry.count, false);
        return new Norms() {
          @Override
          public long get(int docID) {
            return reader.get(docID);
          }

          @Override
          public long ramBytesUsed() {
            return reader.ramBytesUsed();
          }

          @Override
          public Collection<Accountable> getChildResources() {
            return Collections.singleton(reader);
          }

          @Override
          public String toString() {
            return "delta compressed";
          }
        };
      }
      case TABLE_COMPRESSED: {
        data.seek(entry.offset);
        int packedIntsVersion = data.readVInt();
        final int formatID = data.readVInt();
        final int bitsPerValue = data.readVInt();
        
        if (bitsPerValue != 1 && bitsPerValue != 2 && bitsPerValue != 4) {
          throw new CorruptIndexException("TABLE_COMPRESSED only supports bpv=1, bpv=2 and bpv=4, got=" + bitsPerValue, data);
        }
        int size = 1 << bitsPerValue;
        final byte decode[] = new byte[size];
        final int ordsSize = data.readVInt();
        for (int i = 0; i < ordsSize; ++i) {
          decode[i] = data.readByte();
        }
        for (int i = ordsSize; i < size; ++i) {
          decode[i] = 0;
        }

        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), packedIntsVersion, entry.count, bitsPerValue);
        return new Norms() {
          @Override
          public long get(int docID) {
            return decode[(int)ordsReader.get(docID)];
          }
          
          @Override
          public long ramBytesUsed() {
            return RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed();
          }

          @Override
          public Collection<Accountable> getChildResources() {
            return Collections.singleton(ordsReader);
          }

          @Override
          public String toString() {
            return "table compressed";
          }
        };
      }
      case INDIRECT: {
        data.seek(entry.offset);
        final long common = data.readLong();
        int packedIntsVersion = data.readVInt();
        int blockSize = data.readVInt();
        final MonotonicBlockPackedReader live = MonotonicBlockPackedReader.of(data, packedIntsVersion, blockSize, entry.count, false);
        final Norms nestedInstance = loadNorms(entry.nested);
        final int upperBound = entry.count-1;
        return new Norms() {
          @Override
          public long get(int docID) {
            int low = 0;
            int high = upperBound;
            while (low <= high) {
              int mid = (low + high) >>> 1;
              long doc = live.get(mid);
              
              if (doc < docID) {
                low = mid + 1;
              } else if (doc > docID) {
                high = mid - 1;
              } else {
                return nestedInstance.get(mid);
              }
            }
            return common;
          }

          @Override
          public long ramBytesUsed() {
            return live.ramBytesUsed() + nestedInstance.ramBytesUsed();
          }

          @Override
          public Collection<Accountable> getChildResources() {
            List<Accountable> children = new ArrayList<>();
            children.add(Accountables.namedAccountable("keys", live));
            children.add(Accountables.namedAccountable("values", nestedInstance));
            return Collections.unmodifiableList(children);
          }

          @Override
          public String toString() {
            return "indirect";
          }
        };
      }
      case PATCHED_BITSET: {
        data.seek(entry.offset);
        final long common = data.readLong();
        int packedIntsVersion = data.readVInt();
        int blockSize = data.readVInt();
        MonotonicBlockPackedReader live = MonotonicBlockPackedReader.of(data, packedIntsVersion, blockSize, entry.count, true);
        final SparseFixedBitSet set = new SparseFixedBitSet(maxDoc);
        for (int i = 0; i < live.size(); i++) {
          int doc = (int) live.get(i);
          set.set(doc);
        }
        Norms nestedInstance = loadNorms(entry.nested);
        return new Norms() {
          @Override
          public long get(int docID) {
            if (set.get(docID)) {
              return nestedInstance.get(docID);
            } else {
              return common;
            }
          }
          
          @Override
          public long ramBytesUsed() {
            return set.ramBytesUsed() + nestedInstance.ramBytesUsed();
          }

          @Override
          public Collection<Accountable> getChildResources() {
            List<Accountable> children = new ArrayList<>();
            children.add(Accountables.namedAccountable("keys", set));
            children.add(Accountables.namedAccountable("values", nestedInstance));
            return Collections.unmodifiableList(children);
          }

          @Override
          public String toString() {
            return "patched bitset";
          }
        };
      }
      case PATCHED_TABLE: {
        data.seek(entry.offset);
        int packedIntsVersion = data.readVInt();
        final int formatID = data.readVInt();
        final int bitsPerValue = data.readVInt();

        if (bitsPerValue != 2 && bitsPerValue != 4) {
          throw new CorruptIndexException("PATCHED_TABLE only supports bpv=2 and bpv=4, got=" + bitsPerValue, data);
        }
        final int size = 1 << bitsPerValue;
        final int ordsSize = data.readVInt();
        final byte decode[] = new byte[ordsSize];
        assert ordsSize + 1 == size;
        for (int i = 0; i < ordsSize; ++i) {
          decode[i] = data.readByte();
        }
        
        final PackedInts.Reader ordsReader = PackedInts.getReaderNoHeader(data, PackedInts.Format.byId(formatID), packedIntsVersion, entry.count, bitsPerValue);
        final Norms nestedInstance = loadNorms(entry.nested);
        
        return new Norms() {
          @Override
          public long get(int docID) {
            int ord = (int)ordsReader.get(docID);
            try {
              // doing a try/catch here eliminates a seemingly unavoidable branch in hotspot...
              return decode[ord];
            } catch (IndexOutOfBoundsException e) {
              return nestedInstance.get(docID);
            }
          }

          @Override
          public long ramBytesUsed() {
            return RamUsageEstimator.sizeOf(decode) + ordsReader.ramBytesUsed() + nestedInstance.ramBytesUsed();
          }

          @Override
          public Collection<Accountable> getChildResources() {
            List<Accountable> children = new ArrayList<>();
            children.add(Accountables.namedAccountable("common", ordsReader));
            children.add(Accountables.namedAccountable("uncommon", nestedInstance));
            return Collections.unmodifiableList(children);
          }

          @Override
          public String toString() {
            return "patched table";
          }
        };
      }
      default:
        throw new AssertionError();
    }
  }

