  /** Save a single segment's info. */
  private void writeInfo(IndexOutput output, SegmentInfo si) throws IOException {
    assert si.getDelCount() <= si.docCount: "delCount=" + si.getDelCount() + " docCount=" + si.docCount + " segment=" + si.name;
    // Write the Lucene version that created this segment, since 3.1
    output.writeString(si.getVersion());
    output.writeString(si.name);
    output.writeInt(si.docCount);
    output.writeLong(si.getDelGen());
    // we still need to write this in 4.0 since we can open a 3.x with shared docStores
    output.writeInt(si.getDocStoreOffset());
    if (si.getDocStoreOffset() != -1) {
      output.writeString(si.getDocStoreSegment());
      output.writeByte((byte) (si.getDocStoreIsCompoundFile() ? 1:0));
    }

    Map<Integer,Long> normGen = si.getNormGen();
    if (normGen == null) {
      output.writeInt(SegmentInfo.NO);
    } else {
      output.writeInt(normGen.size());
      for (Entry<Integer,Long> entry : normGen.entrySet()) {
        output.writeInt(entry.getKey());
        output.writeLong(entry.getValue());
      }
    }

    output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));
    output.writeInt(si.getDelCount());
    output.writeByte((byte) (si.getHasProx() ? 1 : 0));
    output.writeString(si.getCodec().getName());
    output.writeStringStringMap(si.getDiagnostics());
    output.writeByte((byte) (si.getHasVectors() ? 1 : 0));
    output.writeByte((byte) (si.getHasDocValues() ? 1 : 0));
    output.writeByte((byte) (si.getHasNorms() ? 1 : 0));
    output.writeByte((byte) (si.getHasFreq() ? 1 : 0));
  }

