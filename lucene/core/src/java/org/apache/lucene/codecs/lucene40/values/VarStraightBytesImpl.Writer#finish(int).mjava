    @Override
    public void finish(int docCount) throws IOException {
      boolean success = false;
      assert (!merge && datOut == null) || (merge && datOut != null); 
      final IndexOutput datOut = getOrCreateDataOut();
      try {
        if (!merge) {
          // header is already written in getDataOut()
          pool.writePool(datOut);
        }
        success = true;
      } finally {
        if (success) {
          IOUtils.close(datOut);
        } else {
          IOUtils.closeWhileHandlingException(datOut);
        }
        pool.reset(false, false);
      }

      success = false;
      final IndexOutput idxOut = getOrCreateIndexOut();
      try {
        if (lastDocID == -1) {
          idxOut.writeVLong(0);
          final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount+1,
              PackedInts.bitsRequired(0), PackedInts.DEFAULT);
          // docCount+1 so we write sentinel
          for (int i = 0; i < docCount+1; i++) {
            w.add(0);
          }
          w.finish();
        } else {
          fill(docCount, address);
          idxOut.writeVLong(address);
          final PackedInts.Writer w = PackedInts.getWriter(idxOut, docCount+1,
              PackedInts.bitsRequired(address), PackedInts.DEFAULT);
          for (int i = 0; i < docCount; i++) {
            w.add(docToAddress[i]);
          }
          // write sentinel
          w.add(address);
          w.finish();
        }
        success = true;
      } finally {
        bytesUsed.addAndGet(-(docToAddress.length)
            * RamUsageEstimator.NUM_BYTES_INT);
        docToAddress = null;
        if (success) {
          IOUtils.close(idxOut);
        } else {
          IOUtils.closeWhileHandlingException(idxOut);
        }
      }
    }

