    public void merge(MergeState mergeState) throws IOException {

      // First pass: mark "live" terms
      for (AtomicReader reader : mergeState.readers) {
        // nocommit what if this is null...?  need default source?
        int maxDoc = reader.maxDoc();

        SegmentState state = new SegmentState();
        state.reader = reader;
        state.values = reader.getSortedDocValues(mergeState.fieldInfo.name);
        if (state.values == null) {
          state.values = new SortedDocValues.EMPTY(maxDoc);
        }

        segStates.add(state);
        assert state.values.getValueCount() < Integer.MAX_VALUE;
        if (reader.hasDeletions()) {
          state.liveTerms = new FixedBitSet(state.values.getValueCount());
          Bits liveDocs = reader.getLiveDocs();
          for(int docID=0;docID<maxDoc;docID++) {
            if (liveDocs.get(docID)) {
              state.liveTerms.set(state.values.getOrd(docID));
            }
          }
        }

        // nocommit we can unload the bits to disk to reduce
        // transient ram spike...
      }

      // Second pass: merge only the live terms

      TermMergeQueue q = new TermMergeQueue(segStates.size());
      for(SegmentState segState : segStates) {
        if (segState.nextTerm() != null) {

          // nocommit we could defer this to 3rd pass (and
          // reduce transient RAM spike) but then
          // we'd spend more effort computing the mapping...:
          segState.segOrdToMergedOrd = new int[segState.values.getValueCount()];
          q.add(segState);
        }
      }

      BytesRef lastTerm = null;
      int ord = 0;
      while (q.size() != 0) {
        SegmentState top = q.top();
        if (lastTerm == null || !lastTerm.equals(top.scratch)) {
          lastTerm = BytesRef.deepCopyOf(top.scratch);
          // nocommit we could spill this to disk instead of
          // RAM, and replay on finish...
          mergedTerms.add(lastTerm);
          ord++;
          if (fixedLength == -2) {
            fixedLength = lastTerm.length;
          } else {
            if (lastTerm.length != fixedLength) {
              fixedLength = -1;
            }
          }
          maxLength = Math.max(maxLength, lastTerm.length);
        }

        top.segOrdToMergedOrd[top.ord] = ord-1;
        if (top.nextTerm() == null) {
          q.pop();
        } else {
          q.updateTop();
        }
      }

      numMergedTerms = ord;
    }

