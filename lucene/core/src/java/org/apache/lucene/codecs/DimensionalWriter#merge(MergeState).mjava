  /** Default merge implementation to merge incoming dimensional readers by visiting all their points and
   *  adding to this writer */
  public void merge(MergeState mergeState) throws IOException {
    for (FieldInfo fieldInfo : mergeState.mergeFieldInfos) {
      if (fieldInfo.getDimensionCount() != 0) {
        writeField(fieldInfo,
                   new DimensionalReader() {
                     @Override
                     public void intersect(String fieldName, IntersectVisitor mergedVisitor) throws IOException {
                       if (fieldName.equals(fieldInfo.name) == false) {
                         throw new IllegalArgumentException("field name must match the field being merged");
                       }
                       for (int i=0;i<mergeState.dimensionalReaders.length;i++) {
                         DimensionalReader dimensionalReader = mergeState.dimensionalReaders[i];
                         if (dimensionalReader == null) {
                           // This segment has no dimensional values
                           continue;
                         }
                         MergeState.DocMap docMap = mergeState.docMaps[i];
                         int docBase = mergeState.docBase[i];
                         dimensionalReader.intersect(fieldInfo.name,
                                                     new IntersectVisitor() {
                                                       @Override
                                                       public void visit(int docID) {
                                                         // Should never be called because our compare method never returns Relation.CELL_INSIDE_QUERY
                                                         throw new IllegalStateException();
                                                       }

                                                       @Override
                                                       public void visit(int docID, byte[] packedValue) throws IOException {
                                                         int newDocID = docMap.get(docID);
                                                         if (newDocID != -1) {
                                                           // Not deleted:
                                                           mergedVisitor.visit(docBase + newDocID, packedValue);
                                                         }
                                                       }

                                                       @Override
                                                       public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
                                                         // Forces this segment's DimensionalReader to always visit all docs + values:
                                                         return Relation.CELL_CROSSES_QUERY;
                                                       }
                                                     });
                       }
                     }

                     @Override
                     public void checkIntegrity() {
                       throw new UnsupportedOperationException();
                     }

                     @Override
                     public long ramBytesUsed() {
                       return 0L;
                     }

                     @Override
                     public void close() {
                     }
                   });
      }
    }
  }

