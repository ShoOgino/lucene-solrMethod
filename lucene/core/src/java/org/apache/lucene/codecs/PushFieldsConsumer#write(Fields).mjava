  @Override
  public final void write(Fields fields) throws IOException {

    boolean success = false;
    try {
      for(String field : fields) { // for all fields
        FieldInfo fieldInfo = writeState.fieldInfos.fieldInfo(field);
        IndexOptions indexOptions = fieldInfo.getIndexOptions();
        TermsConsumer termsConsumer = addField(fieldInfo);

        Terms terms = fields.terms(field);
        if (terms != null) {

          // Holds all docs that have this field:
          FixedBitSet visitedDocs = new FixedBitSet(writeState.segmentInfo.getDocCount());

          boolean hasFreq = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS) >= 0;
          boolean hasPositions = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS) >= 0;
          assert hasPositions == terms.hasPositions();
          boolean hasOffsets = indexOptions.compareTo(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS) >= 0;
          assert hasOffsets == terms.hasOffsets();
          boolean hasPayloads = fieldInfo.hasPayloads();

          long sumTotalTermFreq = 0;
          long sumDocFreq = 0;

          int flags = 0;
          if (hasPositions == false) {
            if (hasFreq) {
              flags = flags | DocsEnum.FLAG_FREQS;
            }
          } else {
            if (hasPayloads) {
              flags = flags | DocsAndPositionsEnum.FLAG_PAYLOADS;
            }
            if (hasOffsets) {
              flags = flags | DocsAndPositionsEnum.FLAG_OFFSETS;
            }
          }

          DocsEnum docsEnum = null;
          DocsAndPositionsEnum docsAndPositionsEnum = null;
          TermsEnum termsEnum = terms.iterator(null);

          while (true) { // for all terms in this field
            BytesRef term = termsEnum.next();
            if (term == null) {
              break;
            }
            if (hasPositions) {
              docsAndPositionsEnum = termsEnum.docsAndPositions(null, docsAndPositionsEnum, flags);
              docsEnum = docsAndPositionsEnum;
            } else {
              docsEnum = termsEnum.docs(null, docsEnum, flags);
              docsAndPositionsEnum = null;
            }
            assert docsEnum != null;

            PostingsConsumer postingsConsumer = termsConsumer.startTerm(term);

            // How many documents have this term:
            int docFreq = 0;

            // How many times this term occurs:
            long totalTermFreq = 0;

            while(true) { // for all docs in this field+term
              int doc = docsEnum.nextDoc();
              if (doc == DocsEnum.NO_MORE_DOCS) {
                break;
              }
              docFreq++;
              visitedDocs.set(doc);
              if (hasFreq) {
                int freq = docsEnum.freq();
                postingsConsumer.startDoc(doc, freq);
                totalTermFreq += freq;

                if (hasPositions) {
                  for(int i=0;i<freq;i++) { // for all positions in this field+term + doc
                    int pos = docsAndPositionsEnum.nextPosition();
                    BytesRef payload = docsAndPositionsEnum.getPayload();
                    if (hasOffsets) {
                      postingsConsumer.addPosition(pos, payload, docsAndPositionsEnum.startOffset(), docsAndPositionsEnum.endOffset());
                    } else {
                      postingsConsumer.addPosition(pos, payload, -1, -1);
                    }
                  }
                }
              } else {
                postingsConsumer.startDoc(doc, -1);
              }
              postingsConsumer.finishDoc();
            }

            if (docFreq > 0) {
              termsConsumer.finishTerm(term, new TermStats(docFreq, hasFreq ? totalTermFreq : -1));
              sumTotalTermFreq += totalTermFreq;
              sumDocFreq += docFreq;
            }
          }

          termsConsumer.finish(hasFreq ? sumTotalTermFreq : -1, sumDocFreq, visitedDocs.cardinality());
        }
      }
      success = true;
    } finally {
      if (success) {
        IOUtils.close(this);
      } else {
        IOUtils.closeWhileHandlingException(this);
      }
    }
  }

