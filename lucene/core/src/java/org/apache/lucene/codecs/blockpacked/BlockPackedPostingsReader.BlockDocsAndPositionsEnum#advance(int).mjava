    @Override
    public int advance(int target) throws IOException {
      // nocommit make frq block load lazy/skippable
      if (DEBUG) {
        System.out.println("  FPR.advance target=" + target);
      }

      // nocommit 2 is heuristic guess!!
      // nocommit put cheating back!  does it help?
      // nocommit use skipper!!!  it has next last doc id!!
      //if (docFreq > blockSize && target - (blockSize - docBufferUpto) - 2*blockSize > accum) {
      if (docFreq > BLOCK_SIZE && target - accum > BLOCK_SIZE) {
        if (DEBUG) {
          System.out.println("    try skipper");
        }
        if (skipper == null) {
          // Lazy init: first time this enum has ever been used for skipping
          if (DEBUG) {
            System.out.println("    create skipper");
          }
          skipper = new BlockPackedSkipReader((IndexInput) docIn.clone(),
                                        BlockPackedPostingsWriter.maxSkipLevels,
                                        BLOCK_SIZE,
                                        true,
                                        indexHasOffsets,
                                        indexHasPayloads);
        }

        if (!skipped) {
          assert skipOffset != -1;
          // This is the first time this enum has skipped
          // since reset() was called; load the skip data:
          if (DEBUG) {
            System.out.println("    init skipper");
          }
          skipper.init(docTermStartFP+skipOffset, docTermStartFP, posTermStartFP, payTermStartFP, docFreq);
          skipped = true;
        }

        final int newDocUpto = skipper.skipTo(target); 

        if (newDocUpto > docUpto) {
          // Skipper moved
          if (DEBUG) {
            System.out.println("    skipper moved to docUpto=" + newDocUpto + " vs current=" + docUpto + "; docID=" + skipper.getDoc() + " fp=" + skipper.getDocPointer() + " pos.fp=" + skipper.getPosPointer() + " pos.bufferUpto=" + skipper.getPosBufferUpto());
          }

          assert newDocUpto % BLOCK_SIZE == (BLOCK_SIZE - 1): "got " + newDocUpto;
          docUpto = newDocUpto+1;

          // Force to read next block
          docBufferUpto = BLOCK_SIZE;
          accum = skipper.getDoc();
          docIn.seek(skipper.getDocPointer());
          posPendingFP = skipper.getPosPointer();
          posPendingCount = skipper.getPosBufferUpto();
        }
      }

      // Now scan... this is an inlined/pared down version
      // of nextDoc():
      while (true) {
        if (DEBUG) {
          System.out.println("  scan doc=" + accum + " docBufferUpto=" + docBufferUpto);
        }
        if (docUpto == docFreq) {
          return doc = NO_MORE_DOCS;
        }
        // nocommit: in theory we should not hit this?  ie
        // skipper should already have moved us to the block
        // containing the doc?  yet assert false trips ... i
        // think because if you advance w/o having done a
        // nextDoc yet()... can we assert/remove this?
        if (docBufferUpto == BLOCK_SIZE) {
          // nocommit hmm skip freq?  but: we don't ever
          // scan over more than one block?
          refillDocs();
        }
        accum += docDeltaBuffer[docBufferUpto];
        freq = (int) freqBuffer[docBufferUpto];
        posPendingCount += freq;
        docBufferUpto++;
        docUpto++;

        if (accum >= target) {
          break;
        }
      }

      if (liveDocs == null || liveDocs.get(accum)) {
        if (DEBUG) {
          System.out.println("  return doc=" + accum);
        }
        position = 0;
        return doc = accum;
      } else {
        if (DEBUG) {
          System.out.println("  now do nextDoc()");
        }
        return nextDoc();
      }
    }

