  /**
   * Creates a cache (jump table) for {@link IndexedDISI}.
   * If the cache has previously been created, the old cache is returned.
   * @param slice the input slice.
   * @param key identifier for the cache, unique within the segment that originated the slice.
   *            Recommendation is offset+length for the slice, relative to the data mapping the segment.
   *            Warning: Do not use slice.getFilePointer and slice.length as they are not guaranteed
   *            to be unique within the segment (slice.getFilePointer is 0 when a sub-slice is created).
   * @param name human readable designation, typically a field name. Used for debug, log and inspection.
   * @return a cache for the given slice+offset+length or null if not suitable for caching.
   */
  public IndexedDISICache getCache(IndexInput slice, long key, String name) throws IOException {
    final long length = slice.length();
    if (length < MIN_LENGTH_FOR_CACHING) {
      return null;
    }

    IndexedDISICache cache = disiPool.get(key);
    if (cache == null) {
      // TODO: Avoid overlapping builds of the same cache
      // Both BLOCK & DENSE caches are created as they might be requested later for the field,
      // regardless of whether they are requested now
      cache = new IndexedDISICache(slice, name);
      disiPool.put(key, cache);
    }
    return cache;
  }

