  @Override
  public BytesRef next() throws IOException {

    //if (DEBUG) {
    //  System.out.println("\nintEnum.next seg=" + fr.parent.segment);
    //  System.out.println("  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " outputPrefix=" + currentFrame.outputPrefix + " trans: " + currentFrame.transition + " useAutoPrefix=" + useAutoPrefixTerm);
    //}

    nextTerm:
    while (true) {

      boolean isSubBlock;

      if (useAutoPrefixTerm) {

        assert currentFrame.isAutoPrefixTerm;
        useAutoPrefixTerm = false;
        currentFrame.termState.isRealTerm = true;

        //if (DEBUG) {
        //  System.out.println("    now scan beyond auto-prefix term=" + brToString(term) + " floorSuffixLeadEnd=" + Integer.toHexString(currentFrame.floorSuffixLeadEnd));
        //}
        // If we last returned an auto-prefix term, we must now skip all
        // actual terms sharing that prefix.  At most, that skipping
        // requires popping one frame, but it can also require simply
        // scanning ahead within the current frame.  This scanning will
        // skip sub-blocks that contain many terms, which is why the
        // optimization "works":
        int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;
        if (floorSuffixLeadEnd == -1) {
          // An ordinary prefix, e.g. foo*
          int prefix = currentFrame.prefix;
          int suffix = currentFrame.suffix;
          //if (DEBUG) System.out.println("    prefix=" + prefix + " suffix=" + suffix);
          if (suffix == 0) {
            //if (DEBUG) System.out.println("    pop frame & nextTerm");

            // Easy case: the prefix term's suffix is the empty string,
            // meaning the prefix corresponds to all terms in the
            // current block, so we just pop this entire block:
            if (currentFrame.ord == 0) {
              //if (DEBUG) System.out.println("  return null");
              return null;
            }
            currentFrame = stack[currentFrame.ord-1];
            continue nextTerm;
          } else {

            // Just next() until we hit an entry that doesn't share this
            // prefix.  The first next should be a sub-block sharing the
            // same prefix, because if there are enough terms matching a
            // given prefix to warrant an auto-prefix term, then there
            // must also be enough to make a sub-block (assuming
            // minItemsInPrefix > minItemsInBlock):
            scanPrefix:
            while (true) {
              //if (DEBUG) System.out.println("    scan next");
              if (currentFrame.nextEnt == currentFrame.entCount) {
                if (currentFrame.isLastInFloor == false) {
                  currentFrame.loadNextFloorBlock();
                } else if (currentFrame.ord == 0) {
                  //if (DEBUG) System.out.println("  return null0");
                  return null;
                } else {
                  // Pop frame, which also means we've moved beyond this
                  // auto-prefix term:
                  //if (DEBUG) System.out.println("  pop; nextTerm");
                  currentFrame = stack[currentFrame.ord-1];
                  continue nextTerm;
                }
              }
              isSubBlock = currentFrame.next();
              //if (DEBUG) {
              //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);
              //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);
              //  suffixBytes.length = currentFrame.suffix;
              //  System.out.println("      currentFrame.suffix=" + brToString(suffixBytes));
              //}
              for(int i=0;i<suffix;i++) {
                if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {
                  //if (DEBUG) System.out.println("      done; now stop scan");
                  break scanPrefix;
                }
              }
            }
          }
        } else {
          // Floor'd auto-prefix term; in this case we must skip all
          // terms e.g. matching foo[a-m]*.  We are currently "on" fooa,
          // which the automaton accepted (fooa* through foom*), and
          // floorSuffixLeadEnd is m, so we must now scan to foon:
          int prefix = currentFrame.prefix;
          int suffix = currentFrame.suffix;

          if (currentFrame.floorSuffixLeadStart == -1) {
            suffix++;
          }

          //if (DEBUG) System.out.println("      prefix=" + prefix + " suffix=" + suffix);

          if (suffix == 0) {

            //if (DEBUG) System.out.println("  pop frame");

            // This means current frame is fooa*, so we have to first
            // pop the current frame, then scan in parent frame:
            if (currentFrame.ord == 0) {
              //if (DEBUG) System.out.println("  return null");
              return null;
            }
            currentFrame = stack[currentFrame.ord-1];

            // Current (parent) frame is now foo*, so now we just scan
            // until the lead suffix byte is > floorSuffixLeadEnd
            //assert currentFrame.prefix == prefix-1;
            //prefix = currentFrame.prefix;

            // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on
            // its first term = floor prefix term 41[7-9], popping to block 4*:
            prefix = currentFrame.prefix;

            suffix = term.length - currentFrame.prefix;
          } else {
            // No need to pop; just scan in currentFrame:
          }

          //if (DEBUG) System.out.println("    start scan: prefix=" + prefix + " suffix=" + suffix);

          // Now we scan until the lead suffix byte is > floorSuffixLeadEnd
          scanFloor:
          while (true) {
            //if (DEBUG) System.out.println("      scan next");
            if (currentFrame.nextEnt == currentFrame.entCount) {
              if (currentFrame.isLastInFloor == false) {
                //if (DEBUG) System.out.println("      next floor block");
                currentFrame.loadNextFloorBlock();
              } else if (currentFrame.ord == 0) {
                //if (DEBUG) System.out.println("  return null");
                return null;
              } else {
                // Pop frame, which also means we've moved beyond this
                // auto-prefix term:
                currentFrame = stack[currentFrame.ord-1];
                //if (DEBUG) System.out.println("      pop, now curFrame.prefix=" + currentFrame.prefix);
                continue nextTerm;
              }
            }
            isSubBlock = currentFrame.next();
            //if (DEBUG) {
            //  BytesRef suffixBytes = new BytesRef(currentFrame.suffix);
            //  System.arraycopy(currentFrame.suffixBytes, currentFrame.startBytePos, suffixBytes.bytes, 0, currentFrame.suffix);
            //  suffixBytes.length = currentFrame.suffix;
            //  System.out.println("      currentFrame.suffix=" + brToString(suffixBytes));
            //}
            for(int i=0;i<suffix-1;i++) {
              if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {
                //if (DEBUG) System.out.println("      done; now stop scan");
                break scanFloor;
              }
            }
            //if (DEBUG) {
            //  if (currentFrame.suffix >= suffix) {
            //    System.out.println("      cmp label=" + Integer.toHexString(currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]) + " vs " + floorSuffixLeadEnd);
            //  }
            //}
            if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {
              // Done scanning: we are now on the first term after all
              // terms matched by this auto-prefix term
              //if (DEBUG) System.out.println("      done; now stop scan");
              break;
            }
          }
        }
      } else {
        // Pop finished frames
        while (currentFrame.nextEnt == currentFrame.entCount) {
          if (!currentFrame.isLastInFloor) {
            //if (DEBUG) System.out.println("    next-floor-block: trans: " + currentFrame.transition);
            // Advance to next floor block
            currentFrame.loadNextFloorBlock();
            //if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " outputPrefix=" + currentFrame.outputPrefix);
            break;
          } else {
            //if (DEBUG) System.out.println("  pop frame");
            if (currentFrame.ord == 0) {
              //if (DEBUG) System.out.println("  return null");
              return null;
            }
            final long lastFP = currentFrame.fpOrig;
            currentFrame = stack[currentFrame.ord-1];
            assert currentFrame.lastSubFP == lastFP;
            //if (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " outputPrefix=" + currentFrame.outputPrefix);
          }
        }

        isSubBlock = currentFrame.next();
      }

      //if (DEBUG) {
      //  final BytesRef suffixRef = new BytesRef();
      //  suffixRef.bytes = currentFrame.suffixBytes;
      //  suffixRef.offset = currentFrame.startBytePos;
      //  suffixRef.length = currentFrame.suffix;
      //  System.out.println("    " + (isSubBlock ? "sub-block" : "term") + " " + currentFrame.nextEnt + " (of " + currentFrame.entCount + ") suffix=" + brToString(suffixRef));
      //}

      if (currentFrame.suffix != 0) {
        // Advance where we are in the automaton to match what terms
        // dict next'd to:
        final int label = currentFrame.suffixBytes[currentFrame.startBytePos] & 0xff;
        //if (DEBUG) {
        //  System.out.println("    move automaton to label=" + label + " vs curMax=" + currentFrame.curTransitionMax);
        // }
        while (label > currentFrame.curTransitionMax) {
          if (currentFrame.transitionIndex >= currentFrame.transitionCount-1) {
            // Pop this frame: no further matches are possible because
            // we've moved beyond what the max transition will allow
            //if (DEBUG) System.out.println("      break: trans");
            if (currentFrame.ord == 0) {
              //if (DEBUG) System.out.println("  return null");
              return null;
            }
            currentFrame = stack[currentFrame.ord-1];
            continue nextTerm;
          }
          currentFrame.transitionIndex++;
          automaton.getNextTransition(currentFrame.transition);
          currentFrame.curTransitionMax = currentFrame.transition.max;
          //if (DEBUG) System.out.println("      next trans");
        }
      }

      // First test the common suffix, if set:
      if (commonSuffix != null && !isSubBlock) {
        final int termLen = currentFrame.prefix + currentFrame.suffix;
        if (termLen < commonSuffix.length) {
          // No match
          //if (DEBUG) System.out.println("      skip: common suffix length");
          continue nextTerm;
        }

        final byte[] suffixBytes = currentFrame.suffixBytes;
        final byte[] commonSuffixBytes = commonSuffix.bytes;

        final int lenInPrefix = commonSuffix.length - currentFrame.suffix;
        assert commonSuffix.offset == 0;
        int suffixBytesPos;
        int commonSuffixBytesPos = 0;

        if (lenInPrefix > 0) {
          // A prefix of the common suffix overlaps with
          // the suffix of the block prefix so we first
          // test whether the prefix part matches:
          final byte[] termBytes = term.bytes;
          int termBytesPos = currentFrame.prefix - lenInPrefix;
          assert termBytesPos >= 0;
          final int termBytesPosEnd = currentFrame.prefix;
          while (termBytesPos < termBytesPosEnd) {
            if (termBytes[termBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {
              //if (DEBUG) System.out.println("      skip: common suffix mismatch (in prefix)");
              continue nextTerm;
            }
          }
          suffixBytesPos = currentFrame.startBytePos;
        } else {
          suffixBytesPos = currentFrame.startBytePos + currentFrame.suffix - commonSuffix.length;
        }

        // Test overlapping suffix part:
        final int commonSuffixBytesPosEnd = commonSuffix.length;
        while (commonSuffixBytesPos < commonSuffixBytesPosEnd) {
          if (suffixBytes[suffixBytesPos++] != commonSuffixBytes[commonSuffixBytesPos++]) {
            //if (DEBUG) System.out.println("      skip: common suffix mismatch");
            continue nextTerm;
          }
        }
      }

      // TODO: maybe we should do the same linear test
      // that AutomatonTermsEnum does, so that if we
      // reach a part of the automaton where .* is
      // "temporarily" accepted, we just blindly .next()
      // until the limit

      // TODO: for first iter of this loop can't we just use the current trans?  we already advanced it and confirmed it matches lead
      // byte of the suffix

      // See if the term suffix matches the automaton:
      int state = currentFrame.state;
      int lastState = currentFrame.lastState;
      //if (DEBUG) {
      //  System.out.println("  a state=" + state + " curFrame.suffix.len=" + currentFrame.suffix + " curFrame.prefix=" + currentFrame.prefix);
      // }
      for (int idx=0;idx<currentFrame.suffix;idx++) {
        lastState = state;
        //if (DEBUG) System.out.println("    step label=" + (char) (currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff));
        state = runAutomaton.step(state, currentFrame.suffixBytes[currentFrame.startBytePos+idx] & 0xff);
        if (state == -1) {
          // No match
          //System.out.println("    no s=" + state);
          continue nextTerm;
        } else {
          //System.out.println("    c s=" + state);
        }
      }

      //if (DEBUG) System.out.println("    after suffix: state=" + state + " lastState=" + lastState);

      if (isSubBlock) {
        // Match!  Recurse:
        //if (DEBUG) System.out.println("      sub-block match to state=" + state + "; recurse fp=" + currentFrame.lastSubFP);
        copyTerm();
        currentFrame = pushFrame(state);
        currentFrame.lastState = lastState;
        //xif (DEBUG) System.out.println("\n  frame ord=" + currentFrame.ord + " prefix=" + brToString(new BytesRef(term.bytes, term.offset, currentFrame.prefix)) + " state=" + currentFrame.state + " lastInFloor?=" + currentFrame.isLastInFloor + " fp=" + currentFrame.fp + " trans=" + (currentFrame.transitions.length == 0 ? "n/a" : currentFrame.transitions[currentFrame.transitionIndex]) + " outputPrefix=" + currentFrame.outputPrefix);
      } else if (currentFrame.isAutoPrefixTerm) {
        // We are on an auto-prefix term, meaning this term was compiled
        // at indexing time, matching all terms sharing this prefix (or,
        // a floor'd subset of them if that count was too high).  A
        // prefix term represents a range of terms, so we now need to
        // test whether, from the current state in the automaton, it
        // accepts all terms in that range.  As long as it does, we can
        // use this term and then later skip ahead past all terms in
        // this range:
        if (allowAutoPrefixTerms) {

          if (currentFrame.floorSuffixLeadEnd == -1) {
            // Simple prefix case
            useAutoPrefixTerm = state == sinkState;
          } else {
            if (currentFrame.floorSuffixLeadStart == -1) {
              // Must also accept the empty string in this case
              if (automaton.isAccept(state)) {
                //if (DEBUG) System.out.println("      state is accept");
                useAutoPrefixTerm = acceptsSuffixRange(state, 0, currentFrame.floorSuffixLeadEnd);
              }
            } else {
              useAutoPrefixTerm = acceptsSuffixRange(lastState, currentFrame.floorSuffixLeadStart, currentFrame.floorSuffixLeadEnd);
            }
          }

          //if (DEBUG) System.out.println("  useAutoPrefixTerm=" + useAutoPrefixTerm);

          if (useAutoPrefixTerm) {
            copyTerm();
            currentFrame.termState.isRealTerm = false;
            //if (DEBUG) System.out.println("  return auto prefix term: " + brToString(term));
            return term;
          } else {
            // We move onto the next term
          }
        } else {
          // We are not allowed to use auto-prefix terms, so we just skip it
        }
      } else if (runAutomaton.isAccept(state)) {
        copyTerm();
        //if (DEBUG) System.out.println("      term match to state=" + state);
        assert savedStartTerm == null || term.compareTo(savedStartTerm) > 0: "saveStartTerm=" + savedStartTerm.utf8ToString() + " term=" + term.utf8ToString();
        //if (DEBUG) System.out.println("      return term=" + brToString(term));
        return term;
      } else {
        //System.out.println("    no s=" + state);
      }
    }
  }

