  private void readFields(IndexInput meta, FieldInfos infos) throws IOException {
    int fieldNumber = meta.readVInt();
    while (fieldNumber != -1) {
      DocValues.Type type = infos.fieldInfo(fieldNumber).getDocValuesType();
      if (DocValues.isNumber(type) || DocValues.isFloat(type)) {
        numerics.put(fieldNumber, readNumericEntry(meta));
      } else if (DocValues.isBytes(type)) {
        BinaryEntry b = readBinaryEntry(meta);
        binaries.put(fieldNumber, b);
        if (b.minLength != b.maxLength) {
          if (meta.readVInt() != fieldNumber) {
            throw new CorruptIndexException("binary entry for field: " + fieldNumber + " is corrupt");
          }
          // variable length byte[]: read addresses as a numeric dv field
          numerics.put(fieldNumber, readNumericEntry(meta));
        }
      } else if (DocValues.isSortedBytes(type)) {
        BinaryEntry b = readBinaryEntry(meta);
        binaries.put(fieldNumber, b);
        if (b.minLength != b.maxLength) {
          if (meta.readVInt() != fieldNumber) {
            throw new CorruptIndexException("sorted entry for field: " + fieldNumber + " is corrupt");
          }
          // variable length byte[]: read addresses as a numeric dv field
          numerics.put(fieldNumber, readNumericEntry(meta));
        }
        // sorted byte[]: read ords as a numeric dv field
        if (meta.readVInt() != fieldNumber) {
          throw new CorruptIndexException("sorted entry for field: " + fieldNumber + " is corrupt");
        }
        ords.put(fieldNumber, readNumericEntry(meta));
      }
      fieldNumber = meta.readVInt();
    }
  }

