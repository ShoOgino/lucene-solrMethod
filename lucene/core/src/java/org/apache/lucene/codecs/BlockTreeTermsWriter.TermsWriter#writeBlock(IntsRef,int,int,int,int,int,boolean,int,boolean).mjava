    // Writes all entries in the pending slice as a single
    // block: 
    private PendingBlock writeBlock(IntsRef prevTerm, int prefixLength, int indexPrefixLength, int startBackwards, int length,
                                    int futureTermCount, boolean isFloor, int floorLeadByte, boolean isLastInFloor) throws IOException {

      assert length > 0;

      final int start = pending.size()-startBackwards;

      assert start >= 0: "pending.size()=" + pending.size() + " startBackwards=" + startBackwards + " length=" + length;

      final List<PendingEntry> slice = pending.subList(start, start + length);

      final long startFP = out.getFilePointer();

      final BytesRef prefix = new BytesRef(indexPrefixLength);
      for(int m=0;m<indexPrefixLength;m++) {
        prefix.bytes[m] = (byte) prevTerm.ints[m];
      }
      prefix.length = indexPrefixLength;

      // Write block header:
      out.writeVInt((length<<1)|(isLastInFloor ? 1:0));

      // if (DEBUG) {
      //   System.out.println("  writeBlock " + (isFloor ? "(floor) " : "") + "seg=" + segment + " pending.size()=" + pending.size() + " prefixLength=" + prefixLength + " indexPrefix=" + toString(prefix) + " entCount=" + length + " startFP=" + startFP + " futureTermCount=" + futureTermCount + (isFloor ? (" floorLeadByte=" + Integer.toHexString(floorLeadByte&0xff)) : "") + " isLastInFloor=" + isLastInFloor);
      // }

      // 1st pass: pack term suffix bytes into byte[] blob
      // TODO: cutover to bulk int codec... simple64?

      final boolean isLeafBlock;
      if (lastBlockIndex < start) {
        // This block definitely does not contain sub-blocks:
        isLeafBlock = true;
        //System.out.println("no scan true isFloor=" + isFloor);
      } else if (!isFloor) {
        // This block definitely does contain at least one sub-block:
        isLeafBlock = false;
        //System.out.println("no scan false " + lastBlockIndex + " vs start=" + start + " len=" + length);
      } else {
        // Must scan up-front to see if there is a sub-block
        boolean v = true;
        //System.out.println("scan " + lastBlockIndex + " vs start=" + start + " len=" + length);
        for (PendingEntry ent : slice) {
          if (!ent.isTerm) {
            v = false;
            break;
          }
        }
        isLeafBlock = v;
      }

      final List<FST<BytesRef>> subIndices;

      int termCount;
      if (isLeafBlock) {
        subIndices = null;
        for (PendingEntry ent : slice) {
          assert ent.isTerm;
          PendingTerm term = (PendingTerm) ent;
          final int suffix = term.term.length - prefixLength;
          // if (DEBUG) {
          //   BytesRef suffixBytes = new BytesRef(suffix);
          //   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
          //   suffixBytes.length = suffix;
          //   System.out.println("    write term suffix=" + suffixBytes);
          // }
          // For leaf block we write suffix straight
          bytesWriter.writeVInt(suffix);
          bytesWriter.writeBytes(term.term.bytes, prefixLength, suffix);

          // Write term stats, to separate byte[] blob:
          bytesWriter2.writeVInt(term.stats.docFreq);
          if (fieldInfo.getIndexOptions() != IndexOptions.DOCS_ONLY) {
            assert term.stats.totalTermFreq >= term.stats.docFreq;
            bytesWriter2.writeVLong(term.stats.totalTermFreq - term.stats.docFreq);
          }
        }
        termCount = length;
      } else {
        subIndices = new ArrayList<FST<BytesRef>>();
        termCount = 0;
        for (PendingEntry ent : slice) {
          if (ent.isTerm) {
            PendingTerm term = (PendingTerm) ent;
            final int suffix = term.term.length - prefixLength;
            // if (DEBUG) {
            //   BytesRef suffixBytes = new BytesRef(suffix);
            //   System.arraycopy(term.term.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
            //   suffixBytes.length = suffix;
            //   System.out.println("    write term suffix=" + suffixBytes);
            // }
            // For non-leaf block we borrow 1 bit to record
            // if entry is term or sub-block
            bytesWriter.writeVInt(suffix<<1);
            bytesWriter.writeBytes(term.term.bytes, prefixLength, suffix);

            // Write term stats, to separate byte[] blob:
            bytesWriter2.writeVInt(term.stats.docFreq);
            if (fieldInfo.getIndexOptions() != IndexOptions.DOCS_ONLY) {
              assert term.stats.totalTermFreq >= term.stats.docFreq;
              bytesWriter2.writeVLong(term.stats.totalTermFreq - term.stats.docFreq);
            }

            termCount++;
          } else {
            PendingBlock block = (PendingBlock) ent;
            final int suffix = block.prefix.length - prefixLength;

            assert suffix > 0;

            // For non-leaf block we borrow 1 bit to record
            // if entry is term or sub-block
            bytesWriter.writeVInt((suffix<<1)|1);
            bytesWriter.writeBytes(block.prefix.bytes, prefixLength, suffix);
            assert block.fp < startFP;

            // if (DEBUG) {
            //   BytesRef suffixBytes = new BytesRef(suffix);
            //   System.arraycopy(block.prefix.bytes, prefixLength, suffixBytes.bytes, 0, suffix);
            //   suffixBytes.length = suffix;
            //   System.out.println("    write sub-block suffix=" + toString(suffixBytes) + " subFP=" + block.fp + " subCode=" + (startFP-block.fp) + " floor=" + block.isFloor);
            // }

            bytesWriter.writeVLong(startFP - block.fp);
            subIndices.add(block.index);
          }
        }

        assert subIndices.size() != 0;
      }

      // TODO: we could block-write the term suffix pointers;
      // this would take more space but would enable binary
      // search on lookup

      // Write suffixes byte[] blob to terms dict output:
      out.writeVInt((int) (bytesWriter.getFilePointer() << 1) | (isLeafBlock ? 1:0));
      bytesWriter.writeTo(out);
      bytesWriter.reset();

      // Write term stats byte[] blob
      out.writeVInt((int) bytesWriter2.getFilePointer());
      bytesWriter2.writeTo(out);
      bytesWriter2.reset();

      // Have postings writer write block
      postingsWriter.flushTermsBlock(futureTermCount+termCount, termCount);

      // Remove slice replaced by block:
      slice.clear();

      if (lastBlockIndex >= start) {
        if (lastBlockIndex < start+length) {
          lastBlockIndex = start;
        } else {
          lastBlockIndex -= length;
        }
      }

      // if (DEBUG) {
      //   System.out.println("      fpEnd=" + out.getFilePointer());
      // }

      return new PendingBlock(prefix, startFP, termCount != 0, isFloor, floorLeadByte, subIndices);
    }

