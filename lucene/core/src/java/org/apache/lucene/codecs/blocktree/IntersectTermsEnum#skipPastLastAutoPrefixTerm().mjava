  private boolean skipPastLastAutoPrefixTerm() throws IOException {
    assert currentFrame.isAutoPrefixTerm;
    useAutoPrefixTerm = false;
    currentFrame.termState.isRealTerm = true;

    // If we last returned an auto-prefix term, we must now skip all
    // actual terms sharing that prefix.  At most, that skipping
    // requires popping one frame, but it can also require simply
    // scanning ahead within the current frame.  This scanning will
    // skip sub-blocks that contain many terms, which is why the
    // optimization "works":
    int floorSuffixLeadEnd = currentFrame.floorSuffixLeadEnd;

    boolean isSubBlock;

    if (floorSuffixLeadEnd == -1) {
      // An ordinary prefix, e.g. foo*
      int prefix = currentFrame.prefix;
      int suffix = currentFrame.suffix;
      if (suffix == 0) {

        // Easy case: the prefix term's suffix is the empty string,
        // meaning the prefix corresponds to all terms in the
        // current block, so we just pop this entire block:
        if (currentFrame.ord == 0) {
          throw NoMoreTermsException.INSTANCE;
        }
        currentFrame = stack[currentFrame.ord-1];
        currentTransition = currentFrame.transition;

        return popPushNext();

      } else {

        // Just next() until we hit an entry that doesn't share this
        // prefix.  The first next should be a sub-block sharing the
        // same prefix, because if there are enough terms matching a
        // given prefix to warrant an auto-prefix term, then there
        // must also be enough to make a sub-block (assuming
        // minItemsInPrefix > minItemsInBlock):
        scanPrefix:
        while (true) {
          if (currentFrame.nextEnt == currentFrame.entCount) {
            if (currentFrame.isLastInFloor == false) {
              currentFrame.loadNextFloorBlock();
            } else if (currentFrame.ord == 0) {
              throw NoMoreTermsException.INSTANCE;
            } else {
              // Pop frame, which also means we've moved beyond this
              // auto-prefix term:
              currentFrame = stack[currentFrame.ord-1];
              currentTransition = currentFrame.transition;

              return popPushNext();
            }
          }
          isSubBlock = currentFrame.next();
          for(int i=0;i<suffix;i++) {
            if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {
              break scanPrefix;
            }
          }
        }
      }
    } else {
      // Floor'd auto-prefix term; in this case we must skip all
      // terms e.g. matching foo[a-m]*.  We are currently "on" fooa,
      // which the automaton accepted (fooa* through foom*), and
      // floorSuffixLeadEnd is m, so we must now scan to foon:
      int prefix = currentFrame.prefix;
      int suffix = currentFrame.suffix;

      if (currentFrame.floorSuffixLeadStart == -1) {
        suffix++;
      }

      if (suffix == 0) {

        // This means current frame is fooa*, so we have to first
        // pop the current frame, then scan in parent frame:
        if (currentFrame.ord == 0) {
          throw NoMoreTermsException.INSTANCE;
        }
        currentFrame = stack[currentFrame.ord-1];
        currentTransition = currentFrame.transition;

        // Current (parent) frame is now foo*, so now we just scan
        // until the lead suffix byte is > floorSuffixLeadEnd
        //assert currentFrame.prefix == prefix-1;
        //prefix = currentFrame.prefix;

        // In case when we pop, and the parent block is not just prefix-1, e.g. in block 417* on
        // its first term = floor prefix term 41[7-9], popping to block 4*:
        prefix = currentFrame.prefix;

        suffix = term.length - currentFrame.prefix;
      } else {
        // No need to pop; just scan in currentFrame:
      }

      // Now we scan until the lead suffix byte is > floorSuffixLeadEnd
      scanFloor:
      while (true) {
        if (currentFrame.nextEnt == currentFrame.entCount) {
          if (currentFrame.isLastInFloor == false) {
            currentFrame.loadNextFloorBlock();
          } else if (currentFrame.ord == 0) {
            throw NoMoreTermsException.INSTANCE;
          } else {
            // Pop frame, which also means we've moved beyond this
            // auto-prefix term:
            currentFrame = stack[currentFrame.ord-1];
            currentTransition = currentFrame.transition;

            return popPushNext();
          }
        }
        isSubBlock = currentFrame.next();
        for(int i=0;i<suffix-1;i++) {
          if (term.bytes[prefix+i] != currentFrame.suffixBytes[currentFrame.startBytePos+i]) {
            break scanFloor;
          }
        }
        if (currentFrame.suffix >= suffix && (currentFrame.suffixBytes[currentFrame.startBytePos+suffix-1]&0xff) > floorSuffixLeadEnd) {
          // Done scanning: we are now on the first term after all
          // terms matched by this auto-prefix term
          break;
        }
      }
    }

    return isSubBlock;
  }

