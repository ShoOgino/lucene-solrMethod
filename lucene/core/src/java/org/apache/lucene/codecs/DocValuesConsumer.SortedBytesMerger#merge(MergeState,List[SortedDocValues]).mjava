    public void merge(MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {

      // First pass: mark "live" terms
      for (int readerIDX=0;readerIDX<toMerge.size();readerIDX++) {
        AtomicReader reader = mergeState.readers.get(readerIDX);      
        // nocommit what if this is null...?  need default source?
        int maxDoc = reader.maxDoc();

        SegmentState state = new SegmentState();
        state.segmentID = readerIDX;
        state.reader = reader;
        state.values = toMerge.get(readerIDX);

        segStates.add(state);
        assert state.values.getValueCount() < Integer.MAX_VALUE;
        if (reader.hasDeletions()) {
          state.liveTerms = new FixedBitSet(state.values.getValueCount());
          Bits liveDocs = reader.getLiveDocs();
          assert liveDocs != null;
          for(int docID=0;docID<maxDoc;docID++) {
            if (liveDocs.get(docID)) {
              state.liveTerms.set(state.values.getOrd(docID));
            }
          }
        }

        // nocommit we can unload the bits to disk to reduce
        // transient ram spike...
      }

      // Second pass: merge only the live terms

      TermMergeQueue q = new TermMergeQueue(segStates.size());
      for(SegmentState segState : segStates) {
        if (segState.nextTerm() != null) {

          // nocommit we could defer this to 3rd pass (and
          // reduce transient RAM spike) but then
          // we'd spend more effort computing the mapping...:
          segState.segOrdToMergedOrd = new int[segState.values.getValueCount()];
          q.add(segState);
        }
      }

      int lastOrds[] = new int[segStates.size()];
      BytesRef lastTerm = null;
      int ord = 0;
      while (q.size() != 0) {
        SegmentState top = q.top();
        if (lastTerm == null || !lastTerm.equals(top.scratch)) {
          // a new unique term: record its segment ID / sourceOrd pair
          int readerId = top.segmentID;
          ordToReaderId.add(readerId);

          int sourceOrd = top.lastOrd;
             
          int delta = sourceOrd - lastOrds[readerId];
          lastOrds[readerId] = sourceOrd;
          top.ordDeltas.add(delta);
          
          lastTerm = BytesRef.deepCopyOf(top.scratch);
          ord++;
        }

        top.segOrdToMergedOrd[top.ord] = ord-1;
        if (top.nextTerm() == null) {
          q.pop();
        } else {
          q.updateTop();
        }
      }

      numMergedTerms = ord;
      // clear our bitsets for GC: we dont need them anymore (e.g. while flushing merged stuff to codec)
      for (SegmentState state : segStates) {
        state.liveTerms = null;
      }
    }

