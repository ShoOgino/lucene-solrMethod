    public void merge(MergeState mergeState, List<SortedDocValues> toMerge) throws IOException {

      // First pass: mark "live" terms
      for (int readerIDX=0;readerIDX<toMerge.size();readerIDX++) {
        AtomicReader reader = mergeState.readers.get(readerIDX);      
        int maxDoc = reader.maxDoc();

        SegmentState state = new SegmentState();
        state.segmentID = readerIDX;
        state.reader = reader;
        state.values = toMerge.get(readerIDX);

        segStates.add(state);
        assert state.values.getValueCount() < Integer.MAX_VALUE;
        if (reader.hasDeletions()) {
          state.liveTerms = new FixedBitSet(state.values.getValueCount());
          Bits liveDocs = reader.getLiveDocs();
          assert liveDocs != null;
          for(int docID=0;docID<maxDoc;docID++) {
            if (liveDocs.get(docID)) {
              state.liveTerms.set(state.values.getOrd(docID));
            }
          }
        }

        // TODO: we can unload the bits/packed ints to disk to reduce
        // transient ram spike... most of these just require iterators
      }

      // Second pass: merge only the live terms

      TermMergeQueue q = new TermMergeQueue(segStates.size());
      for(SegmentState segState : segStates) {
        if (segState.nextTerm() != null) {
          q.add(segState);
        }
      }

      int lastOrds[] = new int[segStates.size()];
      BytesRef lastTerm = null;
      int ord = 0;
      while (q.size() != 0) {
        SegmentState top = q.top();
        if (lastTerm == null || !lastTerm.equals(top.scratch)) {
          // a new unique term: record its segment ID / sourceOrd pair
          int readerId = top.segmentID;
          ordToReaderId.add(readerId);

          int sourceOrd = top.ord;             
          int delta = sourceOrd - lastOrds[readerId];
          lastOrds[readerId] = sourceOrd;
          top.ordDeltas.add(delta);
          
          if (lastTerm == null) {
            lastTerm = BytesRef.deepCopyOf(top.scratch);
          } else {
            lastTerm.copyBytes(top.scratch);
          }
          ord++;
        }

        long signedDelta = (ord-1) - top.ord; // global ord space - segment ord space
        // fill in any holes for unused ords, then finally the value we want (segOrdToMergedOrd[top.ord])
        // TODO: is there a better way...
        while (top.segOrdToMergedOrd.size() <= top.ord) {
          top.segOrdToMergedOrd.add(signedDelta);
        }
        if (top.nextTerm() == null) {
          q.pop();
        } else {
          q.updateTop();
        }
      }

      numMergedTerms = ord;
      // clear our bitsets for GC: we dont need them anymore (e.g. while flushing merged stuff to codec)
      for (SegmentState state : segStates) {
        state.liveTerms = null;
      }
    }

