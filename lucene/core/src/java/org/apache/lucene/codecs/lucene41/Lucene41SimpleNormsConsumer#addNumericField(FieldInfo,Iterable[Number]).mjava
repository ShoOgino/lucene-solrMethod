  @Override
  public void addNumericField(FieldInfo field, Iterable<Number> values) throws IOException {
    meta.writeVInt(field.number);
    meta.writeLong(data.getFilePointer());
    long minValue = Long.MAX_VALUE;
    long maxValue = Long.MIN_VALUE;
    int count = 0;
    // TODO: more efficient?
    HashSet<Long> uniqueValues = new HashSet<Long>();
    for(Number nv : values) {
      long v = nv.longValue();
      minValue = Math.min(minValue, v);
      maxValue = Math.max(maxValue, v);
      count++;
      if (uniqueValues != null) {
        if (uniqueValues.add(v)) {
          if (uniqueValues.size() > 256) {
            uniqueValues = null;
          }
        }
      }
    }

    long delta = maxValue - minValue;
    final int bitsPerValue;
    if (delta < 0) {
      bitsPerValue = 64;
      meta.writeByte((byte)0); // delta-compressed
    } else if (uniqueValues != null && PackedInts.bitsRequired(uniqueValues.size()-1) < PackedInts.bitsRequired(delta)) {
      // smaller to tableize
      bitsPerValue = PackedInts.bitsRequired(uniqueValues.size()-1);
      minValue = 0; // we will write indexes into the table instead of values
      meta.writeByte((byte)1); // table-compressed
      Long[] decode = uniqueValues.toArray(new Long[uniqueValues.size()]);
      final HashMap<Long,Integer> encode = new HashMap<Long,Integer>();
      data.writeVInt(decode.length);
      for (int i = 0; i < decode.length; i++) {
        data.writeLong(decode[i]);
        encode.put(decode[i], i);
      }
      final Iterable<Number> original = values;
      values = new Iterable<Number>() {
        @Override
        public Iterator<Number> iterator() {
          final Iterator<Number> inner = original.iterator();
          return new Iterator<Number>() {
            @Override
            public boolean hasNext() {
              return inner.hasNext();
            }

            @Override
            public Number next() {
              return encode.get(inner.next());
            }

            @Override
            public void remove() { throw new UnsupportedOperationException(); }
          };
        }
      };
    } else {
      bitsPerValue = PackedInts.bitsRequired(delta);
      meta.writeByte((byte)0); // delta-compressed
    }

    data.writeLong(minValue);

    FormatAndBits formatAndBits = PackedInts.fastestFormatAndBits(count, bitsPerValue, PackedInts.COMPACT);
    
    // nocommit: refactor this crap in PackedInts.java
    // e.g. Header.load()/save() or something rather than how it works now.
    CodecUtil.writeHeader(data, PackedInts.CODEC_NAME, PackedInts.VERSION_CURRENT);
    data.writeVInt(bitsPerValue);
    data.writeVInt(count);
    data.writeVInt(formatAndBits.format.getId());
    
    final PackedInts.Writer writer = PackedInts.getWriterNoHeader(data, formatAndBits.format, count, formatAndBits.bitsPerValue, 0);
    for(Number nv : values) {
      writer.add(nv.longValue() - minValue);
    }
    writer.finish();
  }

