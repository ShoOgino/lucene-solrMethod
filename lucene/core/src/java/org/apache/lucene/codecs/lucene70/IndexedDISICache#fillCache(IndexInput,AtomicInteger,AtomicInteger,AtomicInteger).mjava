  private int fillCache(
      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)
      throws IOException {
    char[] buildRank = new char[256];
    int largestBlock = -1;
    long index = 0;
    int rankIndex = -1;
    while (slice.getFilePointer() < slice.length()) {
      final long startFilePointer = slice.getFilePointer();

      final int blockIndex = Short.toUnsignedInt(slice.readShort());
      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());

      assert blockIndex > largestBlock;
      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached
        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);
        break;
      }
      largestBlock = blockIndex;

      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough
      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;
      index += numValues;

      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE
        statBlockSPARSE.incrementAndGet();
        slice.seek(slice.getFilePointer() + (numValues << 1));
        continue;
      }
      if (numValues == 65536) { // ALL
        statBlockALL.incrementAndGet();
        // Already at next block offset
        continue;
      }

      // The block is DENSE
      statBlockDENSE.incrementAndGet();
      long nextBlockOffset = slice.getFilePointer() + (1 << 13);
      int setBits = 0;
      int rankOrigo = blockIndex << 16 >> 9; // Double shift for clarity: The compiler will simplify it
      for (int rankDelta = 0 ; rankDelta < RANKS_PER_BLOCK ; rankDelta++) { // 128 rank-entries in a block
        rankIndex = rankOrigo + rankDelta;
        buildRank = ArrayUtil.grow(buildRank, rankIndex+1);
        buildRank[rankIndex] = (char)setBits;
        for (int i = 0 ; i < 512/64 ; i++) { // 8 longs for each rank-entry
          setBits += Long.bitCount(slice.readLong());
        }
      }
      assert slice.getFilePointer() == nextBlockOffset;
    }
    // Compress the buildRank as it is potentially very sparse
    if (rankIndex < 0) {
      rank = null;
    } else {
      PackedInts.Mutable ranks = PackedInts.getMutable(rankIndex, 16, PackedInts.DEFAULT); // Char = 16 bit
      for (int i = 0 ; i < rankIndex ; i++) {
        ranks.set(i, buildRank[i]);
      }
      rank = LongCompressor.compress(ranks);
    }

    return largestBlock;
  }

