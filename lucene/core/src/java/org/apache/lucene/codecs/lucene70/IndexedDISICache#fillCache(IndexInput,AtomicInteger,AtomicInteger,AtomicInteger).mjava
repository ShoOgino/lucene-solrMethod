  private int fillCache(
      IndexInput slice, AtomicInteger statBlockALL, AtomicInteger statBlockDENSE, AtomicInteger statBlockSPARSE)
      throws IOException {
    int largestBlock = -1;
    long index = 0;
    int rankIndex = -1;
    while (slice.getFilePointer() < slice.length()) {
      final long startFilePointer = slice.getFilePointer();

      final int blockIndex = Short.toUnsignedInt(slice.readShort());
      final int numValues = 1 + Short.toUnsignedInt(slice.readShort());

      assert blockIndex > largestBlock;
      if (blockIndex == DocIdSetIterator.NO_MORE_DOCS >>> 16) { // End reached
        assert Short.toUnsignedInt(slice.readShort()) == (DocIdSetIterator.NO_MORE_DOCS & 0xFFFF);
        break;
      }
      largestBlock = blockIndex;

      blockCache = ArrayUtil.grow(blockCache, blockIndex+1); // No-op if large enough
      blockCache[blockIndex] = (index << BLOCK_INDEX_SHIFT) | startFilePointer;
      index += numValues;

      if (numValues <= MAX_ARRAY_LENGTH) { // SPARSE
        statBlockSPARSE.incrementAndGet();
        slice.seek(slice.getFilePointer() + (numValues << 1));
        continue;
      }
      if (numValues == 65536) { // ALL
        statBlockALL.incrementAndGet();
        // Already at next block offset
        continue;
      }

      // The block is DENSE
      statBlockDENSE.incrementAndGet();
      long nextBlockOffset = slice.getFilePointer() + (1 << 13);
      slice.seek(nextBlockOffset);
    }

    return largestBlock;
  }

