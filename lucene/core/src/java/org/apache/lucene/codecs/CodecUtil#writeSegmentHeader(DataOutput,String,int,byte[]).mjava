  /**
   * Writes a codec header for a per-segment, which records both a string to
   * identify the file, a version number, and the unique ID of the segment. 
   * This header can be parsed and validated with 
   * {@link #checkSegmentHeader(DataInput, String, int, int, byte[]) checkSegmentHeader()}.
   * <p>
   * CodecSegmentHeader --&gt; CodecHeader,SegmentID
   * <ul>
   *    <li>CodecHeader --&gt; {@link #writeHeader}
   *    <li>SegmentID   --&gt; {@link DataOutput#writeByte byte}<sup>16</sup>.
   *        Unique identifier for the segment.
   * </ul>
   * <p>
   * Note that the length of a segment header depends only upon the
   * name of the codec, so this length can be computed at any time
   * with {@link #headerLength(String)}.
   * 
   * @param out Output stream
   * @param codec String to identify this file. It should be simple ASCII, 
   *              less than 128 characters in length.
   * @param segmentID Unique identifier for the segment
   * @param version Version number
   * @throws IOException If there is an I/O error writing to the underlying medium.
   * @throws IllegalArgumentException If the codec name is not simple ASCII, or 
   *         is more than 127 characters in length, or if segmentID is invalid.
   */
  public static void writeSegmentHeader(DataOutput out, String codec, int version, byte[] segmentID) throws IOException {
    if (segmentID.length != StringHelper.ID_LENGTH) {
      throw new IllegalArgumentException("Invalid id: " + StringHelper.idToString(segmentID));
    }
    writeHeader(out, codec, version);
    out.writeBytes(segmentID, 0, segmentID.length);
  }

