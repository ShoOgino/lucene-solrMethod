  private List<CodecReader> maybeSortReaders(List<CodecReader> originalReaders, SegmentInfo segmentInfo) throws IOException {

    // Default to identity:
    for(int i=0;i<originalReaders.size();i++) {
      leafDocMaps[i] = new DocMap() {
          @Override
          public int get(int docID) {
            return docID;
          }
        };
    }

    Sort indexSort = segmentInfo.getIndexSort();
    if (indexSort == null) {
      return originalReaders;
    }

    // If an incoming reader is not sorted, because it was flushed by IW, we sort it here:
    final Sorter sorter = new Sorter(indexSort);
    List<CodecReader> readers = new ArrayList<>(originalReaders.size());

    for (CodecReader leaf : originalReaders) {
      Sort segmentSort = leaf.getIndexSort();

      if (segmentSort == null) {
        // TODO: fix IW to also sort when flushing?  It's somewhat tricky because of stored fields and term vectors, which write "live"
        // to their index files on each indexed document:

        // This segment was written by flush, so documents are not yet sorted, so we sort them now:
        long t0 = System.nanoTime();
        Sorter.DocMap sortDocMap = sorter.sort(leaf);
        long t1 = System.nanoTime();
        double msec = (t1-t0)/1000000.0;
        
        if (sortDocMap != null) {
          if (infoStream.isEnabled("SM")) {
            infoStream.message("SM", String.format(Locale.ROOT, "segment %s is not sorted; wrapping for sort %s now (%.2f msec to sort)", leaf, indexSort, msec));
          }
          needsIndexSort = true;
          leaf = SlowCodecReaderWrapper.wrap(SortingLeafReader.wrap(new MergeReaderWrapper(leaf), sortDocMap));
          leafDocMaps[readers.size()] = new DocMap() {
              @Override
              public int get(int docID) {
                return sortDocMap.oldToNew(docID);
              }
            };
        } else {
          if (infoStream.isEnabled("SM")) {
            infoStream.message("SM", String.format(Locale.ROOT, "segment %s is not sorted, but is already accidentally in sort %s order (%.2f msec to sort)", leaf, indexSort, msec));
          }
        }

      } else {
        if (segmentSort.equals(indexSort) == false) {
          throw new IllegalArgumentException("index sort mismatch: merged segment has sort=" + indexSort + " but to-be-merged segment has sort=" + segmentSort);
        }
        if (infoStream.isEnabled("SM")) {
          infoStream.message("SM", "segment " + leaf + " already sorted");
        }
      }

      readers.add(leaf);
    }

    return readers;
  }

