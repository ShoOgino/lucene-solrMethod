  /**
   * Carefully merges deletes and updates for the segments we just merged. This
   * is tricky because, although merging will clear all deletes (compacts the
   * documents) and compact all the updates, new deletes and updates may have
   * been flushed to the segments since the merge was started. This method
   * "carries over" such new deletes and updates onto the newly merged segment,
   * and saves the resulting deletes and updates files (incrementing the delete
   * and DV generations for merge.info). If no deletes were flushed, no new
   * deletes file is saved.
   */
  // TODO (DVU_RENAME) to commitMergedDeletesAndUpdates
  synchronized private ReadersAndLiveDocs commitMergedDeletes(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {

    assert testPoint("startCommitMergeDeletes");

    final List<SegmentInfoPerCommit> sourceSegments = merge.segments;

    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW", "commitMergeDeletes " + segString(merge.segments));
    }

    // Carefully merge deletes that occurred after we
    // started merging:
    int docUpto = 0;
    long minGen = Long.MAX_VALUE;

    // Lazy init (only when we find a delete to carry over):
    ReadersAndLiveDocs mergedDeletes = null; // TODO (DVU_RENAME) to mergedDeletesAndUpdates
    boolean initWritableLiveDocs = false;
    MergePolicy.DocMap docMap = null;
    final Map<Integer,Map<String,Long>> mergedUpdates = new HashMap<Integer,Map<String,Long>>();
    
    for (int i = 0; i < sourceSegments.size(); i++) {
      SegmentInfoPerCommit info = sourceSegments.get(i);
      minGen = Math.min(info.getBufferedDeletesGen(), minGen);
      final int docCount = info.info.getDocCount();
      final Bits prevLiveDocs = merge.readers.get(i).getLiveDocs();
      final ReadersAndLiveDocs rld = readerPool.get(info, false);
      // We hold a ref so it should still be in the pool:
      assert rld != null: "seg=" + info.info.name;
      final Bits currentLiveDocs = rld.getLiveDocs();
      final Map<Integer,Map<String,Long>> mergingUpdates = rld.getMergingUpdates();
      
      if (prevLiveDocs != null) {

        // If we had deletions on starting the merge we must
        // still have deletions now:
        assert currentLiveDocs != null;
        assert prevLiveDocs.length() == docCount;
        assert currentLiveDocs.length() == docCount;

        // There were deletes on this segment when the merge
        // started.  The merge has collapsed away those
        // deletes, but, if new deletes were flushed since
        // the merge started, we must now carefully keep any
        // newly flushed deletes but mapping them to the new
        // docIDs.

        // Since we copy-on-write, if any new deletes were
        // applied after merging has started, we can just
        // check if the before/after liveDocs have changed.
        // If so, we must carefully merge the liveDocs one
        // doc at a time:
        if (currentLiveDocs != prevLiveDocs) {
          // This means this segment received new deletes
          // since we started the merge, so we
          // must merge them:
          for (int j = 0; j < docCount; j++) {
            if (!prevLiveDocs.get(j)) {
              assert !currentLiveDocs.get(j);
            } else {
              if (!currentLiveDocs.get(j)) {
                if (mergedDeletes == null) {
                  mergedDeletes = readerPool.get(merge.info, true);
                  mergedDeletes.initWritableLiveDocs();
                  initWritableLiveDocs = true;
                  docMap = getDocMap(merge, mergeState);
                } else if (!initWritableLiveDocs) { // mergedDeletes was initialized by field-updates changes
                  mergedDeletes.initWritableLiveDocs();
                  initWritableLiveDocs = true;
                }
                mergedDeletes.delete(docMap.map(docUpto));
              } else if (mergingUpdates != null) {
                // document isn't deleted, check if it has updates
                Map<String,Long> docUpdates = mergingUpdates.get(Integer.valueOf(j));
                if (docUpdates != null) {
                  if (mergedDeletes == null) {
                    mergedDeletes = readerPool.get(merge.info, true);
                    docMap = getDocMap(merge, mergeState);
                  }
                  mergedUpdates.put(Integer.valueOf(docMap.map(docUpto)), docUpdates);
                }
              }
              docUpto++;
            }
          }
        } else if (mergingUpdates != null) {
          // need to check each non-deleted document if it has any updates
          for (int j = 0; j < docCount; j++) {
            if (prevLiveDocs.get(j)) {
              // document isn't deleted, check if it has updates
              Map<String,Long> docUpdates = mergingUpdates.get(Integer.valueOf(j));
              if (docUpdates != null) {
                if (mergedDeletes == null) {
                  mergedDeletes = readerPool.get(merge.info, true);
                  docMap = getDocMap(merge, mergeState);
                }
                mergedUpdates.put(Integer.valueOf(docMap.map(docUpto)), docUpdates);
              }
              // advance docUpto for every non-deleted document
              docUpto++;
            }
          }
        } else {
          docUpto += info.info.getDocCount() - info.getDelCount() - rld.getPendingDeleteCount();
        }
      } else if (currentLiveDocs != null) {
        assert currentLiveDocs.length() == docCount;
        // This segment had no deletes before but now it
        // does:
        for (int j = 0; j < docCount; j++) {
          if (!currentLiveDocs.get(j)) {
            if (mergedDeletes == null) {
              mergedDeletes = readerPool.get(merge.info, true);
              mergedDeletes.initWritableLiveDocs();
              initWritableLiveDocs = true;
              docMap = getDocMap(merge, mergeState);
            } else if (!initWritableLiveDocs) { // mergedDeletes was initialized by field-updates changes
              mergedDeletes.initWritableLiveDocs();
              initWritableLiveDocs = true;
            }
            mergedDeletes.delete(docMap.map(docUpto));
          } else if (mergingUpdates != null) {
            // document isn't deleted, check if it has updates
            Map<String,Long> docUpdates = mergingUpdates.get(Integer.valueOf(j));
            if (docUpdates != null) {
              if (mergedDeletes == null) {
                mergedDeletes = readerPool.get(merge.info, true);
                docMap = getDocMap(merge, mergeState);
              }
              mergedUpdates.put(Integer.valueOf(docMap.map(docUpto)), docUpdates);
            }
          }
          docUpto++;
        }
      } else if (mergingUpdates != null) {
        // no deletions before or after, but there were updates
        for (int j = 0; j < docCount; j++) {
          Map<String,Long> docUpdates = mergingUpdates.get(Integer.valueOf(j));
          if (docUpdates != null) {
            if (mergedDeletes == null) {
              mergedDeletes = readerPool.get(merge.info, true);
              docMap = getDocMap(merge, mergeState);
            }
            mergedUpdates.put(Integer.valueOf(docMap.map(docUpto)), docUpdates);
          }
          // advance docUpto for every non-deleted document
          docUpto++;
        }
      } else {
        // No deletes before or after
        docUpto += info.info.getDocCount();
      }
    }

    assert docUpto == merge.info.info.getDocCount();

    // set any updates that came while the segment was merging
    if (!mergedUpdates.isEmpty()) {
      assert mergedDeletes != null;
      mergedDeletes.setMergingUpdates(mergedUpdates);
    }

    if (infoStream.isEnabled("IW")) {
      if (mergedDeletes == null) {
        infoStream.message("IW", "no new deletes or field updates since merge started");
      } else {
        infoStream.message("IW", mergedDeletes.getPendingDeleteCount() + " new deletes since merge started and "
                + mergedDeletes.getPendingUpdatesCount() + " new field updates since merge started");
      }
    }

    merge.info.setBufferedDeletesGen(minGen);

    return mergedDeletes;
  }

