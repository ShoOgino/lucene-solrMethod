  /** Make an effort to visit "fake" (e.g. auto-prefix) terms.  We do this by running term range intersections across an initially wide
   *  interval of terms, at different boundaries, and then gradually decrease the interval.  This is not guaranteed to hit all non-real
   *  terms (doing that in general is non-trivial), but it should hit many of them, and validate their postings against the postings for the
   *  real terms. */
  private static void checkTermRanges(String field, int maxDoc, Terms terms, long numTerms) throws IOException {

    // We'll target this many terms in our interval for the current level:
    double currentInterval = numTerms;

    FixedBitSet normalDocs = new FixedBitSet(maxDoc);
    FixedBitSet intersectDocs = new FixedBitSet(maxDoc);

    TermsEnum termsEnum = null;
    //System.out.println("CI.checkTermRanges field=" + field + " numTerms=" + numTerms);

    while (currentInterval >= 10.0) {
      //System.out.println("  cycle interval=" + currentInterval);

      // We iterate this terms enum to locate min/max term for each sliding/overlapping interval we test at the current level:
      termsEnum = terms.iterator(termsEnum);

      long termCount = 0;

      Deque<BytesRef> termBounds = new LinkedList<>();

      long lastTermAdded = Long.MIN_VALUE;

      BytesRefBuilder lastTerm = null;

      while (true) {
        BytesRef term = termsEnum.next();
        if (term == null) {
          break;
        }
        //System.out.println("  top: term=" + term.utf8ToString());
        if (termCount >= lastTermAdded + currentInterval/4) {
          termBounds.add(BytesRef.deepCopyOf(term));
          lastTermAdded = termCount;
          if (termBounds.size() == 5) {
            BytesRef minTerm = termBounds.removeFirst();
            BytesRef maxTerm = termBounds.getLast();
            checkSingleTermRange(field, maxDoc, terms, minTerm, maxTerm, normalDocs, intersectDocs);
          }
        }
        termCount++;

        if (lastTerm == null) {
          lastTerm = new BytesRefBuilder();
          lastTerm.copyBytes(term);
        } else {
          if (lastTerm.get().compareTo(term) >= 0) {
            throw new RuntimeException("terms out of order: lastTerm=" + lastTerm + " term=" + term);
          }
          lastTerm.copyBytes(term);
        }
      }
      //System.out.println("    count=" + termCount);

      if (lastTerm != null && termBounds.isEmpty() == false) {
        BytesRef minTerm = termBounds.removeFirst();
        BytesRef maxTerm = lastTerm.get();
        checkSingleTermRange(field, maxDoc, terms, minTerm, maxTerm, normalDocs, intersectDocs);
      }

      currentInterval *= .75;
    }
  }

