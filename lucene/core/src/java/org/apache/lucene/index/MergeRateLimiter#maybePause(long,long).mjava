  /** Returns NO if no pause happened, STOPPED if pause because rate was 0.0 (merge is stopped), PAUSED if paused with a normal rate limit. */
  private synchronized PauseResult maybePause(long bytes, long curNS) throws MergePolicy.MergeAbortedException {

    // Now is a good time to abort the merge:
    checkAbort();

    double secondsToPause = (bytes/1024./1024.) / mbPerSec;

    // Time we should sleep until; this is purely instantaneous
    // rate (just adds seconds onto the last time we had paused to);
    // maybe we should also offer decayed recent history one?
    long targetNS = lastNS + (long) (1000000000 * secondsToPause);

    long curPauseNS = targetNS - curNS;

    // NOTE: except maybe on real-time JVMs, minimum realistic
    // wait/sleep time is 1 msec; if you pass just 1 nsec the impl
    // rounds up to 1 msec, so we don't bother unless it's > 2 msec:

    if (curPauseNS <= 2000000) {
      return PauseResult.NO;
    }

    // Defensive: sleep for at most 250 msec; the loop above will call us again if we should keep sleeping:
    if (curPauseNS > 250L*1000000) {
      curPauseNS = 250L*1000000;
    }

    int sleepMS = (int) (curPauseNS / 1000000);
    int sleepNS = (int) (curPauseNS % 1000000);

    double rate = mbPerSec;

    try {
      // CMS can wake us up here if it changes our target rate:
      wait(sleepMS, sleepNS);
    } catch (InterruptedException ie) {
      throw new ThreadInterruptedException(ie);
    }

    if (rate == 0.0) {
      return PauseResult.STOPPED;
    } else {
      return PauseResult.PAUSED;
    }
  }

