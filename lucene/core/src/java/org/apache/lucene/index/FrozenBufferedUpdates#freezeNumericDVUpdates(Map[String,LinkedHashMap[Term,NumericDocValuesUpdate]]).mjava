  private byte[] freezeNumericDVUpdates(Map<String,LinkedHashMap<Term,NumericDocValuesUpdate>> numericDVUpdates)
    throws IOException {
    // TODO: we could do better here, e.g. collate the updates by field
    // so if you are updating 2 fields interleaved we don't keep writing the field strings

    RAMOutputStream out = new RAMOutputStream();
    String lastTermField = null;
    String lastUpdateField = null;
    for (LinkedHashMap<Term,NumericDocValuesUpdate> numericUpdates : numericDVUpdates.values()) {
      numericDVUpdateCount += numericUpdates.size();
      for (NumericDocValuesUpdate update : numericUpdates.values()) {

        int code = update.term.bytes().length << 2;

        String termField = update.term.field();
        if (termField.equals(lastTermField) == false) {
          code |= 1;
        }
        String updateField = update.field;
        if (updateField.equals(lastUpdateField) == false) {
          code |= 2;
        }
        out.writeVInt(code);
        out.writeVInt(update.docIDUpto);
        if ((code & 1) != 0) {
          out.writeString(termField);
          lastTermField = termField;
        }
        if ((code & 2) != 0) {
          out.writeString(updateField);
          lastUpdateField = updateField;
        }

        out.writeBytes(update.term.bytes().bytes, update.term.bytes().offset, update.term.bytes().length);
        out.writeZLong(((Long) update.value).longValue());
      }
    }
    byte[] bytes = new byte[(int) out.getFilePointer()];
    out.writeTo(bytes, 0);
    return bytes;
  }

