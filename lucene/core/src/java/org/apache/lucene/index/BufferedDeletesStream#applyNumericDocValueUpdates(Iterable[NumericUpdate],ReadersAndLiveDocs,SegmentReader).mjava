  // NumericDocValue Updates
  private synchronized boolean applyNumericDocValueUpdates(Iterable<NumericUpdate> updates, ReadersAndLiveDocs rld, SegmentReader reader) throws IOException {
    Fields fields = reader.fields();
    if (fields == null) {
      // This reader has no postings
      return false;
    }

    TermsEnum termsEnum = null;
    DocsEnum docs = null;
    boolean any = false;
    //System.out.println(Thread.currentThread().getName() + " numericDVUpdate reader=" + reader);
    for (NumericUpdate update : updates) {
      Term term = update.term;
      int limit = update.docIDUpto;
      
      // TODO: we rely on the map being ordered by updates order, not by terms order.
      // we need that so that if two terms update the same document, the one that came
      // last wins.
      // alternatively, we could keep a map from doc->lastUpto and apply the update
      // in terms order, where an update is applied only if its docIDUpto is greater
      // than lastUpto.
      // but, since app can send two updates, in order, which will have same upto, we
      // cannot rely solely on docIDUpto, and need to have our own gen, which is
      // incremented with every update.
      
      // Unlike applyTermDeletes, we visit terms in update order, not term order.
      // Therefore we cannot assume we can only seek forwards and must ask for a
      // new TermsEnum
      Terms terms = fields.terms(term.field);
      if (terms == null) { // no terms in that field
        termsEnum = null;
        continue;
      }
      
      termsEnum = terms.iterator(termsEnum);

      // System.out.println("  term=" + term);

      if (termsEnum.seekExact(term.bytes())) {
        // we don't need term frequencies for this
        DocsEnum docsEnum = termsEnum.docs(rld.getLiveDocs(), docs, DocsEnum.FLAG_NONE);
      
        //System.out.println("BDS: got docsEnum=" + docsEnum);

        int doc;
        while ((doc = docsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {
          //System.out.println(Thread.currentThread().getName() + " numericDVUpdate term=" + term + " doc=" + docID);
          if (doc >= limit) {
            break; // no more docs that can be updated for this term
          }
          rld.updateNumericDocValue(update.field, doc, update.value);
          any = true;
        }
      }
    }
    return any;
  }

