  /**
   * Constructs a new SegmentReader with a new core.
   * @throws CorruptIndexException if the index is corrupt
   * @throws IOException if there is a low-level IO error
   */
  // TODO: why is this public?
  public SegmentReader(SegmentInfoPerCommit si, IOContext context) throws IOException {
    this.si = si;
    // TODO if the segment uses CFS, we may open the CFS file twice: once for
    // reading the FieldInfos (if they are not gen'd) and second time by
    // SegmentCoreReaders. We can open the CFS here and pass to SCR, but then it
    // results in less readable code (resource not closed where it was opened).
    // Best if we could somehow read FieldInfos in SCR but not keep it there, but
    // constructors don't allow returning two things...
    fieldInfos = readFieldInfos(si);
    core = new SegmentCoreReaders(this, si.info.dir, si, context);

    boolean success = false;
    final Codec codec = si.info.getCodec();
    try {
      if (si.hasDeletions()) {
        // NOTE: the bitvector is stored using the regular directory, not cfs
        liveDocs = codec.liveDocsFormat().readLiveDocs(directory(), si, IOContext.READONCE);
      } else {
        assert si.getDelCount() == 0;
        liveDocs = null;
      }
      numDocs = si.info.getDocCount() - si.getDelCount();
      
      if (fieldInfos.hasDocValues()) {
        final Directory dir = core.cfsReader != null ? core.cfsReader : si.info.dir;
        final DocValuesFormat dvFormat = codec.docValuesFormat();
        // initialize the per generation numericDVProducers and put the correct
        // DVProducer for each field
        final Map<Long,List<FieldInfo>> genInfos = getGenInfos(si);
        
//        System.out.println("[" + Thread.currentThread().getName() + "] SR.init: new reader: " + si + "; gens=" + genInfos.keySet());

        for (Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {
          Long gen = e.getKey();
          List<FieldInfo> infos = e.getValue();
          RefCount<DocValuesProducer> dvp = genDVProducers.get(gen);
          if (dvp == null) {
            dvp = newDocValuesProducer(si, context, dir, dvFormat, gen, infos);
            assert dvp != null;
            genDVProducers.put(gen, dvp);
          }
          for (FieldInfo fi : infos) {
            dvProducers.put(fi.name, dvp.get());
          }
        }
      }

      success = true;
    } finally {
      // With lock-less commits, it's entirely possible (and
      // fine) to hit a FileNotFound exception above.  In
      // this case, we want to explicitly close any subset
      // of things that were opened so that we don't have to
      // wait for a GC to do so.
      if (!success) {
        doClose();
      }
    }
  }

