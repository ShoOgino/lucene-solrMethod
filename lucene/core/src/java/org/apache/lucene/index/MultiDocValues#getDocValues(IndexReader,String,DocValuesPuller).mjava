  private static DocValues getDocValues(IndexReader reader, final String field, final DocValuesPuller puller) throws IOException {
    if (reader instanceof AtomicReader) {
      // already an atomic reader
      return puller.pull((AtomicReader) reader, field);
    }
    assert reader instanceof CompositeReader;
    final List<AtomicReaderContext> leaves = reader.leaves();
    switch (leaves.size()) {
      case 0:
        // no fields
        return null;
      case 1:
        // already an atomic reader / reader with one leave
        return getDocValues(leaves.get(0).reader(), field, puller);
      default:
        final List<DocValuesSlice> slices = new ArrayList<DocValuesSlice>();
        
        TypePromoter promotedType =  TypePromoter.getIdentityPromoter();
        
        // gather all docvalues fields, accumulating a promoted type across 
        // potentially incompatible types
        for (final AtomicReaderContext ctx : leaves) {
          final AtomicReader r = ctx.reader();
          final DocValues d = puller.pull(r, field);
          if (d != null) {
            TypePromoter incoming = TypePromoter.create(d.getType(), d.getValueSize());
            promotedType = promotedType.promote(incoming);
          } else if (puller.stopLoadingOnNull(r, field)){
            return null;
          }
          slices.add(new DocValuesSlice(d, ctx.docBase, r.maxDoc()));
        }
        
        // return null if no docvalues encountered anywhere
        if (promotedType == TypePromoter.getIdentityPromoter()) {
          return null;
        }
             
        // populate starts and fill gaps with empty docvalues 
        int starts[] = new int[slices.size()];
        for (int i = 0; i < slices.size(); i++) {
          DocValuesSlice slice = slices.get(i);
          starts[i] = slice.start;
          if (slice.docValues == null) {
            Type promoted = promotedType.type();
            switch(promoted) {
              case BYTES_FIXED_DEREF:
              case BYTES_FIXED_STRAIGHT:
              case BYTES_FIXED_SORTED:
                assert promotedType.getValueSize() >= 0;
                slice.docValues = new EmptyFixedDocValues(slice.length, promoted, promotedType.getValueSize());
                break;
              default:
                slice.docValues = new EmptyDocValues(slice.length, promoted);
            }
          }
        }
        
        return new MultiDocValues(slices.toArray(new DocValuesSlice[slices.size()]), starts, promotedType);
    }
  }

