  private Status.DocValuesStatus testDocValues(SegmentInfo info,
      SegmentReader reader) {
    final Status.DocValuesStatus status = new Status.DocValuesStatus();
    try {
      if (infoStream != null) {
        infoStream.print("    test: DocValues........");
      }
      final FieldInfos fieldInfos = info.getFieldInfos();
      for (FieldInfo fieldInfo : fieldInfos) {
        if (fieldInfo.hasDocValues()) {
          status.totalValueFields++;
          final DocValues docValues = reader.docValues(fieldInfo.name);
          if (docValues == null) {
            throw new RuntimeException("field: " + fieldInfo.name + " omits docvalues but should have them!");
          }
          DocValues.Type type = docValues.type();
          if (type != fieldInfo.getDocValuesType()) {
            throw new RuntimeException("field: " + fieldInfo.name + " has type: " + type + " but fieldInfos says:" + fieldInfo.getDocValuesType());
          }
          final Source values = docValues.getDirectSource();
          final int maxDoc = reader.maxDoc();
          int size = docValues.getValueSize();
          for (int i = 0; i < maxDoc; i++) {
            switch (fieldInfo.getDocValuesType()) {
            case BYTES_FIXED_SORTED:
            case BYTES_VAR_SORTED:
            case BYTES_FIXED_DEREF:
            case BYTES_FIXED_STRAIGHT:
            case BYTES_VAR_DEREF:
            case BYTES_VAR_STRAIGHT:
              BytesRef bytes = new BytesRef();
              values.getBytes(i, bytes);
              if (size != -1 && size != bytes.length) {
                throw new RuntimeException("field: " + fieldInfo.name + " returned wrongly sized bytes, was: " + bytes.length + " should be: " + size);
              }
              break;
            case FLOAT_32:
              assert size == 4;
              values.getFloat(i);
              break;
            case FLOAT_64:
              assert size == 8;
              values.getFloat(i);
              break;
            case VAR_INTS:
              assert size == -1;
              values.getInt(i);
              break;
            case FIXED_INTS_16:
              assert size == 2;
              values.getInt(i);
              break;
            case FIXED_INTS_32:
              assert size == 4;
              values.getInt(i);
              break;
            case FIXED_INTS_64:
              assert size == 8;
              values.getInt(i);
              break;
            case FIXED_INTS_8:
              assert size == 1;
              values.getInt(i);
              break;
            default:
              throw new IllegalArgumentException("Field: " + fieldInfo.name
                          + " - no such DocValues type: " + fieldInfo.getDocValuesType());
            }
          }
          if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {
            // check sorted bytes
            SortedSource sortedValues = values.asSortedSource();
            Comparator<BytesRef> comparator = sortedValues.getComparator();
            int lastOrd = -1;
            BytesRef lastBytes = new BytesRef();
            for (int i = 0; i < maxDoc; i++) {
              int ord = sortedValues.ord(i);
              if (ord < 0 || ord > maxDoc) {
                throw new RuntimeException("field: " + fieldInfo.name + " ord is out of bounds: " + ord);
              }
              BytesRef bytes = new BytesRef();
              sortedValues.getByOrd(ord, bytes);
              if (lastOrd != -1) {
                int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));
                int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));
                if (ordComp != bytesComp) {
                  throw new RuntimeException("field: " + fieldInfo.name + " ord comparison is wrong: " + ordComp + " comparator claims: " + bytesComp);
                }
              }
              lastOrd = ord;
              lastBytes = bytes;
            }
          }
        } else {
          if (reader.docValues(fieldInfo.name) != null) {
            throw new RuntimeException("field: " + fieldInfo.name + " has docvalues but should omit them!");
          }
        }
      }

      msg("OK [" + status.docCount + " total doc Count; Num DocValues Fields "
          + status.totalValueFields);
    } catch (Throwable e) {
      msg("ERROR [" + String.valueOf(e.getMessage()) + "]");
      status.error = e;
      if (infoStream != null) {
        e.printStackTrace(infoStream);
      }
    }
    return status;
  }

