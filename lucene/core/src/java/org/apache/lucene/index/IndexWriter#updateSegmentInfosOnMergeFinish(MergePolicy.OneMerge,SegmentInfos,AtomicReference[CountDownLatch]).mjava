  private MergePolicy.OneMerge updateSegmentInfosOnMergeFinish(MergePolicy.OneMerge merge, final SegmentInfos toCommit,
                                                                AtomicReference<CountDownLatch> mergeLatchRef) {
    return new MergePolicy.OneMerge(merge.segments) {
      public void mergeFinished() throws IOException {
        super.mergeFinished();
        CountDownLatch mergeAwaitLatch = mergeLatchRef.get();
        if (mergeAwaitLatch == null) {
          // Commit thread timed out waiting for this merge and moved on. No need to manipulate toCommit.
          return;
        }
        if (committed) {
          deleter.incRef(this.info.files());
          // Resolve "live" SegmentInfos segments to their toCommit cloned equivalents, based on segment name.
          Set<String> mergedSegmentNames = new HashSet<>();
          for (SegmentCommitInfo sci : this.segments) {
            deleter.decRef(sci.files());
            mergedSegmentNames.add(sci.info.name);
          }
          List<SegmentCommitInfo> toCommitMergedAwaySegments = new ArrayList<>();
          for (SegmentCommitInfo sci : toCommit) {
            if (mergedSegmentNames.contains(sci.info.name)) {
              toCommitMergedAwaySegments.add(sci);
            }
          }
          // Construct a OneMerge that applies to toCommit
          MergePolicy.OneMerge applicableMerge = new MergePolicy.OneMerge(toCommitMergedAwaySegments);
          applicableMerge.info = this.info.clone();
          long segmentCounter = Long.parseLong(this.info.info.name.substring(1), Character.MAX_RADIX);
          toCommit.counter = Math.max(toCommit.counter, segmentCounter + 1);
          toCommit.applyMergeChanges(applicableMerge, false);
        }
        mergeAwaitLatch.countDown();
      }
    };
  }

