  /** If {@code key} exists, returns its ordinal, else
   *  returns {@code -insertionPoint-1}, like {@code
   *  Arrays.binarySearch}.
   *
   *  @param key Key to look up
   *  @param spare Spare BytesRef
   **/
  // nocommit: what does spare mean? its no spare: because people rely upon its return value!
  // if its 'result' then the parameter and javadoc needs changing, otherwise things need fixing
  // unconditionally set its value to "NONSENSE" bytes to see the bugs!
  public int lookupTerm(BytesRef key, BytesRef spare) {

    int low = 0;
    int high = getValueCount()-1;

    while (low <= high) {
      int mid = (low + high) >>> 1;
      lookupOrd(mid, spare);
      int cmp = spare.compareTo(key);

      if (cmp < 0) {
        low = mid + 1;
      } else if (cmp > 0) {
        high = mid - 1;
      } else {
        // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!
        // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1
        spare.bytes = BytesRef.EMPTY_BYTES;
        spare.offset = 0;
        spare.length = 0;
        return mid; // key found
      }
    }

    // nocommit: we shouldnt have to set spare at all if its actually a spare, but its not!
    // ant test  -Dtestcase=TestFieldCacheRewriteMethod -Dtests.method=testRegexps -Dtests.seed=AFC4A08B212CE143 -Dtests.slow=true -Dtests.locale=th -Dtests.timezone=Canada/Mountain -Dtests.file.encoding=ISO-8859-1
    spare.bytes = BytesRef.EMPTY_BYTES;
    spare.offset = 0;
    spare.length = 0;
    return -(low + 1);  // key not found.
  }

