  private static IndexReader[] prepareSubReaders(CompositeReader[] readers, CompositeReader[] storedFieldsReaders) throws IOException {
    if (readers.length == 0) {
      if (storedFieldsReaders.length > 0)
        throw new IllegalArgumentException("There must be at least one main reader if storedFieldsReaders are used.");
      return new IndexReader[0];
    } else {
      final List<? extends IndexReader> firstSubReaders = readers[0].getSequentialSubReaders();

      // check compatibility:
      final int maxDoc = readers[0].maxDoc(), noSubs = firstSubReaders.size();
      final int[] childMaxDoc = new int[noSubs];
      final boolean[] childAtomic = new boolean[noSubs];
      for (int i = 0; i < noSubs; i++) {
        final IndexReader r = firstSubReaders.get(i);
        childMaxDoc[i] = r.maxDoc();
        childAtomic[i] = r instanceof AtomicReader;
      }
      validate(readers, maxDoc, childMaxDoc, childAtomic);
      validate(storedFieldsReaders, maxDoc, childMaxDoc, childAtomic);

      // hierarchically build the same subreader structure as the first CompositeReader with Parallel*Readers:
      final IndexReader[] subReaders = new IndexReader[noSubs];
      for (int i = 0; i < subReaders.length; i++) {
        if (firstSubReaders.get(i) instanceof AtomicReader) {
          final AtomicReader[] atomicSubs = new AtomicReader[readers.length];
          for (int j = 0; j < readers.length; j++) {
            atomicSubs[j] = (AtomicReader) readers[j].getSequentialSubReaders().get(i);
          }
          final AtomicReader[] storedSubs = new AtomicReader[storedFieldsReaders.length];
          for (int j = 0; j < storedFieldsReaders.length; j++) {
            storedSubs[j] = (AtomicReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);
          }
          // We pass true for closeSubs and we prevent closing of subreaders in doClose():
          // By this the synthetic throw-away readers used here are completely invisible to ref-counting
          subReaders[i] = new ParallelAtomicReader(true, atomicSubs, storedSubs) {
            @Override
            protected void doClose() {}
          };
        } else {
          assert firstSubReaders.get(i) instanceof CompositeReader;
          final CompositeReader[] compositeSubs = new CompositeReader[readers.length];
          for (int j = 0; j < readers.length; j++) {
            compositeSubs[j] = (CompositeReader) readers[j].getSequentialSubReaders().get(i);
          }
          final CompositeReader[] storedSubs = new CompositeReader[storedFieldsReaders.length];
          for (int j = 0; j < storedFieldsReaders.length; j++) {
            storedSubs[j] = (CompositeReader) storedFieldsReaders[j].getSequentialSubReaders().get(i);
          }
          // We pass true for closeSubs and we prevent closing of subreaders in doClose():
          // By this the synthetic throw-away readers used here are completely invisible to ref-counting
          subReaders[i] = new ParallelCompositeReader(true, compositeSubs, storedSubs) {
            @Override
            protected void doClose() {}
          };
        }
      }
      return subReaders;
    }
  }

