  @Override
  public void finish() {
    if (finished) {
      throw new IllegalStateException("already finished");
    }
    finished = true;

    // shrink wrap
    if (size < docs.size()) {
      docs = docs.resize(size);
      values = values.resize(size);
    }

    new InPlaceMergeSorter() {
      @Override
      protected void swap(int i, int j) {
        long tmpDoc = docs.get(j);
        docs.set(j, docs.get(i));
        docs.set(i, tmpDoc);
        
        long tmpVal = values.get(j);
        values.set(j, values.get(i));
        values.set(i, tmpVal);
      }

      @Override
      protected int compare(int i, int j) {
        // increasing docID order:
        // NOTE: we can have ties here, when the same docID was updated in the same segment, in which case we rely on sort being
        // stable and preserving original order so the last update to that docID wins
        return Integer.compare((int) docs.get(i), (int) docs.get(j));
      }
    }.sort(0, size);
  }

