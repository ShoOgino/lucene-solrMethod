  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {

    assert testPoint("startCommitMerge");

    if (hitOOM) {
      throw new IllegalStateException("this writer hit an OutOfMemoryError; cannot complete merge");
    }

    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW", "commitMerge: " + segString(merge.segments) + " index=" + segString());
    }

    assert merge.registerDone;

    // If merge was explicitly aborted, or, if rollback() or
    // rollbackTransaction() had been called since our merge
    // started (which results in an unqualified
    // deleter.refresh() call that will remove any index
    // file that current segments does not reference), we
    // abort this merge
    if (merge.isAborted()) {
      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "commitMerge: skip: it was aborted");
      }
      return false;
    }

    final ReadersAndLiveDocs mergedDeletes =  merge.info.docCount == 0 ? null : commitMergedDeletes(merge);

    assert mergedDeletes == null || mergedDeletes.getPendingDeleteCount() != 0;

    // If the doc store we are using has been closed and
    // is in now compound format (but wasn't when we
    // started), then we will switch to the compound
    // format as well:

    assert !segmentInfos.contains(merge.info);

    final boolean allDeleted = merge.segments.size() == 0 ||
      merge.info.docCount == 0 ||
      (mergedDeletes != null &&
       mergedDeletes.getPendingDeleteCount() == merge.info.docCount);

    if (infoStream.isEnabled("IW")) {
      if (allDeleted) {
        infoStream.message("IW", "merged segment " + merge.info + " is 100% deleted" +  (keepFullyDeletedSegments ? "" : "; skipping insert"));
      }
    }

    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;

    // If we merged no segments then we better be dropping
    // the new segment:
    assert merge.segments.size() > 0 || dropSegment;

    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;

    segmentInfos.applyMergeChanges(merge, dropSegment);

    if (mergedDeletes != null) {
      if (dropSegment) {
        mergedDeletes.dropChanges();
      }
      readerPool.release(mergedDeletes);
      if (dropSegment) {
        readerPool.drop(mergedDeletes.info);
      }
    }

    // Must close before checkpoint, otherwise IFD won't be
    // able to delete the held-open files from the merge
    // readers:
    closeMergeReaders(merge, false);

    // Must note the change to segmentInfos so any commits
    // in-flight don't lose it:
    checkpoint();

    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW", "after commit: " + segString());
    }

    if (merge.maxNumSegments != -1 && !dropSegment) {
      // cascade the forceMerge:
      if (!segmentsToMerge.containsKey(merge.info)) {
        segmentsToMerge.put(merge.info, Boolean.FALSE);
      }
    }

    return true;
  }

