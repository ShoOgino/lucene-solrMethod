  public void flush(FieldInfo fieldInfo, SegmentWriteState state, SortedDocValuesConsumer consumer) throws IOException {
    int valueCount = hash.size();

    final int maxDoc = state.segmentInfo.getDocCount();
    int emptyOrd = -1;
    if (pending.size() < maxDoc) {
      // Make sure we added EMPTY value before sorting:
      emptyOrd = hash.add(EMPTY);
      if (emptyOrd < 0) {
        emptyOrd = -emptyOrd-1;
      }
    }

    int[] sortedValues = hash.sort(BytesRef.getUTF8SortedAsUnicodeComparator());
    // nocommit must budget this into RAM consumption up front!
    int[] ordMap = new int[valueCount];

    // Write values, in sorted order:
    BytesRef scratch = new BytesRef();
    for(int ord=0;ord<valueCount;ord++) {
      consumer.addValue(hash.get(sortedValues[ord], scratch));
      ordMap[sortedValues[ord]] = ord;
    }
    final int bufferedDocCount = pending.size();

    for(int docID=0;docID<bufferedDocCount;docID++) {
      consumer.addDoc(ordMap[pending.get(docID)]);
    }
    for(int docID=bufferedDocCount;docID<maxDoc;docID++) {
      consumer.addDoc(ordMap[emptyOrd]);
    }
    reset();
  }

