  synchronized void lockAndAbortAll() {
    assert indexWriter.holdsFullFlushLock();
    if (infoStream.isEnabled("DW")) {
      infoStream.message("DW", "lockAndAbortAll");
    }
    boolean success = false;
    try {
      deleteQueue.clear();
      final int limit = perThreadPool.getMaxThreadStates();
      for (int i = 0; i < limit; i++) {
        final ThreadState perThread = perThreadPool.getThreadState(i);
        perThread.lock();
        if (perThread.isActive()) { // we might be closed or 
          try {
            perThread.dwpt.abort();
          } finally {
            perThread.dwpt.checkAndResetHasAborted();
            flushControl.doOnAbort(perThread);
          }
        }
      }
      deleteQueue.clear();
      flushControl.abortPendingFlushes();
      flushControl.waitForFlush();
      success = true;
    } finally {
      if (infoStream.isEnabled("DW")) {
        infoStream.message("DW", "finished lockAndAbortAll success=" + success);
      }
      if (!success) {
        // if something happens here we unlock all states again
        unlockAllAfterAbortAll();
      }
    }
  }

