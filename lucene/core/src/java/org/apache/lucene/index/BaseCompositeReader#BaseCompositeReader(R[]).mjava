  /**
   * Constructs a {@code BaseCompositeReader} on the given subReaders.
   * @param subReaders the wrapped sub-readers. This array is returned by
   * {@link #getSequentialSubReaders} and used to resolve the correct
   * subreader for docID-based methods. <b>Please note:</b> This array is <b>not</b>
   * cloned and not protected for modification, the subclass is responsible 
   * to do this.
   */
  protected BaseCompositeReader(R[] subReaders) throws IOException {
    this.subReaders = subReaders;
    this.subReadersList = Collections.unmodifiableList(Arrays.asList(subReaders));
    starts = new int[subReaders.length + 1];    // build starts array
    int maxDoc = 0, numDocs = 0;
    boolean hasDeletions = false;
    for (int i = 0; i < subReaders.length; i++) {
      starts[i] = maxDoc;
      final IndexReader r = subReaders[i];
      maxDoc += r.maxDoc();      // compute maxDocs
      if (maxDoc < 0 /* overflow */) {
        throw new IllegalArgumentException("Too many documents, composite IndexReaders cannot exceed " + Integer.MAX_VALUE);
      }
      numDocs += r.numDocs();    // compute numDocs
      if (r.hasDeletions()) {
        hasDeletions = true;
      }
      r.registerParentReader(this);
    }
    starts[subReaders.length] = maxDoc;
    this.maxDoc = maxDoc;
    this.numDocs = numDocs;
    this.hasDeletions = hasDeletions;
  }

