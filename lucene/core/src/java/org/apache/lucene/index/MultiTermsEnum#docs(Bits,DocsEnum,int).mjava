  @Override
  public DocsEnum docs(Bits liveDocs, DocsEnum reuse, int flags) throws IOException {
    MultiDocsEnum docsEnum;
    // Can only reuse if incoming enum is also a MultiDocsEnum
    if (reuse != null && reuse instanceof MultiDocsEnum) {
      docsEnum = (MultiDocsEnum) reuse;
      // ... and was previously created w/ this MultiTermsEnum:
      if (!docsEnum.canReuse(this)) {
        docsEnum = new MultiDocsEnum(this, subs.length);
      }
    } else {
      docsEnum = new MultiDocsEnum(this, subs.length);
    }
    
    final MultiBits multiLiveDocs;
    if (liveDocs instanceof MultiBits) {
      multiLiveDocs = (MultiBits) liveDocs;
    } else {
      multiLiveDocs = null;
    }

    int upto = 0;

    for(int i=0;i<numTop;i++) {

      final TermsEnumWithSlice entry = top[i];

      final Bits b;

      if (multiLiveDocs != null) {
        // optimize for common case: requested skip docs is a
        // congruent sub-slice of MultiBits: in this case, we
        // just pull the liveDocs from the sub reader, rather
        // than making the inefficient
        // Slice(Multi(sub-readers)):
        final MultiBits.SubResult sub = multiLiveDocs.getMatchingSub(entry.subSlice);
        if (sub.matches) {
          b = sub.result;
        } else {
          // custom case: requested skip docs is foreign:
          // must slice it on every access
          b = new BitsSlice(liveDocs, entry.subSlice);
        }
      } else if (liveDocs != null) {
        b = new BitsSlice(liveDocs, entry.subSlice);
      } else {
        // no deletions
        b = null;
      }

      assert entry.index < docsEnum.subDocsEnum.length: entry.index + " vs " + docsEnum.subDocsEnum.length + "; " + subs.length;
      final DocsEnum subDocsEnum = entry.terms.docs(b, docsEnum.subDocsEnum[entry.index], flags);
      if (subDocsEnum != null) {
        docsEnum.subDocsEnum[entry.index] = subDocsEnum;
        subDocs[upto].docsEnum = subDocsEnum;
        subDocs[upto].slice = entry.subSlice;
        upto++;
      } else {
        // One of our subs cannot provide a docsenum:
        assert false;
      }
    }

    if (upto == 0) {
      return null;
    } else {
      return docsEnum.reset(subDocs, upto);
    }
  }

