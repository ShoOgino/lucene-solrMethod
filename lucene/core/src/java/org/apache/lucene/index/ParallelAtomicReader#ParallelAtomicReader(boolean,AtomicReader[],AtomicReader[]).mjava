  /** Expert: create a ParallelAtomicReader based on the provided
   *  readers and storedFieldReaders; when a document is
   *  loaded, only storedFieldsReaders will be used. */
  public ParallelAtomicReader(boolean closeSubReaders, AtomicReader[] readers, AtomicReader[] storedFieldsReaders) throws IOException {
    this.closeSubReaders = closeSubReaders;
    if (readers.length == 0 && storedFieldsReaders.length > 0)
      throw new IllegalArgumentException("There must be at least one main reader if storedFieldsReaders are used.");
    this.parallelReaders = readers.clone();
    this.storedFieldsReaders = storedFieldsReaders.clone();
    this.numDocs = (readers.length > 0) ? readers[0].numDocs() : 0;
    this.maxDoc = (readers.length > 0) ? readers[0].maxDoc() : 0;
    this.hasDeletions = (readers.length > 0) ? readers[0].hasDeletions() : false;
    Collections.addAll(completeReaderSet, this.parallelReaders);
    Collections.addAll(completeReaderSet, this.storedFieldsReaders);
    
    // check compatibility:
    for(AtomicReader reader : completeReaderSet) {
      if (reader.maxDoc() != maxDoc) {
        throw new IllegalArgumentException("All readers must have same maxDoc: "+maxDoc+"!="+reader.maxDoc());
      }
    }
      
    for (final AtomicReader reader : this.parallelReaders) {
      final FieldInfos readerFieldInfos = reader.getFieldInfos();
      for(FieldInfo fieldInfo : readerFieldInfos) { // update fieldToReader map
        // NOTE: first reader having a given field "wins":
        if (fieldToReader.get(fieldInfo.name) == null) {
          fieldInfos.add(fieldInfo);
          fieldToReader.put(fieldInfo.name, reader);
          this.fields.addField(fieldInfo.name, reader.terms(fieldInfo.name));
        }
      }
    } 

    // do this finally so any Exceptions occurred before don't affect refcounts:
    if (!closeSubReaders) {
      for (AtomicReader reader : completeReaderSet) {
        reader.incRef();
      }
    }
  }

