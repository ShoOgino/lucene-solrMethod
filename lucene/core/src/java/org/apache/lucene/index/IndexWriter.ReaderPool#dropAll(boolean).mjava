    /** Remove all our references to readers, and commits
     *  any pending changes. */
    synchronized void dropAll(boolean doSave) throws IOException {
      Throwable priorE = null;
      final Iterator<Map.Entry<SegmentInfoPerCommit,ReadersAndLiveDocs>> it = readerMap.entrySet().iterator();
      while(it.hasNext()) {
        final ReadersAndLiveDocs rld = it.next().getValue();

        try {
          if (doSave && rld.writeLiveDocs(directory)) {
            // Make sure we only write del docs for a live segment:
            assert infoIsLive(rld.info);
            // Must checkpoint w/ deleter, because we just
            // created created new _X_N.del file.
            deleter.checkpoint(segmentInfos, false);
          }
        } catch (Throwable t) {
          if (priorE != null) {
            priorE = t;
          }
        }

        // Important to remove as-we-go, not with .clear()
        // in the end, in case we hit an exception;
        // otherwise we could over-decref if close() is
        // called again:
        it.remove();

        // NOTE: it is allowed that these decRefs do not
        // actually close the SRs; this happens when a
        // near real-time reader is kept open after the
        // IndexWriter instance is closed:
        try {
          rld.dropReaders();
        } catch (Throwable t) {
          if (priorE != null) {
            priorE = t;
          }
        }
      }
      assert readerMap.size() == 0;
      if (priorE != null) {
        throw new RuntimeException(priorE);
      }
    }

