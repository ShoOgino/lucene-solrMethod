  private <T extends DocValuesUpdate> boolean addDocValuesUpdate(Map<String,LinkedHashMap<Term,T>> updates, T update,
                                                                 int docIDUpto, IntFunction<T> prepareForApply,
                                                                 long bytesPerUpdateEntry, long bytesPerFieldEntry) {
    LinkedHashMap<Term,T> fieldUpdates = updates.get(update.field);
    if (fieldUpdates == null) {
      fieldUpdates = new LinkedHashMap<>();
      updates.put(update.field, fieldUpdates);
      bytesUsed.addAndGet(bytesPerFieldEntry);
    }
    final T current = fieldUpdates.get(update.term);
    if (current != null && docIDUpto < current.docIDUpto) {
      // Only record the new number if it's greater than or equal to the current
      // one. This is important because if multiple threads are replacing the
      // same doc at nearly the same time, it's possible that one thread that
      // got a higher docID is scheduled before the other threads.
      return false;
    }

    // since it's a LinkedHashMap, we must first remove the Term entry so that
    // it's added last (we're interested in insertion-order).
    if (current != null) {
      fieldUpdates.remove(update.term);
    }

    fieldUpdates.put(update.term, prepareForApply.apply(docIDUpto)); // only make a copy if necessary
    if (current == null) {
      bytesUsed.addAndGet(bytesPerUpdateEntry + update.sizeInBytes());
    }
    return true;
  }

