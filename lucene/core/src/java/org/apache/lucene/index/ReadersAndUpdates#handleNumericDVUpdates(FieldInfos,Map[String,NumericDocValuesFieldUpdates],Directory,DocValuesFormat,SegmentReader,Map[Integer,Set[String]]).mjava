  @SuppressWarnings("synthetic-access")
  private void handleNumericDVUpdates(FieldInfos infos, Map<String,NumericDocValuesFieldUpdates> updates,
      Directory dir, DocValuesFormat dvFormat, final SegmentReader reader, Map<Integer,Set<String>> fieldFiles) throws IOException {
    for (Entry<String,NumericDocValuesFieldUpdates> e : updates.entrySet()) {
      final String field = e.getKey();
      final NumericDocValuesFieldUpdates fieldUpdates = e.getValue();

      final long nextDocValuesGen = info.getNextDocValuesGen();
      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);
      final long estUpdatesSize = fieldUpdates.ramBytesPerDoc() * info.info.maxDoc();
      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), estUpdatesSize));
      final FieldInfo fieldInfo = infos.fieldInfo(field);
      assert fieldInfo != null;
      fieldInfo.setDocValuesGen(nextDocValuesGen);
      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });
      // separately also track which files were created for this gen
      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);
      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);
      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {
        // write the numeric updates to a new gen'd docvalues file
        fieldsConsumer.addNumericField(fieldInfo, new EmptyDocValuesProducer() {
            @Override
            public NumericDocValues getNumeric(FieldInfo fieldInfoIn) throws IOException {
              if (fieldInfoIn != fieldInfo) {
                throw new IllegalArgumentException("wrong fieldInfo");
              }
              final int maxDoc = reader.maxDoc();

              final NumericDocValuesFieldUpdates.Iterator updatesIter = fieldUpdates.iterator();

              final NumericDocValues currentValues = reader.getNumericDocValues(field);
              updatesIter.reset();

              // Merge sort of the original doc values with updated doc values:
              return new NumericDocValues() {
                // merged docID
                private int docIDOut = -1;

                // docID from our original doc values
                private int docIDIn = -1;

                // docID from our updates
                private int updateDocID = -1;

                private long value;

                @Override
                public int docID() {
                  return docIDOut;
                }

                @Override
                public int advance(int target) {
                  throw new UnsupportedOperationException();
                }

                @Override
                public long cost() {
                  // TODO
                  return 0;
                }

                @Override
                public long longValue() {
                  return value;
                }

                @Override
                public int nextDoc() throws IOException {
                  if (docIDIn == docIDOut) {
                    if (currentValues == null) {
                      docIDIn = NO_MORE_DOCS;
                    } else {
                      docIDIn = currentValues.nextDoc();
                    }
                  }
                  if (updateDocID == docIDOut) {
                    updateDocID = updatesIter.nextDoc();
                  }
                  if (docIDIn < updateDocID) {
                    // no update to this doc
                    docIDOut = docIDIn;
                    value = currentValues.longValue();
                  } else {
                    docIDOut = updateDocID;
                    if (docIDOut != NO_MORE_DOCS) {
                      value = updatesIter.value();
                    }
                  }
                  return docIDOut;
                }
              };
            }
          });
      }
      info.advanceDocValuesGen();
      assert !fieldFiles.containsKey(fieldInfo.number);
      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());
    }
  }

