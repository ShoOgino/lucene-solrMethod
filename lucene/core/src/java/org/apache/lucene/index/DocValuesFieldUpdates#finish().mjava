  /** Freezes internal data structures and sorts updates by docID for efficient iteration. */
  final synchronized void finish() {
    if (finished) {
      throw new IllegalStateException("already finished");
    }
    finished = true;
    // shrink wrap
    if (size < docs.size()) {
      resize(size);
    }
    new InPlaceMergeSorter() {
      @Override
      protected void swap(int i, int j) {
        DocValuesFieldUpdates.this.swap(i, j);
      }

      @Override
      protected int compare(int i, int j) {
        // increasing docID order:
        // NOTE: we can have ties here, when the same docID was updated in the same segment, in which case we rely on sort being
        // stable and preserving original order so the last update to that docID wins
        return Long.compare(docs.get(i)>>>1, docs.get(j)>>>1);
      }
    }.sort(0, size);
  }

