  /**
   * Update the stalled flag status. This method will set the stalled flag to
   * <code>true</code> iff the number of flushing
   * {@link DocumentsWriterPerThread} is greater than the number of active
   * {@link DocumentsWriterPerThread}. Otherwise it will reset the
   * {@link DocumentsWriterStallControl} to healthy and release all threads waiting on
   * {@link #waitIfStalled()}
   */
  void updateStalled(MemoryController controller) {
    do {
      final long netBytes = controller.netBytes();
      final long flushBytes = controller.flushBytes();
      final long limit = controller.stallLimitBytes();
      assert netBytes >= flushBytes;
      assert limit > 0;
      /*
       * we block indexing threads if net byte grows due to slow flushes
       * yet, for small ram buffers and large documents we can easily
       * reach the limit without any ongoing flushes. we need to ensure
       * that we don't stall/block if an ongoing or pending flush can 
       * not free up enough memory to release the stall lock.
       */
      while (netBytes > limit && (netBytes - flushBytes) < limit) {
        if (sync.trySetStalled()) {
          assert wasStalled = true;
          return;
        }
      }
    } while (!sync.tryReset());
  }

