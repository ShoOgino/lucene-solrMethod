  @SuppressWarnings("synthetic-access")
  private synchronized void handleNumericDVUpdates(FieldInfos infos,
                                                   Directory dir, DocValuesFormat dvFormat, final SegmentReader reader,
                                                   Map<Integer,Set<String>> fieldFiles, long maxDelGen, InfoStream infoStream) throws IOException {

    for (Entry<String,List<DocValuesFieldUpdates>> ent : pendingDVUpdates.entrySet()) {
      final String field = ent.getKey();
      final List<DocValuesFieldUpdates> updates = ent.getValue();
      if (updates.get(0).type != DocValuesType.NUMERIC) {
        continue;
      }

      final List<DocValuesFieldUpdates> updatesToApply = new ArrayList<>();
      long bytes = 0;
      for(DocValuesFieldUpdates update : updates) {
        if (update.delGen <= maxDelGen) {
          // safe to apply this one
          bytes += update.ramBytesUsed();
          updatesToApply.add(update);
        }
      }
      if (updatesToApply.isEmpty()) {
        // nothing to apply yet
        continue;
      }

      if (infoStream.isEnabled("BD")) {
        infoStream.message("BD", String.format(Locale.ROOT,
                                               "now write %d pending numeric DV updates for field=%s, seg=%s, bytes=%.3f MB",
                                               updatesToApply.size(),
                                               field,
                                               info,
                                               bytes/1024./1024.));
      }

      final long nextDocValuesGen = info.getNextDocValuesGen();
      final String segmentSuffix = Long.toString(nextDocValuesGen, Character.MAX_RADIX);
      final IOContext updatesContext = new IOContext(new FlushInfo(info.info.maxDoc(), bytes));
      final FieldInfo fieldInfo = infos.fieldInfo(field);
      assert fieldInfo != null;
      fieldInfo.setDocValuesGen(nextDocValuesGen);
      final FieldInfos fieldInfos = new FieldInfos(new FieldInfo[] { fieldInfo });
      // separately also track which files were created for this gen
      final TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);
      final SegmentWriteState state = new SegmentWriteState(null, trackingDir, info.info, fieldInfos, null, updatesContext, segmentSuffix);
      try (final DocValuesConsumer fieldsConsumer = dvFormat.fieldsConsumer(state)) {
        // write the numeric updates to a new gen'd docvalues file
        fieldsConsumer.addNumericField(fieldInfo, new EmptyDocValuesProducer() {
            @Override
            public NumericDocValues getNumeric(FieldInfo fieldInfoIn) throws IOException {
              if (fieldInfoIn != fieldInfo) {
                throw new IllegalArgumentException("wrong fieldInfo");
              }
              final int maxDoc = reader.maxDoc();
              DocValuesFieldUpdates.Iterator[] subs = new DocValuesFieldUpdates.Iterator[updatesToApply.size()];
              for(int i=0;i<subs.length;i++) {
                subs[i] = updatesToApply.get(i).iterator();
              }

              final DocValuesFieldUpdates.Iterator updatesIter = DocValuesFieldUpdates.mergedIterator(subs);

              final NumericDocValues currentValues = reader.getNumericDocValues(field);

              // Merge sort of the original doc values with updated doc values:
              return new NumericDocValues() {
                // merged docID
                private int docIDOut = -1;

                // docID from our original doc values
                private int docIDIn = -1;

                // docID from our updates
                private int updateDocID = -1;

                private long value;

                @Override
                public int docID() {
                  return docIDOut;
                }

                @Override
                public int advance(int target) {
                  throw new UnsupportedOperationException();
                }

                @Override
                public boolean advanceExact(int target) throws IOException {
                  throw new UnsupportedOperationException();
                }

                @Override
                public long cost() {
                  // TODO
                  return 0;
                }

                @Override
                public long longValue() {
                  return value;
                }

                @Override
                public int nextDoc() throws IOException {
                  if (docIDIn == docIDOut) {
                    if (currentValues == null) {
                      docIDIn = NO_MORE_DOCS;
                    } else {
                      docIDIn = currentValues.nextDoc();
                    }
                  }
                  if (updateDocID == docIDOut) {
                    updateDocID = updatesIter.nextDoc();
                  }
                  if (docIDIn < updateDocID) {
                    // no update to this doc
                    docIDOut = docIDIn;
                    value = currentValues.longValue();
                  } else {
                    docIDOut = updateDocID;
                    if (docIDOut != NO_MORE_DOCS) {
                      value = (Long) updatesIter.value();
                    }
                  }
                  return docIDOut;
                }
              };
            }
          });
      }
      info.advanceDocValuesGen();
      assert !fieldFiles.containsKey(fieldInfo.number);
      fieldFiles.put(fieldInfo.number, trackingDir.getCreatedFiles());
    }
  }

