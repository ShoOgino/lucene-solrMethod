  private DocMap[] buildDocMaps(List<CodecReader> readers, Sort indexSort) throws IOException {

    int numReaders = readers.size();

    if (indexSort == null) {
      // no index sort ... we only must map around deletions, and rebase to the merged segment's docID space

      int totalDocs = 0;
      DocMap[] docMaps = new DocMap[numReaders];

      // Remap docIDs around deletions:
      for (int i = 0; i < numReaders; i++) {
        LeafReader reader = readers.get(i);
        Bits liveDocs = reader.getLiveDocs();

        final PackedLongValues delDocMap;
        if (liveDocs != null) {
          delDocMap = removeDeletes(reader.maxDoc(), liveDocs);
        } else {
          delDocMap = null;
        }

        final int docBase = totalDocs;
        docMaps[i] = new DocMap() {
          @Override
          public int get(int docID) {
            if (liveDocs == null) {
              return docBase + docID;
            } else if (liveDocs.get(docID)) {
              return docBase + (int) delDocMap.get(docID);
            } else {
              return -1;
            }
          }
        };
        totalDocs += reader.numDocs();
      }

      return docMaps;

    } else {
      // do a merge sort of the incoming leaves:
      long t0 = System.nanoTime();
      DocMap[] result = MultiSorter.sort(indexSort, readers);
      long t1 = System.nanoTime();
      if (infoStream.isEnabled("SM")) {
        infoStream.message("SM", String.format(Locale.ROOT, "%.2f msec to build merge sorted DocMaps", (t1-t0)/1000000.0));
      }
      return result;
    }
  }

