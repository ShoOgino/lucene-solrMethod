  private DocFieldProcessorPerField processField(FieldInfos.Builder fieldInfos,
      final int thisFieldGen, final String fieldName, IndexableFieldType ft) {

    // Make sure we have a PerField allocated
    final int hashPos = fieldName.hashCode() & hashMask;
    DocFieldProcessorPerField fp = fieldHash[hashPos];
    while(fp != null && !fp.fieldInfo.name.equals(fieldName)) {
      fp = fp.next;
    }

    if (fp == null) {

      // TODO FI: we need to genericize the "flags" that a
      // field holds, and, how these flags are merged; it
      // needs to be more "pluggable" such that if I want
      // to have a new "thing" my Fields can do, I can
      // easily add it
      FieldInfo fi = fieldInfos.addOrUpdate(fieldName, ft);

      fp = new DocFieldProcessorPerField(this, fi);
      fp.next = fieldHash[hashPos];
      fieldHash[hashPos] = fp;
      totalFieldCount++;

      if (totalFieldCount >= fieldHash.length/2) {
        rehash();
      }
    } else {
      // nocommit: dangerous: maybe FI.update()/FI ctor()/FIS.addOrUpdate need only take FT
      // instead of a thousand parameters? Surely we can make this better... like:
      // fp.fieldInfo.update(ft);
      fp.fieldInfo.update(ft.indexed(), false, ft.omitNorms(), false, ft.indexOptions());
    }

    if (thisFieldGen != fp.lastGen) {

      // First time we're seeing this field for this doc
      fp.fieldCount = 0;

      if (fieldCount == fields.length) {
        final int newSize = fields.length*2;
        DocFieldProcessorPerField newArray[] = new DocFieldProcessorPerField[newSize];
        System.arraycopy(fields, 0, newArray, 0, fieldCount);
        fields = newArray;
      }

      fields[fieldCount++] = fp;
      fp.lastGen = thisFieldGen;
    }
    return fp;
  }

