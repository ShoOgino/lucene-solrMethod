  private long prepareCommitInternal() throws IOException {
    startCommitTime = System.nanoTime();
    synchronized(commitLock) {
      ensureOpen(false);
      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "prepareCommit: flush");
        infoStream.message("IW", "  index before flush " + segString());
      }

      if (tragedy.get() != null) {
        throw new IllegalStateException("this writer hit an unrecoverable error; cannot commit", tragedy.get());
      }

      if (pendingCommit != null) {
        throw new IllegalStateException("prepareCommit was already called with no corresponding call to commit");
      }

      doBeforeFlush();
      testPoint("startDoFlush");
      SegmentInfos toCommit = null;
      boolean anyChanges = false;
      long seqNo;
      List<MergePolicy.OneMerge> commitMerges = null;
      AtomicReference<CountDownLatch> mergeAwaitLatchRef = null;

      // This is copied from doFlush, except it's modified to
      // clone & incRef the flushed SegmentInfos inside the
      // sync block:

      try {

        synchronized (fullFlushLock) {
          boolean flushSuccess = false;
          boolean success = false;
          try {
            seqNo = docWriter.flushAllThreads();
            if (seqNo < 0) {
              anyChanges = true;
              seqNo = -seqNo;
            }
            if (anyChanges == false) {
              // prevent double increment since docWriter#doFlush increments the flushcount
              // if we flushed anything.
              flushCount.incrementAndGet();
            }
            publishFlushedSegments(true);
            // cannot pass triggerMerges=true here else it can lead to deadlock:
            processEvents(false);
            
            flushSuccess = true;

            applyAllDeletesAndUpdates();
            synchronized(this) {
              writeReaderPool(true);
              if (changeCount.get() != lastCommitChangeCount) {
                // There are changes to commit, so we will write a new segments_N in startCommit.
                // The act of committing is itself an NRT-visible change (an NRT reader that was
                // just opened before this should see it on reopen) so we increment changeCount
                // and segments version so a future NRT reopen will see the change:
                changeCount.incrementAndGet();
                segmentInfos.changed();
              }

              if (commitUserData != null) {
                Map<String,String> userData = new HashMap<>();
                for(Map.Entry<String,String> ent : commitUserData) {
                  userData.put(ent.getKey(), ent.getValue());
                }
                segmentInfos.setUserData(userData, false);
              }

              // Must clone the segmentInfos while we still
              // hold fullFlushLock and while sync'd so that
              // no partial changes (eg a delete w/o
              // corresponding add from an updateDocument) can
              // sneak into the commit point:
              toCommit = segmentInfos.clone();

              if (anyChanges) {
                // Find any merges that can execute on commit (per MergePolicy).
                MergePolicy.MergeSpecification mergeSpec =
                    config.getMergePolicy().findFullFlushMerges(MergeTrigger.COMMIT, segmentInfos, this);
                if (mergeSpec != null && mergeSpec.merges.size() > 0) {
                  int mergeCount = mergeSpec.merges.size();
                  commitMerges = new ArrayList<>(mergeCount);
                  mergeAwaitLatchRef = new AtomicReference<>(new CountDownLatch(mergeCount));
                  for (MergePolicy.OneMerge oneMerge : mergeSpec.merges) {
                    MergePolicy.OneMerge trackedMerge =
                        updateSegmentInfosOnMergeFinish(oneMerge, toCommit, mergeAwaitLatchRef);
                    if (registerMerge(trackedMerge) == false) {
                      throw new IllegalStateException("MergePolicy " + config.getMergePolicy().getClass() +
                          " returned merging segments from findFullFlushMerges");
                    }
                    commitMerges.add(trackedMerge);
                  }
                  if (infoStream.isEnabled("IW")) {
                    infoStream.message("IW", "Registered " + mergeCount + " commit merges");
                    infoStream.message("IW", "Before executing commit merges, had " + toCommit.size() + " segments");
                  }
                }
              }

              pendingCommitChangeCount = changeCount.get();

              // This protects the segmentInfos we are now going
              // to commit.  This is important in case, eg, while
              // we are trying to sync all referenced files, a
              // merge completes which would otherwise have
              // removed the files we are now syncing.    
              deleter.incRef(toCommit.files(false));
            }
            success = true;
          } finally {
            if (!success) {
              if (infoStream.isEnabled("IW")) {
                infoStream.message("IW", "hit exception during prepareCommit");
              }
            }
            assert holdsFullFlushLock();
            // Done: finish the full flush!
            docWriter.finishFullFlush(flushSuccess);
            doAfterFlush();
          }
        }
      } catch (VirtualMachineError tragedy) {
        tragicEvent(tragedy, "prepareCommit");
        throw tragedy;
      } finally {
        maybeCloseOnTragicEvent();
      }

      if (mergeAwaitLatchRef != null) {
        CountDownLatch mergeAwaitLatch = mergeAwaitLatchRef.get();
        // If we found and registered any merges above, within the flushLock, then we want to ensure that they
        // complete execution. Note that since we released the lock, other merges may have been scheduled. We will
        // block until  the merges that we registered complete. As they complete, they will update toCommit to
        // replace merged segments with the result of each merge.
        config.getIndexWriterEvents().beginMergeOnCommit();
        mergeScheduler.merge(this, MergeTrigger.COMMIT, true);
        long mergeWaitStart = System.nanoTime();
        int abandonedCount = 0;
        long waitTimeMillis = (long) (config.getMaxCommitMergeWaitSeconds() * 1000.0);
        try {
          if (mergeAwaitLatch.await(waitTimeMillis, TimeUnit.MILLISECONDS) == false) {
            synchronized (this) {
              // Need to do this in a synchronized block, to make sure none of our commit merges are currently
              // executing mergeFinished (since mergeFinished itself is called from within the IndexWriter lock).
              // After we clear the value from mergeAwaitLatchRef, the merges we schedule will still execute as
              // usual, but when they finish, they won't attempt to update toCommit or modify segment reference
              // counts.
              mergeAwaitLatchRef.set(null);
              for (MergePolicy.OneMerge commitMerge : commitMerges) {
                if (runningMerges.contains(commitMerge) || pendingMerges.contains(commitMerge)) {
                  abandonedCount++;
                }
              }
            }
          }
        } catch (InterruptedException ie) {
          throw new ThreadInterruptedException(ie);
        } finally {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", String.format(Locale.ROOT, "Waited %.1f ms for commit merges",
                (System.nanoTime() - mergeWaitStart)/1_000_000.0));
            infoStream.message("IW", "After executing commit merges, had " + toCommit.size() + " segments");
            if (abandonedCount > 0) {
              infoStream.message("IW", "Abandoned " + abandonedCount + " commit merges after " + waitTimeMillis + " ms");
            }
          }
          if (abandonedCount > 0) {
            config.getIndexWriterEvents().abandonedMergesOnCommit(abandonedCount);
          }
          config.getIndexWriterEvents().finishMergeOnCommit();
        }
      }
      filesToCommit = toCommit.files(false);
     
      try {
        if (anyChanges) {
          maybeMerge.set(true);
        }
        startCommit(toCommit);
        if (pendingCommit == null) {
          return -1;
        } else {
          return seqNo;
        }
      } catch (Throwable t) {
        synchronized (this) {
          if (filesToCommit != null) {
            try {
              deleter.decRef(filesToCommit);
            } catch (Throwable t1) {
              t.addSuppressed(t1);
            } finally {
              filesToCommit = null;
            }
          }
        }
        throw t;
      }
    }
  }

