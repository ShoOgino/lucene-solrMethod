  /** Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).
   * <p>
   * This is an extremely slow way to access sorted values. Instead, access them per-segment
   * with {@link AtomicReader#getSortedDocValues(String)}
   * </p>  
   */
  public static SortedDocValues getSortedValues(final IndexReader r, final String field) throws IOException {
    final List<AtomicReaderContext> leaves = r.leaves();
    if (leaves.size() == 1) {
      return leaves.get(0).reader().getSortedDocValues(field);
    }
    boolean anyReal = false;

    for(AtomicReaderContext ctx : leaves) {
      SortedDocValues values = ctx.reader().getSortedDocValues(field);

      if (values != null) {
        anyReal = true;
      }
    }

    if (!anyReal) {
      return null;
    } else {
      // its called slow-wrapper for a reason right?
      final Directory scratch = new RAMDirectory();
      IndexWriterConfig config = new IndexWriterConfig(Version.LUCENE_50, null);
      config.setCodec(Codec.forName("SimpleText"));
      IndexWriter writer = new IndexWriter(scratch, config);
      List<AtomicReader> newLeaves = new ArrayList<AtomicReader>();
      // fake up fieldinfos
      FieldInfo fi = new FieldInfo(field, false, 0, false, false, false, null, DocValuesType.SORTED, null, null);
      final FieldInfos fis = new FieldInfos(new FieldInfo[] { fi });
      for (AtomicReaderContext ctx : leaves) {
        final AtomicReader a = ctx.reader();
        newLeaves.add(new FilterAtomicReader(a) {
          @Override
          public Bits getLiveDocs() {
            return null; // lie
          }
          @Override
          public int numDocs() {
            return maxDoc(); // lie
          }
          @Override
          public boolean hasDeletions() {
            return false; // lie
          }
          @Override
          public FieldInfos getFieldInfos() {
            return fis;
          }
          @Override
          public Fields getTermVectors(int docID) throws IOException {
            return null; // lie
          }
          @Override
          public void document(int docID, StoredFieldVisitor visitor) throws IOException {
            // lie
          }
          @Override
          public Fields fields() throws IOException {
            return null; // lie
          }
        });
      }
      writer.addIndexes(newLeaves.toArray(new AtomicReader[0]));
      writer.close();
      final IndexReader newR = DirectoryReader.open(scratch);
      assert newR.leaves().size() == 1;
      r.addReaderClosedListener(new ReaderClosedListener() {
        @Override
        public void onClose(IndexReader reader) {
          IOUtils.closeWhileHandlingException(newR, scratch);
        }
      });
      return newR.leaves().get(0).reader().getSortedDocValues(field);
    }
  }

