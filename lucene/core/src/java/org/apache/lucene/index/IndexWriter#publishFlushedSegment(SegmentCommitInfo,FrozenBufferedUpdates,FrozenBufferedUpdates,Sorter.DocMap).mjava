  /**
   * Atomically adds the segment private delete packet and publishes the flushed
   * segments SegmentInfo to the index writer.
   */
  synchronized void publishFlushedSegment(SegmentCommitInfo newSegment,
                                          FrozenBufferedUpdates packet, FrozenBufferedUpdates globalPacket,
                                          Sorter.DocMap sortMap) throws IOException {
    try {
      // Lock order IW -> BDS
      ensureOpen(false);

      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "publishFlushedSegment " + newSegment);
      }

      if (globalPacket != null && globalPacket.any()) {
        // Do this as an event so it applies higher in the stack when we are not holding DocumentsWriterFlushQueue.purgeLock:
        bufferedUpdatesStream.push(globalPacket);
        docWriter.putEvent(new DocumentsWriter.ResolveUpdatesEvent(globalPacket));
      }

      // Publishing the segment must be sync'd on IW -> BDS to make the sure
      // that no merge prunes away the seg. private delete packet
      final long nextGen;
      if (packet != null && packet.any()) {
        nextGen = bufferedUpdatesStream.push(packet);

        // Do this as an event so it applies higher in the stack when we are not holding DocumentsWriterFlushQueue.purgeLock:
        docWriter.putEvent(new DocumentsWriter.ResolveUpdatesEvent(packet));
          
      } else {
        // Since we don't have a delete packet to apply we can get a new
        // generation right away
        nextGen = bufferedUpdatesStream.getNextGen();
        // No deletes/updates here, so marked finished immediately:
        bufferedUpdatesStream.finishedSegment(nextGen);
      }
      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "publish sets newSegment delGen=" + nextGen + " seg=" + segString(newSegment));
      }
      newSegment.setBufferedDeletesGen(nextGen);
      segmentInfos.add(newSegment);
      checkpoint();

      if (packet != null && packet.any() && sortMap != null) {
        // TODO: not great we do this heavyish op while holding IW's monitor lock,
        // but it only applies if you are using sorted indices and updating doc values:
        ReadersAndUpdates rld = readerPool.get(newSegment, true);
        rld.sortMap = sortMap;
      }
      
    } finally {
      flushCount.incrementAndGet();
      doAfterFlush();
    }
  }

