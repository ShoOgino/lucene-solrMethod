  private void closeInternal(boolean waitForMerges, boolean doFlush) throws IOException {
    boolean interrupted = false;
    try {

      if (pendingCommit != null) {
        throw new IllegalStateException("cannot close: prepareCommit was already called with no corresponding call to commit");
      }

      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "now flush at close waitForMerges=" + waitForMerges);
      }

      docWriter.close();

      try {
        // Only allow a new merge to be triggered if we are
        // going to wait for merges:
        if (doFlush) {
          flush(waitForMerges, true);
        } else {
          docWriter.abort(this); // already closed -- never sync on IW 
        }
        
      } finally {
        try {
          // clean up merge scheduler in all cases, although flushing may have failed:
          interrupted = Thread.interrupted();
        
          if (waitForMerges) {
            try {
              // Give merge scheduler last chance to run, in case
              // any pending merges are waiting:
              mergeScheduler.merge(this);
            } catch (ThreadInterruptedException tie) {
              // ignore any interruption, does not matter
              interrupted = true;
              if (infoStream.isEnabled("IW")) {
                infoStream.message("IW", "interrupted while waiting for final merges");
              }
            }
          }
          
          synchronized(this) {
            for (;;) {
              try {
                finishMerges(waitForMerges && !interrupted);
                break;
              } catch (ThreadInterruptedException tie) {
                // by setting the interrupted status, the
                // next call to finishMerges will pass false,
                // so it will not wait
                interrupted = true;
                if (infoStream.isEnabled("IW")) {
                  infoStream.message("IW", "interrupted while waiting for merges to finish");
                }
              }
            }
            stopMerges = true;
          }
          
        } finally {
          // shutdown policy, scheduler and all threads (this call is not interruptible):
          IOUtils.closeWhileHandlingException(mergePolicy, mergeScheduler);
        }
      }

      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "now call final commit()");
      }

      // Must do this before commitInternal, in case any of
      // the dropped readers in the pool wrote a new live
      // docs: 
      synchronized(this) {
        readerPool.dropAll(true);
      }

      if (doFlush) {
        commitInternal();
      }

      synchronized(this) {
        deleter.close();
      }

      // used by assert below
      final DocumentsWriter oldWriter = docWriter;

      synchronized (this) {
        docWriter = null;
      }

      if (infoStream.isEnabled("IW")) {
        infoStream.message("IW", "at close: " + segString());
      }

      if (writeLock != null) {
        writeLock.release();                          // release write lock
        writeLock = null;
      }
      synchronized(this) {
        closed = true;
      }
      assert oldWriter.perThreadPool.numDeactivatedThreadStates() == oldWriter.perThreadPool.getMaxThreadStates() : "" +  oldWriter.perThreadPool.numDeactivatedThreadStates() + " " +  oldWriter.perThreadPool.getMaxThreadStates();
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "closeInternal");
    } finally {
      synchronized(this) {
        closing = false;
        notifyAll();
        if (!closed) {
          if (infoStream.isEnabled("IW")) {
            infoStream.message("IW", "hit exception while closing");
          }
        }
      }
      // finally, restore interrupt status:
      if (interrupted) Thread.currentThread().interrupt();
    }
  }

