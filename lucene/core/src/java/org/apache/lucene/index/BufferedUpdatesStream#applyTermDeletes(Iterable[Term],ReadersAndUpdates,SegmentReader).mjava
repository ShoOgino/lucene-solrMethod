  // Delete by Term
  private synchronized TermDeleteCounts applyTermDeletes(Iterable<Term> termsIter, ReadersAndUpdates rld, SegmentReader reader) throws IOException {
    int delCount = 0;
    long termVisitedCount = 0;
    Fields fields = reader.fields();

    TermsEnum termsEnum = null;

    String currentField = null;
    DocsEnum docsEnum = null;

    assert checkDeleteTerm(null);

    boolean any = false;

    long ns = System.nanoTime();

    for (Term term : termsIter) {
      termVisitedCount++;
      // Since we visit terms sorted, we gain performance
      // by re-using the same TermsEnum and seeking only
      // forwards
      if (!term.field().equals(currentField)) {
        assert currentField == null || currentField.compareTo(term.field()) < 0;
        currentField = term.field();
        Terms terms = fields.terms(currentField);
        if (terms != null) {
          termsEnum = terms.iterator(termsEnum);
        } else {
          termsEnum = null;
        }
      }

      if (termsEnum == null) {
        // no terms in this field
        continue;
      }

      assert checkDeleteTerm(term);

      // System.out.println("  term=" + term);

      if (termsEnum.seekExact(term.bytes())) {
        // we don't need term frequencies for this
        docsEnum = termsEnum.docs(rld.getLiveDocs(), docsEnum, DocsEnum.FLAG_NONE);
        //System.out.println("BDS: got docsEnum=" + docsEnum);

        assert docsEnum != null;

        while (true) {
          final int docID = docsEnum.nextDoc();
          //System.out.println(Thread.currentThread().getName() + " del term=" + term + " doc=" + docID);
          if (docID == DocIdSetIterator.NO_MORE_DOCS) {
            break;
          }   
          if (!any) {
            rld.initWritableLiveDocs();
            any = true;
          }
          // NOTE: there is no limit check on the docID
          // when deleting by Term (unlike by Query)
          // because on flush we apply all Term deletes to
          // each segment.  So all Term deleting here is
          // against prior segments:
          if (rld.delete(docID)) {
            delCount++;
          }
        }
      }
    }

    return new TermDeleteCounts(delCount, termVisitedCount);
  }

