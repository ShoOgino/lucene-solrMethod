  private final boolean updateStallState() {
    
    assert Thread.holdsLock(this);
    final long limit = stallLimitBytes();
    /*
     * we block indexing threads if net byte grows due to slow flushes
     * yet, for small ram buffers and large documents we can easily
     * reach the limit without any ongoing flushes. we need to ensure
     * that we don't stall/block if an ongoing or pending flush can
     * not free up enough memory to release the stall lock.
     */
    final boolean stall = ((activeBytes + flushBytes) > limit)  &&
                          (activeBytes < limit) &&
                          !closed;
    stallControl.updateStalled(stall);
    return stall;
  }

