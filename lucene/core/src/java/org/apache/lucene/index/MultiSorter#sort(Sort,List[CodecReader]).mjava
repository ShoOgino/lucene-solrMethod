  /** Does a merge sort of the leaves of the incoming reader, returning {@link MergeState#DocMap} to map each leaf's
   *  documents into the merged segment.  The documents for each incoming leaf reader must already be sorted by the same sort! */
  static MergeState.DocMap[] sort(Sort sort, List<CodecReader> readers) throws IOException {

    SortField fields[] = sort.getSort();
    final CrossReaderComparator[] comparators = new CrossReaderComparator[fields.length];
    for(int i=0;i<fields.length;i++) {
      comparators[i] = getComparator(readers, fields[i]);
    }

    int leafCount = readers.size();

    PriorityQueue<LeafAndDocID> queue = new PriorityQueue<LeafAndDocID>(leafCount) {
        @Override
        public boolean lessThan(LeafAndDocID a, LeafAndDocID b) {
          for(int i=0;i<comparators.length;i++) {
            int cmp = comparators[i].compare(a.readerIndex, a.docID, b.readerIndex, b.docID);
            if (cmp != 0) {
              return cmp < 0;
            }
          }

          // tie-break by docID natural order:
          if (a.readerIndex != b.readerIndex) {
            return a.readerIndex < b.readerIndex;
          }
          return a.docID < b.docID;
        }
    };

    PackedLongValues.Builder[] builders = new PackedLongValues.Builder[leafCount];

    for(int i=0;i<leafCount;i++) {
      CodecReader reader = readers.get(i);
      queue.add(new LeafAndDocID(i, reader.getLiveDocs(), reader.maxDoc()));
      builders[i] = PackedLongValues.monotonicBuilder(PackedInts.COMPACT);
    }

    int mappedDocID = 0;
    while (queue.size() != 0) {
      LeafAndDocID top = queue.top();
      builders[top.readerIndex].add(mappedDocID);
      if (top.liveDocs == null || top.liveDocs.get(top.docID)) {
        mappedDocID++;
      }
      top.docID++;
      if (top.docID < top.maxDoc) {
        queue.updateTop();
      } else {
        queue.pop();
      }
    }

    MergeState.DocMap[] docMaps = new MergeState.DocMap[leafCount];
    for(int i=0;i<leafCount;i++) {
      final PackedLongValues remapped = builders[i].build();
      final Bits liveDocs = readers.get(i).getLiveDocs();
      docMaps[i] = new MergeState.DocMap() {
          @Override
          public int get(int docID) {
            if (liveDocs == null || liveDocs.get(docID)) {
              return (int) remapped.get(docID);
            } else {
              return -1;
            }
          }
        };
    }

    return docMaps;
  }

