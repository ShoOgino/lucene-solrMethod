  /** <p>Expert: prepare for commit, specifying
   *  commitUserData Map (String -> String).  This does the
   *  first phase of 2-phase commit. This method does all
   *  steps necessary to commit changes since this writer
   *  was opened: flushes pending added and deleted docs,
   *  syncs the index files, writes most of next segments_N
   *  file.  After calling this you must call either {@link
   *  #commit()} to finish the commit, or {@link
   *  #rollback()} to revert the commit and undo all changes
   *  done since the writer was opened.</p>
   *
   *  <p>You can also just call {@link #commit(Map)} directly
   *  without prepareCommit first in which case that method
   *  will internally call prepareCommit.
   *
   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError
   *  you should immediately close the writer.  See <a
   *  href="#OOME">above</a> for details.</p>
   *
   *  @param commitUserData Opaque Map (String->String)
   *  that's recorded into the segments file in the index,
   *  and retrievable by {@link
   *  IndexCommit#getUserData}.  Note that when
   *  IndexWriter commits itself during {@link #close}, the
   *  commitUserData is unchanged (just carried over from
   *  the prior commit).  If this is null then the previous
   *  commitUserData is kept.  Also, the commitUserData will
   *  only "stick" if there are actually changes in the
   *  index to commit.
   */
  public final void prepareCommit(Map<String,String> commitUserData) throws CorruptIndexException, IOException {
    ensureOpen(false);

    if (infoStream.isEnabled("IW")) {
      infoStream.message("IW", "prepareCommit: flush");
      infoStream.message("IW", "  index before flush " + segString());
    }

    if (hitOOM) {
      throw new IllegalStateException("this writer hit an OutOfMemoryError; cannot commit");
    }

    if (pendingCommit != null) {
      throw new IllegalStateException("prepareCommit was already called with no corresponding call to commit");
    }

    doBeforeFlush();
    assert testPoint("startDoFlush");
    SegmentInfos toCommit = null;
    boolean anySegmentsFlushed = false;

    // This is copied from doFlush, except it's modified to
    // clone & incRef the flushed SegmentInfos inside the
    // sync block:

    try {

      synchronized (fullFlushLock) {
        boolean flushSuccess = false;
        boolean success = false;
        try {
          anySegmentsFlushed = docWriter.flushAllThreads();
          if (!anySegmentsFlushed) {
            // prevent double increment since docWriter#doFlush increments the flushcount
            // if we flushed anything.
            flushCount.incrementAndGet();
          }
          flushSuccess = true;

          synchronized(this) {
            maybeApplyDeletes(true);

            readerPool.commit(segmentInfos);

            // Must clone the segmentInfos while we still
            // hold fullFlushLock and while sync'd so that
            // no partial changes (eg a delete w/o
            // corresponding add from an updateDocument) can
            // sneak into the commit point:
            toCommit = segmentInfos.clone();

            pendingCommitChangeCount = changeCount;

            // This protects the segmentInfos we are now going
            // to commit.  This is important in case, eg, while
            // we are trying to sync all referenced files, a
            // merge completes which would otherwise have
            // removed the files we are now syncing.    
            filesToCommit = toCommit.files(directory, false);
            deleter.incRef(filesToCommit);
          }
          success = true;
        } finally {
          if (!success) {
            if (infoStream.isEnabled("IW")) {
              infoStream.message("IW", "hit exception during prepareCommit");
            }
          }
          // Done: finish the full flush!
          docWriter.finishFullFlush(flushSuccess);
          doAfterFlush();
        }
      }
    } catch (OutOfMemoryError oom) {
      handleOOM(oom, "prepareCommit");
    }
 
    boolean success = false;
    try {
      if (anySegmentsFlushed) {
        maybeMerge();
      }
      success = true;
    } finally {
      if (!success) {
        synchronized (this) {
          deleter.decRef(filesToCommit);
          filesToCommit = null;
        }
      }
    }

    startCommit(toCommit, commitUserData);
  }

