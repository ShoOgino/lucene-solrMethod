  @Override
  public void processDocument() throws IOException, AbortingException {

    // How many indexed field names we've seen (collapses
    // multiple field instances by the same name):
    int fieldCount = 0;

    long fieldGen = nextFieldGen++;

    // NOTE: we need two passes here, in case there are
    // multi-valued fields, because we must process all
    // instances of a given field at once, since the
    // analyzer is free to reuse TokenStream across fields
    // (i.e., we cannot have more than one TokenStream
    // running "at once"):

    termsHash.startDocument();

    // Invert indexed fields:
    try {
      for (IndexableField field : docState.doc.indexableFields()) {
        IndexableFieldType fieldType = field.fieldType();
        
        // if the field omits norms, the boost cannot be indexed.
        if (fieldType.omitNorms() && field.boost() != 1.0f) {
          throw new UnsupportedOperationException("You cannot set an index-time boost: norms are omitted for field '" + field.name() + "'");
        }
        
        PerField fp = getOrAddField(field.name(), fieldType, true);
        boolean first = fp.fieldGen != fieldGen;
        fp.invert(field, first);

        if (first) {
          fields[fieldCount++] = fp;
          fp.fieldGen = fieldGen;
        }
      }
    } finally {
      // Finish each field name seen in the document:
      for (int i=0;i<fieldCount;i++) {
        fields[i].finish();
      }
    }

    try {
      termsHash.finishDocument();
    } catch (Throwable th) {
      // Must abort, on the possibility that on-disk term
      // vectors are now corrupt:
      throw AbortingException.wrap(th);
    }

    // Add stored fields:
    fillStoredFields(docState.docID);
    startStoredFields();

    // TODO: clean up this loop, it's bogus that docvalues are treated as stored fields...
    boolean abort = false;
    try {
      for (StorableField field : docState.doc.storableFields()) {
        String fieldName = field.name();
        IndexableFieldType fieldType = field.fieldType();
      
        verifyFieldType(fieldName, fieldType);

        PerField fp = getOrAddField(fieldName, fieldType, false);
        if (fieldType.stored()) {
          try {
            storedFieldsWriter.writeField(fp.fieldInfo, field);
          } catch (Throwable th) {
            abort = true;
            throw AbortingException.wrap(th);
          }
        }

        DocValuesType dvType = fieldType.docValuesType();
        if (dvType == null) {
          throw new NullPointerException("docValuesType cannot be null (field: \"" + fieldName + "\")");
        }
        if (dvType != DocValuesType.NONE) {
          indexDocValue(fp, dvType, field);
        }
      }
    } finally {
      if (abort == false) {
        finishStoredFields();
      }
    }
  }

