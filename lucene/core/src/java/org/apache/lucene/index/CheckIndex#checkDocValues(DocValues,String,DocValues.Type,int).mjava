  /** Helper method to verify values (either docvalues or norms), also checking
   *  type and size against fieldinfos/segmentinfo
   */
  private void checkDocValues(DocValues docValues, String fieldName, DocValues.Type expectedType, int expectedDocs) throws IOException {
    if (docValues == null) {
      throw new RuntimeException("field: " + fieldName + " omits docvalues but should have them!");
    }
    DocValues.Type type = docValues.getType();
    if (type != expectedType) {
      throw new RuntimeException("field: " + fieldName + " has type: " + type + " but fieldInfos says:" + expectedType);
    }
    final Source values = docValues.getDirectSource();
    int size = docValues.getValueSize();
    for (int i = 0; i < expectedDocs; i++) {
      switch (type) {
      case BYTES_FIXED_SORTED:
      case BYTES_VAR_SORTED:
      case BYTES_FIXED_DEREF:
      case BYTES_FIXED_STRAIGHT:
      case BYTES_VAR_DEREF:
      case BYTES_VAR_STRAIGHT:
        BytesRef bytes = new BytesRef();
        values.getBytes(i, bytes);
        if (size != -1 && size != bytes.length) {
          throw new RuntimeException("field: " + fieldName + " returned wrongly sized bytes, was: " + bytes.length + " should be: " + size);
        }
        break;
      case FLOAT_32:
        assert size == 4;
        values.getFloat(i);
        break;
      case FLOAT_64:
        assert size == 8;
        values.getFloat(i);
        break;
      case VAR_INTS:
        assert size == -1;
        values.getInt(i);
        break;
      case FIXED_INTS_16:
        assert size == 2;
        values.getInt(i);
        break;
      case FIXED_INTS_32:
        assert size == 4;
        values.getInt(i);
        break;
      case FIXED_INTS_64:
        assert size == 8;
        values.getInt(i);
        break;
      case FIXED_INTS_8:
        assert size == 1;
        values.getInt(i);
        break;
      default:
        throw new IllegalArgumentException("Field: " + fieldName
                    + " - no such DocValues type: " + type);
      }
    }
    if (type == DocValues.Type.BYTES_FIXED_SORTED || type == DocValues.Type.BYTES_VAR_SORTED) {
      // check sorted bytes
      SortedSource sortedValues = values.asSortedSource();
      Comparator<BytesRef> comparator = sortedValues.getComparator();
      int lastOrd = -1;
      BytesRef lastBytes = new BytesRef();
      for (int i = 0; i < expectedDocs; i++) {
        int ord = sortedValues.ord(i);
        if (ord < 0 || ord > expectedDocs) {
          throw new RuntimeException("field: " + fieldName + " ord is out of bounds: " + ord);
        }
        BytesRef bytes = new BytesRef();
        sortedValues.getByOrd(ord, bytes);
        if (lastOrd != -1) {
          int ordComp = Integer.signum(new Integer(ord).compareTo(new Integer(lastOrd)));
          int bytesComp = Integer.signum(comparator.compare(bytes, lastBytes));
          if (ordComp != bytesComp) {
            throw new RuntimeException("field: " + fieldName + " ord comparison is wrong: " + ordComp + " comparator claims: " + bytesComp);
          }
        }
        lastOrd = ord;
        lastBytes = bytes;
      }
    }
  }

