  /**
   * Try to wrap a given field comparator to add to it a functionality to skip over non-competitive docs.
   * If for the given comparator the skip functionality is not implemented, return the comparator itself.
   * @param comparator – comparator to wrap
   * @param reverse – if this sort is reverse
   * @param singleSort – true if this sort is based on a single field and there are no other sort fields for tie breaking
   * @return comparator wrapped as a filtering comparator or the original comparator if the filtering functionality
   * is not implemented for it
   */
  public static FieldComparator<?> wrapToFilteringComparator(FieldComparator<?> comparator, boolean reverse, boolean singleSort) {
    Class<?> comparatorClass = comparator.getClass();
    if (comparatorClass == FieldComparator.LongComparator.class){
      return new FilteringNumericComparator<>((FieldComparator.LongComparator) comparator, reverse, singleSort);
    }
    if (comparatorClass == FieldComparator.IntComparator.class){
      return new FilteringNumericComparator<>((FieldComparator.IntComparator) comparator, reverse, singleSort);
    }
    if (comparatorClass == FieldComparator.DoubleComparator.class){
      return new FilteringNumericComparator<>((FieldComparator.DoubleComparator) comparator, reverse, singleSort);
    }
    if (comparatorClass == FieldComparator.FloatComparator.class){
      return new FilteringNumericComparator<>((FieldComparator.FloatComparator) comparator, reverse, singleSort);
    }
    return comparator;
  }

