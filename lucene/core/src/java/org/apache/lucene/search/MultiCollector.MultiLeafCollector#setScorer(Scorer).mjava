    @Override
    public void setScorer(Scorer scorer) throws IOException {
      if (cacheScores) {
        scorer = new ScoreCachingWrappingScorer(scorer);
      }
      scorer = new FilterScorer(scorer) {
        @Override
        public void setMinCompetitiveScore(float minScore) {
          // Ignore calls to setMinCompetitiveScore so that if we wrap two
          // collectors and one of them wants to skip low-scoring hits, then
          // the other collector still sees all hits. We could try to reconcile
          // min scores and take the maximum min score across collectors, but
          // this is very unlikely to be helpful in practice.
        }
        @Override
        public float getMaxScore(int upTo) throws IOException {
          return in.getMaxScore(upTo);
        }
      };
      for (int i = 0; i < numCollectors; ++i) {
        final LeafCollector c = collectors[i];
        c.setScorer(scorer);
      }
    }

