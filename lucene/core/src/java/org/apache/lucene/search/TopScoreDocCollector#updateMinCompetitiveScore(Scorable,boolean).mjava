  protected void updateMinCompetitiveScore(Scorable scorer, boolean checkQueue) throws IOException {
    if (hitsThresholdChecker.isThresholdReached()) {
      boolean hasChanged = false;
      if (checkQueue && isQueueFull()) {
        // since we tie-break on doc id and collect in doc id order, we can require
        // the next float
        float localMinScore = Math.nextUp(pqTop.score);
        if (localMinScore > minCompetitiveScore) {
          hasChanged = true;
          minCompetitiveScore = localMinScore;
          if (bottomValueChecker != null) {
            // we don't use the next float here since we register a minimum value
            // for other segments that might have smaller doc ids
            bottomValueChecker.updateThreadLocalBottomValue(pqTop.score);
          }
        }
      }

      // Global bottom can only be greater than or equal to the local bottom score
      // The updating of global bottom score for this hit before getting here should
      // ensure that
      if (bottomValueChecker != null) {
        float globalMinScore = bottomValueChecker.getBottomValue();
        if (globalMinScore > minCompetitiveScore) {
          assert isQueueFull() == false || bottomValueChecker.getBottomValue() > Math.nextUp(pqTop.score);
          hasChanged = true;
          minCompetitiveScore = bottomValueChecker.getBottomValue();
        }
      }

      if (hasChanged) {
        scorer.setMinCompetitiveScore(minCompetitiveScore);
        totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;
      }
    }
  }

