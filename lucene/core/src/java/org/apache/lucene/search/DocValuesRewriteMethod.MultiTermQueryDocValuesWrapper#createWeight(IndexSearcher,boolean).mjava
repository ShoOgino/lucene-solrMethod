    @Override
    public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
      return new ConstantScoreWeight(this) {
        @Override
        Scorer scorer(LeafReaderContext context, Bits acceptDocs, float score) throws IOException {
          final SortedSetDocValues fcsi = DocValues.getSortedSet(context.reader(), query.field);
          TermsEnum termsEnum = query.getTermsEnum(new Terms() {
            
            @Override
            public TermsEnum iterator() {
              return fcsi.termsEnum();
            }

            @Override
            public long getSumTotalTermFreq() {
              return -1;
            }

            @Override
            public long getSumDocFreq() {
              return -1;
            }

            @Override
            public int getDocCount() {
              return -1;
            }

            @Override
            public long size() {
              return -1;
            }

            @Override
            public boolean hasFreqs() {
              return false;
            }

            @Override
            public boolean hasOffsets() {
              return false;
            }

            @Override
            public boolean hasPositions() {
              return false;
            }
            
            @Override
            public boolean hasPayloads() {
              return false;
            }
          });
          
          assert termsEnum != null;
          if (termsEnum.next() == null) {
            // no matching terms
            return null;
          }
          // fill into a bitset
          // Cannot use FixedBitSet because we require long index (ord):
          final LongBitSet termSet = new LongBitSet(fcsi.getValueCount());
          do {
            long ord = termsEnum.ord();
            if (ord >= 0) {
              termSet.set(ord);
            }
          } while (termsEnum.next() != null);
          
          final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());
          final TwoPhaseIterator twoPhaseIterator = new TwoPhaseIterator(approximation) {
            @Override
            public boolean matches() throws IOException {
              final int doc = approximation.docID();
              if (acceptDocs != null && acceptDocs.get(doc) == false) {
                return false;
              }
              fcsi.setDocument(doc);
              for (long ord = fcsi.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = fcsi.nextOrd()) {
                if (termSet.get(ord)) {
                  return true;
                }
              }
              return false;
            }
          };
          final DocIdSetIterator disi = TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator);
          return new Scorer(this) {

            @Override
            public TwoPhaseIterator asTwoPhaseIterator() {
              return twoPhaseIterator;
            }

            @Override
            public float score() throws IOException {
              return score;
            }

            @Override
            public int freq() throws IOException {
              return 1;
            }

            @Override
            public int docID() {
              return disi.docID();
            }

            @Override
            public int nextDoc() throws IOException {
              return disi.nextDoc();
            }

            @Override
            public int advance(int target) throws IOException {
              return disi.advance(target);
            }

            @Override
            public long cost() {
              return disi.cost();
            }

          };
        }
      };
    }

