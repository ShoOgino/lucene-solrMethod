    @Override
    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
      docBase = context.docBase;
      final int afterDoc = after.doc - docBase;
      return new MultiComparatorLeafCollector(queue.getComparators(context), queue.getReverseMul(), mayNeedScoresTwice) {

        @Override
        public void collect(int doc) throws IOException {
          //System.out.println("  collect doc=" + doc);

          totalHits++;

          float score = Float.NaN;
          if (trackMaxScore) {
            score = scorer.score();
            if (score > maxScore) {
              maxScore = score;
            }
          }

          if (queueFull) {
            // Fastmatch: return if this hit is no better than
            // the worst hit currently in the queue:
            final int cmp = compareBottom(doc);
            if (cmp <= 0) {
              // not competitive since documents are visited in doc id order
              return;
            }
          }

          final int topCmp = compareTop(doc);
          if (topCmp > 0 || (topCmp == 0 && doc <= afterDoc)) {
            // Already collected on a previous page
            return;
          }

          if (queueFull) {
            // This hit is competitive - replace bottom element in queue & adjustTop
            copy(bottom.slot, doc);

            // Compute score only if it is competitive.
            if (trackDocScores && !trackMaxScore) {
              score = scorer.score();
            }
            updateBottom(doc, score);

            setBottom(bottom.slot);
          } else {
            collectedHits++;

            // Startup transient: queue hasn't gathered numHits yet
            final int slot = collectedHits - 1;
            //System.out.println("    slot=" + slot);
            // Copy hit into queue
            copy(slot, doc);

            // Compute score only if it is competitive.
            if (trackDocScores && !trackMaxScore) {
              score = scorer.score();
            }
            bottom = pq.add(new Entry(slot, docBase + doc, score));
            queueFull = collectedHits == numHits;
            if (queueFull) {
              setBottom(bottom.slot);
            }
          }
        }
      };
    }

