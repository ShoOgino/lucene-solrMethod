    @Override
    public DocIdSet getDocIdSet(final AtomicReaderContext context, final Bits acceptDocs) throws IOException {
      int loc = Arrays.binarySearch(docIDs, context.docBase);
      if (loc < 0) {
        loc = -loc-1;
      }

      final int startLoc = loc;
      final int endDoc = context.docBase + context.reader().maxDoc();

      return new DocIdSet() {

        int pos = startLoc;

        @Override
        public DocIdSetIterator iterator() throws IOException {
          return new DocIdSetIterator() {

            int docID;

            @Override
            public int docID() {
              return docID;
            }

            @Override
            public int nextDoc() {
              if (pos == docIDs.length) {
                return NO_MORE_DOCS;
              }
              int docID = docIDs[pos];
              if (docID >= endDoc) {
                return NO_MORE_DOCS;
              }
              pos++;
              assert acceptDocs == null || acceptDocs.get(docID-context.docBase);
              return docID-context.docBase;
            }

            @Override
            public long cost() {
              // NOTE: not quite right, since this is cost
              // across all segments, and we are supposed to
              // return cost for just this segment:
              return docIDs.length;
            }

            @Override
            public int advance(int target) {
              // TODO: this is a full binary search; we
              // could optimize (a bit) by setting lower
              // bound to current pos instead:
              int loc = Arrays.binarySearch(docIDs, target + context.docBase);
              if (loc < 0) {
                loc = -loc-1;
              }
              pos = loc;
              return nextDoc();
            }
          };
        }
      };
    }

