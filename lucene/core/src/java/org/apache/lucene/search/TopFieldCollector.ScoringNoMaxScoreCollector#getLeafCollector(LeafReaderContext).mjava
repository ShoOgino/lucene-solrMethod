    @Override
    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {
      docBase = context.docBase;

      final LeafFieldComparator[] comparators = queue.getComparators(context);
      final int[] reverseMul = queue.getReverseMul();

      if (comparators.length == 1) {
        return new OneComparatorLeafCollector(comparators[0], reverseMul[0]) {

          @Override
          public void collect(int doc) throws IOException {
            ++totalHits;
            if (queueFull) {
              if ((reverseMul * comparator.compareBottom(doc)) <= 0) {
                // since docs are visited in doc Id order, if compare is 0, it means
                // this document is largest than anything else in the queue, and
                // therefore not competitive.
                return;
              }

              // Compute the score only if the hit is competitive.
              final float score = scorer.score();

              // This hit is competitive - replace bottom element in queue & adjustTop
              comparator.copy(bottom.slot, doc);
              updateBottom(doc, score);
              comparator.setBottom(bottom.slot);
            } else {
              // Compute the score only if the hit is competitive.
              final float score = scorer.score();

              // Startup transient: queue hasn't gathered numHits yet
              final int slot = totalHits - 1;
              // Copy hit into queue
              comparator.copy(slot, doc);
              add(slot, doc, score);
              if (queueFull) {
                comparator.setBottom(bottom.slot);
              }
            }
          }

        };
      } else {
        return new MultiComparatorLeafCollector(comparators, reverseMul) {

          @Override
          public void collect(int doc) throws IOException {
            ++totalHits;
            if (queueFull) {
              if ((compareBottom(doc)) <= 0) {
                // since docs are visited in doc Id order, if compare is 0, it means
                // this document is largest than anything else in the queue, and
                // therefore not competitive.
                return;
              }

              // Compute the score only if the hit is competitive.
              final float score = scorer.score();

              // This hit is competitive - replace bottom element in queue & adjustTop
              copy(bottom.slot, doc);
              updateBottom(doc, score);
              setBottom(bottom.slot);
            } else {
              // Compute the score only if the hit is competitive.
              final float score = scorer.score();

              // Startup transient: queue hasn't gathered numHits yet
              final int slot = totalHits - 1;
              // Copy hit into queue
              copy(slot, doc);
              add(slot, doc, score);
              if (queueFull) {
                setBottom(bottom.slot);
              }
            }
          }

        };
      }
    }

