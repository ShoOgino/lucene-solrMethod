  /** Returns a new TopDocs, containing topN results across
   *  the provided TopDocs, sorting by the specified {@link
   *  Sort}.  Each of the TopDocs must have been sorted by
   *  the same Sort, and sort field values must have been
   *  filled (ie, <code>fillFields=true</code> must be
   *  passed to {@link
   *  TopFieldCollector#create}.
   *
   * <p>Pass sort=null to merge sort by score descending.
   *
   * @lucene.experimental */
  public static TopDocs merge(Sort sort, int topN, TopDocs[] shardHits) throws IOException {

    final PriorityQueue<ShardRef> queue;
    if (sort == null) {
      queue = new ScoreMergeSortQueue(shardHits);
    } else {
      queue = new MergeSortQueue(sort, shardHits);
    }

    int totalHitCount = 0;
    int availHitCount = 0;
    float maxScore = Float.MIN_VALUE;
    for(int shardIDX=0;shardIDX<shardHits.length;shardIDX++) {
      final TopDocs shard = shardHits[shardIDX];
      // totalHits can be non-zero even if no hits were
      // collected, when searchAfter was used:
      totalHitCount += shard.totalHits;
      if (shard.scoreDocs != null && shard.scoreDocs.length > 0) {
        availHitCount += shard.scoreDocs.length;
        queue.add(new ShardRef(shardIDX));
        maxScore = Math.max(maxScore, shard.getMaxScore());
        //System.out.println("  maxScore now " + maxScore + " vs " + shard.getMaxScore());
      }
    }

    if (availHitCount == 0) {
      maxScore = Float.NaN;
    }

    final ScoreDoc[] hits = new ScoreDoc[Math.min(topN, availHitCount)];

    int hitUpto = 0;
    while(hitUpto < hits.length) {
      assert queue.size() > 0;
      ShardRef ref = queue.pop();
      final ScoreDoc hit = shardHits[ref.shardIndex].scoreDocs[ref.hitIndex++];
      hit.shardIndex = ref.shardIndex;
      hits[hitUpto] = hit;

      //System.out.println("  hitUpto=" + hitUpto);
      //System.out.println("    doc=" + hits[hitUpto].doc + " score=" + hits[hitUpto].score);

      hitUpto++;

      if (ref.hitIndex < shardHits[ref.shardIndex].scoreDocs.length) {
        // Not done with this these TopDocs yet:
        queue.add(ref);
      }
    }

    if (sort == null) {
      return new TopDocs(totalHitCount, hits, maxScore);
    } else {
      return new TopFieldDocs(totalHitCount, hits, sort.getSort(), maxScore);
    }
  }

