  @Override
  public Query rewrite(IndexReader reader) throws IOException {
    if (minNrShouldMatch == 0 && clauses.size() == 1) {                    // optimize 1-clause queries
      BooleanClause c = clauses.get(0);
      if (!c.isProhibited()) {  // just return clause

        Query query = c.getQuery().rewrite(reader);    // rewrite first

        if (c.isScoring()) {
          if (getBoost() != 1.0f) {                 // incorporate boost
            if (query == c.getQuery()) {                   // if rewrite was no-op
              query = query.clone();         // then clone before boost
            }
            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be
            // written out. Therefore the rewritten Query's boost must incorporate both
            // the clause's boost, and the boost of the BooleanQuery itself
            query.setBoost(getBoost() * query.getBoost());
          }
        } else {
          // our single clause is a filter
          if (query.getBoost() != 0f) {
            query = query.clone();
            query.setBoost(0);
          }
        }

        return query;
      }
    }

    BooleanQuery clone = null;                    // recursively rewrite
    for (int i = 0 ; i < clauses.size(); i++) {
      BooleanClause c = clauses.get(i);
      Query query = c.getQuery().rewrite(reader);
      if (query != c.getQuery()) {                     // clause rewrote: must clone
        if (clone == null) {
          // The BooleanQuery clone is lazily initialized so only initialize
          // it if a rewritten clause differs from the original clause (and hasn't been
          // initialized already).  If nothing differs, the clone isn't needlessly created
          clone = this.clone();
        }
        clone.clauses.set(i, new BooleanClause(query, c.getOccur()));
      }
    }
    if (clone != null) {
      return clone;                               // some clauses rewrote
    } else {
      return this;                                // no clauses rewrote
    }
  }

