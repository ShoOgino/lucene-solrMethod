  @Override
  public Query rewrite(IndexReader reader) throws IOException {
    if (minimumNumberShouldMatch == 0 && clauses.size() == 1) {// optimize 1-clause queries
      BooleanClause c = clauses.get(0);
      if (!c.isProhibited()) {  // just return clause

        Query query = c.getQuery().rewrite(reader);    // rewrite first

        if (c.isScoring()) {
          if (getBoost() != 1.0f) {                 // incorporate boost
            if (query == c.getQuery()) {                   // if rewrite was no-op
              query = query.clone();         // then clone before boost
            }
            // Since the BooleanQuery only has 1 clause, the BooleanQuery will be
            // written out. Therefore the rewritten Query's boost must incorporate both
            // the clause's boost, and the boost of the BooleanQuery itself
            query.setBoost(getBoost() * query.getBoost());
          }
        } else {
          // our single clause is a filter
          query = new ConstantScoreQuery(query);
          query.setBoost(0);
        }

        return query;
      }
    }

    BooleanQuery.Builder builder = new BooleanQuery.Builder();
    builder.setDisableCoord(isCoordDisabled());
    builder.setMinimumNumberShouldMatch(getMinimumNumberShouldMatch());
    boolean actuallyRewritten = false;
    for (BooleanClause clause : this) {
      Query query = clause.getQuery();
      Query rewritten = query.rewrite(reader);
      if (rewritten != query) {
        actuallyRewritten = true;
      }
      builder.add(rewritten, clause.getOccur());
    }
    if (actuallyRewritten) {
      BooleanQuery rewritten = builder.build();
      rewritten.setBoost(getBoost());
      return rewritten;
    }
    return super.rewrite(reader);
  }

