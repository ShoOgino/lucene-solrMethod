    @Override
    public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {
      
      // NOTE: this is messy ... we need it in cases where a single vistor (us) is shared across multiple leaf readers
      // (e.g. SlowCompositeReaderWrapper), in which case we need to reset our iterator to re-start the merge sort.  Maybe we should instead
      // add an explicit .start() to IntersectVisitor, and clarify the semantics that in the 1D case all cells will be visited in order?
      if (StringHelper.compare(bytesPerDim, lastMaxPackedValue, 0, minPackedValue, 0) > 0) {    
        resetIterator();
      }
      System.arraycopy(maxPackedValue, 0, lastMaxPackedValue, 0, bytesPerDim);

      while (nextQueryPoint != null) {
        scratch.bytes = minPackedValue;
        int cmpMin = nextQueryPoint.compareTo(scratch);
        if (cmpMin < 0) {
          // query point is before the start of this cell
          nextQueryPoint = iterator.next();
          continue;
        }
        scratch.bytes = maxPackedValue;
        int cmpMax = nextQueryPoint.compareTo(scratch);
        if (cmpMax > 0) {
          // query point is after the end of this cell
          return Relation.CELL_OUTSIDE_QUERY;
        }

        if (cmpMin == 0 && cmpMax == 0) {
          // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,
          // which can easily happen if many (> 1024) docs share this one value
          return Relation.CELL_INSIDE_QUERY;
        } else {
          return Relation.CELL_CROSSES_QUERY;
        }
      }

      // We exhausted all points in the query:
      return Relation.CELL_OUTSIDE_QUERY;
    }

