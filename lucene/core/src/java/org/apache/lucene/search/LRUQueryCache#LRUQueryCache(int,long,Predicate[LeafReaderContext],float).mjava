  /**
   * Expert: Create a new instance that will cache at most <code>maxSize</code>
   * queries with at most <code>maxRamBytesUsed</code> bytes of memory, only on
   * leaves that satisfy {@code leavesToCache}. Also, only clauses whose cost is
   * no more than {@code maxCostFactor} times the cost of the top-level query
   * will be cached in order to not slow down queries too much due to caching.
   * Pass {@link Float#POSITIVE_INFINITY} to cache regardless of costs.
   */
  public LRUQueryCache(int maxSize, long maxRamBytesUsed,
      Predicate<LeafReaderContext> leavesToCache,
      float maxCostFactor) {
    this.maxSize = maxSize;
    this.maxRamBytesUsed = maxRamBytesUsed;
    this.leavesToCache = leavesToCache;
    uniqueQueries = new LinkedHashMap<>(16, 0.75f, true);
    mostRecentlyUsedQueries = uniqueQueries.keySet();
    cache = new IdentityHashMap<>();
    lock = new ReentrantLock();
    ramBytesUsed = 0;
    if (maxCostFactor < 1) {
      throw new IllegalArgumentException("maxCostFactor must be no less than 1, got " + maxCostFactor);
    }
    this.maxCostFactor = maxCostFactor;
  }

