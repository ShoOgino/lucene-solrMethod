    @Override
    protected Object createValue(AtomicReader reader, CacheKey key, boolean setDocsWithField)
        throws IOException {

      NumericDocValues valuesIn = reader.getNumericDocValues(key.field);
      if (valuesIn != null) {
        final NumericDocValues ramInstance = valuesIn.newRAMInstance();
        return new Floats() {
          @Override
          public float get(int docID) {
            return Float.intBitsToFloat((int) ramInstance.get(docID));
          }
        };
        // nocommit should we throw exc if parser isn't
        // null?  if setDocsWithField is true?
      } else {
        int maxDoc = reader.maxDoc();
        final float[] values;
        final FloatParser parser = (FloatParser) key.custom;
        if (parser == null) {
          // Confusing: must delegate to wrapper (vs simply
          // setting parser =
          // DEFAULT_FLOAT_PARSER/NUMERIC_UTILS_FLOAT_PARSER) so
          // cache key includes
          // DEFAULT_FLOAT_PARSER/NUMERIC_UTILS_FLOAT_PARSER:
          try {
            return wrapper.getFloats(reader, key.field, DEFAULT_FLOAT_PARSER, setDocsWithField);
          } catch (NumberFormatException ne) {
            return wrapper.getFloats(reader, key.field, NUMERIC_UTILS_FLOAT_PARSER, setDocsWithField);
          }
        }

        // nocommit how to avoid double alloc in numeric field
        // case ...
        values = new float[reader.maxDoc()];

        Uninvert u = new Uninvert() {
            private float currentValue;

            @Override
            public void visitTerm(BytesRef term) {
              currentValue = parser.parseFloat(term);
            }

            @Override
            public void visitDoc(int docID) {
              values[docID] = currentValue;
            }
          };

        u.uninvert(reader, key.field, setDocsWithField);

        if (setDocsWithField) {
          wrapper.setDocsWithField(reader, key.field, u.docsWithField);
        }

        return new FloatsFromArray(values);
      }
    }

