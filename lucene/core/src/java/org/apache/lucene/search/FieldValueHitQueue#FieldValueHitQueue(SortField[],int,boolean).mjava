  // prevent instantiation and extension.
  private FieldValueHitQueue(SortField[] fields, int size, boolean filterNonCompetitiveDocs) {
    super(size);
    // When we get here, fields.length is guaranteed to be > 0, therefore no
    // need to check it again.
    
    // All these are required by this class's API - need to return arrays.
    // Therefore even in the case of a single comparator, create an array
    // anyway.
    this.fields = fields;
    int numComparators = fields.length;
    comparators = new FieldComparator<?>[numComparators];
    reverseMul = new int[numComparators];
    for (int i = 0; i < numComparators; ++i) {
      SortField field = fields[i];
      reverseMul[i] = field.reverse ? -1 : 1;
      if (i == 0 && filterNonCompetitiveDocs) {
        // try to rewrite the 1st comparator to the comparator that can skip non-competitive documents
        // skipping functionality is beneficial only for the 1st comparator
        comparators[i] = FilteringFieldComparator.wrapToFilteringComparator(field.getComparator(size, i),
            field.reverse, numComparators == 1);
      } else {
        comparators[i] = field.getComparator(size, i);
      }
    }
  }

