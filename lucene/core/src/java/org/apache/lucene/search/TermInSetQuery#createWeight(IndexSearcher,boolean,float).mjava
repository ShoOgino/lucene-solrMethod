  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores, float boost) throws IOException {
    return new ConstantScoreWeight(this, boost) {

      @Override
      public void extractTerms(Set<Term> terms) {
        // no-op
        // This query is for abuse cases when the number of terms is too high to
        // run efficiently as a BooleanQuery. So likewise we hide its terms in
        // order to protect highlighters
      }

      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        final LeafReader reader = context.reader();

        Terms terms = reader.terms(field);
        if (terms == null) {
          return null;
        }
        TermsEnum termsEnum = terms.iterator();
        PostingsEnum docs = null;
        TermIterator iterator = termData.iterator();

        // Here we partition postings based on cost: longer ones will be consumed
        // lazily while shorter ones are consumed eagerly into a bitset. Compared to
        // putting everything into a bitset, this should help skip over unnecessary doc
        // ids in the longer postings lists. This should be especially useful if
        // document frequencies have a zipfian distribution.
        final PriorityQueue<PostingsEnum> longestPostingsLists = new PriorityQueue<PostingsEnum>(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD) {
          @Override
          protected boolean lessThan(PostingsEnum a, PostingsEnum b) {
            return a.cost() < b.cost();
          }
        };
        DocIdSetBuilder shortestPostingsLists = null;

        for (BytesRef term = iterator.next(); term != null; term = iterator.next()) {
          assert field.equals(iterator.field());
          if (termsEnum.seekExact(term)) {
            docs = termsEnum.postings(docs, PostingsEnum.NONE);
            docs = longestPostingsLists.insertWithOverflow(docs);
            if (docs != null) { // the pq is full
              if (shortestPostingsLists == null) {
                shortestPostingsLists = new DocIdSetBuilder(reader.maxDoc());
              }
              shortestPostingsLists.add(docs);
            }
          }
        }

        final int numClauses = longestPostingsLists.size() + (shortestPostingsLists == null ? 0 : 1);
        if (numClauses == 0) {
          return null;
        }

        DisiPriorityQueue queue = new DisiPriorityQueue(numClauses);
        for (PostingsEnum postings : longestPostingsLists) {
          queue.add(new DisiWrapper(postings));
        }
        if (shortestPostingsLists != null) {
          queue.add(new DisiWrapper(shortestPostingsLists.build().iterator()));
        }
        final DocIdSetIterator disi = new DisjunctionDISIApproximation(queue);
        return new ConstantScoreScorer(this, boost, disi);
      }
    };
  }

