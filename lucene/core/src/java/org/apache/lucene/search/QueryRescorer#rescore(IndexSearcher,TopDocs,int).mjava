  @Override
  public TopDocs rescore(IndexSearcher searcher, TopDocs topDocs, int topN) throws IOException {
    int[] docIDs = new int[topDocs.scoreDocs.length];
    for(int i=0;i<docIDs.length;i++) {
      docIDs[i] = topDocs.scoreDocs[i].doc;
    }

    TopDocs topDocs2 = searcher.search(query, new OnlyDocIDsFilter(docIDs), topDocs.scoreDocs.length);

    // TODO: we could save small young GC cost here if we
    // cloned the incoming ScoreDoc[], sorted that by doc,
    // passed that to OnlyDocIDsFilter, sorted 2nd pass
    // TopDocs by doc, did a merge sort to combine the
    // scores, and finally re-sorted by the combined score,
    // but that is sizable added code complexity for minor
    // GC savings:
    Map<Integer,Float> newScores = new HashMap<Integer,Float>();
    for(ScoreDoc sd : topDocs2.scoreDocs) {
      newScores.put(sd.doc, sd.score);
    }

    ScoreDoc[] newHits = new ScoreDoc[topDocs.scoreDocs.length];
    for(int i=0;i<topDocs.scoreDocs.length;i++) {
      ScoreDoc sd = topDocs.scoreDocs[i];
      Float newScore = newScores.get(sd.doc);
      float combinedScore;
      if (newScore == null) {
        combinedScore = combine(sd.score, false, 0.0f);
      } else {
        combinedScore = combine(sd.score, true, newScore.floatValue());
      }
      newHits[i] = new ScoreDoc(sd.doc, combinedScore);
    }

    // TODO: we should do a partial sort (of only topN)
    // instead, but typically the number of hits is
    // smallish:
    Arrays.sort(newHits,
                new Comparator<ScoreDoc>() {
                  @Override
                  public int compare(ScoreDoc a, ScoreDoc b) {
                    // Sort by score descending, then docID ascending:
                    if (a.score > b.score) {
                      return -1;
                    } else if (a.score < b.score) {
                      return 1;
                    } else {
                      // This subtraction can't overflow int
                      // because docIDs are >= 0:
                      return a.doc - b.doc;
                    }
                  }
                });

    if (topN < newHits.length) {
      ScoreDoc[] subset = new ScoreDoc[topN];
      System.arraycopy(newHits, 0, subset, 0, topN);
      newHits = subset;
    }

    return new TopDocs(topDocs.totalHits, newHits, newHits[0].score);
  }

