    @Override
    protected Object createValue(AtomicReader reader, CacheKey key, boolean setDocsWithField /* ignored */)
        throws IOException {

      BinaryDocValues valuesIn = reader.getBinaryDocValues(key.field);
      if (valuesIn != null) {
        return valuesIn.newRAMInstance();
      } else {
        final int maxDoc = reader.maxDoc();
        Terms terms = reader.terms(key.field);

        final float acceptableOverheadRatio = ((Float) key.custom).floatValue();

        final int termCountHardLimit = maxDoc;

        // Holds the actual term data, expanded.
        final PagedBytes bytes = new PagedBytes(15);

        int startBPV;

        if (terms != null) {
          // Try for coarse estimate for number of bits; this
          // should be an underestimate most of the time, which
          // is fine -- GrowableWriter will reallocate as needed
          long numUniqueTerms = terms.size();
          if (numUniqueTerms != -1L) {
            if (numUniqueTerms > termCountHardLimit) {
              numUniqueTerms = termCountHardLimit;
            }
            startBPV = PackedInts.bitsRequired(numUniqueTerms*4);
          } else {
            startBPV = 1;
          }
        } else {
          startBPV = 1;
        }

        final GrowableWriter docToOffset = new GrowableWriter(startBPV, maxDoc, acceptableOverheadRatio);
      
        // pointer==0 means not set
        bytes.copyUsingLengthPrefix(new BytesRef());

        int sameLength = -2;
        int maxLength = -1;

        if (terms != null) {
          int termCount = 0;
          final TermsEnum termsEnum = terms.iterator(null);
          DocsEnum docs = null;
          while(true) {
            if (termCount++ == termCountHardLimit) {
              // app is misusing the API (there is more than
              // one term per doc); in this case we make best
              // effort to load what we can (see LUCENE-2142)
              break;
            }

            final BytesRef term = termsEnum.next();
            if (term == null) {
              break;
            }
            if (sameLength == -2) {
              sameLength = term.length;
            } else if (sameLength != term.length) {
              sameLength = -1;
            }
            maxLength = Math.max(maxLength, term.length);
            final long pointer = bytes.copyUsingLengthPrefix(term);
            docs = termsEnum.docs(null, docs, 0);
            while (true) {
              final int docID = docs.nextDoc();
              if (docID == DocIdSetIterator.NO_MORE_DOCS) {
                break;
              }
              docToOffset.set(docID, pointer);
            }
          }
        }

        // maybe an int-only impl?
        return new BinaryDocValuesImpl(bytes.freeze(true), docToOffset.getMutable(), maxLength, sameLength >= 0);
      }
    }

