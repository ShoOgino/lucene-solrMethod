  /**
   * You must call this, periodically, if you want that {@link #acquire()} will
   * return refreshed instances.
   * 
   * <p>
   * <b>Threads</b>: it's fine for more than one thread to call this at once.
   * Only the first thread will attempt the refresh; subsequent threads will see
   * that another thread is already handling refresh and will return
   * immediately. Note that this means if another thread is already refreshing
   * then subsequent threads will return right away without waiting for the
   * refresh to complete.
   * 
   * <p>
   * This method returns true if the reference was in fact refreshed, or if the
   * current reference has no pending changes.
   */
  public final boolean maybeRefresh() throws IOException {
    ensureOpen();
    // Ensure only 1 thread does reopen at once; other threads just return immediately:
    if (reopenLock.tryAcquire()) {
      try {
        final G reference = acquire();
        try {
          G newReference = refreshIfNeeded(reference);
          if (newReference != null) {
            assert newReference != reference : "refreshIfNeeded should return null if refresh wasn't needed";
            boolean success = false;
            try {
              swapReference(newReference);
              success = true;
            } finally {
              if (!success) {
                release(newReference);
              }
            }
          }
        } finally {
          release(reference);
        }
        return true;
      } finally {
        reopenLock.release();
      }
    } else {
      return false;
    }
  }

