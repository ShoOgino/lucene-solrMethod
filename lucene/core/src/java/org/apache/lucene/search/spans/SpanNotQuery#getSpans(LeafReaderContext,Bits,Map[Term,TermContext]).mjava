  @Override
  public Spans getSpans(final LeafReaderContext context, final Bits acceptDocs, final Map<Term,TermContext> termContexts) throws IOException {
    Spans includeSpans = include.getSpans(context, acceptDocs, termContexts);
    if (includeSpans == null) {
      return null;
    }

    Spans excludeSpans = exclude.getSpans(context, acceptDocs, termContexts);
    if (excludeSpans == null) {
      return includeSpans;
    }

    return new Spans() {
      private boolean moreInclude = true;
      private int includeStart = -1;
      private int includeEnd = -1;
      private boolean atFirstInCurrentDoc = false;

      private boolean moreExclude = excludeSpans.nextDoc() != NO_MORE_DOCS;
      private int excludeStart = moreExclude ? excludeSpans.nextStartPosition() : NO_MORE_POSITIONS;


      @Override
      public int nextDoc() throws IOException {
        if (moreInclude) {
          moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;
          if (moreInclude) {
            atFirstInCurrentDoc = true;
            includeStart = includeSpans.nextStartPosition();
            assert includeStart != NO_MORE_POSITIONS;
          }
        }
        toNextIncluded();
        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;
        return res;
      }

      private void toNextIncluded() throws IOException {
        while (moreInclude && moreExclude) {
          if (includeSpans.docID() > excludeSpans.docID()) {
            moreExclude = excludeSpans.advance(includeSpans.docID()) != NO_MORE_DOCS;
            if (moreExclude) {
              excludeStart = -1; // only use exclude positions at same doc
            }
          }
          if (excludeForwardInCurrentDocAndAtMatch()) {
            break; // at match.
          }

          // else intersected: keep scanning, to next doc if needed
          includeStart = includeSpans.nextStartPosition();
          if (includeStart == NO_MORE_POSITIONS) {
            moreInclude = includeSpans.nextDoc() != NO_MORE_DOCS;
            if (moreInclude) {
              atFirstInCurrentDoc = true;
              includeStart = includeSpans.nextStartPosition();
              assert includeStart != NO_MORE_POSITIONS;
            }
          }
        }
      }

      private boolean excludeForwardInCurrentDocAndAtMatch() throws IOException {
        assert moreInclude;
        assert includeStart != NO_MORE_POSITIONS;
        if (! moreExclude) {
          return true;
        }
        if (includeSpans.docID() != excludeSpans.docID()) {
          return true;
        }
        // at same doc
        if (excludeStart == -1) { // init exclude start position if needed
          excludeStart = excludeSpans.nextStartPosition();
          assert excludeStart != NO_MORE_POSITIONS;
        }
        while (excludeSpans.endPosition() <= includeStart - pre) {
          // exclude end position is before a possible exclusion
          excludeStart = excludeSpans.nextStartPosition();
          if (excludeStart == NO_MORE_POSITIONS) {
            return true; // no more exclude at current doc.
          }
        }
        // exclude end position far enough in current doc, check start position:
        boolean res = includeSpans.endPosition() + post <= excludeStart;
        return res;
      }

      @Override
      public int advance(int target) throws IOException {
        if (moreInclude) {
          assert target > includeSpans.docID() : "target="+target+", includeSpans.docID()="+includeSpans.docID();
          moreInclude = includeSpans.advance(target) != NO_MORE_DOCS;
          if (moreInclude) {
            atFirstInCurrentDoc = true;
            includeStart = includeSpans.nextStartPosition();
            assert includeStart != NO_MORE_POSITIONS;
          }
        }
        toNextIncluded();
        int res = moreInclude ? includeSpans.docID() : NO_MORE_DOCS;
        return res;
      }

      @Override
      public int docID() {
        int res = includeSpans.docID();
        return res;
      }

      @Override
      public int nextStartPosition() throws IOException {
        assert moreInclude;

        if (atFirstInCurrentDoc) {
          atFirstInCurrentDoc = false;
          assert includeStart != NO_MORE_POSITIONS;
          return includeStart;
        }

        includeStart = includeSpans.nextStartPosition();
        while ((includeStart != NO_MORE_POSITIONS)
            && (! excludeForwardInCurrentDocAndAtMatch()))
        {
          includeStart = includeSpans.nextStartPosition();
        }

        return includeStart;
      }

      @Override
      public int startPosition() {
        assert includeStart == includeSpans.startPosition();
        return atFirstInCurrentDoc ? -1 : includeStart;
      }

      @Override
      public int endPosition() {
        return atFirstInCurrentDoc ? -1 : includeSpans.endPosition();
      }

      @Override
      public Collection<byte[]> getPayload() throws IOException {
        ArrayList<byte[]> result = null;
        if (includeSpans.isPayloadAvailable()) {
          result = new ArrayList<>(includeSpans.getPayload());
        }
        return result;
      }

      @Override
      public boolean isPayloadAvailable() throws IOException {
        return includeSpans.isPayloadAvailable();
      }

      @Override
      public long cost() {
        return includeSpans.cost();
      }

      @Override
      public String toString() {
        return "spans(" + SpanNotQuery.this.toString() + ")";
      }
    };
  }

