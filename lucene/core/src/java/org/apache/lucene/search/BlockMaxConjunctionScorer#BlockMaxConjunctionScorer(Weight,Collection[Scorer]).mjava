  /** Create a new {@link BlockMaxConjunctionScorer} from scoring clauses. */
  BlockMaxConjunctionScorer(Weight weight, Collection<Scorer> scorersList) throws IOException {
    super(weight);
    this.scorers = scorersList.toArray(new Scorer[scorersList.size()]);
    for (Scorer scorer : scorers) {
      scorer.advanceShallow(0);
    }
    this.maxScorePropagator = new MaxScoreSumPropagator(scorersList);

    // Put scorers with the higher max scores first
    // We tie-break on cost
    Comparator<Scorer> comparator = (s1, s2) -> {
      int cmp;
      try {
        cmp = Float.compare(s2.getMaxScore(DocIdSetIterator.NO_MORE_DOCS), s1.getMaxScore(DocIdSetIterator.NO_MORE_DOCS));
      } catch (IOException e) {
        throw new RuntimeException(e);
      }
      if (cmp == 0) {
        cmp = Long.compare(s1.iterator().cost(), s2.iterator().cost());
      }
      return cmp;
    };
    Arrays.sort(this.scorers, comparator);
    minScores = new double[this.scorers.length];
  }

