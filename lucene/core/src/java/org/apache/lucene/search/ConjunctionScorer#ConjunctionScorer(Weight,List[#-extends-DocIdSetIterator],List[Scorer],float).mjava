  /** Create a new {@link ConjunctionScorer}, note that {@code scorers} must be a subset of {@code required}. */
  ConjunctionScorer(Weight weight, List<? extends DocIdSetIterator> required, List<Scorer> scorers, float coord) {
    super(weight);
    assert required.containsAll(scorers);
    this.coord = coord;
    this.docsAndFreqs = new DocsAndFreqs[required.size()];
    for (int i = 0; i < required.size(); ++i) {
      docsAndFreqs[i] = new DocsAndFreqs(required.get(i));
    }
    // Sort the array the first time to allow the least frequent DocsEnum to
    // lead the matching.
    ArrayUtil.timSort(docsAndFreqs, new Comparator<DocsAndFreqs>() {
      @Override
      public int compare(DocsAndFreqs o1, DocsAndFreqs o2) {
        return Long.compare(o1.cost, o2.cost);
      }
    });

    lead = docsAndFreqs[0]; // least frequent DocsEnum leads the intersection

    this.scorers = scorers.toArray(new Scorer[scorers.size()]);
  }

