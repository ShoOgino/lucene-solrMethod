  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
    final Weight weight = query.createWeight(searcher, needsScores);
    if (needsScores) {
      // our cache is not sufficient, we need scores too
      return weight;
    }
    policy.onUse(weight.getQuery());
    return new ConstantScoreWeight(weight.getQuery()) {
      @Override
      public void extractTerms(Set<Term> terms) {
        weight.extractTerms(terms);
      }

      @Override
      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
        final LeafReader reader = context.reader();
        final Object key = reader.getCoreCacheKey();

        DocIdSet docIdSet = cache.get(key);
        if (docIdSet != null) {
          hitCount++;
        } else if (policy.shouldCache(query, context)) {
          missCount++;
          final Scorer scorer = weight.scorer(context, null);
          if (scorer == null) {
            docIdSet = DocIdSet.EMPTY;
          } else {
            docIdSet = cacheImpl(scorer, context.reader());
          }
          cache.put(key, docIdSet);
        } else {
          return weight.scorer(context, acceptDocs);
        }

        assert docIdSet != null;
        if (docIdSet == DocIdSet.EMPTY) {
          return null;
        }
        final DocIdSetIterator disi = docIdSet.iterator();
        if (disi == null) {
          return null;
        }

        // We apply acceptDocs as an approximation
        if (acceptDocs == null) {
          return new ConstantScoreScorer(this, 0f, disi);
        } else {
          final TwoPhaseIterator twoPhaseView = new TwoPhaseIterator(disi) {

            @Override
            public boolean matches() throws IOException {
              final int doc = approximation.docID();
              return acceptDocs.get(doc);
            }

          };
          return new ConstantScoreScorer(this, 0f, twoPhaseView);
        }
      }
    };
  }

