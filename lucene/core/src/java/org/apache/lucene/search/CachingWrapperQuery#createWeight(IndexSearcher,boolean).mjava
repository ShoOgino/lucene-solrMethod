  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
    final Weight weight = query.createWeight(searcher, needsScores);
    if (needsScores) {
      // our cache is not sufficient, we need scores too
      return weight;
    }

    return new ConstantScoreWeight(weight.getQuery()) {

      final AtomicBoolean used = new AtomicBoolean(false);

      @Override
      public void extractTerms(Set<Term> terms) {
        weight.extractTerms(terms);
      }

      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        if (used.compareAndSet(false, true)) {
          policy.onUse(getQuery());
        }

        final LeafReader reader = context.reader();
        final Object key = reader.getCoreCacheKey();

        DocIdSet docIdSet = cache.get(key);
        if (docIdSet != null) {
          hitCount++;
        } else if (policy.shouldCache(query, context)) {
          missCount++;
          final Scorer scorer = weight.scorer(context);
          if (scorer == null) {
            docIdSet = DocIdSet.EMPTY;
          } else {
            docIdSet = cacheImpl(scorer, context.reader());
          }
          cache.put(key, docIdSet);
        } else {
          return weight.scorer(context);
        }

        assert docIdSet != null;
        if (docIdSet == DocIdSet.EMPTY) {
          return null;
        }
        final DocIdSetIterator disi = docIdSet.iterator();
        if (disi == null) {
          return null;
        }

        return new ConstantScoreScorer(this, 0f, disi);
      }
    };
  }

