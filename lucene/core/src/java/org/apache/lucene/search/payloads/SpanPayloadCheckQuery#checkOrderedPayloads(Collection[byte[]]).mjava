  /**
   * Check to see if the collected payloads match the required set.
   *
   * This is called for Near span queries which collect their sub spans
   * out-of-order, meaning that we can't rely on the order of payloads
   * in the collection
   *
   * @param candidate a collection of payloads from the current Spans
   * @return whether or not the payloads match
   */
  protected AcceptStatus checkOrderedPayloads(Collection<byte[]> candidate) {
    if (candidate.size() == payloadToMatch.size()){
      //TODO: check the byte arrays are the same
      Iterator<byte[]> toMatchIter = payloadToMatch.iterator();
      //check each of the byte arrays, in order
      //hmm, can't rely on order here
      for (byte[] candBytes : candidate) {
        //if one is a mismatch, then return false
        if (Arrays.equals(candBytes, toMatchIter.next()) == false){
          return AcceptStatus.NO;
        }
      }
      //we've verified all the bytes
      return AcceptStatus.YES;
    } else {
      return AcceptStatus.NO;
    }
  }

