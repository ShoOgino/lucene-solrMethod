    @Override
    protected Object createValue(AtomicReader reader, CacheKey key, boolean setDocsWithField)
        throws IOException {

      int maxDoc = reader.maxDoc();
      final short[] values;

      NumericDocValues valuesIn = reader.getNumericDocValues(key.field);
      if (valuesIn != null) {
        // nocommit should we throw exc if parser isn't
        // null?  if setDocsWithField is true?
        values = new short[maxDoc];
        for(int docID=0;docID<maxDoc;docID++) {
          values[docID] = (short) valuesIn.get(docID);
        }
      } else {
        final ShortParser parser = (ShortParser) key.custom;
        if (parser == null) {
          // Confusing: must delegate to wrapper (vs simply
          // setting parser = DEFAULT_SHORT_PARSER) so cache
          // key includes DEFAULT_SHORT_PARSER:
          return wrapper.getShorts(reader, key.field, DEFAULT_SHORT_PARSER, setDocsWithField);
        }

        values = new short[maxDoc];
        Uninvert u = new Uninvert() {
            private short currentValue;

            @Override
            public void visitTerm(BytesRef term) {
              currentValue = parser.parseShort(term);
            }

            @Override
            public void visitDoc(int docID) {
              values[docID] = currentValue;
            }
          };

        u.uninvert(reader, key.field, setDocsWithField);

        if (setDocsWithField) {
          wrapper.setDocsWithField(reader, key.field, u.docsWithField);
        }
      }
      return new ShortsFromArray(values);
    }

