    @Override
    public LeafCollector getLeafCollector(LeafReaderContext context)
        throws IOException {
      final int docBase = context.docBase;
      if (scoreDocsInOrder) {
        return new ScorerLeafCollector(scoreDocsInOrder) {

          @Override
          public void collect(int doc) throws IOException {
            float score = scorer.score();

            // This collector cannot handle these scores:
            assert score != Float.NEGATIVE_INFINITY;
            assert !Float.isNaN(score);

            totalHits++;
            if (score <= pqTop.score) {
              // Since docs are returned in-order (i.e., increasing doc Id), a document
              // with equal score to pqTop.score cannot compete since HitQueue favors
              // documents with lower doc Ids. Therefore reject those docs too.
              return;
            }
            pqTop.doc = doc + docBase;
            pqTop.score = score;
            pqTop = pq.updateTop();
          }

        };
      } else {
        return new ScorerLeafCollector(scoreDocsInOrder) {

          @Override
          public void collect(int doc) throws IOException {
            float score = scorer.score();

            // This collector cannot handle NaN
            assert !Float.isNaN(score);

            totalHits++;
            if (score < pqTop.score) {
              // Doesn't compete w/ bottom entry in queue
              return;
            }
            doc += docBase;
            if (score == pqTop.score && doc > pqTop.doc) {
              // Break tie in score by doc ID:
              return;
            }
            pqTop.doc = doc;
            pqTop.score = score;
            pqTop = pq.updateTop();
          }

        };
      }
    }

