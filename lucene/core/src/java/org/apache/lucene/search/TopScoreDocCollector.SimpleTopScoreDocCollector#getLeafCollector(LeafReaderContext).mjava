    @Override
    public LeafCollector getLeafCollector(LeafReaderContext context)
        throws IOException {
      final int docBase = context.docBase;
      return new ScorerLeafCollector() {

        private void updateMinCompetitiveScore() {
          // since we tie-break on doc id and collect in doc id order, we can require
          // the next float
          scorer.setMinCompetitiveScore(Math.nextUp(pqTop.score));
          totalHitsRelation = TotalHits.Relation.GREATER_THAN_OR_EQUAL_TO;
        }

        @Override
        public void setScorer(Scorable scorer) throws IOException {
          super.setScorer(scorer);
          if (totalHits >= totalHitsThreshold
              && pqTop != null
              && pqTop.score != Float.NEGATIVE_INFINITY) {
            updateMinCompetitiveScore();
          }
        }

        @Override
        public void collect(int doc) throws IOException {
          float score = scorer.score();

          // This collector relies on the fact that scorers produce positive values:
          assert score >= 0; // NOTE: false for NaN

          totalHits++;
          if (score <= pqTop.score) {
            if (totalHitsRelation == TotalHits.Relation.EQUAL_TO && totalHits >= totalHitsThreshold) {
              // we just reached totalHitsThreshold, we can start setting the min
              // competitive score now
              updateMinCompetitiveScore();
            }
            // Since docs are returned in-order (i.e., increasing doc Id), a document
            // with equal score to pqTop.score cannot compete since HitQueue favors
            // documents with lower doc Ids. Therefore reject those docs too.
            return;
          }
          pqTop.doc = doc + docBase;
          pqTop.score = score;
          pqTop = pq.updateTop();
          if (totalHits >= totalHitsThreshold && pqTop.score != Float.NEGATIVE_INFINITY) { // -Infinity is the score of sentinels
            updateMinCompetitiveScore();
          }
        }

      };
    }

