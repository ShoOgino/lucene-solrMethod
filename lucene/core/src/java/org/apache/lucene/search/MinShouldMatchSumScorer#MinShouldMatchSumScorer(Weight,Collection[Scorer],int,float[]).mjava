  MinShouldMatchSumScorer(Weight weight, Collection<Scorer> scorers, int minShouldMatch, float[] coord) {
    super(weight);

    if (minShouldMatch > scorers.size()) {
      throw new IllegalArgumentException("minShouldMatch should be <= the number of scorers");
    }
    if (minShouldMatch < 1) {
      throw new IllegalArgumentException("minShouldMatch should be >= 1");
    }

    this.minShouldMatch = minShouldMatch;
    this.coord = coord;
    this.doc = -1;

    head = new ScorerPriorityQueue(scorers.size() - minShouldMatch + 1);
    // there can be at most minShouldMatch - 1 scorers beyond the current position
    // otherwise we might be skipping over matching documents
    tail = new ScorerWrapper[minShouldMatch - 1];

    for (Scorer scorer : scorers) {
      addLead(new ScorerWrapper(scorer));
    }

    List<ChildScorer> children = new ArrayList<>();
    for (Scorer scorer : scorers) {
      children.add(new ChildScorer(scorer, "SHOULD"));
    }
    this.childScorers = Collections.unmodifiableCollection(children);
    this.cost = cost(scorers, minShouldMatch);
  }

