    @Override
    public Scorer scorer(LeafReaderContext context, Bits acceptDocs)
        throws IOException {
      // initially the user provided value,
      // but if minNrShouldMatch == optional.size(),
      // we will optimize and move these to required, making this 0
      int minShouldMatch = minNrShouldMatch;

      List<Scorer> required = new ArrayList<>();
      List<Scorer> prohibited = new ArrayList<>();
      List<Scorer> optional = new ArrayList<>();
      Iterator<BooleanClause> cIter = clauses.iterator();
      for (Weight w  : weights) {
        BooleanClause c =  cIter.next();
        Scorer subScorer = w.scorer(context, acceptDocs);
        if (subScorer == null) {
          if (c.isRequired()) {
            return null;
          }
        } else if (c.isRequired()) {
          required.add(subScorer);
        } else if (c.isProhibited()) {
          prohibited.add(subScorer);
        } else {
          optional.add(subScorer);
        }
      }
      
      // scorer simplifications:
      
      if (optional.size() == minShouldMatch) {
        // any optional clauses are in fact required
        required.addAll(optional);
        optional.clear();
        minShouldMatch = 0;
      }
      
      if (required.isEmpty() && optional.isEmpty()) {
        // no required and optional clauses.
        return null;
      } else if (optional.size() < minShouldMatch) {
        // either >1 req scorer, or there are 0 req scorers and at least 1
        // optional scorer. Therefore if there are not enough optional scorers
        // no documents will be matched by the query
        return null;
      }
      
      // three cases: conjunction, disjunction, or mix
      
      // pure conjunction
      if (optional.isEmpty()) {
        return excl(req(required, disableCoord), prohibited);
      }
      
      // pure disjunction
      if (required.isEmpty()) {
        return excl(opt(optional, minShouldMatch, disableCoord), prohibited);
      }
      
      // conjunction-disjunction mix:
      // we create the required and optional pieces with coord disabled, and then
      // combine the two: if minNrShouldMatch > 0, then it's a conjunction: because the
      // optional side must match. otherwise it's required + optional, factoring the
      // number of optional terms into the coord calculation
      
      Scorer req = excl(req(required, true), prohibited);
      Scorer opt = opt(optional, minShouldMatch, true);

      // TODO: clean this up: it's horrible
      if (disableCoord) {
        if (minShouldMatch > 0) {
          return new ConjunctionScorer(this, new Scorer[] { req, opt }, 1F);
        } else {
          return new ReqOptSumScorer(req, opt);          
        }
      } else if (optional.size() == 1) {
        if (minShouldMatch > 0) {
          return new ConjunctionScorer(this, new Scorer[] { req, opt }, coord(required.size()+1, maxCoord));
        } else {
          float coordReq = coord(required.size(), maxCoord);
          float coordBoth = coord(required.size() + 1, maxCoord);
          return new BooleanTopLevelScorers.ReqSingleOptScorer(req, opt, coordReq, coordBoth);
        }
      } else {
        if (minShouldMatch > 0) {
          return new BooleanTopLevelScorers.CoordinatingConjunctionScorer(this, coords(), req, required.size(), opt);
        } else {
          return new BooleanTopLevelScorers.ReqMultiOptScorer(req, opt, required.size(), coords()); 
        }
      }
    }

