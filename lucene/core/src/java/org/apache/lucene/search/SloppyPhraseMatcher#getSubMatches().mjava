  @Override
  MatchesIterator getSubMatches() throws IOException {
    int[][] submatches = new int[phrasePositions.length][3];
    for (PhrasePositions pp : phrasePositions) {
      if (pp.ord == leadOrd) {
        submatches[pp.ord][0] = leadPosition;
        submatches[pp.ord][1] = leadOffset;
        submatches[pp.ord][2] = leadEndOffset;
      }
      else {
        submatches[pp.ord][0] = pp.position + pp.offset;
        submatches[pp.ord][1] = pp.postings.startOffset();
        submatches[pp.ord][2] = pp.postings.endOffset();
      }
    }
    Arrays.sort(submatches, Comparator.comparingInt(a -> a[0]));
    return new MatchesIterator() {
      int upTo = -1;
      @Override
      public boolean next() throws IOException {
        upTo++;
        return upTo < submatches.length;
      }

      @Override
      public int startPosition() {
        return submatches[upTo][0];
      }

      @Override
      public int endPosition() {
        return submatches[upTo][0];
      }

      @Override
      public int startOffset() {
        return submatches[upTo][1];
      }

      @Override
      public int endOffset() {
        return submatches[upTo][2];
      }

      @Override
      public MatchesIterator getSubMatches() {
        return MatchesIterator.EMPTY_ITERATOR;
      }

      @Override
      public Object label() {
        return this;
      }
    };
  }

