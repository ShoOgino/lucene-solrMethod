  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {

    // We don't use RandomAccessWeight here: it's no good to approximate with "match all docs".
    // This is an inverted structure and should be used in the first pass:

    return new ConstantScoreWeight(this) {

      @Override
      public Scorer scorer(LeafReaderContext context) throws IOException {
        LeafReader reader = context.reader();
        PointValues values = reader.getPointValues();
        if (values == null) {
          // No docs in this segment indexed any points
          return null;
        }
        FieldInfo fieldInfo = reader.getFieldInfos().fieldInfo(field);
        if (fieldInfo == null) {
          // No docs in this segment indexed this field at all
          return null;
        }
        if (fieldInfo.getPointDimensionCount() != numDims) {
          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with numDims=" + fieldInfo.getPointDimensionCount() + " but this query has numDims=" + numDims);
        }
        if (bytesPerDim != fieldInfo.getPointNumBytes()) {
          throw new IllegalArgumentException("field=\"" + field + "\" was indexed with bytesPerDim=" + fieldInfo.getPointNumBytes() + " but this query has bytesPerDim=" + bytesPerDim);
        }
        int bytesPerDim = fieldInfo.getPointNumBytes();

        DocIdSetBuilder result = new DocIdSetBuilder(reader.maxDoc());

        int[] hitCount = new int[1];
        final TermIterator iterator = sortedPackedPoints.iterator();
        byte[] pointBytes = new byte[bytesPerDim * numDims];

        if (numDims == 1) {

          final BytesRef scratch = new BytesRef();
          scratch.length = bytesPerDim;

          // Optimize this common case, effectively doing a merge sort of the indexed values vs the queried set:
          values.intersect(field,
                           new IntersectVisitor() {

                             private BytesRef nextQueryPoint = iterator.next();

                             @Override
                             public void grow(int count) {
                               result.grow(count);
                             }

                             @Override
                             public void visit(int docID) {
                               hitCount[0]++;
                               result.add(docID);
                             }

                             @Override
                             public void visit(int docID, byte[] packedValue) {
                               scratch.bytes = packedValue;
                               while (nextQueryPoint != null) {
                                 int cmp = nextQueryPoint.compareTo(scratch);
                                 if (cmp == 0) {
                                   // Query point equals index point, so collect and return
                                   hitCount[0]++;
                                   result.add(docID);
                                   break;
                                 } else if (cmp < 0) {
                                   // Query point is before index point, so we move to next query point
                                   nextQueryPoint = iterator.next();
                                 } else {
                                   // Query point is after index point, so we don't collect and we return:
                                   break;
                                 }
                               }
                             }

                             @Override
                             public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {

                               while (nextQueryPoint != null) {
                                 scratch.bytes = minPackedValue;
                                 int cmpMin = nextQueryPoint.compareTo(scratch);
                                 if (cmpMin < 0) {
                                   // query point is before the start of this cell
                                   nextQueryPoint = iterator.next();
                                   continue;
                                 }
                                 scratch.bytes = maxPackedValue;
                                 int cmpMax = nextQueryPoint.compareTo(scratch);
                                 if (cmpMax > 0) {
                                   // query point is after the end of this cell
                                   return Relation.CELL_OUTSIDE_QUERY;
                                 }

                                 if (cmpMin == 0 && cmpMax == 0) {
                                   // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,
                                   // which can easily happen if many (> 1024) docs share this one value
                                   return Relation.CELL_INSIDE_QUERY;
                                 } else {
                                   return Relation.CELL_CROSSES_QUERY;
                                 }
                               }

                               // We exhausted all points in the query:
                               return Relation.CELL_OUTSIDE_QUERY;
                             }
                           });
        } else {
          for (BytesRef point = iterator.next(); point != null; point = iterator.next()) {
            // nocommit make sure a test tests this:
            assert point.length == pointBytes.length;
            System.arraycopy(point.bytes, point.offset, pointBytes, 0, pointBytes.length);

            final BytesRef finalPoint = point;

            values.intersect(field,
                             // nocommit don't make new instance of this for each point?
                             new IntersectVisitor() {

                               @Override
                               public void grow(int count) {
                                 result.grow(count);
                               }

                               @Override
                               public void visit(int docID) {
                                 hitCount[0]++;
                                 result.add(docID);
                               }

                               @Override
                               public void visit(int docID, byte[] packedValue) {
                                 assert packedValue.length == finalPoint.length;
                                 if (Arrays.equals(packedValue, pointBytes)) {
                                   // The point for this doc matches the point we are querying on
                                   hitCount[0]++;
                                   result.add(docID);
                                 }
                               }

                               @Override
                               public Relation compare(byte[] minPackedValue, byte[] maxPackedValue) {

                                 boolean crosses = false;

                                 for(int dim=0;dim<numDims;dim++) {
                                   int offset = dim*bytesPerDim;

                                   int cmpMin = StringHelper.compare(bytesPerDim, minPackedValue, offset, pointBytes, offset);
                                   if (cmpMin > 0) {
                                     return Relation.CELL_OUTSIDE_QUERY;
                                   }

                                   int cmpMax = StringHelper.compare(bytesPerDim, maxPackedValue, offset, pointBytes, offset);
                                   if (cmpMax < 0) {
                                     return Relation.CELL_OUTSIDE_QUERY;
                                   }

                                   if (cmpMin != 0 || cmpMax != 0) {
                                     crosses = true;
                                   }
                                 }

                                 if (crosses) {
                                   return Relation.CELL_CROSSES_QUERY;
                                 } else {
                                   // nocommit make sure tests hit this case:
                                   // NOTE: we only hit this if we are on a cell whose min and max values are exactly equal to our point,
                                   // which can easily happen if many docs share this one value
                                   return Relation.CELL_INSIDE_QUERY;
                                 }
                               }
                             });
          }
        }

        // NOTE: hitCount[0] will be over-estimate in multi-valued case
        return new ConstantScoreScorer(this, score(), result.build(hitCount[0]).iterator());
      }
    };
  }

