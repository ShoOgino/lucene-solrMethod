  /** 
   * Expert: create a multidimensional range query for point values.
   * <p>
   * You can have half-open ranges (which are in fact &lt;/&le; or &gt;/&ge; queries)
   * by setting a {@code lowerValue} element or {@code upperValue} element to {@code null}. 
   * <p>
   * By setting a dimension's inclusive ({@code lowerInclusive} or {@code upperInclusive}) to false, it will
   * match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
   *
   * @param field field name. must not be {@code null}.
   * @param lowerPoint lower portion of the range. {@code null} values mean "open" for that dimension.
   * @param lowerInclusive {@code true} if the lower portion of the range is inclusive, {@code false} if it should be excluded.
   * @param upperPoint upper portion of the range. {@code null} values mean "open" for that dimension.
   * @param upperInclusive {@code true} if the upper portion of the range is inclusive, {@code false} if it should be excluded.
   * @throws IllegalArgumentException if {@code field} is null, or if {@code lowerValue.length != upperValue.length}
   */
  protected PointRangeQuery(String field,
                         byte[][] lowerPoint, boolean[] lowerInclusive,
                         byte[][] upperPoint, boolean[] upperInclusive) {
    checkArgs(field, lowerPoint, upperPoint);
    this.field = field;
    numDims = lowerPoint.length;
    if (upperPoint.length != numDims) {
      throw new IllegalArgumentException("lowerPoint has length=" + numDims + " but upperPoint has different length=" + upperPoint.length);
    }
    if (lowerInclusive.length != numDims) {
      throw new IllegalArgumentException("lowerInclusive has length=" + lowerInclusive.length + " but expected=" + numDims);
    }
    if (upperInclusive.length != numDims) {
      throw new IllegalArgumentException("upperInclusive has length=" + upperInclusive.length + " but expected=" + numDims);
    }
    this.lowerPoint = lowerPoint;
    this.lowerInclusive = lowerInclusive;
    this.upperPoint = upperPoint;
    this.upperInclusive = upperInclusive;

    int bytesPerDim = -1;
    for(byte[] value : lowerPoint) {
      if (value != null) {
        if (bytesPerDim == -1) {
          bytesPerDim = value.length;
        } else if (value.length != bytesPerDim) {
          throw new IllegalArgumentException("all dimensions must have same bytes length, but saw " + bytesPerDim + " and " + value.length);
        }
      }
    }
    for(byte[] value : upperPoint) {
      if (value != null) {
        if (bytesPerDim == -1) {
          bytesPerDim = value.length;
        } else if (value.length != bytesPerDim) {
          throw new IllegalArgumentException("all dimensions must have same bytes length, but saw " + bytesPerDim + " and " + value.length);
        }
      }
    }
    if (bytesPerDim == -1) {
      this.bytesPerDim = null;
    } else {
      this.bytesPerDim = bytesPerDim;
    }
  }

