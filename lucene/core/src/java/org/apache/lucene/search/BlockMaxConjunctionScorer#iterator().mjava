  @Override
  public DocIdSetIterator iterator() {
    // TODO: support two-phase
    final Scorer leadScorer = this.scorers[0]; // higher max score
    final DocIdSetIterator[] iterators = Arrays.stream(this.scorers)
        .map(Scorer::iterator)
        .toArray(DocIdSetIterator[]::new);
    final DocIdSetIterator lead = iterators[0];

    return new DocIdSetIterator() {

      float maxScore;
      int upTo = -1;

      @Override
      public int docID() {
        return lead.docID();
      }

      @Override
      public long cost() {
        return lead.cost();
      }

      private void moveToNextBlock(int target) throws IOException {
        upTo = advanceShallow(target);
        maxScore = getMaxScore(upTo);

        // Also compute the minimum required scores for a hit to be competitive
        // A double that is less than 'score' might still be converted to 'score'
        // when casted to a float, so we go to the previous float to avoid this issue
        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;
        for (int i = scorers.length - 1; i > 0; --i) {
          double minScore = minScores[i];
          float clauseMaxScore = scorers[i].getMaxScore(upTo);
          if (minScore > clauseMaxScore) {
            minScores[i - 1] = minScore - clauseMaxScore;
            assert minScores[i - 1] + clauseMaxScore <= minScore;
          } else {
            minScores[i - 1] = 0;
          }
        }
      }

      private int advanceTarget(int target) throws IOException {
        if (target > upTo) {
          moveToNextBlock(target);
        }

        while (true) {
          assert upTo >= target;

          if (maxScore >= minScore) {
            return target;
          }

          if (upTo == NO_MORE_DOCS) {
            return NO_MORE_DOCS;
          }

          target = upTo + 1;

          moveToNextBlock(target);
        }
      }

      @Override
      public int nextDoc() throws IOException {
        return advance(docID() + 1);
      }

      @Override
      public int advance(int target) throws IOException {
        return doNext(lead.advance(advanceTarget(target)));
      }

      private int doNext(int doc) throws IOException {
        advanceHead: for(;;) {
          assert doc == lead.docID();

          if (doc == NO_MORE_DOCS) {
            return NO_MORE_DOCS;
          }

          if (minScore > 0) {
            score = leadScorer.score();
            if (score < minScores[0]) {
              // computing a score is usually less costly than advancing other clauses
              doc = lead.advance(advanceTarget(doc + 1));
              continue;
            }
          }

          // then find agreement with other iterators
          for (int i = 1; i < iterators.length; ++i) {
            final DocIdSetIterator other = iterators[i];
            // other.doc may already be equal to doc if we "continued advanceHead"
            // on the previous iteration and the advance on the lead scorer exactly matched.
            if (other.docID() < doc) {
              final int next = other.advance(doc);

              if (next > doc) {
                // iterator beyond the current doc - advance lead and continue to the new highest doc.
                doc = lead.advance(advanceTarget(next));
                continue advanceHead;
              }
            }

            assert other.docID() == doc;
            if (minScore > 0) {
              score += scorers[i].score();

              if (score < minScores[i]) {
                // computing a score is usually less costly than advancing the next clause
                doc = lead.advance(advanceTarget(doc + 1));
                continue advanceHead;
              }
            }
          }

          if (minScore > 0 == false) {
            // the score hasn't been computed on the fly, do it now
            score = 0;
            for (Scorer scorer : scorers) {
              score += scorer.score();
            }
          }

          // success - all iterators are on the same doc and the score is competitive
          return doc;
        }
      }
    };
  }

