  @Override
  public Weight createWeight(IndexSearcher searcher, boolean needsScores) throws IOException {
    return new Weight(this) {

      @Override
      public void extractTerms(Set<Term> terms) {}

      @Override
      public float getValueForNormalization() throws IOException {
        return 0f;
      }

      @Override
      public void normalize(float norm, float topLevelBoost) {}

      @Override
      public Explanation explain(LeafReaderContext context, int doc) throws IOException {
        final Scorer scorer = scorer(context, context.reader().getLiveDocs());
        final boolean match = (scorer != null && scorer.advance(doc) == doc);
        if (match) {
          assert scorer.score() == 0f;
          return Explanation.match(0f, "Match on id " + doc);
        } else {
          return Explanation.match(0f, "No match on id " + doc);
        }
      }

      @Override
      public Scorer scorer(LeafReaderContext context, Bits acceptDocs) throws IOException {
        final DocIdSet set = getDocIdSet(context, acceptDocs);
        if (set == null) {
          return null;
        }
        if (applyLazily && set.bits() != null) {
          final Bits bits = set.bits();
          final DocIdSetIterator approximation = DocIdSetIterator.all(context.reader().maxDoc());
          final TwoPhaseIterator twoPhase = new TwoPhaseIterator(approximation) {
            @Override
            public boolean matches() throws IOException {
              return bits.get(approximation.docID());
            }
          };
          return new ConstantScoreScorer(this, 0f, twoPhase);
        }
        final DocIdSetIterator iterator = set.iterator();
        if (iterator == null) {
          return null;
        }
        return new ConstantScoreScorer(this, 0f, iterator);
      }

    };
  }

