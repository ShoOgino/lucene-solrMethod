    @Override
    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {
      if (used.compareAndSet(false, true)) {
        policy.onUse(getQuery());
      }

      if (in.isCacheable(context) == false) {
        // this segment is not suitable for caching
        return in.scorerSupplier(context);
      }

      // Short-circuit: Check whether this segment is eligible for caching
      // before we take a lock because of #get
      if (shouldCache(context) == false) {
        return in.scorerSupplier(context);
      }

      // If the lock is already busy, prefer using the uncached version than waiting
      if (lock.tryLock() == false) {
        return in.scorerSupplier(context);
      }

      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();
      if (cacheHelper == null) {
        // this reader has no cache helper
        return in.scorerSupplier(context);
      }
      DocIdSet docIdSet;
      try {
        docIdSet = get(in.getQuery(), context, cacheHelper);
      } finally {
        lock.unlock();
      }

      if (docIdSet == null) {
        ScorerSupplier inSupplier = in.scorerSupplier(context);
        if (inSupplier == null) {
          putIfAbsent(in.getQuery(), context, DocIdSet.EMPTY, cacheHelper);
          return null;
        }
        
        if (policy.shouldCache(in.getQuery())) {
          return new ScorerSupplier() {

            @Override
            public Scorer get(long leadCost) throws IOException {
              double costFactor = (double) inSupplier.cost() / leadCost;
              if (costFactor >= maxCostFactor) {
                // too costly, caching might make the query much slower
                return inSupplier.get(leadCost);
              }
              DocIdSet cached = cacheImpl(new DefaultBulkScorer(inSupplier.get(Long.MAX_VALUE)), context.reader().maxDoc());
              putIfAbsent(in.getQuery(), context, cached, cacheHelper);
              DocIdSetIterator iterator = cached.iterator();
              if (iterator == null) {
                // DIS.iterator() is allowed to return null when empty but we want a non-null iterator here
                iterator = DocIdSetIterator.empty();
              }
              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, iterator);
            }

            @Override
            public long cost() {
              return inSupplier.cost();
            }
          };
        } else {
          return inSupplier;
        }
      }

      assert docIdSet != null;
      if (docIdSet == DocIdSet.EMPTY) {
        return null;
      }
      final DocIdSetIterator disi = docIdSet.iterator();
      if (disi == null) {
        return null;
      }

      return new ScorerSupplier() {
        @Override
        public Scorer get(long LeadCost) throws IOException {
          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);
        }
        
        @Override
        public long cost() {
          return disi.cost();
        }
      };

    }

