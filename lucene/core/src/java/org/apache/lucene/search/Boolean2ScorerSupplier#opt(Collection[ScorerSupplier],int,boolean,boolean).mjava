  private Scorer opt(Collection<ScorerSupplier> optional, int minShouldMatch,
      boolean needsScores, boolean randomAccess) throws IOException {
    if (optional.size() == 1) {
      return optional.iterator().next().get(randomAccess);
    } else if (minShouldMatch > 1) {
      final List<Scorer> optionalScorers = new ArrayList<>();
      final PriorityQueue<ScorerSupplier> pq = new PriorityQueue<ScorerSupplier>(subs.get(Occur.SHOULD).size() - minShouldMatch + 1) {
        @Override
        protected boolean lessThan(ScorerSupplier a, ScorerSupplier b) {
          return a.cost() > b.cost();
        }
      };
      for (ScorerSupplier scorer : subs.get(Occur.SHOULD)) {
        ScorerSupplier overflow = pq.insertWithOverflow(scorer);
        if (overflow != null) {
          optionalScorers.add(overflow.get(true));
        }
      }
      for (ScorerSupplier scorer : pq) {
        optionalScorers.add(scorer.get(randomAccess));
      }
      return new MinShouldMatchSumScorer(weight, optionalScorers, minShouldMatch);
    } else {
      final List<Scorer> optionalScorers = new ArrayList<>();
      for (ScorerSupplier scorer : optional) {
        optionalScorers.add(scorer.get(randomAccess));
      }
      return new DisjunctionSumScorer(weight, optionalScorers, needsScores);
    }
  }

