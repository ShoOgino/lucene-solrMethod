  @Override
  public boolean nextMatch() throws IOException {
    if (!positioned) {
      return false;
    }
    PhrasePositions pp = pq.pop();
    assert pp != null;  // if the pq is empty, then positioned == false
    leadPosition = pp.position + pp.offset;
    leadOffset = pp.postings.startOffset();
    currentEndPostings = advanceEndPostings;
    matchLength = end - pp.position;
    int next = pq.top().position; 
    while (advancePP(pp)) {
      if (hasRpts && !advanceRpts(pp)) {
        break; // pps exhausted
      }
      if (pp.position > next) { // done minimizing current match-length
        pq.add(pp);
        if (matchLength <= slop) {
          return true;
        }
        pp = pq.pop();
        next = pq.top().position;
        matchLength = end - pp.position;
      } else {
        int matchLength2 = end - pp.position;
        if (matchLength2 < matchLength) {
          matchLength = matchLength2;
        }
      }
      leadPosition = pp.position + pp.offset;
      leadOffset = pp.postings.startOffset();
      currentEndPostings = advanceEndPostings;
    }
    positioned = false;
    return matchLength <= slop;
  }

