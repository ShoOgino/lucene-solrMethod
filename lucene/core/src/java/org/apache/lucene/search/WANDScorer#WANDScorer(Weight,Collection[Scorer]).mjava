  WANDScorer(Weight weight, Collection<Scorer> scorers) {
    super(weight);

    this.minCompetitiveScore = 0;
    this.doc = -1;

    head = new DisiPriorityQueue(scorers.size());
    // there can be at most num_scorers - 1 scorers beyond the current position
    tail = new DisiWrapper[scorers.size() - 1];

    OptionalInt scalingFactor = OptionalInt.empty();
    for (Scorer scorer : scorers) {
      float maxScore = scorer.maxScore();
      if (maxScore != 0 && Float.isFinite(maxScore)) {
        // 0 and +Infty should not impact the scale
        scalingFactor = OptionalInt.of(Math.min(scalingFactor.orElse(Integer.MAX_VALUE), scalingFactor(maxScore)));
      }
    }
    // Use a scaling factor of 0 if all max scores are either 0 or +Infty
    this.scalingFactor = scalingFactor.orElse(0);
    
    for (Scorer scorer : scorers) {
      DisiWrapper w = new DisiWrapper(scorer);
      float maxScore = scorer.maxScore();
      w.maxScore = scaleMaxScore(maxScore, this.scalingFactor);
      addLead(w);
    }

    long cost = 0;
    for (DisiWrapper w = lead; w != null; w = w.next) {
      cost += w.cost;
    }
    this.cost = cost;
    this.maxScorePropagator = new MaxScoreSumPropagator(scorers);
  }

