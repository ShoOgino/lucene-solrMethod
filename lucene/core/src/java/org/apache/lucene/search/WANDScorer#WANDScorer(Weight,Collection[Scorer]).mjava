  WANDScorer(Weight weight, Collection<Scorer> scorers) {
    super(weight);

    this.minCompetitiveScore = 0;
    this.doc = -1;

    head = new DisiPriorityQueue(scorers.size());
    // there can be at most num_scorers - 1 scorers beyond the current position
    tail = new DisiWrapper[scorers.size() - 1];

    OptionalInt scalingFactor = OptionalInt.empty();
    for (Scorer scorer : scorers) {
      float maxScore = scorer.maxScore();
      if (maxScore != 0 && Float.isFinite(maxScore)) {
        // 0 and +Infty should not impact the scale
        scalingFactor = OptionalInt.of(Math.min(scalingFactor.orElse(Integer.MAX_VALUE), scalingFactor(maxScore)));
      }
    }
    // Use a scaling factor of 0 if all max scores are either 0 or +Infty
    this.scalingFactor = scalingFactor.orElse(0);
    
    double maxScoreSum = 0;
    for (Scorer scorer : scorers) {
      DisiWrapper w = new DisiWrapper(scorer);
      float maxScore = scorer.maxScore();
      w.maxScore = scaleMaxScore(maxScore, this.scalingFactor);
      maxScoreSum += maxScore;
      addLead(w);
    }

    long cost = 0;
    for (DisiWrapper w = lead; w != null; w = w.next) {
      cost += w.cost;
    }
    this.cost = cost;
    // The error of sums depends on the order in which values are summed up. In
    // order to avoid this issue, we compute an upper bound of the value that
    // the sum may take. If the max relative error is b, then it means that two
    // sums are always within 2*b of each other.
    double maxScoreRelativeErrorBound = MathUtil.sumRelativeErrorBound(scorers.size());
    this.maxScore = (float) ((1.0 + 2 * maxScoreRelativeErrorBound) * maxScoreSum);
  }

