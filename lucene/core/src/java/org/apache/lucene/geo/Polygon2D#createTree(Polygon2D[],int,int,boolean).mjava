  /** Creates tree from sorted components (with range low and high inclusive) */
  private static Polygon2D createTree(Polygon2D components[], int low, int high, boolean splitX) {
    if (low > high) {
      return null;
    } else if (low < high) {
      // TODO: do one sort instead! there are better algorithms!
      if (splitX) {
        Arrays.sort(components, low, high+1, (left, right) -> {
          int ret = Double.compare(left.minLon, right.minLon);
          if (ret == 0) {
            ret = Double.compare(left.maxX, right.maxX);
          }
          return ret;
        });
      } else {
        Arrays.sort(components, low, high+1, (left, right) -> {
          int ret = Double.compare(left.minLat, right.minLat);
          if (ret == 0) {
            ret = Double.compare(left.maxY, right.maxY);
          }
          return ret;
        });
      }
    }
    // add midpoint
    int mid = (low + high) >>> 1;
    Polygon2D newNode = components[mid];
    newNode.splitX = splitX;
    // add children
    newNode.left = createTree(components, low, mid - 1, !splitX);
    newNode.right = createTree(components, mid + 1, high, !splitX);
    // pull up max values to this node
    if (newNode.left != null) {
      newNode.maxX = Math.max(newNode.maxX, newNode.left.maxX);
      newNode.maxY = Math.max(newNode.maxY, newNode.left.maxY);
    }
    if (newNode.right != null) {
      newNode.maxX = Math.max(newNode.maxX, newNode.right.maxX);
      newNode.maxY = Math.max(newNode.maxY, newNode.right.maxY);
    }
    return newNode;
  }

