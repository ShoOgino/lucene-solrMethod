  private boolean crossesSlowly(double minLat, double maxLat, final double minLon, final double maxLon) {
    /*
     * Accurately compute (within restrictions of cartesian decimal degrees) whether a rectangle crosses a polygon
     */
    final double[] boxLats = new double[] { minLat, minLat, maxLat, maxLat, minLat };
    final double[] boxLons = new double[] { minLon, maxLon, maxLon, minLon, minLon };

    // computes the intersection point between each bbox edge and the polygon edge
    for (int b=0; b<4; ++b) {
      double a1 = boxLats[b+1]-boxLats[b];
      double b1 = boxLons[b]-boxLons[b+1];
      double c1 = a1*boxLons[b+1] + b1*boxLats[b+1];
      for (int p=0; p<polyLons.length-1; ++p) {
        double a2 = polyLats[p+1]-polyLats[p];
        double b2 = polyLons[p]-polyLons[p+1];
        // compute determinant
        double d = a1*b2 - a2*b1;
        if (d != 0) {
          // lines are not parallel, check intersecting points
          double c2 = a2*polyLons[p+1] + b2*polyLats[p+1];
          double s = (1/d)*(b2*c1 - b1*c2);
          // todo TOLERANCE SHOULD MATCH EVERYWHERE this is currently blocked by LUCENE-7165
          double x00 = Math.min(boxLons[b], boxLons[b+1]) - ENCODING_TOLERANCE;
          if (x00 > s) {
            continue; // out of range
          }
          double x01 = Math.max(boxLons[b], boxLons[b+1]) + ENCODING_TOLERANCE;
          if (x01 < s) {
            continue; // out of range
          }
          double x10 = Math.min(polyLons[p], polyLons[p+1]) - ENCODING_TOLERANCE;
          if (x10 > s) {
            continue; // out of range
          }
          double x11 = Math.max(polyLons[p], polyLons[p+1]) + ENCODING_TOLERANCE;
          if (x11 < s) {
            continue; // out of range
          }

          double t = (1/d)*(a1*c2 - a2*c1);
          double y00 = Math.min(boxLats[b], boxLats[b+1]) - ENCODING_TOLERANCE;
          if (y00 > t || (x00 == s && y00 == t)) {
            continue; // out of range or touching
          }
          double y01 = Math.max(boxLats[b], boxLats[b+1]) + ENCODING_TOLERANCE;
          if (y01 < t || (x01 == s && y01 == t)) {
            continue; // out of range or touching
          }
          double y10 = Math.min(polyLats[p], polyLats[p+1]) - ENCODING_TOLERANCE;
          if (y10 > t || (x10 == s && y10 == t)) {
            continue; // out of range or touching
          }
          double y11 = Math.max(polyLats[p], polyLats[p+1]) + ENCODING_TOLERANCE;
          if (y11 < t || (x11 == s && y11 == t)) {
            continue; // out of range or touching
          }
          // if line segments are not touching and the intersection point is within the range of either segment
          return true;
        }
      } // for each poly edge
    } // for each bbox edge
    return false;
  }

