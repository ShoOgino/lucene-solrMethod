  private ByteBufferIndexInput buildSlice(long offset, long length) {
    if (buffers == null) {
      throw new AlreadyClosedException("Already closed: " + this);
    }
    if (offset < 0 || length < 0 || offset+length > this.length) {
      throw new IllegalArgumentException("slice() " + sliceDescription + " out of bounds: offset=" + offset + ",length=" + length + ",fileLength="  + this.length + ": "  + this);
    }
    
    // include our own offset into the final offset:
    offset += this.offset;
    
    final ByteBufferIndexInput clone = (ByteBufferIndexInput)super.clone();
    clone.isClone = true;
    // we keep clone.clones, so it shares the same map with original and we have no additional cost on clones
    assert clone.clones == this.clones;
    clone.buffers = buildSlice(buffers, offset, length);
    clone.offset = (int) (offset & chunkSizeMask);
    clone.length = length;

    // register the new clone in our clone list to clean it up on closing:
    this.clones.put(clone, Boolean.TRUE);
    
    return clone;
  }

