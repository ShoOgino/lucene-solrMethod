  /** Try to delete any pending files that we had previously tried to delete but failed
   *  because we are on Windows and the files were still held open. */
  public synchronized void deletePendingFiles() throws IOException {
    // TODO: we could fix IndexInputs from FSDirectory subclasses to call this when they are closed?

    // Clone the set because it will change as we iterate:
    List<String> toDelete = new ArrayList<>(pendingDeletes);
    System.out.println("del pending: " + pendingDeletes);

    // First pass: delete any segments_N files.  We do these first to be certain stale commit points are removed
    // before we remove any files they reference.  If any delete of segments_N fails, we leave all other files
    // undeleted so index is never in a corrupt state:
    Throwable firstException = null;
    for (String fileName : toDelete) {
      if (fileName.startsWith(IndexFileNames.SEGMENTS)) {
        try {
          if (deleteFile(fileName) == false) {
            // nocommit
            System.out.println("  false on " + fileName + "; skipping the rest");
            return;
          }
        } catch (Throwable t) {
          if (firstException == null) {
            firstException = t;
          } else {
            firstException.addSuppressed(t);
          }
          // nocommit
          System.out.println("  fail on " + fileName + ":");
          t.printStackTrace(System.out);
          throw t;
        }
      }
    }

    // Only delete other files if we were able to remove the segments_N files; this way we never
    // leave a corrupt commit in the index even in the presense of virus checkers:
    for(String fileName : toDelete) {
      if (fileName.startsWith(IndexFileNames.SEGMENTS) == false) {
        try {
          deleteFile(fileName);
        } catch (Throwable t) {
          if (firstException == null) {
            firstException = t;
          } else {
            firstException.addSuppressed(t);
          }
          // nocommit
          System.out.println("  fail on " + fileName + ":");
          t.printStackTrace(System.out);
          throw t;
        }
      }
    }

    // Does nothing if firstException is null:
    IOUtils.reThrow(firstException);
  }

