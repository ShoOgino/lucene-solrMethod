    @Override
    protected void readInternal(byte[] b, int offset, int len) throws IOException {
      final ByteBuffer bb;

      // Determine the ByteBuffer we should use
      if (b == buffer) {
        // Use our own pre-wrapped byteBuf:
        assert byteBuf != null;
        bb = byteBuf;
        byteBuf.clear().position(offset);
      } else {
        bb = ByteBuffer.wrap(b, offset, len);
      }

      synchronized(channel) {
        long pos = getFilePointer() + off;
        
        if (pos + len > end) {
          throw new EOFException("read past EOF: " + this);
        }
               
        try {
          channel.position(pos);

          int readLength = len;
          while (readLength > 0) {
            final int toRead = Math.min(CHUNK_SIZE, readLength);
            bb.limit(bb.position() + toRead);
            assert bb.remaining() == toRead;
            final int i = channel.read(bb);
            if (i < 0) { // be defensive here, even though we checked before hand, something could have changed
              throw new EOFException("read past EOF: " + this + " off: " + offset + " len: " + len + " pos: " + pos + " chunkLen: " + toRead + " end: " + end);
            }
            assert i > 0 : "SeekableByteChannel.read with non zero-length bb.remaining() must always read at least one byte (Channel is in blocking mode, see spec of ReadableByteChannel)";
            pos += i;
            readLength -= i;
          }
          assert readLength == 0;
        } catch (IOException ioe) {
          throw new IOException(ioe.getMessage() + ": " + this, ioe);
        }
      }
    }

