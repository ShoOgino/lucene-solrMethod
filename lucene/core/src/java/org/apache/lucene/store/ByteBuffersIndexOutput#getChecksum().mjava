  @Override
  public long getChecksum() throws IOException {
    ensureOpen();

    if (checksum == null) {
      throw new IOException("This index output has no checksum computing ability: " + toString());
    }

    // Compute checksum on the current content of the delegate.
    //
    // This way we can override more methods and pass them directly to the delegate for efficiency of writing,
    // while allowing the checksum to be correctly computed on the current content of the output buffer (IndexOutput
    // is per-thread, so no concurrent changes).
    if (lastChecksumPosition != delegate.size()) {
      lastChecksumPosition = delegate.size();
      checksum.reset();
      byte [] buffer = null;
      for (ByteBuffer bb : delegate.toBufferList()) {
        if (bb.hasArray()) {
          checksum.update(bb.array(), bb.arrayOffset() + bb.position(), bb.remaining());
        } else {
          if (buffer == null) buffer = new byte [1024 * 4];

          bb = bb.asReadOnlyBuffer();
          int remaining = bb.remaining();
          while (remaining > 0) {
            int len = Math.min(remaining, buffer.length);
            bb.get(buffer, 0, len);
            checksum.update(buffer, 0, len);
            remaining -= len;
          }
        }
      }
      lastChecksum = checksum.getValue(); 
    }
    return lastChecksum;
  }

