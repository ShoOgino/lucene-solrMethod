  @Override
  public synchronized boolean obtain() throws IOException {

    if (lock != null) {
      // Our instance is already locked:
      return false;
    }

    // Ensure that lockDir exists and is a directory.
    if (!lockDir.exists()) {
      if (!lockDir.mkdirs())
        throw new IOException("Cannot create directory: " +
            lockDir.getAbsolutePath());
    } else if (!lockDir.isDirectory()) {
      // TODO: NoSuchDirectoryException instead?
      throw new IOException("Found regular file where directory expected: " + 
          lockDir.getAbsolutePath());
    }
    final String canonicalPath = path.getCanonicalPath();
    // Make sure nobody else in-process has this lock held
    // already, and, mark it held if not:
    // This is a pretty crazy workaround for some documented
    // but yet awkward JVM behavior:
    //
    //   On some systems, closing a channel releases all locks held by the Java virtual machine on the underlying file
    //   regardless of whether the locks were acquired via that channel or via another channel open on the same file.
    //   It is strongly recommended that, within a program, a unique channel be used to acquire all locks on any given
    //   file.
    //
    // This essentially means if we close "A" channel for a given file all locks might be released... the odd part
    // is that we can't re-obtain the lock in the same JVM but from a different process if that happens. Nevertheless
    // this is super trappy. See LUCENE-5738
    boolean obtained = false;
    if (LOCK_HELD.add(canonicalPath)) {
      try {
        channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);
        try {
          lock = channel.tryLock();
          obtained = lock != null;
        } catch (IOException | OverlappingFileLockException e) {
          // At least on OS X, we will sometimes get an
          // intermittent "Permission Denied" IOException,
          // which seems to simply mean "you failed to get
          // the lock".  But other IOExceptions could be
          // "permanent" (eg, locking is not supported via
          // the filesystem).  So, we record the failure
          // reason here; the timeout obtain (usually the
          // one calling us) will use this as "root cause"
          // if it fails to get the lock.
          failureReason = e;
        }
      } finally {
        if (obtained == false) { // not successful - clear up and move out
          clearLockHeld(path);
          final FileChannel toClose = channel;
          channel = null;
          IOUtils.closeWhileHandlingException(toClose);
        }
      }
    }
    return obtained;
  }

