  @Override
  public synchronized boolean obtain() throws IOException {

    if (lockExists()) {
      // Our instance is already locked:
      return false;
    }

    // Ensure that lockDir exists and is a directory.
    if (!lockDir.exists()) {
      if (!lockDir.mkdirs())
        throw new IOException("Cannot create directory: " +
            lockDir.getAbsolutePath());
    } else if (!lockDir.isDirectory()) {
      // TODO: NoSuchDirectoryException instead?
      throw new IOException("Found regular file where directory expected: " + 
          lockDir.getAbsolutePath());
    }
    
    channel = FileChannel.open(path.toPath(), StandardOpenOption.CREATE, StandardOpenOption.WRITE);
    boolean success = false;
    try {
      lock = channel.tryLock();
      success = true;
    } catch (IOException | OverlappingFileLockException e) {
      // At least on OS X, we will sometimes get an
      // intermittent "Permission Denied" IOException,
      // which seems to simply mean "you failed to get
      // the lock".  But other IOExceptions could be
      // "permanent" (eg, locking is not supported via
      // the filesystem).  So, we record the failure
      // reason here; the timeout obtain (usually the
      // one calling us) will use this as "root cause"
      // if it fails to get the lock.
      failureReason = e;
    } finally {
      if (!success) {
        try {
          IOUtils.closeWhileHandlingException(channel);
        } finally {
          channel = null;
        }
      }
    }
    return lockExists();
  }

