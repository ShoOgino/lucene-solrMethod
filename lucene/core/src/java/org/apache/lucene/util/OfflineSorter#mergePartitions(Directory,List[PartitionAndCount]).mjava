  /** Merge the most recent {@code maxTempFile} partitions into a new partition. */
  void mergePartitions(Directory trackingDir, List<PartitionAndCount> segments) throws IOException {
    long start = System.currentTimeMillis();

    List<PartitionAndCount> segmentsToMerge;
    if (segments.size() > maxTempFiles) {
      segmentsToMerge = segments.subList(segments.size() - maxTempFiles, segments.size());
    } else {
      segmentsToMerge = segments;
    }

    long totalCount = 0;
    for (PartitionAndCount segment : segmentsToMerge) {
      totalCount += segment.count;
    }

    PriorityQueue<FileAndTop> queue = new PriorityQueue<FileAndTop>(segmentsToMerge.size()) {
      @Override
      protected boolean lessThan(FileAndTop a, FileAndTop b) {
        return comparator.compare(a.current, b.current) < 0;
      }
    };

    ByteSequencesReader[] streams = new ByteSequencesReader[segmentsToMerge.size()];

    String newSegmentName = null;

    try (ByteSequencesWriter writer = getWriter(trackingDir.createTempOutput(tempFileNamePrefix, "sort", IOContext.DEFAULT), totalCount)) {

      newSegmentName = writer.out.getName();
      
      // Open streams and read the top for each file
      for (int i = 0; i < segmentsToMerge.size(); i++) {
        streams[i] = getReader(dir.openChecksumInput(segmentsToMerge.get(i).fileName, IOContext.READONCE), segmentsToMerge.get(i).fileName);
        BytesRef item = null;
        try {
          item = streams[i].next();
        } catch (Throwable t) {
          verifyChecksum(t, streams[i]);
        }
        assert item != null;
        queue.insertWithOverflow(new FileAndTop(i, item));
      }
  
      // Unix utility sort() uses ordered array of files to pick the next line from, updating
      // it as it reads new lines. The PQ used here is a more elegant solution and has 
      // a nicer theoretical complexity bound :) The entire sorting process is I/O bound anyway
      // so it shouldn't make much of a difference (didn't check).
      FileAndTop top;
      while ((top = queue.top()) != null) {
        writer.write(top.current);
        try {
          top.current = streams[top.fd].next();
        } catch (Throwable t) {
          verifyChecksum(t, streams[top.fd]);
        }

        if (top.current != null) {
          queue.updateTop();
        } else {
          queue.pop();
        }
      }

      CodecUtil.writeFooter(writer.out);

      for(ByteSequencesReader reader : streams) {
        CodecUtil.checkFooter(reader.in);
      }
  
      sortInfo.mergeTime += System.currentTimeMillis() - start;
      sortInfo.mergeRounds++;
    } finally {
      IOUtils.close(streams);
    }

    IOUtils.deleteFiles(trackingDir, segmentsToMerge.stream().map(segment -> segment.fileName).collect(Collectors.toList()));

    segmentsToMerge.clear();
    segments.add(new PartitionAndCount(totalCount, newSegmentName));

    sortInfo.tempMergeFiles++;
  }

