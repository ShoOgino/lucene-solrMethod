    private int currentOrNextDoc() {
      final int i4096 = doc >>> 12;
      final long index = indices[i4096];
      if (index == 0) {
        // if the index is zero, it means that there is no value in the
        // current block, so return the first document of the next block
        return firstDoc(i4096 + 1);
      } else {
        // now we are on a block that contains at least one document
        assert Long.bitCount(index) <= bits[i4096].length;
        int i64 = doc >>> 6;
        long indexBits = index >>> i64; // shifts are mod 64 in java
        if (indexBits == 0) {
          // if neither the i64-th bit or any other bit on its left is set then
          // it means that there are no more documents in this block, go to the
          // next one
          return firstDoc(i4096 + 1);
        }

        // We know we still have some 64-bits blocks that have bits set, let's
        // advance to the next one by skipping trailing zeros of the index
        int i1 = doc & 0x3F;
        int trailingZeros = Long.numberOfTrailingZeros(indexBits);
        if (trailingZeros != 0) {
          // no bits in the current long, go to the next one
          i64 += trailingZeros;
          i1 = 0;
        }

        // So now we are on a sub 64-bits block that has values
        assert (index & (1L << i64)) != 0;
        // we count the number of ones on the left of i64 to figure out the
        // index of the long that contains the bits we are interested in
        int longIndex = Long.bitCount(index & ((1L << i64) - 1)); // shifts are mod 64 in java
        final long[] longArray = bits[i4096];
        assert longArray[longIndex] != 0;
        long bits = SparseFixedBitSet.this.bits[i4096][longIndex] >>> i1; // shifts are mod 64 in java
        if (bits != 0L) {
          // hurray, we found some non-zero bits, this gives us the next document:
          i1 += Long.numberOfTrailingZeros(bits);
          return doc = (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;
        }

        // otherwise it means that although we were on a sub-64 block that contains
        // documents, all documents of this sub-block have already been consumed
        // so two cases:
        indexBits = index >>> i64 >>> 1; // we don't shift by (i64+1) otherwise we might shift by a multiple of 64 which is a no-op
        if (indexBits == 0) {
          // Case 1: this was the last long of the block of 4096 bits, then go
          // to the next block
          return firstDoc(i4096 + 1);
        }
        // Case 2: go to the next sub 64-bits block in the current block of 4096 bits
        // by skipping trailing zeros of the index
        trailingZeros = Long.numberOfTrailingZeros(indexBits);
        i64 += 1 + trailingZeros;
        bits = longArray[longIndex + 1];
        assert bits != 0;
        i1 = Long.numberOfTrailingZeros(bits);
        return doc = (i4096 << 12) | ((i64 & 0x3F) << 6) | i1;
      }
    }

