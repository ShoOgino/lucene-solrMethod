  /**
   * Gets an integer id for a given term.
   *
   * If there is no position gaps for this token then we can reuse the id for the same term if it appeared at another
   * position without a gap.  If we have a position gap generate a new id so we can keep track of the position
   * increment.
   */
  private int getTermID(int incr, int prevIncr, BytesRef term) {
    assert term != null;
    boolean isStackedGap = incr == 0 && prevIncr > 1;
    boolean hasGap = incr > 1;
    Integer id;
    if (hasGap || isStackedGap) {
      id = idToTerm.size();
      idToTerm.put(id, BytesRef.deepCopyOf(term));

      // stacked token should have the same increment as original token at this position
      if (isStackedGap) {
        idToInc.put(id, prevIncr);
      } else {
        idToInc.put(id, incr);
      }
    } else {
      id = termToID.get(term);
      if (id == null) {
        term = BytesRef.deepCopyOf(term);
        id = idToTerm.size();
        termToID.put(term, id);
        idToTerm.put(id, term);
      }
    }

    return id;
  }

