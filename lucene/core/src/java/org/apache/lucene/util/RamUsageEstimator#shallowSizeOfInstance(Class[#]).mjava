  /**
   * Returns the shallow instance size in bytes an instance of the given class would occupy.
   * This works with all conventional classes and primitive types, but not with arrays
   * (the size then depends on the number of elements and varies from object to object).
   * Use the array-instance methods instead.
   * 
   * @throws IllegalArgumentException if {@code clazz} is an array class. 
   */
  public static long shallowSizeOfInstance(Class<?> clazz) {
    if (clazz.isArray())
      throw new IllegalArgumentException("This method does not work with array classes.");
    if (clazz.isPrimitive())
      return primitiveSizes.get(clazz);
    
    long size = NUM_BYTES_OBJECT_HEADER;
    
    // Walk type hierarchy
    while (clazz != null) {
      final Field[] fields = clazz.getDeclaredFields();
      boolean fieldFound = false;
      for (final Field f : fields) {
        if (Modifier.isStatic(f.getModifiers())) {
          continue;
        }

        size = reflectFieldSize(size, f);
        fieldFound = true;
      }
      if (useUnsafe && fieldFound) {
        // no need to recurse to superclasses, as all fields are
        // added at the end, so we won't find any larger offset
        break;
      }
      clazz = clazz.getSuperclass();
    }
    return alignObjectSize(size);    
  }

