    /**
     * Gets a slice out of {@link PagedBytes} starting at <i>start</i>, the
     * length is read as 1 or 2 byte vInt prefix. Iff the slice spans across a
     * block border this method will allocate sufficient resources and copy the
     * paged data.
     * <p>
     * Slices spanning more than one block are not supported.
     * </p>
     * 
     * @lucene.internal
     **/
    public BytesRef fillSliceWithPrefix(BytesRef b, long start) {
      int index = (int) (start >> blockBits);
      int offset = (int) (start & blockMask);
      byte[] block = blocks[index];
      final int length;
      assert offset <= block.length-1;
      if ((block[offset] & 128) == 0) {
        length = block[offset];
        offset = offset+1;
      } else {
        if (offset==block.length-1) {
          final byte[] nextBlock = blocks[++index];
          length = ((block[offset] & 0x7f) << 8) | (nextBlock[0] & 0xff);
          offset = 1;
          block = nextBlock;
          assert length > 0; 
        } else {
          assert offset < block.length-1;
          length = ((block[offset] & 0x7f) << 8) | (block[1+offset] & 0xff);
          offset = offset+2;
          assert length > 0;
        }
      }
      assert length >= 0: "length=" + length;
      b.length = length;

      // NOTE: even though copyUsingLengthPrefix always
      // allocs a new block if the byte[] to be added won't
      // fit in current block,
      // VarDerefBytesImpl.finishInternal does its own
      // prefix + byte[] writing which can span two blocks,
      // so we support that here on decode:
      if (blockSize - offset >= length) {
        // Within block
        b.offset = offset;
        b.bytes = blocks[index];
      } else {
        // Split
        b.bytes = new byte[length];
        b.offset = 0;
        System.arraycopy(blocks[index], offset, b.bytes, 0, blockSize-offset);
        System.arraycopy(blocks[1+index], 0, b.bytes, blockSize-offset, length-(blockSize-offset));
      }
      return b;
    }

