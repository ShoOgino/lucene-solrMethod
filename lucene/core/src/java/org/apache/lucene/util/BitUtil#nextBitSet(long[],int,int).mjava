  /**
   * Returns the index of the next bit set following the given bit zero-based index.
   * <br>For example with bits 100011:
   * the next bit set after index=-1 is at index=0;
   * the next bit set after index=0 is at index=1;
   * the next bit set after index=1 is at index=5;
   * there is no next bit set after index=5.
   *
   * @param bits     The bits stored in an array of long for efficiency.
   * @param numLongs The number of longs in {@code bits} to consider.
   * @param bitIndex The bit zero-based index. It must be greater than or equal to -1,
   *                 and strictly less than {@code numLongs * Long.SIZE}.
   * @return The zero-based index of the next bit set after the provided {@code bitIndex};
   * or -1 if none.
   */
  public static int nextBitSet(long[] bits, int numLongs, int bitIndex) {
    assert numLongs >= 0 && numLongs <= bits.length && bitIndex >= -1 && bitIndex < numLongs * Long.SIZE
        : "bitIndex=" + bitIndex + " numLongs=" + numLongs + " bits.length=" + bits.length;
    int longIndex = bitIndex / Long.SIZE;
    // Prepare a mask with 1s on the left down to bitIndex exclusive.
    long mask = -(1L << (bitIndex + 1)); // Shifts are mod 64.
    long l = mask == -1 && bitIndex != -1 ? 0 : bits[longIndex] & mask;
    while (l == 0) {
      if (++longIndex == numLongs) {
        return -1;
      }
      l = bits[longIndex];
    }
    return Long.numberOfTrailingZeros(l) + longIndex * 64;
  }

