    // If back plus this arc is competitive then add to queue:
    protected void addIfCompetitive(FSTPath<T> path) {

      assert queue != null;

      T cost = fst.outputs.add(path.cost, path.arc.output);
      //System.out.println("  addIfCompetitive queue.size()=" + queue.size() + " path=" + path + " + label=" + path.arc.label);

      if (queue.size() == maxQueueDepth) {
        FSTPath<T> bottom = queue.last();
        int comp = comparator.compare(cost, bottom.cost);
        if (comp > 0) {
          // Doesn't compete
          return;
        } else if (comp == 0) {
          // Tie break by alpha sort on the input:
          path.input.grow(path.input.length+1);
          path.input.ints[path.input.length++] = path.arc.label;
          final int cmp = bottom.input.compareTo(path.input);
          path.input.length--;

          // We should never see dups:
          assert cmp != 0;

          if (cmp < 0) {
            // Doesn't compete
            return;
          }
        }
        // Competes
      } else {
        // Queue isn't full yet, so any path we hit competes:
      }

      // copy over the current input to the new input
      // and add the arc.label to the end
      IntsRef newInput = new IntsRef(path.input.length+1);     
      System.arraycopy(path.input.ints, 0, newInput.ints, 0, path.input.length);
      newInput.ints[path.input.length] = path.arc.label;
      newInput.length = path.input.length+1;
      final FSTPath<T> newPath = new FSTPath<T>(cost, path.arc, newInput);

      queue.add(newPath);

      if (queue.size() == maxQueueDepth+1) {
        queue.pollLast();
      }
    }

