  private FST.Arc<T> doSeekFloorArrayWithGaps(FST.Arc<T> arc, int targetLabel, final FST.BytesReader in) throws IOException {
    // The array is addressed directly by label and may contain holes.
    in.setPosition(arc.posArcsStart);
    in.skipBytes(1);
    int firstLabel = fst.readLabel(in);
    int targetOffset = targetLabel - firstLabel;
    if (targetOffset < 0) {
      //System.out.println(" before first"); Very first arc is after our target TODO: if each
      // arc could somehow read the arc just before, we can save this re-scan.  The ceil case
      // doesn't need this because it reads the next arc instead:
      while(true) {
        // First, walk backwards until we find a first arc
        // that's before our target label:
        fst.readFirstTargetArc(getArc(upto-1), arc, fstReader);
        if (arc.label < targetLabel) {
          // Then, scan forwards to the arc just before
          // the targetLabel:
          while(!arc.isLast() && fst.readNextArcLabel(arc, in) < targetLabel) {
            fst.readNextArc(arc, fstReader);
          }
          pushLast();
          return null;
        }
        upto--;
        if (upto == 0) {
          return null;
        }
        targetLabel = getTargetLabel();
        arc = getArc(upto);
      }
    } else {
      if (targetOffset >= arc.numArcs) {
        arc.nextArc = arc.posArcsStart - arc.bytesPerArc * (arc.numArcs - 1);
        fst.readNextRealArc(arc, in);
        assert arc.isLast();
        assert arc.label < targetLabel: "arc.label=" + arc.label + " vs targetLabel=" + targetLabel;
        pushLast();
        return null;
      }
      arc.nextArc = arc.posArcsStart - arc.bytesPerArc * targetOffset;
      fst.readNextRealArc(arc, in);
      if (arc.label == targetLabel) {
        // found -- copy pasta from below
        output[upto] = fst.outputs.add(output[upto-1], arc.output);
        if (targetLabel == FST.END_LABEL) {
          return null;
        }
        setCurrentLabel(arc.label);
        incr();
        return fst.readFirstTargetArc(arc, getArc(upto), fstReader);
      }
      // Scan backwards to find a floor arc that is not missing
      for (long arcOffset = arc.posArcsStart - targetOffset * arc.bytesPerArc; arcOffset <= arc.posArcsStart; arcOffset += arc.bytesPerArc) {
        // TODO: we can do better here by skipping missing arcs
        arc.nextArc = arcOffset;
        //System.out.println(" hasFloor arcIdx=" + (arc.arcIdx+1));
        fst.readNextRealArc(arc, in);
        if (arc.label < targetLabel) {
          assert arc.isLast() || fst.readNextArcLabel(arc, in) > targetLabel;
          pushLast();
          return null;
        }
      }
      assert false: "arc.label=" + arc.label + " vs targetLabel=" + targetLabel;
      return arc;               // unreachable
    }
  }

