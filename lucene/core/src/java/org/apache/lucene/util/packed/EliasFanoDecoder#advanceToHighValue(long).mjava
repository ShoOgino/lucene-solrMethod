  /** setBitForIndex and efIndex have just been incremented, scan forward to the high set bit
   *  of at least a given high value
   *  by incrementing setBitForIndex, and by setting curHighLong accordingly.
   *  @return the smallest encoded high value that is at least the given one.
   */
  private long advanceToHighValue(long highTarget) {
    int curSetBits = Long.bitCount(curHighLong); // is shifted by getCurrentRightShift()
    int curClearBits = Long.SIZE - curSetBits - getCurrentRightShift();
    while ((currentHighValue() + curClearBits) < highTarget) {
      // curHighLong has not enough clear bits to reach highTarget
      efIndex += curSetBits;
      if (efIndex >= numEncoded) {
        return NO_MORE_VALUES;
      }
      toNextHighLong();
      // assert getCurrentRightShift() == 0;
      curSetBits = Long.bitCount(curHighLong);
      curClearBits = Long.SIZE - curSetBits;
    }
    // curHighLong has enough clear bits to reach highTarget, but may not have enough set bits.
    long highValue = nextHighValue();
    while (highValue < highTarget) {
      /* CHECKME: Instead of the linear search here, use (forward) broadword selection from
       * "Broadword Implementation of Rank/Select Queries", Sebastiano Vigna, January 30, 2012.
       */
      if (! toAfterCurrentHighBit()) {
        return NO_MORE_VALUES;
      }
      highValue = nextHighValue();
    }
    return highValue;
  }

