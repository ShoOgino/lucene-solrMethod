  /** Sort points on the given dimension. */
  public static void sortByDim(int numDataDim, int numIndexDim, int sortedDim, int bytesPerDim, int[] commonPrefixLengths,
                               MutablePointValues reader, int from, int to,
                               BytesRef scratch1, BytesRef scratch2) {

    final int start = sortedDim * bytesPerDim + commonPrefixLengths[sortedDim];
    final int dimEnd =  sortedDim * bytesPerDim + bytesPerDim;
    final int dataStart = numIndexDim * bytesPerDim;
    final int dataEnd = dataStart + (numDataDim - numIndexDim) * bytesPerDim;
    // No need for a fancy radix sort here, this is called on the leaves only so
    // there are not many values to sort
    new IntroSorter() {

      final BytesRef pivot = scratch1;
      int pivotDoc = -1;

      @Override
      protected void swap(int i, int j) {
        reader.swap(i, j);
      }

      @Override
      protected void setPivot(int i) {
        reader.getValue(i, pivot);
        pivotDoc = reader.getDocID(i);
      }

      @Override
      protected int comparePivot(int j) {
        reader.getValue(j, scratch2);
        int cmp = Arrays.compareUnsigned(pivot.bytes, pivot.offset + start, pivot.offset + dimEnd, scratch2.bytes,
            scratch2.offset + start, scratch2.offset + dimEnd);
        if (cmp == 0) {
          cmp = Arrays.compareUnsigned(pivot.bytes, pivot.offset + dataStart, pivot.offset + dataEnd,
              scratch2.bytes, scratch2.offset + dataStart, scratch2.offset + dataEnd);
          if (cmp == 0) {
            cmp = pivotDoc - reader.getDocID(j);
          }
        }
        return cmp;
      }
    }.sort(from, to);
  }

