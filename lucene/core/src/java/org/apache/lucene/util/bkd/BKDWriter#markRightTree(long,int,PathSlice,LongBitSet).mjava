  /** Marks bits for the ords (points) that belong in the right sub tree (those docs that have values >= the splitValue). */
  private byte[] markRightTree(long rightCount, int splitDim, PathSlice source, LongBitSet ordBitSet) throws IOException {

    // Now we mark ords that fall into the right half, so we can partition on all other dims that are not the split dim:

    // Read the split value, then mark all ords in the right tree (larger than the split value):
    try (PointReader reader = source.writer.getReader(source.start + source.count - rightCount, rightCount)) {
      boolean result = reader.next();
      assert result;

      System.arraycopy(reader.packedValue(), splitDim*bytesPerDim, scratch1, 0, bytesPerDim);
      if (numDims > 1) {

        assert ordBitSet.get(reader.ord()) == false;
        ordBitSet.set(reader.ord());

        // Start at 1 because we already did the first value above (so we could keep the split value):
        for(int i=1;i<rightCount;i++) {
          result = reader.next();
          if (result == false) {
            throw new IllegalStateException("did not see enough points from reader=" + reader);
          }
          assert ordBitSet.get(reader.ord()) == false: "ord=" + reader.ord() + " was seen twice from " + source.writer;
          ordBitSet.set(reader.ord());
        }
      }
    } catch (Throwable t) {
      verifyChecksum(t, source.writer);
    }

    return scratch1;
  }

