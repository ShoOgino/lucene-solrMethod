  /**
   * Returns the index of the previous bit set preceding the given bit zero-based index.
   * <br>For example with bits 100011:
   * there is no previous bit set before index=0.
   * the previous bit set before index=1 is at index=0;
   * the previous bit set before index=5 is at index=1;
   * the previous bit set before index=64 is at index=5;
   *
   * @param bits     The bits stored in an array of long for efficiency.
   * @param numLongs The number of longs in {@code bits} to consider.
   * @param bitIndex The bit zero-based index. It must be greater than or equal to 0,
   *                 and less than or equal to {@code numLongs * Long.SIZE}.
   * @return The zero-based index of the previous bit set before the provided {@code bitIndex};
   * or -1 if none.
   */
  public static int previousBitSet(long[] bits, int numLongs, int bitIndex) {
    assert numLongs >= 0 && numLongs <= bits.length && bitIndex >= 0 && bitIndex <= numLongs * Long.SIZE
        : "bitIndex=" + bitIndex + " numLongs=" + numLongs + " bits.length=" + bits.length;
    int longIndex = bitIndex / Long.SIZE;
    long l;
    if (longIndex == numLongs) {
      l = 0;
    } else {
      // Prepare a mask with 1s on the right up to bitIndex exclusive.
      long mask = (1L << bitIndex) - 1L; // Shifts are mod 64.
      l = bits[longIndex] & mask;
    }
    while (l == 0) {
      if (longIndex-- == 0) {
        return -1;
      }
      l = bits[longIndex];
    }
    return 63 - Long.numberOfLeadingZeros(l) + longIndex * 64;
  }

