  /**
   * Reads the first arc greater or equal than the given label into the provided
   * arc in place and returns it iff found, otherwise return <code>null</code>.
   * 
   * @param label the label to ceil on
   * @param fst the fst to operate on
   * @param follow the arc to follow reading the label from
   * @param arc the arc to read into in place
   * @param in the fst's {@link BytesReader}
   */
  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {
    if (label == FST.END_LABEL) {
      return FST.readEndArc(follow, arc);
    }
    if (!FST.targetHasArcs(follow)) {
      return null;
    }
    fst.readFirstTargetArc(follow, arc, in);
    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {
      if (arc.arcIdx() == Integer.MIN_VALUE) {
        // Arcs are in an array-with-gaps
        int offset = label - arc.label();
        if (offset >= arc.numArcs()) {
          return null;
        } else if (offset < 0) {
          return arc;
        } else {
          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());
        }
      }
      // Arcs are packed array -- use binary search to find
      // the target.

      int low = arc.arcIdx();
      int mid = 0;
      int high = arc.numArcs() - 1;
      // System.out.println("do arc array low=" + low + " high=" + high +
      // " targetLabel=" + targetLabel);
      while (low <= high) {
        mid = (low + high) >>> 1;
        in.setPosition(arc.posArcsStart());
        in.skipBytes(arc.bytesPerArc() * mid + 1);
        final int midLabel = fst.readLabel(in);
        final int cmp = midLabel - label;
        // System.out.println("  cycle low=" + low + " high=" + high + " mid=" +
        // mid + " midLabel=" + midLabel + " cmp=" + cmp);
        if (cmp < 0) {
          low = mid + 1;
        } else if (cmp > 0) {
          high = mid - 1;
        } else {
          return fst.readArcByIndex(arc, in, mid);
        }
      }
      if (low == arc.numArcs()) {
        // DEAD END!
        return null;
      }
      return fst.readArcByIndex(arc, in , high + 1);
    }

    // Linear scan
    fst.readFirstRealTargetArc(follow.target(), arc, in);

    while (true) {
      // System.out.println("  non-bs cycle");
      // TODO: we should fix this code to not have to create
      // object for the output of every arc we scan... only
      // for the matching arc, if found
      if (arc.label() >= label) {
        // System.out.println("    found!");
        return arc;
      } else if (arc.isLast()) {
        return null;
      } else {
        fst.readNextRealArc(arc, in);
      }
    }
  }

