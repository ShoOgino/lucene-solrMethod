  /**
   * Reads the first arc greater or equal than the given label into the provided
   * arc in place and returns it iff found, otherwise return <code>null</code>.
   * 
   * @param label the label to ceil on
   * @param fst the fst to operate on
   * @param follow the arc to follow reading the label from
   * @param arc the arc to read into in place
   * @param in the fst's {@link BytesReader}
   */
  public static <T> Arc<T> readCeilArc(int label, FST<T> fst, Arc<T> follow, Arc<T> arc, BytesReader in) throws IOException {
    if (label == FST.END_LABEL) {
      return FST.readEndArc(follow, arc);
    }
    if (!FST.targetHasArcs(follow)) {
      return null;
    }
    fst.readFirstTargetArc(follow, arc, in);
    if (arc.bytesPerArc() != 0 && arc.label() != FST.END_LABEL) {
      if (arc.arcIdx() == Integer.MIN_VALUE) {
        // Arcs are in an array-with-gaps
        int offset = label - arc.label();
        if (offset >= arc.numArcs()) {
          return null;
        } else if (offset < 0) {
          return arc;
        } else {
          return fst.readArcAtPosition(arc, in, arc.posArcsStart() - offset * arc.bytesPerArc());
        }
      }
      // Arcs are packed array -- use binary search to find the target.
      int idx = binarySearch(fst, arc, label);
      if (idx >= 0) {
        return fst.readArcByIndex(arc, in, idx);
      }
      idx = -1 - idx;
      if (idx == arc.numArcs()) {
        // DEAD END!
        return null;
      }
      return fst.readArcByIndex(arc, in , idx);
    }

    // Linear scan
    fst.readFirstRealTargetArc(follow.target(), arc, in);

    while (true) {
      // System.out.println("  non-bs cycle");
      // TODO: we should fix this code to not have to create
      // object for the output of every arc we scan... only
      // for the matching arc, if found
      if (arc.label() >= label) {
        // System.out.println("    found!");
        return arc;
      } else if (arc.isLast()) {
        return null;
      } else {
        fst.readNextRealArc(arc, in);
      }
    }
  }

