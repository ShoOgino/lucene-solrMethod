  /** Returns the set of accepted strings, up to at most
   *  <code>limit</code> strings. If more than <code>limit</code> 
   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then 
   *  the limit is infinite.  If the {@link Automaton} has
   *  cycles then this method might throw {@code
   *  IllegalArgumentException} but that is not guaranteed
   *  when the limit is set. */
  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {
    Set<IntsRef> results = new HashSet<>();

    if (limit == -1 || limit > 0) {
      // OK
    } else {
      throw new IllegalArgumentException("limit must be -1 (which means no limit), or > 0; got: " + limit);
    }

    if (a.isSingleton()) {
      // Easy case: automaton accepts only 1 string
      results.add(Util.toUTF32(a.singleton, new IntsRef()));
    } else {

      if (a.initial.accept) {
        // Special case the empty string, as usual:
        results.add(new IntsRef());
      }

      if (a.initial.numTransitions() > 0 && (limit == -1 || results.size() < limit)) {

        // TODO: we could use state numbers here and just
        // alloc array, but asking for states array can be
        // costly (it's lazily computed):

        // Tracks which states are in the current path, for
        // cycle detection:
        Set<State> pathStates = Collections.newSetFromMap(new IdentityHashMap<State,Boolean>());

        // Stack to hold our current state in the
        // recursion/iteration:
        PathNode[] nodes = new PathNode[4];

        pathStates.add(a.initial);
        PathNode root = getNode(nodes, 0);
        root.resetState(a.initial);

        IntsRef string = new IntsRef(1);
        string.length = 1;

        while (string.length > 0) {

          PathNode node = nodes[string.length-1];

          // Get next label leaving the current node:
          int label = node.nextLabel();

          if (label != -1) {
            string.ints[string.length-1] = label;

            if (node.to.accept) {
              // This transition leads to an accept state,
              // so we save the current string:
              results.add(IntsRef.deepCopyOf(string));
              if (results.size() == limit) {
                break;
              }
            }

            if (node.to.numTransitions() != 0) {
              // Now recurse: the destination of this transition has
              // outgoing transitions:
              if (pathStates.contains(node.to)) {
                throw new IllegalArgumentException("automaton has cycles");
              }
              pathStates.add(node.to);

              // Push node onto stack:
              if (nodes.length == string.length) {
                PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
                System.arraycopy(nodes, 0, newNodes, 0, nodes.length);
                nodes = newNodes;
              }
              getNode(nodes, string.length).resetState(node.to);
              string.length++;
              string.grow(string.length);
            }
          } else {
            // No more transitions leaving this state,
            // pop/return back to previous state:
            assert pathStates.contains(node.state);
            pathStates.remove(node.state);
            string.length--;
          }
        }
      }
    }

    return results;
  }

