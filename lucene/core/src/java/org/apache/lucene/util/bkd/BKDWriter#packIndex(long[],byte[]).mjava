  /** Packs the two arrays, representing a semi-balanced binary tree, into a compact byte[] structure. */
  private byte[] packIndex(long[] leafBlockFPs, byte[] splitPackedValues) throws IOException {
    int numLeaves = leafBlockFPs.length;
    // Possibly rotate the leaf block FPs, if the index not fully balanced binary tree.
    // In this case the leaf nodes may straddle the two bottom
    // levels of the binary tree:
    int lastFullLevel = 31 - Integer.numberOfLeadingZeros(numLeaves);
    int leavesFullLevel = 1 << lastFullLevel;
    int leavesPartialLevel = 2 * (numLeaves - leavesFullLevel);
    if (leavesPartialLevel != 0) {
      // Last level is partially filled, so we must rotate the leaf FPs to match.  We do this here, after loading
      // at read-time, so that we can still delta code them on disk at write:
      long[] newLeafBlockFPs = new long[numLeaves];
      System.arraycopy(leafBlockFPs, leavesPartialLevel, newLeafBlockFPs, 0, numLeaves - leavesPartialLevel);
      System.arraycopy(leafBlockFPs, 0, newLeafBlockFPs, numLeaves - leavesPartialLevel, leavesPartialLevel);
      leafBlockFPs = newLeafBlockFPs;
    }
    /** Reused while packing the index */
    ByteBuffersDataOutput writeBuffer = ByteBuffersDataOutput.newResettableInstance();

    // This is the "file" we append the byte[] to:
    List<byte[]> blocks = new ArrayList<>();
    byte[] lastSplitValues = new byte[bytesPerDim * numIndexDims];
    //System.out.println("\npack index");
    int totalSize = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, 0l, blocks, 1, lastSplitValues, new boolean[numIndexDims], false);

    // Compact the byte[] blocks into single byte index:
    byte[] index = new byte[totalSize];
    int upto = 0;
    for(byte[] block : blocks) {
      System.arraycopy(block, 0, index, upto, block.length);
      upto += block.length;
    }
    assert upto == totalSize;

    return index;
  }

