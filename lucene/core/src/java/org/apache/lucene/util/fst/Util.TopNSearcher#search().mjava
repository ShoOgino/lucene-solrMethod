    public MinResult<T>[] search() throws IOException {
      //System.out.println("  search topN=" + topN);
      final FST.Arc<T> scratchArc = new FST.Arc<T>();

      final List<MinResult<T>> results = new ArrayList<MinResult<T>>();

      final T NO_OUTPUT = fst.outputs.getNoOutput();

      // TODO: we could enable FST to sorting arcs by weight
      // as it freezes... can easily do this on first pass
      // (w/o requiring rewrite)

      // TODO: maybe we should make an FST.INPUT_TYPE.BYTE0.5!?
      // (nibbles)

      // For each top N path:
      while (results.size() < topN) {
        //System.out.println("\nfind next path");

        FSTPath<T> path;

        if (queue == null) {

          if (results.size() != 0) {
            // Ran out of paths
            break;
          }

          // First pass (top path): start from original fromNode
          if (topN > 1) {
            queue = new TreeSet<FSTPath<T>>();
          }

          T minArcCost = null;
          FST.Arc<T> minArc = null;

          path = new FSTPath<T>(NO_OUTPUT, fromNode, comparator);
          fst.readFirstTargetArc(fromNode, path.arc);

          // Bootstrap: find the min starting arc
          while (true) {
            T arcScore = path.arc.output;
            //System.out.println("  arc=" + (char) path.arc.label + " cost=" + arcScore);
            if (minArcCost == null || comparator.compare(arcScore, minArcCost) < 0) {
              minArcCost = arcScore;
              minArc = scratchArc.copyFrom(path.arc);
              //System.out.println("    **");
            }
            if (queue != null) {
              addIfCompetitive(path);
            }
            if (path.arc.isLast()) {
              break;
            }
            fst.readNextArc(path.arc);
          }

          assert minArc != null;

          if (queue != null) {
            // Remove top path since we are now going to
            // pursue it:
            path = queue.pollFirst();
            //System.out.println("  remove init path=" + path);
            assert path.arc.label == minArc.label;
            if (bottom != null && queue.size() == topN-1) {
              bottom = queue.last();
              //System.out.println("    set init bottom: " + bottom);
            }
          } else {
            path.arc.copyFrom(minArc);
            path.input.grow(1);
            path.input.ints[0] = minArc.label;
            path.input.length = 1;
            path.cost = minArc.output;
          }

        } else {
          path = queue.pollFirst();
          if (path == null) {
            // There were less than topN paths available:
            break;
          }
        }

        if (path.arc.label == FST.END_LABEL) {
          //System.out.println("    empty string!  cost=" + path.cost);
          // Empty string!
          path.input.length--;
          results.add(new MinResult<T>(path.input, path.cost, comparator));
          continue;
        }

        if (results.size() == topN-1) {
          // Last path -- don't bother w/ queue anymore:
          queue = null;
        }

        //System.out.println("  path: " + path);
        
        // We take path and find its "0 output completion",
        // ie, just keep traversing the first arc with
        // NO_OUTPUT that we can find, since this must lead
        // to the minimum path that completes from
        // path.arc.

        // For each input letter:
        while (true) {

          //System.out.println("\n    cycle path: " + path);         
          fst.readFirstTargetArc(path.arc, path.arc);

          // For each arc leaving this node:
          boolean foundZero = false;
          while(true) {
            //System.out.println("      arc=" + (char) path.arc.label + " cost=" + path.arc.output);
            // tricky: instead of comparing output == 0, we must
            // express it via the comparator compare(output, 0) == 0
            if (comparator.compare(NO_OUTPUT, path.arc.output) == 0) {
              if (queue == null) {
                foundZero = true;
                break;
              } else if (!foundZero) {
                scratchArc.copyFrom(path.arc);
                foundZero = true;
              } else {
                addIfCompetitive(path);
              }
            } else if (queue != null) {
              addIfCompetitive(path);
            }
            if (path.arc.isLast()) {
              break;
            }
            fst.readNextArc(path.arc);
          }

          assert foundZero;

          if (queue != null) {
            // TODO: maybe we can save this copyFrom if we
            // are more clever above... eg on finding the
            // first NO_OUTPUT arc we'd switch to using
            // scratchArc
            path.arc.copyFrom(scratchArc);
          }

          if (path.arc.label == FST.END_LABEL) {
            // Add final output:
            //System.out.println("    done!: " + path);
            results.add(new MinResult<T>(path.input, fst.outputs.add(path.cost, path.arc.output), comparator));
            break;
          } else {
            path.input.grow(1+path.input.length);
            path.input.ints[path.input.length] = path.arc.label;
            path.input.length++;
            path.cost = fst.outputs.add(path.cost, path.arc.output);
          }
        }
      }
    
      @SuppressWarnings({"rawtypes","unchecked"}) final MinResult<T>[] arr =
        (MinResult<T>[]) new MinResult[results.size()];
      return results.toArray(arr);
    }

