  // sort a given file on a given dimension for start to start + point count
  private OfflinePointWriter sortOffLine(int dim, String inputName, final long start, final long pointCount) throws IOException {

    final int offset = bytesPerDim * dim;

    Comparator<BytesRef> cmp;
    if (dim == numDataDims - 1) {
      // in that case the bytes for the dimension and for the doc id are contiguous,
      // so we don't need a branch
      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {
        @Override
        protected int byteAt(BytesRef ref, int i) {
          return ref.bytes[ref.offset + offset + i] & 0xff;
        }
      };
    } else {
      cmp = new BytesRefComparator(bytesPerDim + Integer.BYTES) {
        @Override
        protected int byteAt(BytesRef ref, int i) {
          if (i < bytesPerDim) {
            return ref.bytes[ref.offset + offset + i] & 0xff;
          } else {
            return ref.bytes[ref.offset + packedBytesLength + i - bytesPerDim] & 0xff;
          }
        }
      };
    }

    OfflineSorter sorter = new OfflineSorter(tempDir, tempFileNamePrefix + "_bkd" + dim, cmp, offlineSorterBufferMB, offlineSorterMaxTempFiles, bytesPerDoc, null, 0) {
      /**
       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.
       */
      @Override
      protected ByteSequencesWriter getWriter(IndexOutput out, long count) {
        return new ByteSequencesWriter(out) {
          @Override
          public void write(byte[] bytes, int off, int len) throws IOException {
            assert len == bytesPerDoc : "len=" + len + " bytesPerDoc=" + bytesPerDoc;
            out.writeBytes(bytes, off, len);
          }
        };
      }

      /**
       * We write/read fixed-byte-width file that {@link OfflinePointReader} can read.
       */
      @Override
      protected ByteSequencesReader getReader(ChecksumIndexInput in, String name) throws IOException {
        //This allows to read only a subset of the original file
        long startPointer = (name.equals(inputName)) ? bytesPerDoc * start : in.getFilePointer();
        long endPointer = (name.equals(inputName)) ? startPointer + bytesPerDoc * pointCount : Long.MAX_VALUE;
        in.seek(startPointer);
        return new ByteSequencesReader(in, name) {
          final BytesRef scratch = new BytesRef(new byte[bytesPerDoc]);

          @Override
          public BytesRef next() throws IOException {
            if (in.getFilePointer() >= end) {
              return null;
            } else if (in.getFilePointer() >= endPointer) {
              in.seek(end);
              return null;
            }
            in.readBytes(scratch.bytes, 0, bytesPerDoc);
            return scratch;
          }
        };
      }
    };

    String name = sorter.sort(inputName);
    return new OfflinePointWriter(tempDir, name, packedBytesLength, pointCount, longOrds, singleValuePerDoc);
  }

