  /**
   * Returns an automaton that accepts the concatenation of the languages of the
   * given automata.
   * <p>
   * Complexity: linear in total number of states.
   */
  static public LightAutomaton concatenateLight(List<LightAutomaton> l) {
    LightAutomaton result = new LightAutomaton();
    LightAutomaton.Transition scratch = new LightAutomaton.Transition();

    // First pass: create all states
    for(LightAutomaton a : l) {
      int numStates = a.getNumStates();
      for(int s=0;s<numStates;s++) {
        result.createState();
      }
    }

    // Second pass: add transitions, carefully linking accept
    // states of A to init state of next A:
    int stateOffset = 0;
    for(int i=0;i<l.size();i++) {
      LightAutomaton a = l.get(i);
      int numStates = a.getNumStates();

      LightAutomaton nextA = (i == l.size()-1) ? null : l.get(i+1);

      for(int s=0;s<numStates;s++) {
        int numTransitions = a.initTransition(s, scratch);
        for(int t=0;t<numTransitions;t++) {
          a.getNextTransition(scratch);
          result.addTransition(stateOffset + s, stateOffset + scratch.dest, scratch.min, scratch.max);
        }

        if (a.isAccept(s)) {
          LightAutomaton followA = nextA;
          int followOffset = stateOffset;
          int upto = i+1;
          while (true) {
            if (followA != null) {
              // Adds a "virtual" epsilon transition:
              numTransitions = followA.initTransition(0, scratch);
              for(int t=0;t<numTransitions;t++) {
                followA.getNextTransition(scratch);
                result.addTransition(stateOffset + s, followOffset + numStates + scratch.dest, scratch.min, scratch.max);
              }
              if (followA.isAccept(0)) {
                // Keep chaining if followA accepts empty string
                followOffset += followA.getNumStates();
                followA = (upto == l.size()-1) ? null : l.get(upto+1);
                upto++;
              } else {
                break;
              }
            } else {
              result.setAccept(stateOffset + s, true);
              break;
            }
          }
        }
      }

      stateOffset += numStates;
    }

    if (result.getNumStates() == 0) {
      result.createState();
    }

    result.finish();

    return result;
  }

