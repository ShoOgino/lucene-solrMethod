  /** Returns the set of accepted strings, up to at most
   *  <code>limit</code> strings. If more than <code>limit</code> 
   *  strings are accepted, the first limit strings found are returned. If <code>limit</code> == -1, then 
   *  the limit is infinite.  If the {@link Automaton} has
   *  cycles then this method might throw {@code
   *  IllegalArgumentException} but that is not guaranteed
   *  when the limit is set. */
  public static Set<IntsRef> getFiniteStrings(Automaton a, int limit) {
    Set<IntsRef> results = new HashSet<>();

    if (limit == -1 || limit > 0) {
      // OK
    } else {
      throw new IllegalArgumentException("limit must be -1 (which means no limit), or > 0; got: " + limit);
    }

    if (a.isAccept(0)) {
      // Special case the empty string, as usual:
      results.add(new IntsRef());
    }

    if (a.getNumTransitions(0) > 0 && (limit == -1 || results.size() < limit)) {

      int numStates = a.getNumStates();

      // Tracks which states are in the current path, for
      // cycle detection:
      BitSet pathStates = new BitSet(numStates);

      // Stack to hold our current state in the
      // recursion/iteration:
      PathNode[] nodes = new PathNode[4];

      pathStates.set(0);
      PathNode root = getNode(nodes, 0);
      root.resetState(a, 0);

      IntsRef string = new IntsRef(1);
      string.length = 1;

      while (string.length > 0) {

        PathNode node = nodes[string.length-1];

        // Get next label leaving the current node:
        int label = node.nextLabel(a);

        if (label != -1) {
          string.ints[string.length-1] = label;

          if (a.isAccept(node.to)) {
            // This transition leads to an accept state,
            // so we save the current string:
            results.add(IntsRef.deepCopyOf(string));
            if (results.size() == limit) {
              break;
            }
          }

          if (a.getNumTransitions(node.to) != 0) {
            // Now recurse: the destination of this transition has
            // outgoing transitions:
            if (pathStates.get(node.to)) {
              throw new IllegalArgumentException("automaton has cycles");
            }
            pathStates.set(node.to);

            // Push node onto stack:
            if (nodes.length == string.length) {
              PathNode[] newNodes = new PathNode[ArrayUtil.oversize(nodes.length+1, RamUsageEstimator.NUM_BYTES_OBJECT_REF)];
              System.arraycopy(nodes, 0, newNodes, 0, nodes.length);
              nodes = newNodes;
            }
            getNode(nodes, string.length).resetState(a, node.to);
            string.length++;
            string.grow(string.length);
          }
        } else {
          // No more transitions leaving this state,
          // pop/return back to previous state:
          assert pathStates.get(node.state);
          pathStates.clear(node.state);
          string.length--;
        }
      }
    }

    return results;
  }

