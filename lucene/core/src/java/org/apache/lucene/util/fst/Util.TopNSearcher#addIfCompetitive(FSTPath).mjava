    // If back plus this arc is competitive then add to queue:
    private void addIfCompetitive(FSTPath path) {

      assert queue != null;

      long cost = path.cost + path.arc.output;
      //System.out.println("  addIfCompetitive bottom=" + bottom + " queue.size()=" + queue.size());

      if (bottom != null) {

        if (cost > bottom.cost) {
          // Doesn't compete
          return;
        } else if (cost == bottom.cost) {
          // Tie break by alpha sort on the input:
          path.input.grow(path.input.length+1);
          path.input.ints[path.input.length++] = path.arc.label;
          final int cmp = bottom.input.compareTo(path.input);
          path.input.length--;
          assert cmp != 0;
          if (cmp < 0) {
            // Doesn't compete
            return;
          }
        }
        // Competes
      } else {
        // Queue isn't full yet, so any path we hit competes:
      }

      final FSTPath newPath = new FSTPath(cost, path.arc);

      newPath.input.grow(path.input.length+1);
      System.arraycopy(path.input.ints, 0, newPath.input.ints, 0, path.input.length);
      newPath.input.ints[path.input.length] = path.arc.label;
      newPath.input.length = path.input.length+1;

      //System.out.println("    add path=" + newPath);
      queue.add(newPath);
      if (bottom != null) {
        final FSTPath removed = queue.pollLast();
        assert removed == bottom;
        bottom = queue.last();
        //System.out.println("    now re-set bottom: " + bottom + " queue=" + queue);
      } else if (queue.size() == topN) {
        // Queue just filled up:
        bottom = queue.last();
        //System.out.println("    now set bottom: " + bottom);
      }
    }

