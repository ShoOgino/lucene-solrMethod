  /** Select a 1-bit from a long.
   * @return The index of the r-th 1 bit in x, or if no such bit exists, 72.
   */
  public static int select9(long x, int r) {
    long s = x - ((x & 0xAAAAAAAAAAAAAAAAL) >>> 1); // Step 0, pairwise bitsums

    // Correct a small mistake in algorithm 2:
    // Use s instead of x the second time in right shift 2, compare to Algorithm 1 in rank9 above.
    s = (s & 0x3333333333333333L) + ((s >>> 2) & 0x3333333333333333L); // Step 1, nibblewise bitsums

    s = ((s + (s >>> 4)) & 0x0F0F0F0F0F0F0F0FL) * L8_L; // Step 2, bytewise bitsums

    long b = ((smallerUpTo7_8(s, (r * L8_L)) >>> 7) * L8_L) >>> 53; // & (~7L); // Step 3, side ways addition for byte number times 8

    long l = r - (((s << 8) >>> b) & 0xFFL); // Step 4, byte wise rank, subtract the rank with byte at b-8, or zero for b=0;
    assert 0L <= l : l;
    //assert l < 8 : l; //fails when bit r is not available.

    // Select bit l from byte (x >>> b):
    long spr = (((x >>> b) & 0xFFL) * L8_L) & L9_L; // spread the 8 bits of the byte at b over the long at L9 positions

    // long spr_bigger8_zero = smaller8(0L, spr); // inlined smaller8 with 0L argument:
    // FIXME: replace by biggerequal8_one formula from article page 6, line 9. four operators instead of five here.
    long spr_bigger8_zero = ( ( H8_L - (spr & (~H8_L)) ) ^ (~spr) ) & H8_L;
    s = (spr_bigger8_zero >>> 7) * L8_L; // Step 5, sideways byte add the 8 bits towards the high byte

    int res = (int) (b + (((smallerUpTo7_8(s, (l * L8_L)) >>> 7) * L8_L) >>> 56)); // Step 6
    return res;
  }

