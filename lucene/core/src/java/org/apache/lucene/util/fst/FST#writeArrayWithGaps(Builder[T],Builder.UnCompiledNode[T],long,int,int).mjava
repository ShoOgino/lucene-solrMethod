  private void writeArrayWithGaps(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn, long fixedArrayStart, int maxBytesPerArc, int labelRange) {
    // expand the arcs in place, backwards
    long srcPos = builder.bytes.getPosition();
    long destPos = fixedArrayStart + labelRange * maxBytesPerArc;
    // if destPos == srcPos it means all the arcs were the same length, and the array of them is *already* direct
    assert destPos >= srcPos;
    if (destPos > srcPos) {
      builder.bytes.skipBytes((int) (destPos - srcPos));
      int arcIdx = nodeIn.numArcs - 1;
      int firstLabel = nodeIn.arcs[0].label;
      int nextLabel = nodeIn.arcs[arcIdx].label;
      for (int directArcIdx = labelRange - 1; directArcIdx >= 0; directArcIdx--) {
        destPos -= maxBytesPerArc;
        if (directArcIdx == nextLabel - firstLabel) {
          int arcLen = builder.reusedBytesPerArc[arcIdx];
          srcPos -= arcLen;
          //System.out.println("  direct pack idx=" + directArcIdx + " arcIdx=" + arcIdx + " srcPos=" + srcPos + " destPos=" + destPos + " label=" + nextLabel);
          if (srcPos != destPos) {
            //System.out.println("  copy len=" + builder.reusedBytesPerArc[arcIdx]);
            assert destPos > srcPos: "destPos=" + destPos + " srcPos=" + srcPos + " arcIdx=" + arcIdx + " maxBytesPerArc=" + maxBytesPerArc + " reusedBytesPerArc[arcIdx]=" + builder.reusedBytesPerArc[arcIdx] + " nodeIn.numArcs=" + nodeIn.numArcs;
            builder.bytes.copyBytes(srcPos, destPos, arcLen);
            if (arcIdx == 0) {
              break;
            }
          }
          --arcIdx;
          nextLabel = nodeIn.arcs[arcIdx].label;
        } else {
          assert directArcIdx > arcIdx;
          // mark this as a missing arc
          //System.out.println("  direct pack idx=" + directArcIdx + " no arc");
          builder.bytes.writeByte(destPos, BIT_MISSING_ARC);
        }
      }
    }
  }

