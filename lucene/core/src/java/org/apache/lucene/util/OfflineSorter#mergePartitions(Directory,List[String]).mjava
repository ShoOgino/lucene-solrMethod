  /** Merge a list of sorted temporary files (partitions) into an output file.  Note that this closes the
   *  incoming {@link IndexOutput}. */
  void mergePartitions(Directory trackingDir, List<String> segments) throws IOException {
    long start = System.currentTimeMillis();

    PriorityQueue<FileAndTop> queue = new PriorityQueue<FileAndTop>(segments.size()) {
      @Override
      protected boolean lessThan(FileAndTop a, FileAndTop b) {
        return comparator.compare(a.current.get(), b.current.get()) < 0;
      }
    };

    ByteSequencesReader[] streams = new ByteSequencesReader[segments.size()];

    String newSegmentName = null;

    try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, "sort", IOContext.DEFAULT)) {
      newSegmentName = out.getName();
      ByteSequencesWriter writer = new ByteSequencesWriter(out);

      // Open streams and read the top for each file
      for (int i = 0; i < segments.size(); i++) {
        streams[i] = new ByteSequencesReader(dir.openInput(segments.get(i), IOContext.READONCE));
        byte[] line = streams[i].read();
        assert line != null;
        queue.insertWithOverflow(new FileAndTop(i, line));
      }
  
      // Unix utility sort() uses ordered array of files to pick the next line from, updating
      // it as it reads new lines. The PQ used here is a more elegant solution and has 
      // a nicer theoretical complexity bound :) The entire sorting process is I/O bound anyway
      // so it shouldn't make much of a difference (didn't check).
      FileAndTop top;
      while ((top = queue.top()) != null) {
        writer.write(top.current.bytes(), 0, top.current.length());
        if (!streams[top.fd].read(top.current)) {
          queue.pop();
        } else {
          queue.updateTop();
        }
      }
  
      sortInfo.mergeTime += System.currentTimeMillis() - start;
      sortInfo.mergeRounds++;
    } finally {
      IOUtils.close(streams);
    }

    IOUtils.deleteFiles(trackingDir, segments);

    segments.clear();
    segments.add(newSegmentName);

    sortInfo.tempMergeFiles++;
  }

