  /** Merge the most recent {@code maxTempFile} partitions into a new partition. */
  void mergePartitions(Directory trackingDir, List<String> segments) throws IOException {
    long start = System.currentTimeMillis();

    List<String> segmentsToMerge;
    if (segments.size() > maxTempFiles) {
      segmentsToMerge = segments.subList(segments.size() - maxTempFiles, segments.size());
    } else {
      segmentsToMerge = segments;
    }

    PriorityQueue<FileAndTop> queue = new PriorityQueue<FileAndTop>(segmentsToMerge.size()) {
      @Override
      protected boolean lessThan(FileAndTop a, FileAndTop b) {
        return comparator.compare(a.current.get(), b.current.get()) < 0;
      }
    };

    ByteSequencesReader[] streams = new ByteSequencesReader[segmentsToMerge.size()];

    String newSegmentName = null;

    try (ByteSequencesWriter writer = getWriter(trackingDir.createTempOutput(tempFileNamePrefix, "sort", IOContext.DEFAULT))) {

      newSegmentName = writer.out.getName();
      
      // Open streams and read the top for each file
      for (int i = 0; i < segmentsToMerge.size(); i++) {
        streams[i] = getReader(dir.openChecksumInput(segmentsToMerge.get(i), IOContext.READONCE), segmentsToMerge.get(i));
        BytesRefBuilder bytes = new BytesRefBuilder();
        boolean result = false;
        try {
          result = streams[i].read(bytes);
        } catch (Throwable t) {
          verifyChecksum(t, streams[i]);
        }
        assert result;
        queue.insertWithOverflow(new FileAndTop(i, bytes));
      }
  
      // Unix utility sort() uses ordered array of files to pick the next line from, updating
      // it as it reads new lines. The PQ used here is a more elegant solution and has 
      // a nicer theoretical complexity bound :) The entire sorting process is I/O bound anyway
      // so it shouldn't make much of a difference (didn't check).
      FileAndTop top;
      while ((top = queue.top()) != null) {
        writer.write(top.current.bytes(), 0, top.current.length());
        boolean result = false;
        try {
          result = streams[top.fd].read(top.current);
        } catch (Throwable t) {
          verifyChecksum(t, streams[top.fd]);
        }

        if (result) {
          queue.updateTop();
        } else {
          queue.pop();
        }
      }

      CodecUtil.writeFooter(writer.out);

      for(ByteSequencesReader reader : streams) {
        CodecUtil.checkFooter(reader.in);
      }
  
      sortInfo.mergeTime += System.currentTimeMillis() - start;
      sortInfo.mergeRounds++;
    } finally {
      IOUtils.close(streams);
    }

    IOUtils.deleteFiles(trackingDir, segmentsToMerge);

    segmentsToMerge.clear();
    segments.add(newSegmentName);

    sortInfo.tempMergeFiles++;
  }

