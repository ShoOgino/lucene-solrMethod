  /**
   * Returns a new automaton that accepts strings representing decimal
   * non-negative integers in the given interval.
   * 
   * @param min minimal value of interval
   * @param max maximal value of interval (both end points are included in the
   *          interval)
   * @param digits if >0, use fixed number of digits (strings must be prefixed
   *          by 0's to obtain the right length) - otherwise, the number of
   *          digits is not fixed
   * @exception IllegalArgumentException if min>max or if numbers in the
   *              interval cannot be expressed with the given fixed number of
   *              digits
   */
  public static LightAutomaton makeIntervalLight(int min, int max, int digits)
      throws IllegalArgumentException {
    String x = Integer.toString(min);
    String y = Integer.toString(max);
    if (min > max || (digits > 0 && y.length() > digits)) {
      throw new IllegalArgumentException();
    }
    int d;
    if (digits > 0) d = digits;
    else d = y.length();
    StringBuilder bx = new StringBuilder();
    for (int i = x.length(); i < d; i++) {
      bx.append('0');
    }
    bx.append(x);
    x = bx.toString();
    StringBuilder by = new StringBuilder();
    for (int i = y.length(); i < d; i++) {
      by.append('0');
    }
    by.append(y);
    y = by.toString();

    LightAutomaton.Builder builder = new LightAutomaton.Builder();

    Collection<Integer> initials = new ArrayList<>();

    betweenLight(builder, x, y, 0, initials, digits <= 0);

    LightAutomaton a1 = builder.finish();

    if (digits <= 0) {
      LightAutomaton a2 = new LightAutomaton();
      a2.createState();
      // TODO: can we somehow do this w/o a full copy here?
      a2.copy(a1);

      for (int p : initials) {
        if (p != 0) {
          a2.addEpsilon(0, p+1);
        }
      }
      
      a2.finish();
      return a2;
    } else {
      return a1;
    }
  }

