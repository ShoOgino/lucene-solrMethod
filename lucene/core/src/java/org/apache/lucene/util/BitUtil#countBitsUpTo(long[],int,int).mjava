  /**
   * Counts the bits set up to the given bit zero-based index, exclusive.
   * <br>In other words, how many 1s there are up to the bit at the given index excluded.
   * <br>Example: bitIndex 66 means the third bit on the right of the second long.
   *
   * @param bits     The bits stored in an array of long for efficiency.
   * @param numLongs The number of longs in {@code bits} to consider.
   * @param bitIndex The bit zero-based index, exclusive. It must be greater than or equal to 0,
   *                 and less than or equal to {@code numLongs * Long.SIZE}.
   */
  public static int countBitsUpTo(long[] bits, int numLongs, int bitIndex) {
    assert numLongs >= 0 && numLongs <= bits.length && bitIndex >= 0 && bitIndex <= numLongs * Long.SIZE
        : "bitIndex=" + bitIndex + " numLongs=" + numLongs + " bits.length=" + bits.length;
    int bitCount = 0;
    int lastLong = bitIndex / Long.SIZE;
    for (int i = 0; i < lastLong; i++) {
      // Count the bits set for all plain longs.
      bitCount += Long.bitCount(bits[i]);
    }
    if (lastLong < numLongs) {
      // Prepare a mask with 1s on the right up to bitIndex exclusive.
      long mask = (1L << bitIndex) - 1L; // Shifts are mod 64.
      // Count the bits set only within the mask part, so up to bitIndex exclusive.
      bitCount += Long.bitCount(bits[lastLong] & mask);
    }
    return bitCount;
  }

