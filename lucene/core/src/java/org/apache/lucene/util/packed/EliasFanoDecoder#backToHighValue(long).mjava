  /** setBitForIndex and efIndex have just been decremented, scan backward to the high set bit
   *  of at most a given high value
   *  by decrementing setBitForIndex and by setting curHighLong accordingly.
   *  @return the largest encoded high value that is at most the given one.
   */
  private long backToHighValue(long highTarget) {
    int curSetBits = Long.bitCount(curHighLong); // is shifted by getCurrentLeftShift()
    int curClearBits = Long.SIZE - curSetBits - getCurrentLeftShift();
    while ((currentHighValue() - curClearBits) > highTarget) {
      // curHighLong has not enough clear bits to reach highTarget
      efIndex -= curSetBits;
      if (efIndex < 0) {
        return NO_MORE_VALUES;
      }
      toPreviousHighLong();
      //assert getCurrentLeftShift() == 0;
      curSetBits = Long.bitCount(curHighLong);
      curClearBits = Long.SIZE - curSetBits;
    }
    // curHighLong has enough clear bits to reach highTarget, but may not have enough set bits.
    long highValue = previousHighValue();
    while (highValue > highTarget) {
      /* CHECKME: See at advanceToHighValue. */
      if (! toBeforeCurrentHighBit()) {
        return NO_MORE_VALUES;
      }
      highValue = previousHighValue();
    }
    return highValue;
  }

