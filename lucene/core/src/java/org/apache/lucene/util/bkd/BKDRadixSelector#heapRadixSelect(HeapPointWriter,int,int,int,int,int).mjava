  private byte[] heapRadixSelect(HeapPointWriter points, int dim, int from, int to, int partitionPoint, int commonPrefix) {
    final int offset = dim * bytesPerDim + commonPrefix;
    final int dimCmpBytes = bytesPerDim - commonPrefix;
    new RadixSelector(bytesSorted - commonPrefix) {

      @Override
      protected void swap(int i, int j) {
        points.swap(i, j);
      }

      @Override
      protected int byteAt(int i, int k) {
        assert k >= 0 : "negative prefix " + k;
        if (k  < dimCmpBytes) {
          // dim bytes
          return points.block[i * packedBytesLength + offset + k] & 0xff;
        } else {
          // doc id
          int s = 3 - (k - dimCmpBytes);
          return (points.docIDs[i] >>> (s * 8)) & 0xff;
        }
      }

      @Override
      protected Selector getFallbackSelector(int d) {
        int skypedBytes = d + commonPrefix;
        final int start = dim * bytesPerDim + skypedBytes;
        final int end =  dim * bytesPerDim + bytesPerDim;
        return new IntroSelector() {

          int pivotDoc = -1;

          @Override
          protected void swap(int i, int j) {
            points.swap(i, j);
          }

          @Override
          protected void setPivot(int i) {
            if (skypedBytes < bytesPerDim) {
              System.arraycopy(points.block, i * packedBytesLength + dim * bytesPerDim, scratch, 0, bytesPerDim);
            }
            pivotDoc = points.docIDs[i];
          }

          @Override
          protected int compare(int i, int j) {
            if (skypedBytes < bytesPerDim) {
              int iOffset = i * packedBytesLength;
              int jOffset = j * packedBytesLength;
              int cmp = Arrays.compareUnsigned(points.block, iOffset + start, iOffset + end,
                  points.block, jOffset + start, jOffset + end);
              if (cmp != 0) {
                return cmp;
              }
            }
            return points.docIDs[i] - points.docIDs[j];
          }

          @Override
          protected int comparePivot(int j) {
            if (skypedBytes < bytesPerDim) {
              int jOffset = j * packedBytesLength;
              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim,
                  points.block, jOffset + start, jOffset + end);
              if (cmp != 0) {
                return cmp;
              }
            }
            return pivotDoc - points.docIDs[j];
          }
        };
      }
    }.select(from, to, partitionPoint);

    byte[] partition = new byte[bytesPerDim];
    PointValue pointValue = points.getPackedValueSlice(partitionPoint);
    BytesRef packedValue = pointValue.packedValue();
    System.arraycopy(packedValue.bytes, packedValue.offset + dim * bytesPerDim, partition, 0, bytesPerDim);
    return partition;
  }

