  /** Sort the heap writer by the specified dim. It is used to sort the leaves of the tree */
  public void heapRadixSort(final HeapPointWriter points, int from, int to, int dim, int commonPrefixLength) {
    final int dimOffset = dim * bytesPerDim + commonPrefixLength;
    final int dimCmpBytes = bytesPerDim - commonPrefixLength;
    final int dataOffset = numIndexDims * bytesPerDim - dimCmpBytes;
    new MSBRadixSorter(bytesSorted - commonPrefixLength) {

      @Override
      protected int byteAt(int i, int k) {
        assert k >= 0 : "negative prefix " + k;
        if (k  < dimCmpBytes) {
          // dim bytes
          return points.block[i * packedBytesDocIDLength + dimOffset + k] & 0xff;
        } else {
          // data bytes
          return points.block[i * packedBytesDocIDLength + dataOffset + k] & 0xff;
        }
      }

      @Override
      protected void swap(int i, int j) {
        points.swap(i, j);
      }

      @Override
      protected Sorter getFallbackSorter(int k) {
        final int skypedBytes = k + commonPrefixLength;
        final int dimStart = dim * bytesPerDim + skypedBytes;
        final int dimEnd =  dim * bytesPerDim + bytesPerDim;
        final int dataOffset = numIndexDims * bytesPerDim;
        // data length is composed by the data dimensions plus the docID
        final int dataLength = (numDataDims - numIndexDims) * bytesPerDim + Integer.BYTES;
        return new IntroSorter() {

          @Override
          protected void swap(int i, int j) {
            points.swap(i, j);
          }

          @Override
          protected void setPivot(int i) {
            if (skypedBytes < bytesPerDim) {
              System.arraycopy(points.block, i * packedBytesDocIDLength + dim * bytesPerDim, scratch, 0, bytesPerDim);
            }
            System.arraycopy(points.block, i * packedBytesDocIDLength + dataOffset, scratch, bytesPerDim, dataLength);
          }

          @Override
          protected int compare(int i, int j) {
            if (skypedBytes < bytesPerDim) {
              int iOffset = i * packedBytesDocIDLength;
              int jOffset = j * packedBytesDocIDLength;
              int cmp = Arrays.compareUnsigned(points.block, iOffset + dimStart, iOffset + dimEnd, points.block, jOffset + dimStart, jOffset + dimEnd);
              if (cmp != 0) {
                return cmp;
              }
            }
            int iOffset = i * packedBytesDocIDLength + dataOffset;
            int jOffset = j * packedBytesDocIDLength + dataOffset;
            return Arrays.compareUnsigned(points.block, iOffset, iOffset + dataLength, points.block, jOffset, jOffset + dataLength);
          }

          @Override
          protected int comparePivot(int j) {
            if (skypedBytes < bytesPerDim) {
              int jOffset = j * packedBytesDocIDLength;
              int cmp = Arrays.compareUnsigned(scratch, skypedBytes, bytesPerDim, points.block, jOffset + dimStart, jOffset + dimEnd);
              if (cmp != 0) {
                return cmp;
              }
            }
            int jOffset = j * packedBytesDocIDLength + dataOffset;
            return Arrays.compareUnsigned(scratch, bytesPerDim, bytesPerDim + dataLength, points.block, jOffset, jOffset + dataLength);
          }
        };
      }
    }.sort(from, to);
  }

