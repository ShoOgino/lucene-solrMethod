  /** 
   * Sort input to output, explicit hint for the buffer size. The amount of allocated
   * memory may deviate from the hint (may be smaller or larger).  
   */
  public SortInfo sort(Path input, Path output) throws IOException {
    sortInfo = new SortInfo();
    sortInfo.totalTime = System.currentTimeMillis();

    // NOTE: don't remove output here: its existence (often created by the caller
    // up above using Files.createTempFile) prevents another concurrent caller
    // of this API (from a different thread) from incorrectly re-using this file name

    ArrayList<Path> merges = new ArrayList<>();
    boolean success3 = false;
    try {
      ByteSequencesReader is = new ByteSequencesReader(input);
      boolean success = false;
      try {
        int lines = 0;
        while ((lines = readPartition(is)) > 0) {
          merges.add(sortPartition(lines));
          sortInfo.tempMergeFiles++;
          sortInfo.lines += lines;

          // Handle intermediate merges.
          if (merges.size() == maxTempFiles) {
            Path intermediate = Files.createTempFile(tempDirectory, "sort", "intermediate");
            boolean success2 = false;
            try {
              mergePartitions(merges, intermediate);
              success2 = true;
            } finally {
              if (success2) {
                IOUtils.deleteFilesIfExist(merges);
              } else {
                IOUtils.deleteFilesIgnoringExceptions(merges);
              }
              merges.clear();
              merges.add(intermediate);
            }
            sortInfo.tempMergeFiles++;
          }
        }
        success = true;
      } finally {
        if (success) {
          IOUtils.close(is);
        } else {
          IOUtils.closeWhileHandlingException(is);
        }
      }

      // One partition, try to rename or copy if unsuccessful.
      if (merges.size() == 1) {     
        Files.move(merges.get(0), output, StandardCopyOption.REPLACE_EXISTING);
      } else { 
        // otherwise merge the partitions with a priority queue.
        mergePartitions(merges, output);
      }
      success3 = true;
    } finally {
      if (success3) {
        IOUtils.deleteFilesIfExist(merges);
      } else {
        IOUtils.deleteFilesIgnoringExceptions(merges);
        IOUtils.deleteFilesIgnoringExceptions(output);
      }
    }

    sortInfo.totalTime = (System.currentTimeMillis() - sortInfo.totalTime); 
    return sortInfo;
  }

