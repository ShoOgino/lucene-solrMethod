  /** Sort the heap writer by the specified dim */
  private void sortHeapPointWriter(final HeapPointWriter writer, int start, int length, int dim) {

    assert pointCount < Integer.MAX_VALUE;
    //int[] swapCount = new int[1];
    //int[] cmpCount = new int[1];

    // System.out.println("SORT length=" + length);

    // All buffered points are still in heap; just do in-place sort:
    new IntroSorter() {
      private final byte[] pivotPackedValue = new byte[bytesPerDim];
      private int pivotDocID;

      @Override
      protected void setPivot(int i) {
        pivotDocID = writer.docIDs[i];
        int block = i / writer.valuesPerBlock;
        int index = i % writer.valuesPerBlock;
        System.arraycopy(writer.blocks.get(block), index*packedBytesLength+dim*bytesPerDim, pivotPackedValue, 0, bytesPerDim);
      }

      @Override
      protected int comparePivot(int j) {
        //cmpCount[0]++;
        int block = j / writer.valuesPerBlock;
        int index = j % writer.valuesPerBlock;
        assert index >= 0: "index=" + index + " j=" + j;
        int cmp = StringHelper.compare(bytesPerDim, pivotPackedValue, 0, writer.blocks.get(block), bytesPerDim*(index*numDims+dim));
        if (cmp != 0) {
          return cmp;
        }

        // Tie-break
        return Integer.compare(pivotDocID, writer.docIDs[j]);
      }

      @Override
      protected void swap(int i, int j) {
        int docID = writer.docIDs[i];
        writer.docIDs[i] = writer.docIDs[j];
        writer.docIDs[j] = docID;

        if (singleValuePerDoc == false) {
          if (longOrds) {
            long ord = writer.ordsLong[i];
            writer.ordsLong[i] = writer.ordsLong[j];
            writer.ordsLong[j] = ord;
          } else {
            int ord = writer.ords[i];
            writer.ords[i] = writer.ords[j];
            writer.ords[j] = ord;
          }
        }

        byte[] blockI = writer.blocks.get(i / writer.valuesPerBlock);
        int indexI = (i % writer.valuesPerBlock) * packedBytesLength;
        byte[] blockJ = writer.blocks.get(j / writer.valuesPerBlock);
        int indexJ = (j % writer.valuesPerBlock) * packedBytesLength;

        // scratch1 = values[i]
        System.arraycopy(blockI, indexI, scratch1, 0, packedBytesLength);
        // values[i] = values[j]
        System.arraycopy(blockJ, indexJ, blockI, indexI, packedBytesLength);
        // values[j] = scratch1
        System.arraycopy(scratch1, 0, blockJ, indexJ, packedBytesLength);
      }

      @Override
      protected int compare(int i, int j) {
        //cmpCount[0]++;
        int blockI = i / writer.valuesPerBlock;
        int dimI = i % writer.valuesPerBlock;
        int blockJ = j / writer.valuesPerBlock;
        int dimJ = j % writer.valuesPerBlock;
        int cmp = StringHelper.compare(bytesPerDim, writer.blocks.get(blockI), bytesPerDim*(dimI*numDims+dim), writer.blocks.get(blockJ), bytesPerDim*(dimJ*numDims+dim));
        if (cmp != 0) {
          return cmp;
        }

        // Tie-break by docID:

        // No need to tie break on ord, for the case where the same doc has the same value in a given dimension indexed more than once: it
        // can't matter at search time since we don't write ords into the index:
        return Integer.compare(writer.docIDs[i], writer.docIDs[j]);
      }
    }.sort(start, start+length);
    //System.out.println("LEN=" + length + " SWAP=" + swapCount[0] + " CMP=" + cmpCount[0]);
  }

