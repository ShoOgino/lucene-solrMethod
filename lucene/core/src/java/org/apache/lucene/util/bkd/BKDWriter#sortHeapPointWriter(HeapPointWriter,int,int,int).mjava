  /** If dim=-1 we sort by docID, else by that dim. */
  private void sortHeapPointWriter(final HeapPointWriter writer, int start, int length, int dim) {

    assert pointCount < Integer.MAX_VALUE;

    // All buffered points are still in heap; just do in-place sort:
    new InPlaceMergeSorter() {
      @Override
      protected void swap(int i, int j) {
        int docID = writer.docIDs[i];
        writer.docIDs[i] = writer.docIDs[j];
        writer.docIDs[j] = docID;

        long ord = writer.ords[i];
        writer.ords[i] = writer.ords[j];
        writer.ords[j] = ord;

        // scratch1 = values[i]
        writer.readPackedValue(i, scratch1);
        // scratch2 = values[j]
        writer.readPackedValue(j, scratch2);
        // values[i] = scratch2
        writer.writePackedValue(i, scratch2);
        // values[j] = scratch1
        writer.writePackedValue(j, scratch1);
      }

      @Override
      protected int compare(int i, int j) {
        if (dim != -1) {
          writer.readPackedValue(i, scratch1);
          writer.readPackedValue(j, scratch2);
          int cmp = BKDUtil.compare(bytesPerDim, scratch1, dim, scratch2, dim);
          if (cmp != 0) {
            return cmp;
          }
        }

        // Tie-break
        int cmp = Integer.compare(writer.docIDs[i], writer.docIDs[j]);
        if (cmp != 0) {
          return cmp;
        }

        return Long.compare(writer.ords[i], writer.ords[j]);
      }
    }.sort(start, start+length);
  }

