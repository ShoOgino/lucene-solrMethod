  /** 
   * Sort input to a new temp file, returning its name.
   */
  public String sort(String inputFileName) throws IOException {
    
    sortInfo = new SortInfo();
    sortInfo.totalTime = System.currentTimeMillis();

    List<PartitionAndCount> segments = new ArrayList<>();
    int[] levelCounts = new int[1];

    // So we can remove any partially written temp files on exception:
    TrackingDirectoryWrapper trackingDir = new TrackingDirectoryWrapper(dir);

    boolean success = false;
    boolean[] isExhausted = new boolean[1];
    try (ByteSequencesReader is = getReader(dir.openChecksumInput(inputFileName, IOContext.READONCE), inputFileName)) {
      while (isExhausted[0] == false) {
        int lineCount = readPartition(is, isExhausted);
        if (lineCount == 0) {
          assert isExhausted[0];
          break;
        }
        segments.add(sortPartition(trackingDir, lineCount));
        sortInfo.tempMergeFiles++;
        sortInfo.lineCount += lineCount;
        levelCounts[0]++;

        // Handle intermediate merges; we need a while loop to "cascade" the merge when necessary:
        int mergeLevel = 0;
        while (levelCounts[mergeLevel] == maxTempFiles) {
          mergePartitions(trackingDir, segments);
          if (mergeLevel+2 > levelCounts.length) {
            levelCounts = ArrayUtil.grow(levelCounts, mergeLevel+2);
          }
          levelCounts[mergeLevel+1]++;
          levelCounts[mergeLevel] = 0;
          mergeLevel++;
        }
      }
      
      // TODO: we shouldn't have to do this?  Can't we return a merged reader to
      // the caller, who often consumes the result just once, instead?

      // Merge all partitions down to 1 (basically a forceMerge(1)):
      while (segments.size() > 1) {     
        mergePartitions(trackingDir, segments);
      }

      String result;
      if (segments.isEmpty()) {
        try (IndexOutput out = trackingDir.createTempOutput(tempFileNamePrefix, "sort", IOContext.DEFAULT)) {
          // Write empty file footer
          CodecUtil.writeFooter(out);
          result = out.getName();
        }
      } else {
        result = segments.get(0).fileName;
      }

      // We should be explicitly removing all intermediate files ourselves unless there is an exception:
      assert trackingDir.getCreatedFiles().size() == 1 && trackingDir.getCreatedFiles().contains(result);

      sortInfo.totalTime = System.currentTimeMillis() - sortInfo.totalTime; 

      CodecUtil.checkFooter(is.in);

      success = true;

      return result;

    } finally {
      if (success == false) {
        IOUtils.deleteFilesIgnoringExceptions(trackingDir, trackingDir.getCreatedFiles());
      }
    }
  }

