  OfflinePointReader(Directory tempDir, String tempFileName, int packedBytesLength, long start, long length,
                     boolean longOrds, boolean singleValuePerDoc) throws IOException {
    this.singleValuePerDoc = singleValuePerDoc;
    int bytesPerDoc = packedBytesLength + Integer.BYTES;
    if (singleValuePerDoc == false) {
      if (longOrds) {
        bytesPerDoc += Long.BYTES;
      } else {
        bytesPerDoc += Integer.BYTES;
      }
    }

    if ((start + length) * bytesPerDoc + CodecUtil.footerLength() > tempDir.fileLength(tempFileName)) {
      throw new IllegalArgumentException("requested slice is beyond the length of this file: start=" + start + " length=" + length + " bytesPerDoc=" + bytesPerDoc + " fileLength=" + tempDir.fileLength(tempFileName) + " tempFileName=" + tempFileName);
    }

    // Best-effort checksumming:
    if (start == 0 && length*bytesPerDoc == tempDir.fileLength(tempFileName) - CodecUtil.footerLength()) {
      // If we are going to read the entire file, e.g. because BKDWriter is now
      // partitioning it, we open with checksums:
      in = tempDir.openChecksumInput(tempFileName, IOContext.READONCE);
    } else {
      // Since we are going to seek somewhere in the middle of a possibly huge
      // file, and not read all bytes from there, don't use ChecksumIndexInput here.
      // This is typically fine, because this same file will later be read fully,
      // at another level of the BKDWriter recursion
      in = tempDir.openInput(tempFileName, IOContext.READONCE);
    }

    long seekFP = start * bytesPerDoc;
    in.seek(seekFP);
    countLeft = length;
    packedValue = new byte[packedBytesLength];
    this.longOrds = longOrds;
  }

