  /** Reverse lookup (lookup by output instead of by input),
   *  in the special case when your FSTs outputs are
   *  strictly ascending.  This locates the input/output
   *  pair where the output is equal to the target, and will
   *  return null if that output does not exist.
   *
   *  <p>NOTE: this only works with {@code FST<Long>}, only
   *  works when the outputs are ascending in order with
   *  the inputs and only works when you shared
   *  the outputs (pass doShare=true to {@link
   *  PositiveIntOutputs#getSingleton}).
   *  For example, simple ordinals (0, 1,
   *  2, ...), or file offets (when appending to a file)
   *  fit this. */
  public static IntsRef getByOutput(FST<Long> fst, long targetOutput) throws IOException {

    final BytesReader in = fst.getBytesReader(0);

    // TODO: would be nice not to alloc this on every lookup
    FST.Arc<Long> arc = fst.getFirstArc(new FST.Arc<Long>());
    
    FST.Arc<Long> scratchArc = new FST.Arc<Long>();

    final IntsRef result = new IntsRef();
    
    return getByOutput(fst, targetOutput, in, arc, scratchArc, result);
  }

