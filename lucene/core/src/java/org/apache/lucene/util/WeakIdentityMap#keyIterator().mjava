  /** Returns an iterator over all weak keys of this map.
   * Keys already garbage collected will not be returned.
   * This Iterator does not support removals. */
  public Iterator<K> keyIterator() {
    reap();
    final Iterator<IdentityWeakReference> iterator = backingStore.keySet().iterator();
    return new Iterator<K>() {
      // holds strong reference to next element in backing iterator:
      private Object next = null;
      // the backing iterator was already consumed:
      private boolean nextIsSet = false;
    
      @Override
      public boolean hasNext() {
        return nextIsSet ? true : setNext();
      }
      
      @Override @SuppressWarnings("unchecked")
      public K next() {
        if (nextIsSet || setNext()) {
          try {
            assert nextIsSet;
            return (K) next;
          } finally {
             // release strong reference and invalidate current value:
            nextIsSet = false;
            next = null;
          }
        }
        throw new NoSuchElementException();
      }
      
      @Override
      public void remove() {
        throw new UnsupportedOperationException();
      }
      
      private boolean setNext() {
        assert !nextIsSet;
        while (iterator.hasNext()) {
          next = iterator.next().get();
          if (next == null) {
            // already garbage collected!
            continue;
          }
          // unfold "null" special value
          if (next == NULL) {
            next = null;
          }
          return nextIsSet = true;
        }
        return false;
      }
    };
  }

