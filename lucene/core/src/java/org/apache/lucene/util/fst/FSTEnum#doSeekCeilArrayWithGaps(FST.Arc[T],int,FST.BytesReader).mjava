  private FST.Arc<T> doSeekCeilArrayWithGaps(final FST.Arc<T> arc, final int targetLabel, final FST.BytesReader in) throws IOException {
    // The array is addressed directly by label and may contain holes.

    in.setPosition(arc.posArcsStart());
    in.skipBytes(1);
    int firstLabel = fst.readLabel(in);
    int arcOffset = targetLabel - firstLabel;
    if (arcOffset >= arc.numArcs()) {
      // target is beyond the last arc
      fst.readArcAtPosition(arc, in, arc.posArcsStart() - (arc.numArcs() - 1) * arc.bytesPerArc());
      assert arc.isLast();
      // Dead end (target is after the last arc);
      // rollback to last fork then push
      upto--;
      while(true) {
        if (upto == 0) {
          return null;
        }
        final FST.Arc<T> prevArc = getArc(upto);
        //System.out.println("  rollback upto=" + upto + " arc.label=" + prevArc.label + " isLast?=" + prevArc.isLast());
        if (!prevArc.isLast()) {
          fst.readNextArc(prevArc, fstReader);
          pushFirst();
          return null;
        }
        upto--;
      }
    } else {
      // TODO: if firstLabel == targetLabel
      long pos;
      if (arcOffset >= 0) {
        pos = arc.posArcsStart() - (arc.bytesPerArc() * arcOffset);
      } else {
        pos = arc.posArcsStart();
      }
      fst.readArcAtPosition(arc, in, pos);
      if (arc.label() == targetLabel) {
        // found -- copy pasta from below
        output[upto] = fst.outputs.add(output[upto-1], arc.output());
        if (targetLabel == FST.END_LABEL) {
          return null;
        }
        setCurrentLabel(arc.label());
        incr();
        return fst.readFirstTargetArc(arc, getArc(upto), fstReader);
      }
      // not found, return the next highest
      assert arc.label() > targetLabel;
      pushFirst();
      return null;
    }
  }

