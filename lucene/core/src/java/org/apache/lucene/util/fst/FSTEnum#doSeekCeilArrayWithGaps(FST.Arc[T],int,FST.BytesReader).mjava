  private FST.Arc<T> doSeekCeilArrayWithGaps(final FST.Arc<T> arc, final int targetLabel, final FST.BytesReader in) throws IOException {
    // The array is addressed directly by label and may contain holes.

    in.setPosition(arc.posArcsStart);
    in.skipBytes(1);
    int firstLabel = fst.readLabel(in);
    int arcOffset = targetLabel - firstLabel;
    if (arcOffset >= arc.numArcs) {
      // target is beyond the last arc
      arc.nextArc = arc.posArcsStart - (arc.numArcs - 1) * arc.bytesPerArc;
      fst.readNextRealArc(arc, in);
      assert arc.isLast();
      // Dead end (target is after the last arc);
      // rollback to last fork then push
      upto--;
      while(true) {
        if (upto == 0) {
          return null;
        }
        final FST.Arc<T> prevArc = getArc(upto);
        //System.out.println("  rollback upto=" + upto + " arc.label=" + prevArc.label + " isLast?=" + prevArc.isLast());
        if (!prevArc.isLast()) {
          fst.readNextArc(prevArc, fstReader);
          pushFirst();
          return null;
        }
        upto--;
      }
    } else {
      // TODO: if firstLabel == targetLabel
      if (arcOffset >= 0) {
        arc.nextArc = arc.posArcsStart - (arc.bytesPerArc * arcOffset);
      } else {
        arc.nextArc = arc.posArcsStart;
      }
      fst.readNextRealArc(arc, in);
      if (arc.label == targetLabel) {
        // found -- copy pasta from below
        output[upto] = fst.outputs.add(output[upto-1], arc.output);
        if (targetLabel == FST.END_LABEL) {
          return null;
        }
        setCurrentLabel(arc.label);
        incr();
        return fst.readFirstTargetArc(arc, getArc(upto), fstReader);
      }
      // not found, return the next highest
      assert arc.label > targetLabel;
      pushFirst();
      return null;
    }
  }

