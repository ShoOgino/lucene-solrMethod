  /**
   * <p>This method assumes valid UTF8 input. This method 
   * <strong>does not perform</strong> full UTF8 validation, it will check only the 
   * first byte of each codepoint (for multi-byte sequences any bytes after 
   * the head are skipped).  
   * 
   * @throws IllegalArgumentException If invalid codepoint header byte occurs or the 
   *    content is prematurely truncated.
   */
  public static void UTF8toUTF32(final BytesRef utf8, final IntsRef utf32) {
    // TODO: broken if incoming result.offset != 0
    // pre-alloc for worst case
    // TODO: ints cannot be null, should be an assert
    if (utf32.ints == null || utf32.ints.length < utf8.length) {
      utf32.ints = new int[utf8.length];
    }
    int utf32Count = 0;
    int utf8Upto = utf8.offset;
    final int[] ints = utf32.ints;
    final byte[] bytes = utf8.bytes;
    final int utf8Limit = utf8.offset + utf8.length;
    while(utf8Upto < utf8Limit) {
      final int numBytes = utf8CodeLength[bytes[utf8Upto] & 0xFF];
      int v = 0;
      switch(numBytes) {
      case 1:
        ints[utf32Count++] = bytes[utf8Upto++];
        continue;
      case 2:
        // 5 useful bits
        v = bytes[utf8Upto++] & 31;
        break;
      case 3:
        // 4 useful bits
        v = bytes[utf8Upto++] & 15;
        break;
      case 4:
        // 3 useful bits
        v = bytes[utf8Upto++] & 7;
        break;
      default :
        throw new IllegalArgumentException("invalid utf8");
      }

      // TODO: this may read past utf8's limit.
      final int limit = utf8Upto + numBytes-1;
      while(utf8Upto < limit) {
        v = v << 6 | bytes[utf8Upto++]&63;
      }
      ints[utf32Count++] = v;
    }
    
    utf32.offset = 0;
    utf32.length = utf32Count;
  }

