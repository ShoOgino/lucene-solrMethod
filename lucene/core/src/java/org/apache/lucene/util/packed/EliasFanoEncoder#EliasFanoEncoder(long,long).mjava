  /**
   * Construct an Elias-Fano encoder.
   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode
   * a non decreasing sequence of non negative numbers.
   * @param numValues The number of values that is to be encoded.
   * @param upperBound  At least the highest value that will be encoded.
   *                For space efficiency this should not exceed the power of two that equals
   *                or is the first higher than the actual maximum.
   *                <br>When <code>numValues >= (upperBound/3)</code>
   *                a {@link FixedBitSet} will take less space.
   * @throws IllegalArgumentException when:
   *         <ul>
   *         <li><code>numValues</code> is negative, or
   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or
   *         <li>the low bits do not fit in a <code>long[]</code>:
   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or
   *         <li>the high bits do not fit in a <code>long[]</code>:
   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>.
   *         </ul>
   */
  public EliasFanoEncoder(long numValues, long upperBound) {
    if (numValues < 0L) {
      throw new IllegalArgumentException("numValues should not be negative: " + numValues);
    }
    this.numValues = numValues;
    if ((numValues > 0L) && (upperBound < 0L)) {
      throw new IllegalArgumentException("upperBound should not be negative: " + upperBound + " when numValues > 0");
    }
    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound
    int nLowBits = 0;
    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))
      long lowBitsFac = this.upperBound / this.numValues;
      if (lowBitsFac > 0) {
        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs
      }
    }
    this.numLowBits = nLowBits;
    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);

    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);
    if (numLongsForLowBits > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("numLongsForLowBits too large to index a long array: " + numLongsForLowBits);
    }
    this.lowerLongs = new long[(int) numLongsForLowBits];

    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;
    assert numHighBitsClear <= (2 * this.numValues);
    long numHighBitsSet = this.numValues;

    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);
    if (numLongsForHighBits > Integer.MAX_VALUE) {
      throw new IllegalArgumentException("numLongsForHighBits too large to index a long array: " + numLongsForHighBits);
    }
    this.upperLongs = new long[(int) numLongsForHighBits];
  }

