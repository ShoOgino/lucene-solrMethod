    @Override
    public AttributeImpl createAttributeInstance(Class<? extends Attribute> attClass) {
      // first lookup from cache:
      Object cached = attClassImplMap.get(attClass);
      if (cached instanceof MethodHandle) {
        return invokeMethodHandle((MethodHandle) cached);
      } else if (cached instanceof Reference) {
        @SuppressWarnings("unchecked") final Class<? extends AttributeImpl> clazz = 
            ((Reference<Class<? extends AttributeImpl>>) cached).get();
        if (clazz != null) {
          return invokeReflective(clazz);
        }
        cached = null;
        // fall-through
      }
      // No cache hit!
      // Please note: we have the slight chance that another thread may do the same, but who cares?
      assert cached == null;
      final Class<? extends AttributeImpl> implClazz = findImplClass(attClass);
      // if the attribute impl is from our own ClassLoader, we optimize to use pre-allocated MethodHandle to instantiate the object
      if (useMethodHandles && implClazz.getClassLoader() == myClassLoader) {
        final MethodHandle constr = findAttributeImplCtor(implClazz);
        attClassImplMap.put(attClass, constr);
        return invokeMethodHandle(constr);
      } else {
        // otherwise, to not refer to the class forever (because the MethodHandle strongly
        // references the class), so it can never be unloaded, we use slower reflection:
        attClassImplMap.put(attClass, new WeakReference<>(implClazz));
        return invokeReflective(implClazz);
      }
    }

