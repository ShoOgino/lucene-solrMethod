    /** Compute the length of the next run, make the run sorted and return its
     *  length. */
    int nextRun() {
      final int runBase = runEnd(0);
      if (runBase == hi) {
        return 1;
      }
      int l = 1; // length of the run
      if (compare(runBase, runBase+1) > 0) {
        // run must be strictly descending
        while (runBase + l <= hi && compare(runBase + l - 1, runBase + l) > 0) {
          ++l;
        }
        if (l < minRun && runBase + l <= hi) {
          l = Math.min(hi - runBase + 1, minRun);
          binarySort(runBase, runBase + l - 1);
        } else {
          // revert
          for (int i = 0, halfL = l >>> 1; i < halfL; ++i) {
            swap(runBase + i, runBase + l - i - 1);
          }
        }
      } else {
        // run must be non-descending
        while (runBase + l <= hi && compare(runBase + l - 1, runBase + l) <= 0) {
          ++l;
        }
        if (l < minRun && runBase + l <= hi) {
          l = Math.min(hi - runBase + 1, minRun);
          binarySort(runBase, runBase + l - 1);
        } // else nothing to do, the run is already sorted
      }
      return l;
    }

