  private int findCommonPrefix(OfflinePointWriter points, long from, long to, int dim) throws IOException{
    //find common prefix
    byte[] commonPrefix = new byte[bytesSorted];
    int commonPrefixPosition = bytesSorted;
    try (OfflinePointReader reader = points.getReader(from, to - from, offlineBuffer)) {
      reader.next();
      reader.packedValueWithDocId(bytesRef1);
      // copy dimension
      System.arraycopy(bytesRef1.bytes, bytesRef1.offset + dim * bytesPerDim, commonPrefix, 0, bytesPerDim);
      // copy docID
      System.arraycopy(bytesRef1.bytes, bytesRef1.offset + packedBytesLength, commonPrefix, bytesPerDim, Integer.BYTES);
      for (long i = from + 1; i< to; i++) {
        reader.next();
        reader.packedValueWithDocId(bytesRef1);
        int startIndex =  dim * bytesPerDim;
        int endIndex  = (commonPrefixPosition > bytesPerDim) ? startIndex + bytesPerDim :  startIndex + commonPrefixPosition;
        int j = FutureArrays.mismatch(commonPrefix, 0, endIndex - startIndex, bytesRef1.bytes, bytesRef1.offset + startIndex, bytesRef1.offset + endIndex);
        if (j == 0) {
          return 0;
        } else if (j == -1) {
          if (commonPrefixPosition > bytesPerDim) {
            //tie-break on docID
            int k = FutureArrays.mismatch(commonPrefix, bytesPerDim, commonPrefixPosition, bytesRef1.bytes, bytesRef1.offset + packedBytesLength, bytesRef1.offset + packedBytesLength + commonPrefixPosition - bytesPerDim );
            if (k != -1) {
              commonPrefixPosition = bytesPerDim + k;
            }
          }
        } else {
          commonPrefixPosition = j;
        }
      }
    }

    //build histogram up to the common prefix
    for (int i = 0; i < commonPrefixPosition; i++) {
      partitionBucket[i] = commonPrefix[i] & 0xff;
      histogram[i][partitionBucket[i]] = to - from;
    }
    return commonPrefixPosition;
  }

