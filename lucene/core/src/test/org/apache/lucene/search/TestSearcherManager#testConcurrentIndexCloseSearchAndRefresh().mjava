  public void testConcurrentIndexCloseSearchAndRefresh() throws Exception {
    final Directory dir = newFSDirectory(createTempDir());
    AtomicReference<IndexWriter> writerRef = new AtomicReference<>();
    final MockAnalyzer analyzer = new MockAnalyzer(random());
    analyzer.setMaxTokenLength(IndexWriter.MAX_TERM_LENGTH);
    writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));

    AtomicReference<SearcherManager> mgrRef = new AtomicReference<>();
    mgrRef.set(new SearcherManager(writerRef.get(), null));
    final AtomicBoolean stop = new AtomicBoolean();

    Thread indexThread = new Thread() {
        @Override
        public void run() {
          try {
            LineFileDocs docs = new LineFileDocs(random());
            long runTimeSec = TEST_NIGHTLY ? atLeast(10) : atLeast(2);
            long endTime = System.nanoTime() + runTimeSec * 1000000000;
            while (System.nanoTime() < endTime) {
              IndexWriter w = writerRef.get();
              w.addDocument(docs.nextDoc());
              if (random().nextInt(1000) == 17) {
                if (random().nextBoolean()) {
                  w.close();
                } else {
                  w.rollback();
                }
                writerRef.set(new IndexWriter(dir, newIndexWriterConfig(analyzer)));
              }
            }
            docs.close();
            if (VERBOSE) {
              System.out.println("TEST: index count=" + writerRef.get().getDocStats().maxDoc);
            }
          } catch (IOException ioe) {
            throw new RuntimeException(ioe);
          } finally {
            stop.set(true);
          }
        }
      };

    Thread searchThread = new Thread() {
        @Override
        public void run() {
          try {
            long totCount = 0;
            while (stop.get() == false) {
              SearcherManager mgr = mgrRef.get();
              if (mgr != null) {
                IndexSearcher searcher;
                try {
                  searcher = mgr.acquire();
                } catch (AlreadyClosedException ace) {
                  // ok
                  continue;
                }
                totCount += searcher.getIndexReader().maxDoc();
                mgr.release(searcher);
              }
            }
            if (VERBOSE) {
              System.out.println("TEST: search totCount=" + totCount);
            }
          } catch (IOException ioe) {
            throw new RuntimeException(ioe);
          }
        }
      };

    Thread refreshThread = new Thread() {
        @Override
        public void run() {
          try {
            int refreshCount = 0;
            int aceCount = 0;
            while (stop.get() == false) {
              SearcherManager mgr = mgrRef.get();
              if (mgr != null) {
                refreshCount++;
                try {
                  mgr.maybeRefreshBlocking();
                } catch (AlreadyClosedException ace) {
                  // ok
                  aceCount++;
                  continue;
                }
              }
            }
            if (VERBOSE) {
              System.out.println("TEST: refresh count=" + refreshCount + " aceCount=" + aceCount);
            }
          } catch (IOException ioe) {
            throw new RuntimeException(ioe);
          }
        }
      };

    Thread closeThread = new Thread() {
        @Override
        public void run() {
          try {
            int closeCount = 0;
            int aceCount = 0;
            while (stop.get() == false) {
              SearcherManager mgr = mgrRef.get();
              assert mgr != null;
              mgr.close();
              closeCount++;
              while (stop.get() == false) {
                try {
                  mgrRef.set(new SearcherManager(writerRef.get(), null));
                  break;
                } catch (AlreadyClosedException ace) {
                  // ok
                  aceCount++;
                }
              }
            }
            if (VERBOSE) {
              System.out.println("TEST: close count=" + closeCount + " aceCount=" + aceCount);
            }
          } catch (IOException ioe) {
            throw new RuntimeException(ioe);
          }
        }
      };

    indexThread.start();
    searchThread.start();
    refreshThread.start();
    closeThread.start();

    indexThread.join();
    searchThread.join();
    refreshThread.join();
    closeThread.join();

    mgrRef.get().close();
    writerRef.get().close();
    dir.close();
  }

