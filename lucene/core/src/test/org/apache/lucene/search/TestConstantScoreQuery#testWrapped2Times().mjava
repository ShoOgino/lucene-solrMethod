  public void testWrapped2Times() throws Exception {
    Directory directory = null;
    IndexReader reader = null;
    IndexSearcher searcher = null;
    try {
      directory = newDirectory();
      RandomIndexWriter writer = new RandomIndexWriter (random(), directory);

      Document doc = new Document();
      doc.add(newStringField("field", "term", Field.Store.NO));
      writer.addDocument(doc);

      reader = writer.getReader();
      writer.close();
      // we don't wrap with AssertingIndexSearcher in order to have the original scorer in setScorer.
      searcher = newSearcher(reader, true, false);
      searcher.setQueryCache(null); // to assert on scorer impl
      
      // set a similarity that does not normalize our boost away
      searcher.setSimilarity(new DefaultSimilarity() {
        @Override
        public float queryNorm(float sumOfSquaredWeights) {
          return 1.0f;
        }
      });
      
      final Query csq1 = new ConstantScoreQuery(new TermQuery(new Term ("field", "term")));
      csq1.setBoost(2.0f);
      final Query csq2 = new ConstantScoreQuery(csq1);
      csq2.setBoost(5.0f);
      
      final BooleanQuery.Builder bq = new BooleanQuery.Builder();
      bq.add(csq1, BooleanClause.Occur.SHOULD);
      bq.add(csq2, BooleanClause.Occur.SHOULD);
      
      final Query csqbq = new ConstantScoreQuery(bq.build());
      csqbq.setBoost(17.0f);
      
      checkHits(searcher, csq1, csq1.getBoost(), TermScorer.class);
      checkHits(searcher, csq2, csq2.getBoost(), TermScorer.class);
      
      // for the combined BQ, the scorer should always be BooleanScorer's BucketScorer, because our scorer supports out-of order collection!
      final Class<FakeScorer> bucketScorerClass = FakeScorer.class;
      checkHits(searcher, csqbq, csqbq.getBoost(), bucketScorerClass);
    } finally {
      IOUtils.close(reader, directory);
    }
  }

