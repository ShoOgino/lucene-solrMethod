  public void testEmptyBucketWithMoreDocs() throws Exception {
    // This test checks the logic of nextDoc() when all sub scorers have docs
    // beyond the first bucket (for example). Currently, the code relies on the
    // 'more' variable to work properly, and this test ensures that if the logic
    // changes, we have a test to back it up.
    
    Directory directory = newDirectory();
    RandomIndexWriter writer = new RandomIndexWriter(random(), directory);
    writer.commit();
    IndexReader ir = writer.getReader();
    writer.close();
    IndexSearcher searcher = newSearcher(ir);
    BooleanWeight weight = (BooleanWeight) new BooleanQuery().createWeight(searcher);
    BulkScorer[] scorers = new BulkScorer[] {new BulkScorer() {
      private int doc = -1;

      @Override
      public boolean score(Collector c, int maxDoc) throws IOException {
        assert doc == -1;
        doc = 3000;
        c.setScorer(new Scorer(null) {
            @Override
            public int advance(int target) {
              throw new UnsupportedOperationException("FakeScorer doesn't support advance(int)");
            }

            @Override
            public int docID() {
              return doc;
            }

            @Override
            public int freq() {
              throw new UnsupportedOperationException("FakeScorer doesn't support freq()");
            }

            @Override
            public int nextDoc() {
              throw new UnsupportedOperationException("FakeScorer doesn't support nextDoc()");
            }
    
            @Override
            public float score() {
              return 1.0f;
            }

            @Override
            public long cost() {
              return 1;
            }
          });
        c.collect(3000);
        return false;
      }
    }};
    
    BooleanScorer bs = new BooleanScorer(weight, false, 1, Arrays.asList(scorers), Collections.<BulkScorer>emptyList(), scorers.length);

    final List<Integer> hits = new ArrayList<Integer>();
    bs.score(new Collector() {
      int docBase;
      @Override
      public void setScorer(Scorer scorer) {
      }
      
      @Override
      public void collect(int doc) {
        hits.add(docBase+doc);
      }
      
      @Override
      public void setNextReader(AtomicReaderContext context) {
        docBase = context.docBase;
      }
      
      @Override
      public boolean acceptsDocsOutOfOrder() {
        return true;
      }
      });

    assertEquals("should have only 1 hit", 1, hits.size());
    assertEquals("hit should have been docID=3000", 3000, hits.get(0).intValue());
    ir.close();
    directory.close();
  }

