  public void testLRUConcurrentLoadsOfSameQuery() throws Exception {
    Directory dir = newDirectory();
    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);

    Document doc = new Document();
    StringField f = new StringField("color", "blue", Store.NO);
    doc.add(f);
    w.addDocument(doc);
    f.setStringValue("red");
    w.addDocument(doc);
    f.setStringValue("green");
    w.addDocument(doc);
    final DirectoryReader reader = w.getReader();
    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache"));

    ExecutorService stressService = new ThreadPoolExecutor(15, 15, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache2"));

    IndexSearcher searcher = new IndexSearcher(reader, service);

    final CountDownLatch latch = new CountDownLatch(1);

    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY) {
      @Override
      protected void onDocIdSetCache(Object readerCoreKey, long ramBytesUsed) {
        super.onDocIdSetCache(readerCoreKey, ramBytesUsed);
        latch.countDown();
      }
    };

    final Query green = new TermQuery(new Term("color", "green"));

    assertEquals(Collections.emptyList(), queryCache.cachedQueries());

    searcher.setQueryCache(queryCache);
    searcher.setQueryCachingPolicy(ALWAYS_CACHE);

    CountDownLatch startLatch = new CountDownLatch(1);

    FutureTask<Void> task = new FutureTask<>(() -> {
      startLatch.await();
      searcher.search(new ConstantScoreQuery(green), 1);
      return null;
    });

    for (int i = 0; i < 5; i++) {
      stressService.submit(task);
    }

    startLatch.countDown();

    latch.await();
    assertEquals(Arrays.asList(green), queryCache.cachedQueries());

    reader.close();
    w.close();
    dir.close();
    service.shutdown();
    stressService.shutdown();
  }

