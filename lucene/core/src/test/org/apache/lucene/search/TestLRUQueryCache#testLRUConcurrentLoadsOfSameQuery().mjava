  public void testLRUConcurrentLoadsOfSameQuery() throws Exception {
    Directory dir = newDirectory();
    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);

    Document doc = new Document();
    StringField f = new StringField("color", "blue", Store.NO);
    doc.add(f);
    w.addDocument(doc);
    f.setStringValue("red");
    w.addDocument(doc);
    f.setStringValue("green");
    w.addDocument(doc);
    final DirectoryReader reader = w.getReader();
    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache"));

    ExecutorService stressService = new ThreadPoolExecutor(15, 15, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache2"));

    IndexSearcher searcher = new IndexSearcher(reader, service);

    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true);

    final Query green = new TermQuery(new Term("color", "green"));

    assertEquals(Collections.emptyList(), queryCache.cachedQueries());

    searcher.setQueryCache(queryCache);
    searcher.setQueryCachingPolicy(ALWAYS_CACHE);

    FutureTask<Void> task = new FutureTask<>(() -> {
      searcher.search(new ConstantScoreQuery(green), 1);
      assertEquals(1, queryCache.inFlightQueries().size());
      return null;
    });

    for (int i = 0; i < 5; i++) {
      stressService.submit(task);
    }

    Thread.sleep(3000);
    assertEquals(Arrays.asList(green), queryCache.cachedQueries());

    reader.close();
    w.close();
    dir.close();
    service.shutdown();
    stressService.shutdown();
  }

