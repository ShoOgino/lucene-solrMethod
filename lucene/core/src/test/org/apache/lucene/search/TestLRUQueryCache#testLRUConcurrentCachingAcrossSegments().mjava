  public void testLRUConcurrentCachingAcrossSegments() throws Exception {
    Directory dir = newDirectory();
    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);

    int numDocs = atLeast(150);
    int numIterations = atLeast(3);

    for (int i = 0; i < numIterations; i++) {
      for (int j = 0; j < numDocs; j++) {
        Document doc = new Document();
        StringField f = new StringField("color", "blue", Store.NO);
        doc.add(f);
        w.addDocument(doc);
        w.addDocument(doc);
        w.addDocument(doc);
      }
      w.commit();
    }

    final DirectoryReader reader = w.getReader();

    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache"));

    IndexSearcher searcher = new IndexSearcher(reader, service) {
      @Override
      protected LeafSlice[] slices(List<LeafReaderContext> leaves) {
        ArrayList<LeafSlice> slices = new ArrayList<>();
        for (LeafReaderContext ctx : leaves) {
          slices.add(new LeafSlice(Arrays.asList(ctx)));
        }
        return slices.toArray(new LeafSlice[0]);
      }
    };

    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY);

    final Query blue = new TermQuery(new Term("color", "blue"));

    assertEquals(Collections.emptyList(), queryCache.cachedQueries());

    searcher.setQueryCache(queryCache);
    searcher.setQueryCachingPolicy(ALWAYS_CACHE);
    assert searcher.getSlices().length > 1;

    searcher.search(new ConstantScoreQuery(blue), 1);

    reader.close();
    w.close();
    dir.close();
    service.shutdown();
  }

