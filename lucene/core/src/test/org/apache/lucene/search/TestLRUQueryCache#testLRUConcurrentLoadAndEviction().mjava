  public void testLRUConcurrentLoadAndEviction() throws Exception {
    Directory dir = newDirectory();
    final RandomIndexWriter w = new RandomIndexWriter(random(), dir);

    Document doc = new Document();
    StringField f = new StringField("color", "blue", Store.NO);
    doc.add(f);
    w.addDocument(doc);
    f.setStringValue("red");
    w.addDocument(doc);
    f.setStringValue("green");
    w.addDocument(doc);
    final DirectoryReader reader = w.getReader();
    ExecutorService service = new ThreadPoolExecutor(4, 4, 0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(),
        new NamedThreadFactory("TestLRUQueryCache"));

    IndexSearcher searcher = new IndexSearcher(reader, service);

    final CountDownLatch[] latch = {new CountDownLatch(1)};

    final LRUQueryCache queryCache = new LRUQueryCache(2, 100000, context -> true, Float.POSITIVE_INFINITY) {
      @Override
      protected void onDocIdSetCache(Object readerCoreKey, long ramBytesUsed) {
        super.onDocIdSetCache(readerCoreKey, ramBytesUsed);
        latch[0].countDown();
      }
    };

    final Query blue = new TermQuery(new Term("color", "blue"));
    final Query red = new TermQuery(new Term("color", "red"));
    final Query green = new TermQuery(new Term("color", "green"));

    assertEquals(Collections.emptyList(), queryCache.cachedQueries());

    searcher.setQueryCache(queryCache);
    // the filter is not cached on any segment: no changes
    searcher.setQueryCachingPolicy(NEVER_CACHE);
    searcher.search(new ConstantScoreQuery(green), 1);
    assertEquals(Collections.emptyList(), queryCache.cachedQueries());

    searcher.setQueryCachingPolicy(ALWAYS_CACHE);

    // First read should miss
    searcher.search(new ConstantScoreQuery(red), 1);

    // Let the cache load be completed
    latch[0].await();
    assertEquals(Collections.singletonList(red), queryCache.cachedQueries());

    // Second read should hit
    searcher.search(new ConstantScoreQuery(red), 1);
    assertEquals(Collections.singletonList(red), queryCache.cachedQueries());
    assertEquals(queryCache.getHitCount(), 1);

    latch[0] = new CountDownLatch(1);
    searcher.search(new ConstantScoreQuery(green), 1);

    // Let the cache load be completed
    latch[0].await();
    assertEquals(Arrays.asList(red, green), queryCache.cachedQueries());

    searcher.search(new ConstantScoreQuery(red), 1);
    assertEquals(Arrays.asList(green, red), queryCache.cachedQueries());
    assertEquals(2, queryCache.getCacheCount());

    latch[0] = new CountDownLatch(1);

    searcher.search(new ConstantScoreQuery(blue), 1);

    // Let the cache load be completed
    latch[0].await();
    assertEquals(Arrays.asList(red, blue), queryCache.cachedQueries());

    searcher.search(new ConstantScoreQuery(blue), 1);
    assertEquals(Arrays.asList(red, blue), queryCache.cachedQueries());
    assertEquals(3, queryCache.getCacheCount());

    latch[0] = new CountDownLatch(1);

    searcher.search(new ConstantScoreQuery(green), 1);

    // Let the cache load be completed
    latch[0].await();
    assertEquals(Arrays.asList(blue, green), queryCache.cachedQueries());

    service.shutdown();
    service.awaitTermination(300, TimeUnit.MILLISECONDS);

    searcher.setQueryCachingPolicy(NEVER_CACHE);
    searcher.search(new ConstantScoreQuery(red), 1);
    assertEquals(Arrays.asList(blue, green), queryCache.cachedQueries());

    reader.close();
    w.close();
    dir.close();
  }

