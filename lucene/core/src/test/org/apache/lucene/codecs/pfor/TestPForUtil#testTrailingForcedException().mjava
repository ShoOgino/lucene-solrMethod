  /**
   * Test correctness of ignored forced exception.
   * The trailing forced exceptions should always be reverted
   * since they're not necessary. 
   */
  public void testTrailingForcedException() throws Exception {
    initRandom();
    int sz=ForPostingsFormat.DEFAULT_BLOCK_SIZE;
    assert sz % 32 == 0;
    Integer[] buff= new Integer[sz];
    int[] data = new int[sz];
    int[] copy = new int[sz];
    byte[] res = new byte[sz*8];
    IntBuffer resBuffer = ByteBuffer.wrap(res).asIntBuffer();

    int excIndex = gen.nextInt(sz/2);
    int excValue = gen.nextInt();
    if ((excValue & 0xffff0000) == 0) {
      excValue |= 0xffff0000; // always prepare a 4 bytes exception
    }

    // make value of numFrameBits to be small, 
    // thus easy to get forced exceptions
    for (int i=0; i<sz; ++i) {
      buff[i]=gen.nextInt() & 1;
    }
    // create only one value exception
    buff[excIndex]=excValue;

    for (int i=0; i<sz; ++i)
      data[i] = buff[i];

    int header = PForUtil.compress(data,resBuffer);
    int ensz = PForUtil.getEncodedSize(header);

    assert (ensz <= sz*8): ensz+" > "+sz*8;  // must not exceed the loose upperbound
    assert (ensz >= 4);       // at least we have an exception, right?

    PForUtil.decompress(resBuffer,copy,header);

//    println(getHex(data,sz)+"\n");
//    println(getHex(res,ensz)+"\n");
//    println(getHex(copy,sz)+"\n");

    // fetch the last int, i.e. last exception.
    int lastExc = (res[ensz-4] << 24) | 
         ((0xff & res[ensz-3]) << 16) | 
         ((0xff & res[ensz-2]) << 8 ) | 
          (0xff & res[ensz-1]);

    // trailing forced exceptions are suppressed, 
    // so the last exception should be what we assigned. 
    assert lastExc==excValue;  
    assert cmp(data,sz,copy,sz)==true;
  }

