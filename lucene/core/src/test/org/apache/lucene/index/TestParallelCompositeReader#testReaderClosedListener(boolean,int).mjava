  private void testReaderClosedListener(boolean closeSubReaders, int wrapMultiReaderType) throws IOException {
    final Directory dir1 = getDir1(random());
    final CompositeReader ir2, ir1 = DirectoryReader.open(dir1);
    switch (wrapMultiReaderType) {
      case 0:
        ir2 = ir1;
        break;
      case 1:
        // default case, does close subreaders:
        ir2 = new MultiReader(ir1); break;
      case 2:
        ir2 = new MultiReader(new CompositeReader[] {ir1}, false); break;
      default:
        throw new AssertionError();
    }
    
    // with overlapping
    ParallelCompositeReader pr = new ParallelCompositeReader(closeSubReaders,
     new CompositeReader[] {ir2},
     new CompositeReader[] {ir2});

    final int[] listenerClosedCount = new int[1];

    assertEquals(3, pr.leaves().size());

    for(LeafReaderContext cxt : pr.leaves()) {
      cxt.reader().addReaderClosedListener(reader -> listenerClosedCount[0]++);
    }
    pr.close();
    if (!closeSubReaders) {
      ir1.close();
    }
    assertEquals(3, listenerClosedCount[0]);
    
    // We have to close the extra MultiReader, because it will not close its own subreaders:
    if (wrapMultiReaderType == 2) {
      ir2.close();
    }
    dir1.close();
  }

