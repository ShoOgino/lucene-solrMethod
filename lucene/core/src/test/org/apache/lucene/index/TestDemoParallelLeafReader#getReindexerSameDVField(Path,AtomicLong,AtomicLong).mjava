  /** Schema change by adding changing how the same "number" DV field is indexed. */
  private ReindexingReader getReindexerSameDVField(Path root, final AtomicLong currentSchemaGen, final AtomicLong mergingSchemaGen) throws IOException {
    return new ReindexingReader(root) {
      @Override
      protected IndexWriterConfig getIndexWriterConfig() throws IOException {
        return newIndexWriterConfig();
      }

      @Override
      protected Directory openDirectory(Path path) throws IOException {
        MockDirectoryWrapper dir = newMockFSDirectory(path);
        dir.setUseSlowOpenClosers(false);
        dir.setThrottling(Throttling.NEVER);
        return dir;
      }

      @Override
      protected void reindex(long oldSchemaGen, long newSchemaGen, LeafReader reader, Directory parallelDir) throws IOException {
        IndexWriterConfig iwc = newIndexWriterConfig();

        // The order of our docIDs must precisely matching incoming reader:
        iwc.setMergePolicy(new LogByteSizeMergePolicy());
        IndexWriter w = new IndexWriter(parallelDir, iwc);
        int maxDoc = reader.maxDoc();

        if (oldSchemaGen <= 0) {
          // Must slowly parse the stored field into a new doc values field:
          for(int i=0;i<maxDoc;i++) {
            // TODO: is this still O(blockSize^2)?
            StoredDocument oldDoc = reader.document(i);
            Document newDoc = new Document();
            long value = Long.parseLong(oldDoc.get("text").split(" ")[1]);
            newDoc.add(new NumericDocValuesField("number", newSchemaGen*value));
            newDoc.add(new LongField("number", value, Field.Store.NO));
            w.addDocument(newDoc);
          }
        } else {
          // Just carry over doc values from previous field:
          NumericDocValues oldValues = reader.getNumericDocValues("number");
          assertNotNull("oldSchemaGen=" + oldSchemaGen, oldValues);
          for(int i=0;i<maxDoc;i++) {
            // TODO: is this still O(blockSize^2)?
            StoredDocument oldDoc = reader.document(i);
            Document newDoc = new Document();
            newDoc.add(new NumericDocValuesField("number", newSchemaGen*(oldValues.get(i)/oldSchemaGen)));
            w.addDocument(newDoc);
          }
        }

        if (random().nextBoolean()) {
          w.forceMerge(1);
        }

        w.close();
      }

      @Override
      protected long getCurrentSchemaGen() {
        return currentSchemaGen.get();
      }

      @Override
      protected long getMergingSchemaGen() {
        return mergingSchemaGen.get();
      }

      @Override
      protected void checkParallelReader(LeafReader r, LeafReader parR, long schemaGen) throws IOException {
        if (DEBUG) System.out.println(Thread.currentThread().getName() + ": TEST: now check parallel number DVs r=" + r + " parR=" + parR);
        NumericDocValues numbers = parR.getNumericDocValues("numbers");
        if (numbers == null) {
          return;
        }
        int maxDoc = r.maxDoc();
        boolean failed = false;
        for(int i=0;i<maxDoc;i++) {
          StoredDocument oldDoc = r.document(i);
          long value = Long.parseLong(oldDoc.get("text").split(" ")[1]);
          value *= schemaGen;
          if (value != numbers.get(i)) {
            System.out.println("FAIL: docID=" + i + " " + oldDoc+ " value=" + value + " number=" + numbers.get(i) + " numbers=" + numbers);
            failed = true;
          } else if (failed) {
            System.out.println("OK: docID=" + i + " " + oldDoc+ " value=" + value + " number=" + numbers.get(i));
          }
        }
        assertFalse("FAILED r=" + r, failed);
      }
    };
  }

