  /**
   * Indexes at least 1 document with f1, and at least 1 document with f2.
   * returns the norms for "field".
   */
  byte[] getNorms(String field, Field f1, Field f2) throws IOException {
    Directory dir = newDirectory();
    IndexWriterConfig iwc = newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy());
    RandomIndexWriter riw = new RandomIndexWriter(random(), dir, iwc);
    
    // add f1
    Document d = new Document();
    d.add(f1);
    riw.addDocument(d);
    
    // add f2
    d = new Document();
    d.add(f2);
    riw.addDocument(d);
    
    // add a mix of f1's and f2's
    int numExtraDocs = _TestUtil.nextInt(random(), 1, 1000);
    for (int i = 0; i < numExtraDocs; i++) {
      d = new Document();
      d.add(random().nextBoolean() ? f1 : f2);
      riw.addDocument(d);
    }

    IndexReader ir1 = riw.getReader();
    // todo: generalize
    DocValues dv1 = MultiDocValues.getNormDocValues(ir1, field);
    byte[] norms1 = dv1 == null ? null : (byte[]) dv1.getSource().getArray();
    
    // fully merge and validate MultiNorms against single segment.
    riw.forceMerge(1);
    DirectoryReader ir2 = riw.getReader();
    DocValues dv2 = getOnlySegmentReader(ir2).normValues(field);
    byte[] norms2 = dv2 == null ? null : (byte[]) dv2.getSource().getArray();
    
    assertArrayEquals(norms1, norms2);
    ir1.close();
    ir2.close();
    riw.close();
    dir.close();
    return norms1;
  }

