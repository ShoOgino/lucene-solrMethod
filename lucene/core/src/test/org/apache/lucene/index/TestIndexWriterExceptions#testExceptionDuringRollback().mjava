  public void testExceptionDuringRollback() throws Exception {
    // currently: fail in two different places
    final String messageToFailOn = random().nextBoolean() ? 
        "rollback: done finish merges" : "rollback before checkpoint";
    
    // infostream that throws exception during rollback
    InfoStream evilInfoStream = new InfoStream() {
      @Override
      public void message(String component, String message) {
        if (messageToFailOn.equals(message)) {
          throw new RuntimeException("BOOM!");
        }
      }

      @Override
      public boolean isEnabled(String component) {
        return true;
      }
      
      @Override
      public void close() throws IOException {}
    };
    
    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles
    IndexWriterConfig iwc = new IndexWriterConfig(null);
    iwc.setInfoStream(evilInfoStream);
    IndexWriter iw = new IndexWriter(dir, iwc);
    // TODO: cutover to RandomIndexWriter.mockIndexWriter?
    iw.enableTestPoints = true;
    Document doc = new Document();
    for (int i = 0; i < 10; i++) {
      iw.addDocument(doc);
    }
    iw.commit();

    iw.addDocument(doc);
    
    // pool readers
    DirectoryReader r = DirectoryReader.open(iw, false);

    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N
    if (random().nextBoolean()) {
      iw.prepareCommit();
    }
    
    try {
      iw.rollback();
      fail();
    } catch (RuntimeException expected) {
      assertEquals("BOOM!", expected.getMessage());
    }
    
    r.close();
    
    // even though we hit exception: we are closed, no locks or files held, index in good state
    assertTrue(iw.isClosed());
    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();
    
    r = DirectoryReader.open(dir);
    assertEquals(10, r.maxDoc());
    r.close();
    
    // no leaks
    dir.close();
  }

