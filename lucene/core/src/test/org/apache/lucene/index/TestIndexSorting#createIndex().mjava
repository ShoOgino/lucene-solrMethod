  @BeforeClass
  public static void createIndex() throws Exception {
    dir = newFSDirectory(createTempDir());
    int numDocs = atLeast(100);

    List<Integer> ids = new ArrayList<>();
    for (int i = 0; i < numDocs; i++) {
      ids.add(Integer.valueOf(i * 10));
    }
    // shuffle them for indexing
    Collections.shuffle(ids, random());
    if (VERBOSE) {
      System.out.println("Shuffled IDs for indexing: " + Arrays.toString(ids.toArray()));
    }
    
    PositionsTokenStream positions = new PositionsTokenStream();
    IndexWriterConfig conf = newIndexWriterConfig(new MockAnalyzer(random()));
    // nocommit:
    conf.setCodec(new SimpleTextCodec());
    conf.setMaxBufferedDocs(4); // create some segments
    conf.setSimilarity(new NormsSimilarity(conf.getSimilarity())); // for testing norms field
    // nocommit
    conf.setMergeScheduler(new SerialMergeScheduler());
    // sort the index by id (as integer, in NUMERIC_DV_FIELD)
    conf.setIndexSort(new Sort(new SortField(NUMERIC_DV_FIELD, SortField.Type.INT)));
    RandomIndexWriter writer = new RandomIndexWriter(random(), dir, conf);
    writer.setDoRandomForceMerge(false);
    for (int id : ids) {
      writer.addDocument(doc(id, positions));
    }
    // delete some documents
    writer.commit();
    // nocommit need thread safety test too
    for (Integer id : ids) {
      if (random().nextDouble() < 0.2) {
        if (VERBOSE) {
          System.out.println("delete doc_id " + id);
        }
        writer.deleteDocuments(new Term(ID_FIELD, id.toString()));
      }
    }
    
    sortedReader = writer.getReader();
    writer.close();
    
    TestUtil.checkReader(sortedReader);
  }

