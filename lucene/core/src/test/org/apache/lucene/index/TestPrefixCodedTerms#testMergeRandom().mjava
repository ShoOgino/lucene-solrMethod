  @SuppressWarnings({"unchecked","rawtypes"})
  public void testMergeRandom() {
    PrefixCodedTerms pb[] = new PrefixCodedTerms[TestUtil.nextInt(random(), 2, 10)];
    Set<Term> superSet = new TreeSet<>();
    
    for (int i = 0; i < pb.length; i++) {
      Set<Term> terms = new TreeSet<>();
      int nterms = TestUtil.nextInt(random(), 0, 10000);
      for (int j = 0; j < nterms; j++) {
        String field = TestUtil.randomUnicodeString(random(), 2);
        //String field = TestUtil.randomSimpleString(random(), 2);
        Term term = new Term(field, TestUtil.randomUnicodeString(random(), 4));
        terms.add(term);
      }
      superSet.addAll(terms);
    
      PrefixCodedTerms.Builder b = new PrefixCodedTerms.Builder();
      //System.out.println("TEST: sub " + i + " has " + terms.size() + " terms");
      for (Term ref: terms) {
        //System.out.println("  add " + ref.field() + " " + ref.bytes());
        b.add(ref);
      }
      pb[i] = b.finish();
    }
    
    Iterator<Term> expected = superSet.iterator();

    MergedPrefixCodedTermsIterator actual = new MergedPrefixCodedTermsIterator(Arrays.asList(pb));
    String field = "";

    BytesRef lastTerm = null;

    while (true) {
      if (actual.next()) {
        field = actual.field();
        if (field == null) {
          break;
        }
        lastTerm = null;
        //System.out.println("\nTEST: new field: " + field);
      }
      if (lastTerm != null && lastTerm.equals(actual.term())) {
        continue;
      }
      //System.out.println("TEST: iter: field=" + field + " term=" + actual.term());
      lastTerm = BytesRef.deepCopyOf(actual.term());
      assertTrue(expected.hasNext());

      Term expectedTerm = expected.next();
      assertEquals(expectedTerm, new Term(field, actual.term()));
    }

    assertFalse(expected.hasNext());
  }

