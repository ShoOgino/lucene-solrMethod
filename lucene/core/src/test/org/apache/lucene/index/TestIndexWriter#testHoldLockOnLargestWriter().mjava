  public void testHoldLockOnLargestWriter() throws IOException, InterruptedException {
    Directory dir = newDirectory();
    IndexWriter w = new IndexWriter(dir, new IndexWriterConfig());
    int numDocs = indexDocsForMultipleThreadStates(w);
    DocumentsWriterPerThreadPool.ThreadState largestNonPendingWriter
        = w.docWriter.flushControl.findLargestNonPendingWriter();
    assertFalse(largestNonPendingWriter.flushPending);
    assertNotNull(largestNonPendingWriter.dwpt);

    CountDownLatch wait = new CountDownLatch(1);
    CountDownLatch locked = new CountDownLatch(1);
    Thread lockThread = new Thread(() -> {
      try {
        largestNonPendingWriter.lock();
        locked.countDown();
        wait.await();
      } catch (InterruptedException e) {
        throw new AssertionError(e);
      } finally {
        largestNonPendingWriter.unlock();
      }
    });
    lockThread.start();
    Thread flushThread = new Thread(() -> {
      try {
        locked.await();
        assertTrue(w.flushNextBuffer());
      } catch (Exception e) {
        throw new AssertionError(e);
      }
    });
    flushThread.start();

    locked.await();
    // access a synced method to ensure we never lock while we hold the flush control monitor
    w.docWriter.flushControl.activeBytes();
    wait.countDown();
    lockThread.join();
    flushThread.join();

    assertNull("largest DWPT should be flushed", largestNonPendingWriter.dwpt);
    // make sure it's not locked
    largestNonPendingWriter.lock();
    largestNonPendingWriter.unlock();
    if (random().nextBoolean()) {
      w.commit();
    }
    DirectoryReader reader = DirectoryReader.open(w, true, true);
    assertEquals(numDocs, reader.numDocs());
    reader.close();
    w.close();
    dir.close();
  }

