  /** If polygon.intersects(box) returns false, then any point in that box should return false as well */
  public void testIntersectRandom() {
    for (int i = 0; i < 100; i++) {
      Polygon polygon = nextPolygon();
      
      for (int j = 0; j < 100; j++) {
        Rectangle rectangle = GeoTestUtil.nextBoxNear(polygon);
        // allowed to conservatively return true.
        if (polygon.relate(rectangle.minLat, rectangle.maxLat, rectangle.minLon, rectangle.maxLon) == Relation.CELL_OUTSIDE_QUERY) {
          for (int k = 0; k < 1000; k++) {
            double point[] = GeoTestUtil.nextPointNear(rectangle);
            // this tests in our range but sometimes outside! so we have to double-check its really in other box
            double latitude = point[0];
            double longitude = point[1];
            // check for sure its in our box
            if (latitude >= rectangle.minLat && latitude <= rectangle.maxLat && longitude >= rectangle.minLon && longitude <= rectangle.maxLon) {
              assertFalse(polygon.contains(latitude, longitude));
            }
          }
          for (int k = 0; k < 100; k++) {
            double point[] = GeoTestUtil.nextPointNear(polygon);
            // this tests in our range but sometimes outside! so we have to double-check its really in other box
            double latitude = point[0];
            double longitude = point[1];
            // check for sure its in our box
            if (latitude >= rectangle.minLat && latitude <= rectangle.maxLat && longitude >= rectangle.minLon && longitude <= rectangle.maxLon) {
              assertFalse(polygon.contains(latitude, longitude));
            }
          }
        }
      }
    }
  }

