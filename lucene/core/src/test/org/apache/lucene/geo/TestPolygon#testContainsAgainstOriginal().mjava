  /** Tests current impl against original algorithm */
  public void testContainsAgainstOriginal() {
    for (int i = 0; i < 1000; i++) {
      Polygon polygon = nextPolygon();
      // currently we don't generate these, but this test does not want holes.
      while (polygon.getHoles().length > 0) {
        polygon = nextPolygon();
      }
      
      double polyLats[] = polygon.getPolyLats();
      double polyLons[] = polygon.getPolyLons();
      
      // random lat/lons in bounding box
      for (int j = 0; j < 1000; j++) {
        double latitude = nextLatitudeAround(polygon.minLat, polygon.maxLat);
        double longitude = nextLongitudeAround(polygon.minLon, polygon.maxLon);
        // bounding box check required due to rounding errors (we don't solve that problem)
        if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {
          boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);
          assertEquals(expected, polygon.contains(latitude, longitude));
        }
      }
      
      // lat lons targeted near vertices
      for (int vertex = 0; vertex < polyLats.length; vertex++) {
        for (int j = 0; j < 100; j++) {
          double latitude = GeoTestUtil.nextLatitudeNear(polyLats[vertex]);
          double longitude = GeoTestUtil.nextLongitudeNear(polyLons[vertex]);
          // bounding box check required due to rounding errors (we don't solve that problem)
          if (latitude >= polygon.minLat && latitude <= polygon.maxLat && longitude >= polygon.minLon && longitude <= polygon.maxLon) {
            boolean expected = containsOriginal(polyLats, polyLons, latitude, longitude);
            assertEquals(expected, polygon.contains(latitude, longitude));
          }
        }
      }
    }
  }

