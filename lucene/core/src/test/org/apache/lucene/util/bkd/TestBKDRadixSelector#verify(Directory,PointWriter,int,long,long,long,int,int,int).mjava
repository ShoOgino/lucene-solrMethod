  private void verify(Directory dir, PointWriter points, int dimensions, long start, long end, long middle, int packedLength, int bytesPerDimensions, int sortedOnHeap) throws IOException{
    for (int splitDim =0; splitDim < dimensions; splitDim++) {
      PointWriter copy = copyPoints(dir, points, packedLength);
      BKDRadixSelector.PathSlice[] slices = new BKDRadixSelector.PathSlice[2];
      BKDRadixSelector radixSelector = new BKDRadixSelector(dimensions, bytesPerDimensions, sortedOnHeap, dir, "test");
      BKDRadixSelector.PathSlice copySlice = new BKDRadixSelector.PathSlice(copy, 0, copy.count());
      byte[] pointsMax = getMax(copySlice, bytesPerDimensions, splitDim);
      byte[] pointsMin = getMin(copySlice, bytesPerDimensions, splitDim);
      int commonPrefixLength = FutureArrays.mismatch(pointsMin, 0, bytesPerDimensions, pointsMax, 0, bytesPerDimensions);
      if (commonPrefixLength == -1) {
        commonPrefixLength = bytesPerDimensions;
      }
      int commonPrefixLengthInput = (random().nextBoolean()) ? commonPrefixLength : commonPrefixLength == 0 ? 0 : random().nextInt(commonPrefixLength);
      byte[] partitionPoint = radixSelector.select(copySlice, slices, start, end, middle, splitDim, commonPrefixLengthInput);
      assertEquals(middle - start, slices[0].count);
      assertEquals(end - middle, slices[1].count);
      byte[] max = getMax(slices[0], bytesPerDimensions, splitDim);
      byte[] min = getMin(slices[1], bytesPerDimensions, splitDim);
      int cmp = FutureArrays.compareUnsigned(max, 0, bytesPerDimensions, min, 0, bytesPerDimensions);
      assertTrue(cmp <= 0);
      if (cmp == 0) {
        int maxDocID = getMaxDocId(slices[0], bytesPerDimensions, splitDim, partitionPoint);
        int minDocId = getMinDocId(slices[1], bytesPerDimensions, splitDim, partitionPoint);
        assertTrue(minDocId >= maxDocID);
      }
      assertTrue(Arrays.equals(partitionPoint, min));
      slices[0].writer.destroy();
      slices[1].writer.destroy();
    }
    points.destroy();
  }

