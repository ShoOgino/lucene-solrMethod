  private static DocIdSetIterator makeDisi(final int[] docIds) {
    class IntArrayDisi extends DocIdSetIterator {
      int i = 0;
      int docId = -1;

      @Override
      public int docID() {
        return docId;
      }

      @Override
      public int nextDoc() {
        if (i >= docIds.length) {
          docId = NO_MORE_DOCS;
          return docId;
        }
        if (docIds[i] < docId) { // Elias-Fano sequence should be non decreasing.
          // The non decreasing condition for Elias-Fano is weaker than normal increasing for DocIdSetIterator
          throw new AssertionError("docIds[] out of order");
        }
        docId = docIds[i++]; // increase i to just after current
        return docId;
      }

      @Override
      public int advance(int target) {
        // ( ((i == 0) and (docId == -1)) or
        //   ((i > 0) and (docIds.length > 0) and (i <= docIds.length) and (docId == docIds[i-1])) )

        // The behavior of this method is undefined when called with target â‰¤ current, or after the iterator has exhausted.
        // Both cases may result in unpredicted behavior, and may throw an assertion error or an IOOBE here.
        // So when nextDoc() or advance() were called earlier, the target should be bigger than current docId:
        assert (docId == -1) || (docId < target);


        // Do a binary search for the index j for which:
        // ((j >= i)
        //  and ((j < docIds.length) implies (docIds[j] >= target))
        //  and ((j >= 1) implies (docIds[j-1] < target)) )
        int j = docIds.length;
        while (i < j) {
          // ((0 <= i) and (i < j) and (j <= docIds.length)) so (docIds.length > 0)
          int m = i + (j - i) / 2; // (i <= m) and (m < j); avoid overflow for (i + j)
          if (docIds[m] < target) {
            i = m + 1; // (docIds[i-1] <  target) and (i <= j)
          } else {
            j = m; //     (docIds[j] >= target)   and (i <= j)
          }
        } // (i == j)
        docId = (i >= docIds.length)
            ? NO_MORE_DOCS // exhausted
                : docIds[i++]; // increase i to just after current
        return docId;
      }

      @Override
      public long cost() {
        return docIds.length;
      }
    };
    return new IntArrayDisi();
  }

