  /**
   * Compiles the given expression.
   *
   * @param sourceText The expression to compile
   * @return A new compiled expression
   * @throws ParseException on failure to compile
   */
  private Expression compileExpression(String sourceText) throws ParseException {
    if (sourceText == null) {
      throw new NullPointerException();
    }
    try {
      this.className = "CompiledExpression";
      externalsMap = new HashMap<String, Integer>();
      externalsList = new ArrayList<String>();
      
      Tree antlrTree = getAntlrComputedExpressionTree(sourceText);
      
      beginCompile();
      recursiveCompile(antlrTree, ComputedType.DOUBLE);
      endCompile();
      
      Class<? extends Expression> evaluatorClass = loader.define(EXPRESSION_CLASS_PREFIX + className, classWriter.toByteArray());
      Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);
      return constructor.newInstance(sourceText, externalsList.toArray(new String[externalsList.size()]));
    } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException exception) {
      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + className + ").", exception);
    }
  }

