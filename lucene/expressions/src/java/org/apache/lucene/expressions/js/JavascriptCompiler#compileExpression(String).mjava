  /**
   * Compiles the given expression.
   *
   * @param expression The expression to compile
   * @return A new compiled expression
   * @throws ParseException on failure to compile
   */
  public Expression compileExpression(String expression) throws ParseException {
    try {
      this.className = "Expr" + Long.toString(counter.incrementAndGet());
      externalsMap = new HashMap<String, Integer>();
      externalsList = new ArrayList<String>();
      
      Tree antlrTree = getAntlrComputedExpressionTree(expression);
      
      beginCompile();
      recursiveCompile(antlrTree, ComputedType.DOUBLE);
      endCompile();
      
      Class<? extends Expression> evaluatorClass = loader.define(EXPRESSION_CLASS_PREFIX + className, classWriter.toByteArray());
      Constructor<? extends Expression> constructor = evaluatorClass.getConstructor(String.class, String[].class);
      return constructor.newInstance(expression, externalsList.toArray(new String[externalsList.size()]));
    } catch (InstantiationException exception) {
      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + className + ").", exception);
    } catch (IllegalAccessException exception) {
      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + className + ").", exception);
    } catch (NoSuchMethodException exception) {
      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + className + ").", exception);
    } catch (InvocationTargetException exception) {
      throw new IllegalStateException("An internal error occurred attempting to compile the expression (" + className + ").", exception);
    }
  }

