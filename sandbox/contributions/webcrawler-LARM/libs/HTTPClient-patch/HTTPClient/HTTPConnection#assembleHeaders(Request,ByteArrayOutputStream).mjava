    /**
     * This writes out the headers on the <var>hdr_buf</var> . It takes special
     * precautions for the following headers: <DL> <DT>Content-type<DI>This is
     * only written if the request has an entity. If the request has an entity
     * and no content-type header was given for the request it defaults to
     * "application/octet-stream" <DT>Content-length<DI>This header is generated
     * if the request has an entity and the entity isn't being sent with the
     * Transfer-Encoding "chunked". <DT>User-Agent <DI>If not present it will be
     * generated with the current HTTPClient version strings. Otherwise the
     * version string is appended to the given User-Agent string. <DT>Connection
     * <DI>This header is only written if no proxy is used. If no connection
     * header is specified and the server is not known to understand HTTP/1.1 or
     * later then a "Connection: keep-alive" header is generated. <DT>
     * Proxy-Connection<DI>This header is only written if a proxy is used. If no
     * connection header is specified and the proxy is not known to understand
     * HTTP/1.1 or later then a "Proxy-Connection: keep-alive" header is
     * generated. <DT>Keep-Alive <DI>This header is only written if the
     * Connection or Proxy-Connection header contains the Keep-Alive token. <DT>
     * Expect <DI>If there is no entity and this header contains the
     * "100-continue" token then this token is removed. before writing the
     * header. <DT>TE <DI>If this header does not exist, it is created; else if
     * the "trailers" token is not specified this token is added; else the
     * header is not touched. </DL> Furthermore, it escapes various characters
     * in request-URI.
     *
     * @param req              the Request
     * @param hdr_buf          the buffer onto which to write the headers
     * @return                 an array of headers; the first element contains
     *      the the value of the Connection or Proxy-Connectin header, the
     *      second element the value of the Expect header.
     * @exception IOException  if writing on <var>hdr_buf</var> generates an an
     *      IOException, or if an error occurs during parsing of a header
     */
    private String[] assembleHeaders(Request req,
            ByteArrayOutputStream hdr_buf)
        throws IOException
    {
        DataOutputStream dataout = new DataOutputStream(hdr_buf);
        String[] con_hdrs = {"", ""};
        NVPair[] hdrs = req.getHeaders();

        // remember various headers

        int ho_idx = -1;

        // remember various headers

        int
                ct_idx = -1;

        // remember various headers

        int
                ua_idx = -1;

        // remember various headers

        int
                co_idx = -1;

        // remember various headers

        int
                pc_idx = -1;

        // remember various headers

        int
                ka_idx = -1;

        // remember various headers

        int
                ex_idx = -1;

        // remember various headers

        int
                te_idx = -1;

        // remember various headers

        int
                tc_idx = -1;

        // remember various headers

        int
                ug_idx = -1;
        for (int idx = 0; idx < hdrs.length; idx++)
        {
            String name = hdrs[idx].getName().trim().toLowerCase();
            if (name.equals("host"))
            {
                ho_idx = idx;
            }
            else if (name.equals("content-type"))
            {
                ct_idx = idx;
            }
            else if (name.equals("user-agent"))
            {
                ua_idx = idx;
            }
            else if (name.equals("connection"))
            {
                co_idx = idx;
            }
            else if (name.equals("proxy-connection"))
            {
                pc_idx = idx;
            }
            else if (name.equals("keep-alive"))
            {
                ka_idx = idx;
            }
            else if (name.equals("expect"))
            {
                ex_idx = idx;
            }
            else if (name.equals("te"))
            {
                te_idx = idx;
            }
            else if (name.equals("transfer-encoding"))
            {
                tc_idx = idx;
            }
            else if (name.equals("upgrade"))
            {
                ug_idx = idx;
            }
        }

        // Generate request line and Host header

        String file = Util.escapeUnsafeChars(req.getRequestURI());
        if (Proxy_Host != null && Protocol != HTTPS && !file.equals("*"))
        {
            dataout.writeBytes(req.getMethod() + " http://" + Host + ":" + Port +
                    file + " " + RequestProtocolVersion + "\r\n");
        }
        else
        {
            dataout.writeBytes(req.getMethod() + " " + file + " " +
                    RequestProtocolVersion + "\r\n");
        }

        String h_hdr = (ho_idx >= 0) ? hdrs[ho_idx].getValue().trim() : Host;
        if (Port != URI.defaultPort(getProtocol()))
        {
            dataout.writeBytes("Host: " + h_hdr + ":" + Port + "\r\n");
        }
        else
        {
            // Netscape-Enterprise has some bugs...
            dataout.writeBytes("Host: " + h_hdr + "\r\n");
        }

        /*
         *  What follows is the setup for persistent connections. We default
         *  to doing persistent connections for both HTTP/1.0 and HTTP/1.1,
         *  unless we're using a proxy server and HTTP/1.0 in which case we
         *  must make sure we don't do persistence (because of the problem of
         *  1.0 proxies blindly passing the Connection header on).
         *
         *  Note: there is a "Proxy-Connection" header for use with proxies.
         *  This however is only understood by Netscape and Netapp caches.
         *  Furthermore, it suffers from the same problem as the Connection
         *  header in HTTP/1.0 except that at least two proxies must be
         *  involved. But I've taken the risk now and decided to send the
         *  Proxy-Connection header. If I get complaints I'll remove it again.
         *
         *  In any case, with this header we can now modify the above to send
         *  the Proxy-Connection header whenever we wouldn't send the normal
         *  Connection header.
         */
        String co_hdr = null;
        if (!(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1 &&
                co_idx == -1))
        {
            if (co_idx == -1)
            {
                // no connection header given by user
                co_hdr = "Keep-Alive";
                con_hdrs[0] = "Keep-Alive";
            }
            else
            {
                con_hdrs[0] = hdrs[co_idx].getValue().trim();
                co_hdr = con_hdrs[0];
            }

            try
            {
                if (ka_idx != -1 &&
                        Util.hasToken(con_hdrs[0], "keep-alive"))
                {
                    dataout.writeBytes("Keep-Alive: " +
                            hdrs[ka_idx].getValue().trim() + "\r\n");
                }
            }
            catch (ParseException pe)
            {
                throw new IOException(pe.toString());
            }
        }

        if ((Proxy_Host != null && Protocol != HTTPS) &&
                !(ServProtVersKnown && ServerProtocolVersion >= HTTP_1_1))
        {
            if (co_hdr != null)
            {
                dataout.writeBytes("Proxy-Connection: ");
                dataout.writeBytes(co_hdr);
                dataout.writeBytes("\r\n");
                co_hdr = null;
            }
        }

        if (co_hdr != null)
        {
            try
            {
                if (!Util.hasToken(co_hdr, "TE"))
                {
                    co_hdr += ", TE";
                }
            }
            catch (ParseException pe)
            {
                throw new IOException(pe.toString());
            }
        }
        else
        {
            co_hdr = "TE";
        }

        if (ug_idx != -1)
        {
            co_hdr += ", Upgrade";
        }

        if (co_hdr != null)
        {
            dataout.writeBytes("Connection: ");
            dataout.writeBytes(co_hdr);
            dataout.writeBytes("\r\n");
        }

        // handle TE header

        if (te_idx != -1)
        {
            dataout.writeBytes("TE: ");
            Vector pte;
            try
            {
                pte = Util.parseHeader(hdrs[te_idx].getValue());
            }
            catch (ParseException pe)
            {
                throw new IOException(pe.toString());
            }

            if (!pte.contains(new HttpHeaderElement("trailers")))
            {
                dataout.writeBytes("trailers, ");
            }

            dataout.writeBytes(hdrs[te_idx].getValue().trim() + "\r\n");
        }
        else
        {
            dataout.writeBytes("TE: trailers\r\n");
        }

        // User-Agent

        if (ua_idx != -1)
        {
            dataout.writeBytes("User-Agent: " + hdrs[ua_idx].getValue().trim() + "\r\n");
        }
        else
        {
            dataout.writeBytes("User-Agent: " + version + "\r\n");
        }

        // Write out any headers left

        for (int idx = 0; idx < hdrs.length; idx++)
        {
            if (idx != ct_idx && idx != ua_idx && idx != co_idx &&
                    idx != pc_idx && idx != ka_idx && idx != ex_idx &&
                    idx != te_idx && idx != ho_idx)
            {
                dataout.writeBytes(hdrs[idx].getName().trim() + ": " +
                        hdrs[idx].getValue().trim() + "\r\n");
            }
        }

        // Handle Content-type, Content-length and Expect headers

        if (req.getData() != null || req.getStream() != null)
        {
            dataout.writeBytes("Content-type: ");
            if (ct_idx != -1)
            {
                dataout.writeBytes(hdrs[ct_idx].getValue().trim());
            }
            else
            {
                dataout.writeBytes("application/octet-stream");
            }
            dataout.writeBytes("\r\n");

            if (req.getData() != null)
            {
                dataout.writeBytes("Content-length: " + req.getData().length +
                        "\r\n");
            }
            else if (req.getStream().getLength() != -1 && tc_idx == -1)
            {
                dataout.writeBytes("Content-length: " +
                        req.getStream().getLength() + "\r\n");
            }

            if (ex_idx != -1)
            {
                con_hdrs[1] = hdrs[ex_idx].getValue().trim();
                dataout.writeBytes("Expect: " + con_hdrs[1] + "\r\n");
            }
        }
        else if (ex_idx != -1)
        {
            Vector expect_tokens;
            try
            {
                expect_tokens = Util.parseHeader(hdrs[ex_idx].getValue());
            }
            catch (ParseException pe)
            {
                throw new IOException(pe.toString());
            }

            // remove any 100-continue tokens

            HttpHeaderElement cont = new HttpHeaderElement("100-continue");
            while (expect_tokens.removeElement(cont))
            {
                ;
            }

            // write out header if any tokens left

            if (!expect_tokens.isEmpty())
            {
                con_hdrs[1] = Util.assembleHeader(expect_tokens);
                dataout.writeBytes("Expect: " + con_hdrs[1] + "\r\n");
            }
        }

        dataout.writeBytes("\r\n");
        // end of header

        return con_hdrs;
    }

