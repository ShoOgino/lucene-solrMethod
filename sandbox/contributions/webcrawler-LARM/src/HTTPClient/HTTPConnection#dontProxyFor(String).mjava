    /**
     * Add <var>host</var> to the list of hosts which should be accessed
     * directly, not via any proxy set by <code>setProxyServer()</code>. <P>
     *
     * The <var>host</var> may be any of:
     * <UL>
     *   <LI> a complete host name (e.g. "www.disney.com")
     *   <LI> a domain name; domain names must begin with a dot (e.g.
     *   ".disney.com")
     *   <LI> an IP-address (e.g. "12.34.56.78")
     *   <LI> an IP-subnet, specified as an IP-address and a netmask separated
     *   by a "/" (e.g. "34.56.78/255.255.255.192"); a 0 bit in the netmask
     *   means that that bit won't be used in the comparison (i.e. the addresses
     *   are AND'ed with the netmask before comparison).
     * </UL>
     * <P>
     *
     * The two properties <var>HTTPClient.nonProxyHosts</var> and <var>
     * http.nonProxyHosts</var> are used when this class is loaded to initialize
     * the list of non-proxy hosts. The second property is only read if the
     * first one is not set; the second property is also used the JDK's
     * URLConnection. These properties must contain a "|" separated list of
     * entries which conform to the above rules for the <var>host</var>
     * parameter (e.g. "11.22.33.44|.disney.com").
     *
     * @param host                a host name, domain name, IP-address or
     *      IP-subnet.
     * @exception ParseException  if the length of the netmask does not match
     *      the length of the IP-address
     */
    public static void dontProxyFor(String host)
        throws ParseException
    {
        host = host.trim().toLowerCase();

        // check for domain name

        if (host.charAt(0) == '.')
        {
            if (!non_proxy_dom_list.contains(host))
            {
                non_proxy_dom_list.addElement(host);
            }
            return;
        }

        // check for host name

        for (int idx = 0; idx < host.length(); idx++)
        {
            if (!Character.isDigit(host.charAt(idx)) &&
                    host.charAt(idx) != '.' && host.charAt(idx) != '/')
            {
                non_proxy_host_list.put(host, "");
                return;
            }
        }

        // must be an IP-address

        byte[] ip_addr;
        byte[] ip_mask;
        int slash;
        if ((slash = host.indexOf('/')) != -1)
        {
            // IP subnet

            ip_addr = string2arr(host.substring(0, slash));
            ip_mask = string2arr(host.substring(slash + 1));
            if (ip_addr.length != ip_mask.length)
            {
                throw new ParseException("length of IP-address (" +
                        ip_addr.length + ") != length of netmask (" +
                        ip_mask.length + ")");
            }
        }
        else
        {
            ip_addr = string2arr(host);
            ip_mask = new byte[ip_addr.length];
            for (int idx = 0; idx < ip_mask.length; idx++)
            {
                ip_mask[idx] = (byte) 255;
            }
        }

        // check if addr or subnet already exists

        ip_loop :
        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)
        {
            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);
            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);
            if (addr.length != ip_addr.length)
            {
                continue;
            }

            for (int idx2 = 0; idx2 < addr.length; idx2++)
            {
                if ((ip_addr[idx2] & mask[idx2]) != (addr[idx2] & mask[idx2]) ||
                        (mask[idx2] != ip_mask[idx2]))
                {
                    continue ip_loop;
                }
            }

            return;
            // already exists
        }
        non_proxy_addr_list.addElement(ip_addr);
        non_proxy_mask_list.addElement(ip_mask);
    }

