    /**
     * Enable SSL Tunneling if we're talking to a proxy. See ietf draft
     * draft-luotonen-ssl-tunneling-03 for more info.
     *
     * @param sock                 the socket
     * @param req                  the request initiating this connection
     * @param timeout              the timeout
     * @return                     the proxy's last response if unsuccessful, or
     *      null if tunnel successfuly established
     * @exception IOException
     * @exception ModuleException
     */
    private Response enableSSLTunneling(Socket[] sock, Request req, int timeout)
        throws IOException, ModuleException
    {
        // copy User-Agent and Proxy-Auth headers from request

        Vector hdrs = new Vector();
        for (int idx = 0; idx < req.getHeaders().length; idx++)
        {
            String name = req.getHeaders()[idx].getName();
            if (name.equalsIgnoreCase("User-Agent") ||
                    name.equalsIgnoreCase("Proxy-Authorization"))
            {
                hdrs.addElement(req.getHeaders()[idx]);
            }
        }

        // create initial CONNECT subrequest

        NVPair[] h = new NVPair[hdrs.size()];
        hdrs.copyInto(h);
        Request connect = new Request(this, "CONNECT", Host + ":" + Port, h,
                null, null, req.allowUI());
        connect.internal_subrequest = true;

        ByteArrayOutputStream hdr_buf = new ByteArrayOutputStream(600);
        HTTPResponse r = new HTTPResponse(gen_mod_insts(), timeout, connect, defaultIncrement);

        // send and handle CONNECT request until successful or tired

        Response resp = null;

        while (true)
        {
            handleRequest(connect, r, resp, true);

            hdr_buf.reset();
            assembleHeaders(connect, hdr_buf);

            Log.write(Log.CONN, "Conn:  Sending SSL-Tunneling Subrequest: ",
                    hdr_buf);

            // send CONNECT

            hdr_buf.writeTo(sock[0].getOutputStream());

            // return if successful

            resp = new Response(connect, sock[0].getInputStream());
            if (resp.getStatusCode() == 200)
            {
                return null;
            }

            // failed!

            // make life easy: read data and close socket

            try
            {
                resp.getData();
            }
            catch (IOException ioe)
            {
            }
            try
            {
                sock[0].close();
            }
            catch (IOException ioe)
            {
            }

            // handle response

            r.set(connect, resp);
            if (!r.handleResponse())
            {
                return resp;
            }

            sock[0] = getSocket(timeout);
        }
    }

