  public void tokenize() throws Exception {
    int c;

    while ((c = read()) != -1) {
      switch (state) {
        case ST_START:
          switch (c) {
            case '<':
              state = ST_TAG_LT;
              isStartTag = true;  // until proven wrong
              tagname.reset();
              break;
            case ' ': case '\t': case '\r': case '\n':
              if (!rcgnzWS) break;
              // else fall through
            default:
              state = ST_PCDATA;
          }
          break;

        case ST_PCDATA:
          if (c == '<') {
            gotPCDATA(true);
            state = ST_TAG_LT;
          }
          break;

        case ST_TAG_LT:
          switch (c) {
            case '/':
              isStartTag = false;
              state = ST_TAG_NAME;
              break;
            case '!':
              c = read();
              if ((c == '-' && !rcgnzComments) || (c == '[' && !rcgnzCDATA)) {
                state = ST_PCDATA;
                break;
              }
              if (c == '-') state = ST_COMMENT;
              else if (c == '[') parseCDATA();
              else {
                // FIXME: shouldn't be delivered as PCDATA
                warning("Bad markup " + buf);
                state = ST_PCDATA;
              }
              break;
            case '?':
              parsePI();
              break;
            case ' ': case '\t': case '\r': case '\n':
              state = ST_TAG_WS;
              break;
            default:
              tagname.write(c);
              state = ST_TAG_NAME;
          }
          break;

        case ST_TAG_NAME:
          switch (c) {
            case ' ': case '\t': case '\r': case '\n':
              state = ST_TAG_WS;
              break;
            case '/': state = ST_EMPTY_TAG_SLASH; break;
            case '>': gotTag(false); break;
            default:  tagname.write(c);
          }
          break;

        case ST_TAG_WS:
          switch (c) {
            case ' ': case '\t': case '\r': case '\n': break;
            case '/': state = ST_EMPTY_TAG_SLASH; break;
            case '>': gotTag(false); break;
            case '?':
              if (inXMLDecl) {
                if ((c = read()) != '>') {
                errHandler.warning("XML PI not terminated properly",
                                   sysID, _line, _column);
                  //err_continue("XML PI not terminated properly");
                }
                //handler.gotXMLDecl(attrs);  // FIXME(?)
                toStart();
                break;
              }
              // NOTE: if !inXMLDecl we fall through to default case
            default:
              if (!isStartTag) {
                // bit of a hack this...
                errHandler.warning("Malformed tag: "+buf, sysID, _line, _column);
                //err_continue("Malformed tag: "+buf);
                if (c == '<') {
                    gotPCDATA(true);
                    state = ST_TAG_LT;
                } else {
                    // we get here e.g. if there's an end tag with attributes
                    state = ST_PCDATA;
                }
              } else {
                // FIXME: this accepts way too many first chars for attr name
                attrName.write(c);
                state = ST_NAME;
              }
          }
          break;

        case ST_EMPTY_TAG_SLASH:
          if (c == '>') {
            //tagtype = TAG_EMPTY;
            gotTag(true);
            break;
          } else {
            // ERROR !? - can't throw Exception here - we go to next tag...
            state = ST_PCDATA;
          }
          break;

        case ST_NAME:
          switch (c) {
            case ' ': case '\t': case '\r': case '\n':
              if (attrName.size() > 0) {
                state = ST_NAME_WS;
              }
              break;
            case '>':
              if (attrName.size() > 0) gotAttr(true);
              gotTag(false);
              break;
            case '=':
              state = ST_EQ;
              break;
            default:
              if (isCtlOrTspecial(c)) {
                state = ST_PCDATA;
              } else {
                attrName.write(c);
              }
          }
          break;

        case ST_NAME_WS:   // white-space between name and '='
          switch (c) {
            case ' ': case '\t': case '\r': case '\n': break;
            case '=': state = ST_EQ; break;
            case '>': gotAttr(true); gotTag(false); break;
            default:
              if (isNameChar(c)) {
                gotAttr(true);
                attrName.write(c);
                state = ST_TAG_WS;
              } else {
                state = ST_PCDATA;
              }
          }
          break;

        case ST_EQ:        // white-space between '=' and value
          switch (c) {
            case ' ': case '\t': case '\r': case '\n': break;
            case '"':  qchar = '"';  state = ST_VALUE_QUOTED; break;
            case '\'': qchar = '\''; state = ST_VALUE_QUOTED; break;
            default:
              if (isCtlOrTspecial(c)) {
                state = ST_PCDATA;
              } else {
                attrValue.write(c);
                state = ST_VALUE;
              }
          }
          break;

        case ST_VALUE:
          switch (c) {
            case ' ': case '\t': case '\r': case '\n':
              gotAttr(false);
              state = ST_TAG_WS;
              break;
            case '>':
              gotAttr(false);
              gotTag(false);
              break;
            case '/':
              gotAttr(false);
              state = ST_EMPTY_TAG_SLASH;
              break;
            default:
              if (isCtlOrTspecial(c)) {
                state = ST_PCDATA;
              } else {
                attrValue.write(c);
              }
          }
          break;

        case ST_VALUE_QUOTED:
          if (c == qchar) {
            gotAttr(false);
            state = ST_TAG_WS;
          } else {
            attrValue.write(c);
          }
          break;

        case ST_COMMENT:
          // we've seen "...<!-" by now
          try {
            if (c != '-') {
              warning("Bad comment");
              state = ST_PCDATA;
              break;
            }
            // we're within comment - read till we see "--"
            while (true) {
              while (read_ex() != '-') ;
              if (read_ex() == '-') break;
            }
            // seen "--" - gotComment() reads past next '>'
            gotComment();
            //while (read_ex() != '>') ;
            //state = ST_PCDATA;
          } catch (EmptyInputStream ex) {
            gotPCDATA(false);
            break;
          }
      }
    }
    /* TODO: catch EmptyInputStream exception only here!
    } catch (EmptyInputStream ex) {
        err_continue("EOF while parsing " + token[state]);
    }
    */

    // input stream ended - return rest, if any, as PCDATA
    if (buf.size() > 0) {
        gotPCDATA(false);
        buf.reset();
        }
    }

