    /**
     * Finds entitiy and character references in the provided char array
     * and decodes them. The operation is destructive, i.e. the encoded
     * string replaces the original - this is atrightforward since the
     * new string can only get shorter.
     */
    public final CharBuffer entityDecode(CharBuffer buffer) throws Exception {
        char[] buf = buffer.getCharArray();  // avoids method calls
        int len = buffer.size();

        // not fastest but certainly simplest:
        if (indexOf(buf, '&', 0, len) == -1) return buffer;
        CharBuffer newbuf = new CharBuffer(len);

        for (int start = 0; ; ) {
            int x = indexOf(buf, '&', start, len);
            if (x == -1) {
                newbuf.write(buf, start, len - start);
                return newbuf;
            } else {
                newbuf.write(buf, start, x - start);
                start = x+1;
                x = indexOf(buf, ';', start, len);
                if (x == -1) {
                    //tok.warning("Entity reference not semicolon terminated");
                    newbuf.write('&');
                    //break; //???????????
                } else {
                    try {
                        writeEntityDef(buf, start, x-start, newbuf);
                        start = x+1;
                    } catch (Exception ex) {
                        //tok.warning("Bad entity reference");
                    }
                }
            }
        }
    }

