    /**
     * this will be called by the fetcher thread and will do all the work
     *
     * @TODO probably split this up into different processing steps
     * @param thread  Description of the Parameter
     */
    public void run(ServerThread thread)
    {

        taskState.setState(FT_STARTED); // state information is always set to make the thread monitor happy

        log = thread.getLog();
        hostManager = ((FetcherThread)thread).getHostManager();

        //HostManager hm = ((FetcherThread)thread).getHostManager();

        errorLog = thread.getErrorLog();

        // startTime = System.currentTimeMillis();
        int threadNr = ((FetcherThread) thread).getThreadNumber();

        log.log("start");
        base = contextUrl = actURLMessage.getUrl();
        String urlString = actURLMessage.getURLString();
        String host = contextUrl.getHost().toLowerCase();
        int hostPos = urlString.indexOf(host);
        int hostLen = host.length();

        HostInfo hi = hostManager.getHostInfo(host); // get and create

        if(!hi.isHealthy())
        {
            // we make this check as late as possible to get the most current information
            log.log("Bad Host: " + contextUrl + "; returning");
            System.out.println("[" + threadNr + "] bad host: " + this.actURLMessage.getUrl());

            taskState.setState(FT_READY, null);
            return;
        }

        foundUrls = new java.util.LinkedList();

        HTTPConnection conn = null;

        title = "*untitled*";

        int size = 1;

        InputStream in = null;
        bytesRead = 0;


        try
        {

            URL ipURL = contextUrl;

            taskState.setState(FT_OPENCONNECTION, urlString);

            log.log("connecting to " + ipURL.getHost());
            taskState.setState(FT_CONNECTING, ipURL);
            conn = new HTTPConnection(host);

            conn.setDefaultTimeout(75000);
            // 75 s
            conn.setDefaultAllowUserInteraction(false);

            taskState.setState(this.FT_GETTING, ipURL);
            log.log("getting");

            HTTPResponse response = conn.Get(ipURL.getFile(), "", headers);
            response.setReadIncrement(2720);
            int statusCode = response.getStatusCode();
            byte[] fullBuffer = null;
            String contentType = "";
            int contentLength = 0;
            Date date = null;

            if (statusCode != 404 && statusCode != 403)
            {
                // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array
                taskState.setState(FT_READING, ipURL);
                contentType = response.getHeader("Content-Type");
                String length = response.getHeader("Content-Length");
                date = response.getHeaderAsDate("Last-Modified");

                if (length != null)
                {
                    contentLength = Integer.parseInt(length);
                }
                log.log("reading");

                fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE); // max. 2 MB
                base = contextUrl = response.getEffectiveURI().toURL();
                // may have changed after a 30x result code
                // to do: record the link between original and effective URL
                // like this the effectiveURL may be crawled twice


                if (fullBuffer != null)
                {
                    contentLength = fullBuffer.length;
                    this.bytesRead += contentLength;
                }
            }
            //conn.stop();    // close connection. todo: Do some caching...


            /*
             *  conn.disconnect();
             */
            if (isInterrupted)
            {
                System.out.println("FetcherTask: interrupted while reading. File truncated");
                log.log("interrupted while reading. File truncated");
            }
            else
            {
                if (fullBuffer != null)
                {
                    taskState.setState(FT_SCANNING, ipURL);

                    log.log("read file (" + fullBuffer.length + " bytes). Now scanning.");

                    if (contentType.startsWith("text/html"))
                    {

                        // ouch. I haven't found a better solution yet. just slower ones.
                        char[] fullCharBuffer = new char[contentLength];
                        new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);
                        Tokenizer tok = new Tokenizer();
                        tok.setLinkHandler(this);
                        tok.parse(new SimpleCharArrayReader(fullCharBuffer));

                        taskState.setState(FT_STORING, ipURL);
                        linkStorage.storeLinks(foundUrls);
                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);
                        d.addField("content", fullCharBuffer);
                        docStorage.store(d);
                    }
                    else
                    {
                        // System.out.println("Discovered unknown content type: " + contentType + " at " + urlString);
                        //errorLog.log("[" + threadNr + "] Discovered unknown content type at " + urlString + ": " + contentType + ". just storing");
                        taskState.setState(FT_STORING, ipURL);
                        linkStorage.storeLinks(foundUrls);
                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostManager);
                        d.addField("content", fullBuffer);
                        docStorage.store(d);
                    }
                    log.log("scanned");
                }

                log.log("stored");
            }
        }
        catch (InterruptedIOException e)
        {
            // timeout while reading this file
            //System.out.println("[" + threadNr + "] FetcherTask: Timeout while opening: " + this.actURLMessage.getUrl());
            errorLog.log("error: Timeout: " + this.actURLMessage.getUrl());
            hi.badRequest();
        }
        catch (FileNotFoundException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] FetcherTask: File not Found: " + this.actURLMessage.getUrl());
            errorLog.log("error: File not Found: " + this.actURLMessage.getUrl());
        }
        catch(NoRouteToHostException e)
        {
            // router is down or firewall prevents to connect
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());
        }
        catch(ConnectException e)
        {
            // no server is listening at this port
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());
        }
        catch (SocketException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "]: SocketException:" + e.getMessage());
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch(UnknownHostException e)
        {
            // IP Address not to be determined
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (IOException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: IOException: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (OutOfMemoryError ome)
        {
            taskState.setState(FT_EXCEPTION);
            System.out.println("[" + threadNr + "] Task " + this.taskNr + " OutOfMemory after " + size + " bytes");
            errorLog.log("error: OutOfMemory after " + size + " bytes");
        }
        catch (Throwable e)
        {
            taskState.setState(FT_EXCEPTION);
            System.out.println("[" + threadNr + "] " + e.getMessage() + " type: " + e.getClass().getName());
            e.printStackTrace();
            System.out.println("[" + threadNr + "]: stopping");
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage() + "; stopping");

        }
        finally
        {

            if (isInterrupted)
            {
                System.out.println("Task was interrupted");
                log.log("interrupted");
                taskState.setState(FT_INTERRUPTED);
            }
        }
        if (isInterrupted)
        {
            System.out.println("Task: closed everything");
        }
        /*
         *  }
         */
        taskState.setState(FT_CLOSING);
        conn.stop();

        taskState.setState(FT_READY);
        foundUrls = null;
    }

