    /**
     * this will be called by the fetcher thread and will do all the work
     *
     * @param thread  Description of the Parameter
     * @TODO          probably split this up into different processing steps
     */
    public void run(ServerThread thread)
    {


        taskState.setState(FT_STARTED);
        // state information is always set to make the thread monitor happy

        log = thread.getLog();
        hostManager = ((FetcherThread) thread).getHostManager();
        hostResolver = hostManager.getHostResolver();
        base = contextUrl = actURLMessage.getUrl();
        String urlString = actURLMessage.getURLString();
        String host = contextUrl.getHost().toLowerCase();
        HostInfo hi = hostManager.getHostInfo(host);
//        System.out.println("FetcherTask with " + urlString + " started");
        if(actURLMessage.linkType == URLMessage.LINKTYPE_REDIRECT)
        {
            taskState.setState(FT_READY, null);
            hi.releaseLock();
            return;     // we've already crawled that (see below)
        }

        NVPair[] headers = ((FetcherThread) thread).getDefaultHeaders();
        int numHeaders = ((FetcherThread) thread).getUsedDefaultHeaders();
        boolean isIncremental = false;
        if (actURLMessage instanceof WebDocument)
        {
            // this is an incremental crawl where we only have to check whether the doc crawled
            // is newer
            isIncremental = true;
            headers[numHeaders] = new NVPair("If-Modified-Since", HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));
        }
        //HostManager hm = ((FetcherThread)thread).getHostManager();

        errorLog = thread.getErrorLog();

        // startTime = System.currentTimeMillis();
        int threadNr = ((FetcherThread) thread).getThreadNumber();

        log.log("start");
        int hostPos = urlString.indexOf(host);
        int hostLen = host.length();

        // get and create

        if (!hi.isHealthy())
        {
            // we make this check as late as possible to get the most current information
            log.log("Bad Host: " + contextUrl + "; returning");
//            System.out.println("[" + threadNr + "] bad host: " + this.actURLMessage.getUrl());

            taskState.setState(FT_READY, null);
            hi.releaseLock();
            return;
        }

        foundUrls = new java.util.LinkedList();

        HTTPConnection conn = null;

        title = "";

        int size = 1;

        InputStream in = null;
        bytesRead = 0;

        try
        {

            URL ipURL = contextUrl;

            taskState.setState(FT_OPENCONNECTION, urlString);

            log.log("connecting to " + ipURL.getHost());
            taskState.setState(FT_CONNECTING, ipURL);
            conn = new HTTPConnection(host);

            conn.setDefaultTimeout(75000);

            // 75 s
            conn.setDefaultAllowUserInteraction(false);

            taskState.setState(this.FT_GETTING, ipURL);
            log.log("getting");

            HTTPResponse response = conn.Get(ipURL.getFile(), "", headers);
            response.setReadIncrement(2720);
            int statusCode = response.getStatusCode();
            byte[] fullBuffer = null;
            String contentType = "";
            int contentLength = 0;
            Date date = null;

             if (isIncremental)
            {
                // experimental
                System.out.println("ftask: if modified since: " + HTTPClient.Util.httpDate(((WebDocument) actURLMessage).getLastModified()));
            }

            URL realURL;

            switch (statusCode)
            {
                case 404:                // file not found
                case 403:                    // access forbidden

                    // if this is an incremental crawl, remove the doc from the repository
                    if (isIncremental)
                    {
                        WebDocument d = (WebDocument) actURLMessage;
                        d.setResultCode(statusCode);
                        // the repository will remove the doc if this statuscode is matched
                        docStorage.store(d);
                    }
                    // otherwise, do nothing
                    // Todo: we could add an error marker to the referal link
                    break;
                case 304:
                    // not modified
                    System.out.println("ftask: -> not modified");
                    // "not modified since"
                    taskState.setState(FT_STORING, ipURL);
                    // let the repository take care of the links
                    // it will determine that this is the old document (because it already
                    // has a docId), and will put back the links associated with it
                    try
                    {
                        WebDocument doc = (WebDocument) this.actURLMessage;
                        doc.setModified(false);
                        docStorage.store(doc);
                        this.bytesRead += doc.getSize();
                    }
                    catch (ClassCastException e)
                    {
                        System.out.println("error while casting to WebDoc: " + actURLMessage.getInfo());
                    }
                    break;
                case 301:                // moved permanently
                case 302:                // moved temporarily
                case 303:                // see other
                case 307:                // temporary redirect
                    /*
                     *  this is a redirect. save it as a link and return.
                     *  note that we could read the doc from the open connection here, but this could mean
                     *  the filters were useless
                     */
                    realURL = response.getEffectiveURI().toURL();
                    foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, "", hostResolver));
                    linkStorage.storeLinks(foundUrls);
                    break;
                default:
                    // this can be a 30x code that was resolved by the HTTPClient and is passed to us as 200
                    // we could turn this off and do it ourselves. But then we'd have to take care that
                    // we don't get into an endless redirection loop -> i.e. extend URLMessage by a counter
                    // at the moment we add the real URL to the message queue and mark it as a REDIRECT link
                    // that way it is added to the visited filter. Then we take care that we don't crawl it again

                    // the other possibility is that we receive a "Location:" header along with a 200 status code
                    // I have experienced that HTTPClient has an error with parsing this, so we do it ourselves
                    //String location = response.getHeader("Location");
                    realURL = response.getEffectiveURI().toURL();

                    /*if(location != null)
                    {
                        //System.out.println("interesting: location header with url " + location);
                        foundUrls.add(new URLMessage(new URL(location), contextUrl, URLMessage.LINKTYPE_REDIRECT, "", hostManager));
                        this.base = this.contextUrl = location;
                    }
                    else*/
                    if(!(realURL.equals(contextUrl)))
                    {
                        //System.out.println("interesting: redirect with url " + realURL + " -context: " + contextUrl);
                        foundUrls.add(new URLMessage(realURL, contextUrl, URLMessage.LINKTYPE_REDIRECT, "", hostResolver));
                        this.base = this.contextUrl = realURL;
                        //System.out.println(response);

                    }




                    if (isIncremental)
                    {
                        // experimental
                        System.out.println("ftask: -> was modified at " + response.getHeaderAsDate("Last-Modified"));
                    }
                    // read up to Constants.FETCHERTASK_MAXFILESIZE bytes into a byte array
                    taskState.setState(FT_READING, ipURL);
                    contentType = response.getHeader("Content-Type");
                    String length = response.getHeader("Content-Length");
                    date = response.getHeaderAsDate("Last-Modified");

                    if (length != null)
                    {
                        contentLength = Integer.parseInt(length);
                    }
                    log.log("reading");
                    realURL = response.getEffectiveURI().toURL();
                    if (contentType != null && contentType.startsWith("text/html"))
                    {
                        fullBuffer = response.getData(Constants.FETCHERTASK_MAXFILESIZE);
                        hi.releaseLock();
                        // max. 2 MB
                        if (fullBuffer != null)
                        {
                            contentLength = fullBuffer.length;
                            this.bytesRead += contentLength;
                        }

                        /*
                         *  conn.disconnect();
                         */
                        if (isInterrupted)
                        {
                            System.out.println("FetcherTask: interrupted while reading. File truncated");
                            log.log("interrupted while reading. File truncated");
                        }
                        else
                        {
                            if (fullBuffer != null)
                            {
                                taskState.setState(FT_SCANNING, ipURL);

                                log.log("read file (" + fullBuffer.length + " bytes). Now scanning.");

                                // convert the bytes to Java characters
                                // ouch. I haven't found a better solution yet. just slower ones.
                                // remember: for better runtime performance avoid decorators, since they
                                // multiply function calls
                                char[] fullCharBuffer = new char[contentLength];
                                new InputStreamReader(new ByteArrayInputStream(fullBuffer)).read(fullCharBuffer);
                                Tokenizer tok = new Tokenizer();
                                tok.setLinkHandler(this);
                                tok.parse(new SimpleCharArrayReader(fullCharBuffer));

                                taskState.setState(FT_STORING, ipURL);
                                linkStorage.storeLinks(foundUrls);
                                WebDocument d;
                                if (isIncremental)
                                {
                                    d = ((WebDocument) this.actURLMessage);
                                    d.setModified(true);
                                    // file is new or newer
                                    d.setUrl(contextUrl);
                                    d.setMimeType(contentType);
                                    d.setResultCode(statusCode);
                                    d.setSize(contentLength);
                                    d.setTitle(title);
                                    d.setLastModified(date);
                                }
                                else
                                {
                                    d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(), contentLength, title, date, hostResolver);
                                }
                                d.addField("content", fullCharBuffer);
                                d.addField("contentBytes", fullBuffer);
                                docStorage.store(d);
                            }

                            log.log("scanned");
                        }

                        log.log("stored");
                    }
                    else
                    {
                        // System.out.println("Discovered unknown content type: " + contentType + " at " + urlString);
                        //errorLog.log("[" + threadNr + "] Discovered unknown content type at " + urlString + ": " + contentType + ". just storing");
                        taskState.setState(FT_STORING, ipURL);
                        linkStorage.storeLinks(foundUrls);
                        WebDocument d = new WebDocument(contextUrl, contentType, statusCode, actURLMessage.getReferer(),
                        /*
                         *  contentLength
                         */
                                0, title, date, hostResolver);
                        //d.addField("content", fullBuffer);
                        //d.addField("content", null);
                        docStorage.store(d);
                    }
                    break;
            }
            /*
             *  switch
             */
            //conn.stop();    // close connection. todo: Do some caching...

        }
        catch (InterruptedIOException e)
        {
            // timeout while reading this file
            //System.out.println("[" + threadNr + "] FetcherTask: Timeout while opening: " + this.actURLMessage.getUrl());
            errorLog.log("error: Timeout: " + this.actURLMessage.getUrl());
            hi.badRequest();
        }
        catch (FileNotFoundException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] FetcherTask: File not Found: " + this.actURLMessage.getUrl());
            errorLog.log("error: File not Found: " + this.actURLMessage.getUrl());
        }
        catch (NoRouteToHostException e)
        {
            // router is down or firewall prevents to connect
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());
        }
        catch (ConnectException e)
        {
            // no server is listening at this port
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (SocketException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "]: SocketException:" + e.getMessage());
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (UnknownHostException e)
        {
            // IP Address not to be determined
            hi.setReachable(false);
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (IOException e)
        {
            taskState.setState(FT_EXCEPTION);
            //System.out.println("[" + threadNr + "] " + e.getClass().getName() + ": " + e.getMessage());
            // e.printStackTrace();
            errorLog.log("error: IOException: " + e.getClass().getName() + ": " + e.getMessage());

        }
        catch (OutOfMemoryError ome)
        {
            taskState.setState(FT_EXCEPTION);
            System.out.println("[" + threadNr + "] Task " + this.taskNr + " OutOfMemory after " + size + " bytes");
            errorLog.log("error: OutOfMemory after " + size + " bytes");
        }
        catch (Throwable e)
        {
            taskState.setState(FT_EXCEPTION);
            System.out.println("[" + threadNr + "] " + e.getMessage() + " type: " + e.getClass().getName());
            e.printStackTrace();
            System.out.println("[" + threadNr + "]: stopping");
            errorLog.log("error: " + e.getClass().getName() + ": " + e.getMessage() + "; stopping");
        }
        finally
        {
            hi.releaseLock();

            if (isInterrupted)
            {
                System.out.println("Task was interrupted");
                log.log("interrupted");
                taskState.setState(FT_INTERRUPTED);
            }
        }
        if (isInterrupted)
        {
            System.out.println("Task: closed everything");
        }
        /*
         *  }
         */
        taskState.setState(FT_CLOSING);
        conn.stop();
        taskState.setState(FT_READY);
        foundUrls = null;
    }

