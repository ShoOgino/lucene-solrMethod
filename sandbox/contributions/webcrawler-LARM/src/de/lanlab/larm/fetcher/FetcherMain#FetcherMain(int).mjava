    /**
     * initializes all classes and registers anonymous adapter classes as
     * listeners for fetcher events.
     *
     * @param nrThreads  number of fetcher threads to be created
     */
    public FetcherMain(int nrThreads)
    {
        // to make things clear, this method is commented a bit better than
        // the rest of the program...

        // this is the main message queue. handlers are registered with
        // the queue, and whenever a message is put in it, they are passed to the
        // filters in a "chain of responibility" manner. Every listener can decide
        // to throw the message away
        messageHandler = new MessageHandler();

        // the storage is the class which saves a WebDocument somewhere, no
        // matter how it does it, whether it's in a file, in a database or
        // whatever


        // example for the (very slow) SQL Server storage:
        // this.storage = new SQLServerStorage("sun.jdbc.odbc.JdbcOdbcDriver","jdbc:odbc:search","sa","...",nrThreads);

        // the LogStorage used here does extensive logging. It logs all links and
        // document information.
        // it also saves all documents to page files. Probably this single storage
        // could also be replaced by a pipeline; or even incorporated into the
        // existing message pipeline
        SimpleLogger storeLog = new SimpleLogger("store", false);
        SimpleLogger linksLog = new SimpleLogger("links", false);


        StoragePipeline storage = new StoragePipeline();
        storage.addDocStorage(new LogStorage(storeLog, /* save in page files? */ false, /* logfile prefix */ "logs/pagefile"));
        storage.addLinkStorage(new LinkLogStorage(linksLog));
        storage.addLinkStorage(messageHandler);
        //storage.addStorage(new LuceneStorage(...));
        //storage.addStorage(new JMSStorage(...));

        // a third example would be the NullStorage, which converts the documents into
        // heat, which evaporates above the processor
        // NullStorage();

        // create the filters and add them to the message queue
        urlScopeFilter = new URLScopeFilter();

        urlVisitedFilter = new URLVisitedFilter(100000);

        // dnsResolver = new DNSResolver();
        hostManager = new HostManager(1000);

        reFilter = new RobotExclusionFilter(hostManager);

        fetcher = new Fetcher(nrThreads, storage, storage, hostManager);

        knownPathsFilter = new KnownPathsFilter();

        urlLengthFilter = new URLLengthFilter(255);

        // prevent message box popups
        HTTPConnection.setDefaultAllowUserInteraction(false);

        // prevent GZipped files from being decoded
        HTTPConnection.removeDefaultModule(HTTPClient.ContentEncodingModule.class);



        // initialize the threads
        fetcher.init();

        // the thread monitor watches the thread pool.

        monitor = new ThreadMonitor(urlLengthFilter,
                urlVisitedFilter,
                urlScopeFilter,
                /*dnsResolver,*/
                reFilter,
                messageHandler,
                fetcher.getThreadPool(),
                hostManager,
                5000        // wake up every 5 seconds
                );


        // add all filters to the handler.
        messageHandler.addListener(urlLengthFilter);
        messageHandler.addListener(urlScopeFilter);
        messageHandler.addListener(reFilter);
        messageHandler.addListener(urlVisitedFilter);
        messageHandler.addListener(knownPathsFilter);
        messageHandler.addListener(fetcher);

        /* uncomment this to enable HTTPClient logging
        try
        {
            HTTPClient.Log.setLogWriter(new java.io.FileWriter("logs/HttpClient.log"),false);
            HTTPClient.Log.setLogging(HTTPClient.Log.ALL, true);
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        */
    }

