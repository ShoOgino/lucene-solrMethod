    /**
     *  the main messageHandler-Thread.
     */
    public void run()
    {
        while(running)
        {
            //System.out.println("MessageHandler-Thread started");

            synchronized(queueMonitor)
            {
                // wait for new messages
                workingOnMessage=false;
                try
                {
                    queueMonitor.wait();
                }
                catch(InterruptedException e)
                {
                    System.out.println("MessageHandler: Caught InterruptedException");
                }
                workingOnMessage=true;
            }
            //messagesWaiting = false;
            Message m;
            try
            {
                while(messagesWaiting)
                {
                    synchronized(this.queueMonitor)
                    {
			// note: another thread may put a new message in the queue after
			// messageQueue.size() is called below, which would result in the
			// inconsistent state: messageWaiting would be set to false, but
			// the queue would actually not be empty
                        m = (Message)messageQueue.remove();
                        if (messageQueue.size() == 0)
                        {
                            messagesWaiting = false;
                        }

                    }
                    //System.out.println("MessageHandler:run: Entferne erstes Element");

                    messageQueueObservable.setChanged();
                    messageQueueObservable.notifyObservers(new Integer(-1));      // Message processed

                    // now distribute them. The handlers get the messages in the order
                    // of insertion and have the right to change them

                    Iterator i = listeners.iterator();
                    while(i.hasNext())
                    {
                        try
                        {
                            MessageListener listener = (MessageListener)i.next();
                            m = (Message)listener.handleRequest(m);
                            if (m == null)
                            {
                                // handler has consumed the message
                                messageProcessorObservable.setChanged();
                                messageProcessorObservable.notifyObservers(listener);
                                break;
                            }
                        }
                        catch(ClassCastException e)
                        {
			    System.out.println("MessageHandler:run: ClassCastException(2): " + e.getMessage());
                        }
                    }
                }
            }
            catch (ClassCastException e)
            {
                System.out.println("MessageHandler:run: ClassCastException: " + e.getMessage());
            }
            catch (UnderflowException e)
            {
                messagesWaiting = false;
                // System.out.println("MessageHandler: messagesWaiting = true although nothing queued!");
                // @FIXME: here is still a multi threading issue. I don't get it why this happens.
                //         does someone want to draw a petri net of this? ;-)
            }
            catch (Exception e)
            {
                System.out.println("MessageHandler: " + e.getClass() + " " + e.getMessage());
                e.printStackTrace();
            }

        }
    }

