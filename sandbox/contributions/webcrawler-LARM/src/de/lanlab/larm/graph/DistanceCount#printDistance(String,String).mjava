    /**
     * Description of the Method
     *
     * @param nodeFrom  Description of the Parameter
     * @param nodeTo    Description of the Parameter
     */
    public void printDistance(String nodeFrom, String nodeTo)
    {

        Node firstNode = (Node) nodes.get(nodeFrom);
        if (firstNode == null)
        {
            System.out.println("FROM node not found");
            return;
        }
        Node toNode = (Node) nodes.get(nodeTo);
        if (toNode == null)
        {
            System.out.println("TO node not found");
            return;
        }
        //System.out.println("resetting node distance...");
        //clearDistances();

        System.out.println("calculating...");
        calculateShortestDistance(firstNode);

        //t1 = System.currentTimeMillis();
        //System.out.println("" + (t1-t2) + " ms");


        System.out.println("\nSorting...");

        /*
         *  Collection nodeCollection = nodes.values();
         *  Object[] nodeArray = nodeCollection.toArray();
         *  Arrays.sort(nodeArray);
         *  t2 = System.currentTimeMillis();
         *  System.out.println("" + (t2-t1) + " ms");
         *  int from = 0;
         *  int to = 1;
         */
        /*
         *  /calculate page Rank
         *  for(int i = 0; i< 1; i++)
         *  {
         *  from = i%2;
         *  to = (i+1) % 2;
         *  for(int j = 0; j<nodeArray.length; j++)
         *  {
         *  Node act = (Node)nodeArray[j];
         *  LinkedList inc = act.getIncoming();
         *  float pageRank = 0;
         *  Iterator it = inc.iterator();
         *  while(it.hasNext())
         *  {
         *  Transition t = (Transition)it.next();
         *  pageRank += t.getLinkRank(from);
         *  }
         *  act.setNodeRank(pageRank, to);
         *  LinkedList out = act.getOutgoing();
         *  int size = out.size();
         *  if(size > 0)
         *  {
         *  float linkRank = pageRank / size;
         *  it = out.iterator();
         *  while(it.hasNext())
         *  {
         *  Transition t = (Transition)it.next();
         *  t.setLinkRank(linkRank, to);
         *  }
         *  }
         *  }
         *  }
         */
        /*
         *  System.out.println("\nLink Count:");
         *  for(int i=0; i<10; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  Node.sortType = to;
         *  Arrays.sort(nodeArray);
         *  System.out.println("\nPageRank Count:");
         *  for(int i=0; i<10; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  for(int i=nodeArray.length/2; i<nodeArray.length/2+10; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  for(int i=nodeArray.length-10; i<nodeArray.length; i++)
         *  {
         *  Node n = ((Node)nodeArray[i]);
         *  System.out.println("Node " + n.name + ": " + n.getIncoming().size() + "; pageRank: " + n.getNodeRank(to));
         *  }
         *  System.out.println("\nStats...");
         *  float distanceAccumulated=0;
         *  float distanceMax = 0;
         *  int notCounted = 0;
         *  for(int j = 0; j<nodeArray.length; j++)
         *  {
         *  Node n = (Node)nodeArray[j];
         *  if(n.distance != Integer.MAX_VALUE)
         *  {
         *  distanceAccumulated += n.distance;
         *  distanceMax = Math.max(distanceMax, n.distance);
         *  }
         *  else
         *  {
         *  notCounted++;
         *  }
         *  }
         *  System.out.println("Mean Distance:          " + ((double)distanceAccumulated)/nodeArray.length);
         *  System.out.println("Max Distance:           " + (distanceMax));
         *  System.out.println("Not reachable nodes(?): " + notCounted);
         *  System.out.println("Referer Median:         " + ((Node)(nodeArray[Math.round(nodeArray.length/2)])).incoming.size());
         *  System.out.println("\nSamples:");
         */

        printShortestRoute(toNode, 0,0);

    }

