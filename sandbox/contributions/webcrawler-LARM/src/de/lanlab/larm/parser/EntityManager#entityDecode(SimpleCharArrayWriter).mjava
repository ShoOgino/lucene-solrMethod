    /**
     * Finds entitiy and character references in the provided char array and
     * decodes them. The operation is destructive, i.e. the encoded string
     * replaces the original - this is atrightforward since the new string can
     * only get shorter.
     *
     * @param buffer         Description of the Parameter
     * @return               Description of the Return Value
     * @exception Exception  Description of the Exception
     */
    public final SimpleCharArrayWriter entityDecode(SimpleCharArrayWriter buffer)
        throws Exception
    {
        char[] buf = buffer.getCharArray();
        // avoids method calls
        int len = buffer.size();

        // not fastest but certainly simplest:
        if (indexOf(buf, '&', 0, len) == -1)
        {
            return buffer;
        }
        SimpleCharArrayWriter newbuf = new SimpleCharArrayWriter(len);

        for (int start = 0; ; )
        {
            int x = indexOf(buf, '&', start, len);
            if (x == -1)
            {
                newbuf.write(buf, start, len - start);
                return newbuf;
            }
            else
            {
                newbuf.write(buf, start, x - start);
                start = x + 1;
                x = indexOf(buf, ';', start, len);
                if (x == -1)
                {
                    //tok.warning("Entity reference not semicolon terminated");
                    newbuf.write('&');
                    //break; //???????????
                }
                else
                {
                    try
                    {
                        writeEntityDef(buf, start, x - start, newbuf);
                        start = x + 1;
                    }
                    catch (Exception ex)
                    {
                        //tok.warning("Bad entity reference");
                    }
                }
            }
        }
    }

