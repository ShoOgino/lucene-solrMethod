  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException 
  {
    if( abortErrorMessage != null ) {
      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );
      return;
    }
    
    if( request instanceof HttpServletRequest) {
      SolrQueryRequest solrReq = null;
      HttpServletRequest req = (HttpServletRequest)request;
      HttpServletResponse resp = (HttpServletResponse)response;
      try {
        String path = req.getServletPath();    
        if( req.getPathInfo() != null ) {
          // this lets you handle /update/commit when /update is a servlet
          path += req.getPathInfo(); 
        }
        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {
          path = path.substring( pathPrefix.length() );
        }
        
        int idx = path.indexOf( ':' );
        if( idx > 0 ) {
          // save the portion after the ':' for a 'handler' path parameter
          path = path.substring( 0, idx );
        }
        
        // By default use the single core.  If multicore is enabled, look for one.
        SolrRequestHandler handler = null;
        SolrCore core = singlecore;
        if( core == null ) {
          // Perhaps this is a multi-core admin page?
          if( path.equals( "/" ) ) {
            chain.doFilter(request, response);
            return;  
          }
          if( path.equals( multicore.getAdminPath() ) ) {
            handler = multicore.getMultiCoreHandler();
            
            // pick a core to use for output
            Collection<SolrCore> cores = multicore.getCores();
            if( cores != null && cores.size() > 0 ) {
              core = cores.iterator().next();
            }
            if( core == null ) {
              throw new RuntimeException( "Can not find a valid core for the multicore admin handler" );
            }
          }
          else {
            idx = path.indexOf( "/", 1 );
            if( idx <= 1 ) {
              idx = path.length();
            }
            
            // try to get the corename as a request parameter first
            String corename = path.substring( 1, idx );
            path = path.substring( idx );
            core = multicore.getCore( corename );
            
            if( path.length() == 0 ) {
              path = "/";
            }
            
            if( core == null ) {
              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown core: "+corename );
            }
          }
        }
        
        SolrRequestParsers parser = parsers.get( core );
        if( parser == null ) {
          parser = new SolrRequestParsers( core.getSolrConfig() );
          parsers.put( core, parser );
        }
        
        // Only try to parse the handler *if* a valid core exists
        // when multi-core is enabled, the path can lead to a null core.
        if( handler == null && path.length() > 1 ) { // don't match "" or "/" as valid path
          handler = core.getRequestHandler( path );
        }
        if( handler == null && parser.isHandleSelect() ) {
          if( "/select".equals( path ) || "/select/".equals( path ) ) {
            solrReq = parser.parse( core, path, req );
            String qt = solrReq.getParams().get( CommonParams.QT );
            if( qt != null && qt.startsWith( "/" ) ) {
              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Invalid query type.  Do not use /select to access: "+qt);
            }
            handler = core.getRequestHandler( qt );
            if( handler == null ) {
              throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
            }
          }
        }
        
        if( handler != null ) {          
          if( solrReq == null ) {
            solrReq = parser.parse( core, path, req );
          }
          
          final SolrConfig conf = core.getSolrConfig();
          final Method reqMethod = Method.getMethod(req.getMethod());

          if (Method.POST != reqMethod) {
            HttpCacheHeaderUtil.setCacheControlHeader(conf, resp);
          }
            
          // unless we have been explicitly told not to, do cache validation
          if (!conf.getHttpCachingConfig().isNever304()) {
            // if we've confirmed cache validation, return immediately
            if (HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req,resp)) {
              return;
            }
          }
          
          SolrQueryResponse solrRsp = new SolrQueryResponse();
          /* even for HEAD requests, we need to execute the handler to
           * ensure we don't get an error (and to make sure the correct 
           * QueryResponseWriter is selectedand we get the correct
           * Content-Type)
           */
          this.execute( req, handler, solrReq, solrRsp );
          if( solrRsp.getException() != null ) {
            sendError( (HttpServletResponse)response, solrRsp.getException() );
            return;
          }
          
          // Now write it out
          QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);
          response.setContentType(responseWriter.getContentType(solrReq, solrRsp));
          if (Method.HEAD == Method.getMethod(req.getMethod())) {
            // nothing to write out, waited this long just to get ContentType
            return; 
          }
          
          PrintWriter out = response.getWriter();
          responseWriter.write(out, solrReq, solrRsp);
          return;
        }
        // otherwise, let's ensure the core is in the SolrCore request attribute so
        // the servlet/jsp can retrieve it
        else {
          req.setAttribute("org.apache.solr.SolrCore", core);

          // Let each core have its own admin page...
          if( singlecore == null && path.startsWith( "/admin" ) ) {
            req.getRequestDispatcher( path ).forward( request, response );
            return; 
          }
        }
      }
      catch( Throwable ex ) {
        sendError( (HttpServletResponse)response, ex );
        return;
      }
      finally {
        if( solrReq != null ) {
          solrReq.close();
        }
      }
    }
    
    // Otherwise let the webapp handle the request
    chain.doFilter(request, response);
  }

