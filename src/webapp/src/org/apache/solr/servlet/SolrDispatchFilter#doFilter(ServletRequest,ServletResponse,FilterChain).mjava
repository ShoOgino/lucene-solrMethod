  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    if( abortErrorMessage != null ) {
      ((HttpServletResponse)response).sendError( 500, abortErrorMessage );
      return;
    }
    
    if( request instanceof HttpServletRequest) {
      HttpServletRequest req = (HttpServletRequest)request;
      HttpServletResponse resp = (HttpServletResponse)response;
      SolrRequestHandler handler = null;
      SolrQueryRequest solrReq = null;

      try {
        String path = req.getServletPath();    
        if( req.getPathInfo() != null ) {
          // this lets you handle /update/commit when /update is a servlet
          path += req.getPathInfo(); 
        }
        if( pathPrefix != null && path.startsWith( pathPrefix ) ) {
          path = path.substring( pathPrefix.length() );
        }
        
        int idx = path.indexOf( ':' );
        if( idx > 0 ) {
          // save the portion after the ':' for a 'handler' path parameter
          path = path.substring( 0, idx );
        }
        
        // By default use the single core.  If multicore is enabled, look for one.
        final SolrCore core;
        if (multicore != null && multicore.isEnabled()) {
          // if this is the multi-core admin page, it will handle it
          if( path.equals( multicore.getAdminPath() ) ) {
            handler = multicore.getMultiCoreHandler();
            // pick a core to use for output generation
            core = multicore.getAdminCore();
            if( core == null ) {
              throw new RuntimeException( "Can not find a valid core for the multicore admin handler" );
            }
          } else {
            //otherwise, we should find a core from the path
            idx = path.indexOf( "/", 1 );
            if( idx > 1 ) {
              // try to get the corename as a request parameter first
              String corename = path.substring( 1, idx );
              path = path.substring( idx );
              core = multicore.getCore( corename );
            } else {
              core = null;
            }
          }
        }
        else {
          core = singlecore;
        }
        
        // With a valid core...
        if( core != null ) {
          final SolrConfig config = core.getSolrConfig();
          // get or create/cache the parser for the core
          SolrRequestParsers parser = null;
          parser = parsers.get(core);
          if( parser == null ) {
            parser = new SolrRequestParsers(config);
            parsers.put( core, parser );
          }
          
          // Determine the handler from the url path if not set
          // (we might already have selected the multicore handler)
          if( handler == null && path.length() > 1 ) { // don't match "" or "/" as valid path
            handler = core.getRequestHandler( path );
            // no handler yet but allowed to handle select; let's check
            if( handler == null && parser.isHandleSelect() ) {
              if( "/select".equals( path ) || "/select/".equals( path ) ) {
                solrReq = parser.parse( core, path, req );
                String qt = solrReq.getParams().get( CommonParams.QT );
                if( qt != null && qt.startsWith( "/" ) ) {
                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "Invalid query type.  Do not use /select to access: "+qt);
                }
                handler = core.getRequestHandler( qt );
                if( handler == null ) {
                  throw new SolrException( SolrException.ErrorCode.BAD_REQUEST, "unknown handler: "+qt);
                }      
              }
            }
          }
          
            // With a valid handler and a valid core...
          if( handler != null ) {          
            // if not a /select, create the request
            if( solrReq == null ) {
              solrReq = parser.parse( core, path, req );
            }
            
            final Method reqMethod = Method.getMethod(req.getMethod());
            if (Method.POST != reqMethod) {
              HttpCacheHeaderUtil.setCacheControlHeader(config, resp);
            }
            // unless we have been explicitly told not to, do cache validation
            // if we fail cache validation, execute the query
            if (config.getHttpCachingConfig().isNever304() ||
                !HttpCacheHeaderUtil.doCacheHeaderValidation(solrReq, req, resp)) {
                SolrQueryResponse solrRsp = new SolrQueryResponse();
                /* even for HEAD requests, we need to execute the handler to
                 * ensure we don't get an error (and to make sure the correct 
                 * QueryResponseWriter is selectedand we get the correct
                 * Content-Type)
                 */
                this.execute( req, handler, solrReq, solrRsp );
                if( solrRsp.getException() != null ) {
                  sendError( (HttpServletResponse)response, solrRsp.getException() );
                }
                else {
                  // Now write it out
                  QueryResponseWriter responseWriter = core.getQueryResponseWriter(solrReq);
                  response.setContentType(responseWriter.getContentType(solrReq, solrRsp));
                  if (Method.HEAD != Method.getMethod(req.getMethod())) {
                    if (responseWriter instanceof BinaryQueryResponseWriter) {
                      BinaryQueryResponseWriter binWriter = (BinaryQueryResponseWriter) responseWriter;
                      binWriter.write(response.getOutputStream(), solrReq, solrRsp);
                    } else {
                      PrintWriter out = response.getWriter();
                      responseWriter.write(out, solrReq, solrRsp);

                    }

                  }
                  //else http HEAD request, nothing to write out, waited this long just to get ContentType
                }
            }
            return; // we are done with a valid handler
          }
          // otherwise (we have a core), let's ensure the core is in the SolrCore request attribute so
          // a servlet/jsp can retrieve it
          else {
            req.setAttribute("org.apache.solr.SolrCore", core);
            req.setAttribute("org.apache.solr.MultiCore", multicore);
              // Modify the request so each core gets its own /admin
            if( singlecore == null && path.startsWith( "/admin" ) ) {
              req.getRequestDispatcher( pathPrefix == null ? path : pathPrefix + path ).forward( request, response );
              return; 
            }
          }
        }
        log.fine("no handler or core retrieved for " + path + ", follow through...");
      } catch (Throwable ex) {
        sendError( (HttpServletResponse)response, ex );
        return;
      } finally {
        if( solrReq != null ) {
          solrReq.close();
        }
      }
    }
    
    // Otherwise let the webapp handle the request
    chain.doFilter(request, response);
  }

