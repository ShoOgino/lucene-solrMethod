  public void init(FilterConfig config) throws ServletException 
  {
    log.info("SolrDispatchFilter.init()");

    boolean abortOnConfigurationError = true;
    try {
      // web.xml configuration
      this.pathPrefix = config.getInitParameter( "path-prefix" );
      
      // Find a valid solr core
      SolrCore core = null;
      multicore = MultiCore.getRegistry();
      String instanceDir = SolrResourceLoader.locateInstanceDir();
      File multiconfig = new File( instanceDir, "multicore.xml" );
      log.info( "looking for multicore.xml: "+multiconfig.getAbsolutePath() );
      if( multiconfig.exists() ) {
        multicore.load( instanceDir, multiconfig );
        core = multicore.getDefaultCore();
      }
      if( multicore.isEnabled() ) {
        singlecore = null;
      }
      else {
        singlecore = new SolrCore( "core", null, new SolrConfig(), null );
        core = singlecore;
      }
      
      log.info("user.dir=" + System.getProperty("user.dir"));
      
      // Read global configuration
      // Only the first registered core configures the following attributes 
      Config globalConfig = core.getSolrConfig();

      long uploadLimitKB = globalConfig.getInt( 
          "requestDispatcher/requestParsers/@multipartUploadLimitInKB", 2000 ); // 2MB default
      
      boolean enableRemoteStreams = globalConfig.getBool( 
          "requestDispatcher/requestParsers/@enableRemoteStreaming", false ); 

      parsers = new SolrRequestParsers( enableRemoteStreams, uploadLimitKB );
      
      // Let this filter take care of /select?xxx format
      this.handleSelect = globalConfig.getBool( "requestDispatcher/@handleSelect", false ); 
      
      // should it keep going if we hit an error?
      abortOnConfigurationError = globalConfig.getBool("abortOnConfigurationError",true);
    }
    catch( Throwable t ) {
      // catch this so our filter still works
      log.log(Level.SEVERE, "Could not start SOLR. Check solr/home property", t);
      SolrConfig.severeErrors.add( t );
      SolrCore.log( t );
    }
    
    // Optionally abort if we found a sever error
    if( abortOnConfigurationError && SolrConfig.severeErrors.size() > 0 ) {
      StringWriter sw = new StringWriter();
      PrintWriter out = new PrintWriter( sw );
      out.println( "Severe errors in solr configuration.\n" );
      out.println( "Check your log files for more detailed information on what may be wrong.\n" );
      out.println( "If you want solr to continue after configuration errors, change: \n");
      out.println( " <abortOnConfigurationError>false</abortOnConfigurationError>\n" );
      if( multicore.isEnabled() ) {
        out.println( "in multicore.xml\n" );
      } 
      else {
        out.println( "in solrconfig.xml\n" );
      }
      
      for( Throwable t : SolrConfig.severeErrors ) {
        out.println( "-------------------------------------------------------------" );
        t.printStackTrace( out );
      }
      out.flush();
      
      // Servlet containers behave slightly differently if you throw an exception during 
      // initialization.  Resin will display that error for every page, jetty prints it in
      // the logs, but continues normally.  (We will see a 404 rather then the real error)
      // rather then leave the behavior undefined, lets cache the error and spit it out 
      // for every request.
      abortErrorMessage = sw.toString();
      //throw new ServletException( abortErrorMessage );
    }
    
    log.info("SolrDispatchFilter.init() done");
  }

