  /*
   * Test a deletion policy that keeps last N commits
   * around, through creates.
   */
  public void testKeepLastNDeletionPolicyWithCreates() throws IOException {

    final int N = 10;

    for(int pass=0;pass<4;pass++) {

      boolean autoCommit = pass < 2;
      boolean useCompoundFile = (pass % 2) > 0;

      KeepLastNDeletionPolicy policy = new KeepLastNDeletionPolicy(N);

      Directory dir = new RAMDirectory();
      IndexWriter writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);
      writer.setMaxBufferedDocs(10);
      writer.setUseCompoundFile(useCompoundFile);
      writer.close();
      Term searchTerm = new Term("content", "aaa");        
      Query query = new TermQuery(searchTerm);

      for(int i=0;i<N+1;i++) {

        writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), false, policy);
        writer.setMaxBufferedDocs(10);
        writer.setUseCompoundFile(useCompoundFile);
        for(int j=0;j<17;j++) {
          addDoc(writer);
        }
        // this is a commit when autoCommit=false:
        writer.close();
        IndexReader reader = IndexReader.open(dir, policy);
        reader.deleteDocument(3);
        reader.setNorm(5, "content", 2.0F);
        IndexSearcher searcher = new IndexSearcher(reader);
        Hits hits = searcher.search(query);
        assertEquals(16, hits.length());
        // this is a commit when autoCommit=false:
        reader.close();
        searcher.close();

        writer = new IndexWriter(dir, autoCommit, new WhitespaceAnalyzer(), true, policy);
        // This will not commit: there are no changes
        // pending because we opened for "create":
        writer.close();
      }

      assertEquals(1+3*(N+1), policy.numOnInit);
      if (autoCommit) {
        assertTrue(policy.numOnCommit > 3*(N+1)-1);
      } else {
        assertEquals(2*(N+1), policy.numOnCommit);
      }

      IndexSearcher searcher = new IndexSearcher(dir);
      Hits hits = searcher.search(query);
      assertEquals(0, hits.length());

      // Simplistic check: just verify only the past N segments_N's still
      // exist, and, I can open a reader on each:
      long gen = SegmentInfos.getCurrentSegmentGeneration(dir);

      int expectedCount = 0;

      for(int i=0;i<N+1;i++) {
        try {
          IndexReader reader = IndexReader.open(dir);

          // Work backwards in commits on what the expected
          // count should be.  Only check this in the
          // autoCommit false case:
          if (!autoCommit) {
            searcher = new IndexSearcher(reader);
            hits = searcher.search(query);
            assertEquals(expectedCount, hits.length());
            searcher.close();
            if (expectedCount == 0) {
              expectedCount = 16;
            } else if (expectedCount == 16) {
              expectedCount = 17;
            } else if (expectedCount == 17) {
              expectedCount = 0;
            }
          }
          reader.close();
          if (i == N) {
            fail("should have failed on commits before last " + N);
          }
        } catch (IOException e) {
          if (i != N) {
            throw e;
          }
        }
        if (i < N) {
          dir.deleteFile(IndexFileNames.fileNameFromGeneration(IndexFileNames.SEGMENTS, "", gen));
        }
        gen--;
      }
      
      dir.close();
    }
  }

