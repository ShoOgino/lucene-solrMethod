  /** alternate scorer skipTo(),skipTo(),next(),next(),skipTo(),skipTo(), etc
   * and ensure a hitcollector receives same docs and scores
   */
  public static void checkSkipTo(final Query q, final IndexSearcher s) throws IOException {
    //System.out.println("Checking "+q);
    
    if (BooleanQuery.getAllowDocsOutOfOrder()) return;  // in this case order of skipTo() might differ from that of next().

    final int skip_op = 0;
    final int next_op = 1;
    final int orders [][] = {
        {next_op},
        {skip_op},
        {skip_op, next_op},
        {next_op, skip_op},
        {skip_op, skip_op, next_op, next_op},
        {next_op, next_op, skip_op, skip_op},
        {skip_op, skip_op, skip_op, next_op, next_op},
    };
    for (int k = 0; k < orders.length; k++) {
      IndexReader[] readers = s.getIndexReader().getSequentialSubReaders();

      for (int x = 0; x < readers.length; x++) {
        IndexReader reader = readers[x];

        final int order[] = orders[k];
        // System.out.print("Order:");for (int i = 0; i < order.length; i++)
        // System.out.print(order[i]==skip_op ? " skip()":" next()");
        // System.out.println();
        final int opidx[] = { 0 };

        final Weight w = q.weight(s);
        final Scorer scorer = w.scorer(reader, true, false);
        if (scorer == null) {
          continue;
        }

        // FUTURE: ensure scorer.doc()==-1

        final int[] sdoc = new int[] { -1 };
        final float maxDiff = 1e-5f;
        s.search(q, new Collector() {
          private int base = 0;
          private Scorer sc;

          public void setScorer(Scorer scorer) throws IOException {
            this.sc = scorer;
          }

          public void collect(int doc) throws IOException {
            doc = doc + base;
            float score = sc.score();
            try {
              int op = order[(opidx[0]++) % order.length];
              // System.out.println(op==skip_op ?
              // "skip("+(sdoc[0]+1)+")":"next()");
              boolean more = op == skip_op ? scorer.advance(sdoc[0] + 1) != DocIdSetIterator.NO_MORE_DOCS
                  : scorer.nextDoc() != DocIdSetIterator.NO_MORE_DOCS;
              sdoc[0] = scorer.docID();
              float scorerScore = scorer.score();
              float scorerScore2 = scorer.score();
              float scoreDiff = Math.abs(score - scorerScore);
              float scorerDiff = Math.abs(scorerScore2 - scorerScore);
              if (!more || doc != sdoc[0] || scoreDiff > maxDiff
                  || scorerDiff > maxDiff) {
                StringBuffer sbord = new StringBuffer();
                for (int i = 0; i < order.length; i++)
                  sbord.append(order[i] == skip_op ? " skip()" : " next()");
                throw new RuntimeException("ERROR matching docs:" + "\n\t"
                    + (doc != sdoc[0] ? "--> " : "") + "doc=" + sdoc[0]
                    + "\n\t" + (!more ? "--> " : "") + "tscorer.more=" + more
                    + "\n\t" + (scoreDiff > maxDiff ? "--> " : "")
                    + "scorerScore=" + scorerScore + " scoreDiff=" + scoreDiff
                    + " maxDiff=" + maxDiff + "\n\t"
                    + (scorerDiff > maxDiff ? "--> " : "") + "scorerScore2="
                    + scorerScore2 + " scorerDiff=" + scorerDiff
                    + "\n\thitCollector.doc=" + doc + " score=" + score
                    + "\n\t Scorer=" + scorer + "\n\t Query=" + q + "  "
                    + q.getClass().getName() + "\n\t Searcher=" + s
                    + "\n\t Order=" + sbord + "\n\t Op="
                    + (op == skip_op ? " skip()" : " next()"));
              }
            } catch (IOException e) {
              throw new RuntimeException(e);
            }
          }

          public void setNextReader(IndexReader reader, int docBase) {
            base = docBase;
          }

          public boolean acceptsDocsOutOfOrder() {
            return true;
          }
        });

        // make sure next call to scorer is false.
        int op = order[(opidx[0]++) % order.length];
        // System.out.println(op==skip_op ? "last: skip()":"last: next()");
        boolean more = (op == skip_op ? scorer.advance(sdoc[0] + 1) : scorer
            .nextDoc()) != DocIdSetIterator.NO_MORE_DOCS;
        Assert.assertFalse(more);
      }
    }
  }

