  public void testSort() throws Throwable {
    r = newRandom();

    // reverse & not
    // all types
    // restrictive & non restrictive searches (on contents)

    create();

    Sort[] sorts = new Sort[50];
    int sortCount = 0;

    for(int r=0;r<2;r++) {
      Sort sort;
      boolean reverse = 1 == r;

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("byte", SortField.BYTE, reverse)});
      
      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("short", SortField.SHORT, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("int", SortField.INT, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("long", SortField.LONG, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("float", SortField.FLOAT, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("double", SortField.DOUBLE, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("string", SortField.STRING_VAL, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField("stringIdx", SortField.STRING, reverse)});

      //sorts[sortCount++] = sort = new Sort();
      //sort.setSort(new SortField[] {new SortField("string", SortField.STRING_ORD, reverse)});

      //sorts[sortCount++] = sort = new Sort();
      //sort.setSort(new SortField[] {new SortField("string", SortField.STRING_ORD_VAL, reverse)});

      //sorts[sortCount++] = sort = new Sort();
      //sort.setSort(new SortField[] {new SortField("string", SortField.STRING_ORD_VAL_DEM, reverse)});

      //sorts[sortCount++] = sort = new Sort();
      //sort.setSort(new SortField[] {new SortField("string", SortField.STRING_ORD_VAL_DEM2, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField(null, SortField.SCORE, reverse)});

      sorts[sortCount++] = sort = new Sort();
      sort.setSort(new SortField[] {new SortField(null, SortField.DOC, reverse)});
    }

    Query[] queries = new Query[4];
    queries[0] = new MatchAllDocsQuery();
    queries[1] = new TermQuery(new Term("contents", "x"));  // matches every 10th doc
    queries[2] = new TermQuery(new Term("contents", "y"));  // matches every 100th doc
    queries[3] = new TermQuery(new Term("contents", "z"));  // matches every 1000th doc

    for(int sx=0;sx<3;sx++) {
      final IndexSearcher searcher;
      if (sx == 0) {
        searcher = searcherSingleSegment;
      } else if (sx == 1) {
        searcher = searcherFewSegment;
      } else {
        searcher = searcherMultiSegment;
      }

      for(int qx=0;qx<queries.length;qx++) {
        final Query query = queries[qx];

        for(int q=0;q<3;q++) {

          final int queueSize;
          if (q == 0) {
            queueSize = 10;
          } else if (q == 1) {
            queueSize = 100;
          } else {
            queueSize = 1000;
          }
        
          for(int s=0;s<sortCount;s++) {
            Sort sort1 = sorts[s];

            for(int s2=-1;s2<sortCount;s2++) {
              Sort sort;
              if (s2 == -1) {
                // Single field sort
                sort = sort1;
              } else {
                sort = new Sort(new SortField[] {sort1.getSort()[0], sorts[s2].getSort()[0]});
              }

              // Old
              Sort oldSort = getOldSort(sort);

              if (VERBOSE) {
                System.out.println("query=" + query);
                if (sx == 0) {
                  System.out.println("  single-segment index");
                } else if (sx == 1) {
                  System.out.println("  few-segment index");
                } else {
                  System.out.println("  many-segment index");
                }
                System.out.println("  numHit=" + queueSize);
                System.out.println("  old=" + oldSort);
                System.out.println("  new=" + sort);
              }

              TopDocs newHits = searcher.search(query, null, queueSize, sort);
              TopDocs oldHits = searcher.search(query, null, queueSize, oldSort);

              compare(oldHits, newHits);
            }
          }
        }
      }
    }

    // we explicitly test the old sort method and
    // compare with the new, so we expect to see SUBREADER
    // sanity checks fail.
    Insanity[] insanity = FieldCacheSanityChecker.checkSanity
      (FieldCache.DEFAULT);
    try {
      int ignored = 0;
      for (int i = 0; i < insanity.length; i++) {
        if (insanity[i].getType() == InsanityType.SUBREADER) {
          insanity[i] = new Insanity(InsanityType.EXPECTED,
                                     insanity[i].getMsg(), 
                                     insanity[i].getCacheEntries());
          ignored++;
        }
      }
      assertEquals("Not all insane field cache usage was expected",
                   ignored, insanity.length);

      insanity = null;
    } finally {
      // report this in the event of any exception/failure
      // if no failure, then insanity will be null
      if (null != insanity) {
        dumpArray(getTestLabel() + ": Insane FieldCache usage(s)", insanity, System.err);
      }
    }
    // we've already checked FieldCache, purge so tearDown doesn't complain
    purgeFieldCache(FieldCache.DEFAULT); // so

    close();
  }

