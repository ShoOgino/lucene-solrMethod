  /**
   * This is for testing CommonGramsQueryFilter which outputs a set of tokens
   * optimized for querying with only one token at each position, either a
   * unigram or a bigram It also will not return a token for the final position
   * if the final word is already in the preceding bigram Example:(three
   * tokens/positions in)
   * "foo bar the"=>"foo:1|bar:2,bar-the:2|the:3=> "foo" "bar-the" (2 tokens
   * out)
   * 
   * @return Map<String,String>
   */
  private static Map<String, String> initQueryMap() {
    Map<String, String> input2expected = new LinkedHashMap<String, String>();

    // Stop words used below are "of" "the" and "s"
    
    // two word queries
    input2expected.put("brown fox", "/brown/fox");
    input2expected.put("the fox", "/the_fox");
    input2expected.put("fox of", "/fox_of");
    input2expected.put("of the", "/of_the");
    
    // one word queries
    input2expected.put("the", "/the");
    input2expected.put("foo", "/foo");

    // 3 word combinations s=stopword/common word n=not a stop word
    input2expected.put("n n n", "/n/n/n");
    input2expected.put("quick brown fox", "/quick/brown/fox");

    input2expected.put("n n s", "/n/n_s");
    input2expected.put("quick brown the", "/quick/brown_the");

    input2expected.put("n s n", "/n_s/s_n");
    input2expected.put("quick the brown", "/quick_the/the_brown");

    input2expected.put("n s s", "/n_s/s_s");
    input2expected.put("fox of the", "/fox_of/of_the");

    input2expected.put("s n n", "/s_n/n/n");
    input2expected.put("the quick brown", "/the_quick/quick/brown");

    input2expected.put("s n s", "/s_n/n_s");
    input2expected.put("the fox of", "/the_fox/fox_of");

    input2expected.put("s s n", "/s_s/s_n");
    input2expected.put("of the fox", "/of_the/the_fox");

    input2expected.put("s s s", "/s_s/s_s");
    input2expected.put("of the of", "/of_the/the_of");

    return input2expected;
  }

