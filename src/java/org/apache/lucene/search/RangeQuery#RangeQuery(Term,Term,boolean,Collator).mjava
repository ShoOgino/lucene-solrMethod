  /** Constructs a query selecting all terms greater than
   * <code>lowerTerm</code> but less than <code>upperTerm</code>.
   * There must be at least one term and either term may be null,
   * in which case there is no bound on that side, but if there are
   * two terms, both terms <b>must</b> be for the same field.
   * <p>
   * If <code>collator</code> is not null, it will be used to decide whether
   * index terms are within the given range, rather than using the Unicode code
   * point order in which index terms are stored.
   * <p>
   * <strong>WARNING:</strong> Using this constructor and supplying a non-null
   * value in the <code>collator</code> parameter will cause every single 
   * index Term in the Field referenced by lowerTerm and/or upperTerm to be
   * examined.  Depending on the number of index Terms in this Field, the 
   * operation could be very slow.
   *
   * @param lowerTerm The Term at the lower end of the range
   * @param upperTerm The Term at the upper end of the range
   * @param inclusive If true, both <code>lowerTerm</code> and
   *  <code>upperTerm</code> will themselves be included in the range.
   * @param collator The collator to use to collate index Terms, to determine
   *  their membership in the range bounded by <code>lowerTerm</code> and
   *  <code>upperTerm</code>.
   */
  public RangeQuery(Term lowerTerm, Term upperTerm, boolean inclusive, Collator collator) {
    if (lowerTerm == null && upperTerm == null)
      throw new IllegalArgumentException("At least one term must be non-null");
    if (lowerTerm != null && upperTerm != null && lowerTerm.field() != upperTerm.field())
      throw new IllegalArgumentException("Both terms must have the same field");
      
    delegate = new TermRangeQuery(
      (lowerTerm == null) ? upperTerm.field() : lowerTerm.field(), 
      (lowerTerm == null) ? null : lowerTerm.text(), 
      (upperTerm == null) ? null : upperTerm.text(), 
      inclusive, inclusive,
      collator
    );
    delegate.setRewriteMethod(TermRangeQuery.SCORING_BOOLEAN_QUERY_REWRITE);
  }

