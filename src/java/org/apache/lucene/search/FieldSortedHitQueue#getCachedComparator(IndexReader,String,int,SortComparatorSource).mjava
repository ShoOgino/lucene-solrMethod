	/**
	 * Returns a comparator for the given field.  If there is already one in the cache, it is returned.
	 * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the
	 * one used for the current cache, or has changed size, the cache is cleared first.
	 * @param reader  Index to use.
	 * @param field   Field to sort by.
	 * @return  Comparator; never <code>null</code>.
	 * @throws IOException  If an error occurs reading the index.
	 * @see #determineComparator
	 */
	static ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)
	throws IOException {

		if (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;
		if (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;

		// see if we have already generated a comparator for this field
		if (reader.hashCode() == lastReaderHash) {
			ScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);
			if (comparer != null && comparer.sizeMatches(reader.maxDoc())) {
				return comparer;
			}
		} else {
			lastReaderHash = reader.hashCode();
			fieldCache.clear();
		}

		ScoreDocComparator comparer = null;
		switch (type) {
			case SortField.AUTO:   comparer = determineComparator (reader, field); break;
			case SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;
			case SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;
			case SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;
			case SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;
			default:
				throw new RuntimeException ("invalid sort field type: "+type);
		}

		// store the comparator in the cache for reuse
		fieldCache.put (field, comparer);

		return comparer;
	}

