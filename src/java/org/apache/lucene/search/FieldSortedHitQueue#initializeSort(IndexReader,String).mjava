    /**
     * Initializes the cache of sort information.  <code>fieldCache</code> is queried
     * to see if it has the term information for the given field.
     * If so, and if the reader still has the same value for maxDoc()
     * (note that we assume new IndexReaders are caught during the
     * constructor), the existing data is used.  If not, all the term values
     * for the given field are fetched.  The value of the term is assumed
     * to be the sort index for any documents containing the term.  Documents
     * should only have one term in the given field. Multiple documents
     * can share the same term if desired (documents with the same term will
     * be sorted relative to each other by the order they were placed in
     * the index).
     * @param reader  The document index.
     * @param field   The field to sort by.
     * @throws IOException  If the term enumerator fails.
     */
    protected final void initializeSort (IndexReader reader, String field)
    throws IOException {

        fieldOrder = (int[]) fieldCache.get (field);
        if (fieldOrder == null || fieldOrder.length != reader.maxDoc()) {
            fieldOrder = new int [reader.maxDoc()];

            TermEnum enumerator = reader.terms (new Term (field, ""));
            TermDocs termDocs = reader.termDocs();
            if (enumerator.term() == null) {
                throw new RuntimeException ("no terms in field "+field);
            }

            try {
                Term term = enumerator.term();
                while (term.field() == field) {
                    termDocs.seek (term);
                    if (termDocs.next()) {
                        fieldOrder[termDocs.doc()] = Integer.parseInt (term.text());
                    } else {
                        throw new RuntimeException ("termDocs.next() failed!");
                    }
                    if (!enumerator.next()) {
                        break;
                    }
                    term = enumerator.term();
                }
            } finally {
                enumerator.close();
                termDocs.close();
            }

            // be careful how the cache is updated so we
            // don't have synchronization problems.  we do
            // it this way because we assume updates will be
            // few compared to the number of reads.
            HashMap newCache = (HashMap) fieldCache.clone();
            newCache.put (field, fieldOrder);
            fieldCache = newCache;
        }
    }

