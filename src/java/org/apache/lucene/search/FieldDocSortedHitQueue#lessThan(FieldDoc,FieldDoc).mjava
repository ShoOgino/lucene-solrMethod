  /**
   * Returns whether <code>a</code> is less relevant than <code>b</code>.
   * @param a ScoreDoc
   * @param b ScoreDoc
   * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
   */
  @SuppressWarnings("unchecked") @Override
  protected final boolean lessThan(final FieldDoc docA, final FieldDoc docB) {
    final int n = fields.length;
    int c = 0;
    for (int i=0; i<n && c==0; ++i) {
      final int type = fields[i].getType();
      if (type == SortField.STRING) {
        final String s1 = (String) docA.fields[i];
        final String s2 = (String) docB.fields[i];
        // null values need to be sorted first, because of how FieldCache.getStringIndex()
        // works - in that routine, any documents without a value in the given field are
        // put first.  If both are null, the next SortField is used
        if (s1 == null) {
          c = (s2 == null) ? 0 : -1;
        } else if (s2 == null) {
          c = 1;
        } else if (fields[i].getLocale() == null) {
          c = s1.compareTo(s2);
        } else {
          c = collators[i].compare(s1, s2);
        }
      } else {
        c = docA.fields[i].compareTo(docB.fields[i]);
        if (type == SortField.SCORE) {
          c = -c;
        }
      }
      // reverse sort
      if (fields[i].getReverse()) {
        c = -c;
      }
    }

    // avoid random sort order that could lead to duplicates (bug #31241):
    if (c == 0)
      return docA.doc > docB.doc;

    return c > 0;
  }

