  public void run() {
    try {
      docs = (sort == null) ? searchable.search (weight, filter, nDocs)
        : searchable.search (weight, filter, nDocs, sort);
    }
    // Store the IOException for later use by the caller of this thread
    catch (IOException ioe) {
      this.ioe = ioe;
    }
    if (ioe == null) {
      if (sort != null) {
        TopFieldDocs docsFields = (TopFieldDocs) docs;
        // If one of the Sort fields is FIELD_DOC, need to fix its values, so that
        // it will break ties by doc Id properly. Otherwise, it will compare to
        // 'relative' doc Ids, that belong to two different searchables.
        for (int j = 0; j < docsFields.fields.length; j++) {
          if (docsFields.fields[j].getType() == SortField.DOC) {
            // iterate over the score docs and change their fields value
            for (int j2 = 0; j2 < docs.scoreDocs.length; j2++) {
              FieldDoc fd = (FieldDoc) docs.scoreDocs[j2];
              fd.fields[j] = Integer.valueOf(((Integer) fd.fields[j]).intValue() + starts[i]);
            }
            break;
          }
        }

        ((FieldDocSortedHitQueue) hq).setFields(docsFields.fields);
      }
      ScoreDoc[] scoreDocs = docs.scoreDocs;
      for (int j = 0;
           j < scoreDocs.length;
           j++) { // merge scoreDocs into hq
        ScoreDoc scoreDoc = scoreDocs[j];
        scoreDoc.doc += starts[i]; // convert doc 
        //it would be so nice if we had a thread-safe insert 
        synchronized (hq) {
          if (scoreDoc == hq.insertWithOverflow(scoreDoc))
            break;
        } // no more scores > minScore
      }
    }
  }

