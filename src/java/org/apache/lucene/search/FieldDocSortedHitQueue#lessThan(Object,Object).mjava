	/**
	 * Returns whether <code>a</code> is less relevant than <code>b</code>.
	 * @param a ScoreDoc
	 * @param b ScoreDoc
	 * @return <code>true</code> if document <code>a</code> should be sorted after document <code>b</code>.
	 */
	protected final boolean lessThan (final Object a, final Object b) {
		final FieldDoc docA = (FieldDoc) a;
		final FieldDoc docB = (FieldDoc) b;
		final int n = fields.length;
		int c = 0;
		for (int i=0; i<n && c==0; ++i) {
			final int type = fields[i].getType();
			if (fields[i].getReverse()) {
				switch (type) {
					case SortField.SCORE:
						float r1 = ((Float)docA.fields[i]).floatValue();
						float r2 = ((Float)docB.fields[i]).floatValue();
						if (r1 < r2) c = -1;
						if (r1 > r2) c = 1;
						break;
					case SortField.DOC:
					case SortField.INT:
					case SortField.STRING:
						int i1 = ((Integer)docA.fields[i]).intValue();
						int i2 = ((Integer)docB.fields[i]).intValue();
						if (i1 > i2) c = -1;
						if (i1 < i2) c = 1;
						break;
					case SortField.FLOAT:
						float f1 = ((Float)docA.fields[i]).floatValue();
						float f2 = ((Float)docB.fields[i]).floatValue();
						if (f1 > f2) c = -1;
						if (f1 < f2) c = 1;
						break;
					case SortField.AUTO:
						// we cannot handle this - even if we determine the type of object (Float or
						// Integer), we don't necessarily know how to compare them (both SCORE and
						// FLOAT both contain floats, but are sorted opposite of each other). Before
						// we get here, each AUTO should have been replaced with its actual value.
						throw new RuntimeException ("FieldDocSortedHitQueue cannot use an AUTO SortField");
					default:
						throw new RuntimeException ("invalid SortField type: "+type);
				}
			} else {
				switch (type) {
					case SortField.SCORE:
						float r1 = ((Float)docA.fields[i]).floatValue();
						float r2 = ((Float)docB.fields[i]).floatValue();
						if (r1 > r2) c = -1;
						if (r1 < r2) c = 1;
						break;
					case SortField.DOC:
					case SortField.INT:
					case SortField.STRING:
						int i1 = ((Integer)docA.fields[i]).intValue();
						int i2 = ((Integer)docB.fields[i]).intValue();
						if (i1 < i2) c = -1;
						if (i1 > i2) c = 1;
						break;
					case SortField.FLOAT:
						float f1 = ((Float)docA.fields[i]).floatValue();
						float f2 = ((Float)docB.fields[i]).floatValue();
						if (f1 < f2) c = -1;
						if (f1 > f2) c = 1;
						break;
					case SortField.AUTO:
						// we cannot handle this - even if we determine the type of object (Float or
						// Integer), we don't necessarily know how to compare them (both SCORE and
						// FLOAT both contain floats, but are sorted opposite of each other). Before
						// we get here, each AUTO should have been replaced with its actual value.
						throw new RuntimeException ("FieldDocSortedHitQueue cannot use an AUTO SortField");
					default:
						throw new RuntimeException ("invalid SortField type: "+type);
				}
			}
		}
		return c > 0;
	}

