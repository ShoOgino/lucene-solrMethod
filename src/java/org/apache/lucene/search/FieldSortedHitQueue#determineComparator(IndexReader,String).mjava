	/**
	 * Looks at the actual values in the field and determines whether
	 * they contain Integers, Floats or Strings.  Only the first term in the field
	 * is looked at.
	 * <p>The following patterns are used to determine the content of the terms:
	 * <p><table border="1" cellspacing="0" cellpadding="3">
	 * <tr><th>Sequence</th><th>Pattern</th><th>Type</th></tr>
	 * <tr><td>1</td><td>[0-9\-]+</td><td>Integer</td></tr>
	 * <tr><td>2</td><td>[0-9+\-\.eEfFdD]+</td><td>Float</td></tr>
	 * <tr><td>3</td><td><i>(none - default)</i></td><td>String</td></tr>
	 * </table>
	 *
	 * @param reader  Index to use.
	 * @param field   Field to create comparator for.
	 * @return  Comparator appropriate for the terms in the given field.
	 * @throws IOException  If an error occurs reading the index.
	 */
	protected static ScoreDocComparator determineComparator (IndexReader reader, String field)
	throws IOException {
		field = field.intern();
		TermEnum enumerator = reader.terms (new Term (field, ""));
		try {
			Term term = enumerator.term();
			if (term == null) {
				throw new RuntimeException ("no terms in field "+field);
			}
			if (term.field() == field) {
				String termtext = term.text().trim();

				if (pIntegers.matcher(termtext).matches())
					return IntegerSortedHitQueue.comparator (reader, enumerator, field);

				else if (pFloats.matcher(termtext).matches())
					return FloatSortedHitQueue.comparator (reader, enumerator, field);

				return StringSortedHitQueue.comparator (reader, enumerator, field);

			} else {
				throw new RuntimeException ("field \""+field+"\" does not appear to be indexed");
			}
		} finally {
			enumerator.close();
		}
	}

