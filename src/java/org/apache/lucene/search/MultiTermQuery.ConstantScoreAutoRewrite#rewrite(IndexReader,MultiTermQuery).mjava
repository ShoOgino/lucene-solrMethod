    @Override
    public Query rewrite(final IndexReader reader, final MultiTermQuery query) throws IOException {

      // Get the enum and start visiting terms.  If we
      // exhaust the enum before hitting either of the
      // cutoffs, we use ConstantBooleanQueryRewrite; else,
      // ConstantFilterRewrite:
      final int docCountCutoff = (int) ((docCountPercent / 100.) * reader.maxDoc());
      final int termCountLimit = Math.min(BooleanQuery.getMaxClauseCount(), termCountCutoff);

      final CutOffTermCollector col = new CutOffTermCollector(reader, docCountCutoff, termCountLimit);
      collectTerms(reader, query, col);
      
      if (col.hasCutOff) {
        return CONSTANT_SCORE_FILTER_REWRITE.rewrite(reader, query);
      } else {
        final Query result;
        if (col.pendingTerms.isEmpty()) {
          result = new BooleanQuery(true);
        } else {
          BooleanQuery bq = new BooleanQuery(true);
          for(Term term : col.pendingTerms) {
            TermQuery tq = new TermQuery(term);
            bq.add(tq, BooleanClause.Occur.SHOULD);
          }
          // Strip scores
          result = new ConstantScoreQuery(new QueryWrapperFilter(bq));
          result.setBoost(query.getBoost());
        }
        query.incTotalNumberOfTerms(col.pendingTerms.size());
        return result;
      }
    }

