  // javadoc inherited
  public void collect(int doc, float score) {
    if (score > 0.0f) {

      maxScore = Math.max(maxScore, score);
      totalHits++;

      // TODO: one optimization we could do is to pre-fill
      // the queue with sentinel value that guaranteed to
      // always compare lower than a real hit; this would
      // save having to check queueFull on each insert

      if (queueFull) {

        if (numComparators == 1) {
          // Common case

          // Fastmatch: return if this hit is not competitive
          final int cmp = reverseMul1 * comparator1.compareBottom(doc, score);
          if (cmp < 0) {
            // Definitely not competitive
            return;
          } else if (cmp == 0 && doc + currentDocBase > bottom.docID) {
            // Definitely not competitive
            return;
          }

          // This hit is competitive -- replace bottom
          // element in queue & adjustTop
          comparator1.copy(bottom.slot, doc, score);

          updateBottom(doc, score);

          comparator1.setBottom(bottom.slot);

        } else {

          // Fastmatch: return if this hit is not competitive
          for(int i=0;;i++) {
            final int c = reverseMul[i] * comparators[i].compareBottom(doc, score);
            if (c < 0) {
              // Definitely not competitive
              return;
            } else if (c > 0) {
              // Definitely competitive
              break;
            } else if (i == numComparators-1) {
              // This is the equals case.
              if (doc + currentDocBase > bottom.docID) {
                // Definitely not competitive
                return;
              } else {
                break;
              }
            }
          }

          // This hit is competitive -- replace bottom
          // element in queue & adjustTop
          for (int i = 0; i < numComparators; i++) {
            comparators[i].copy(bottom.slot, doc, score);
          }

          updateBottom(doc, score);

          for(int i=0;i<numComparators;i++) {
            comparators[i].setBottom(bottom.slot);
          }
        }
      } else {
        // Startup transient: queue hasn't gathered numHits
        // yet

        final int slot = totalHits-1;
        // Copy hit into queue
        if (numComparators == 1) {
          // Common case
          comparator1.copy(slot, doc, score);
          add(slot, doc, score);
          if (queueFull) {
            comparator1.setBottom(bottom.slot);
          }

        } else {
          for (int i = 0; i < numComparators; i++) {
            comparators[i].copy(slot, doc, score);
          }
          add(slot, doc, score);
          if (queueFull) {
            for(int i=0;i<numComparators;i++) {
              comparators[i].setBottom(bottom.slot);
            }
          }
        }
      }
    }
  }

