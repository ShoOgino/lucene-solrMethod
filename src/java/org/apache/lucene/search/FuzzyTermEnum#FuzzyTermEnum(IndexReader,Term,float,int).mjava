    /**
     * Constructor for enumeration of all terms from specified <code>reader</code> which share a prefix of
     * length <code>prefixLength</code> with <code>term</code> and which have a fuzzy similarity &gt;
     * <code>minSimilarity</code>. 
     * 
     * @param reader Delivers terms.
     * @param term Pattern term.
     * @param minSimilarity Minimum required similarity for terms from the reader. Default value is 0.5f.
     * @param prefixLength Length of required common prefix. Default value is 0.
     * @throws IOException
     */
    public FuzzyTermEnum(IndexReader reader, Term term, final float minSimilarity, final int prefixLength) throws IOException {
        super();
        
        if (minSimilarity >= 1.0f)
          throw new IllegalArgumentException("minimumSimilarity cannot be greater than or equal to 1");
        else if (minSimilarity < 0.0f)
          throw new IllegalArgumentException("minimumSimilarity cannot be less than 0");
        if(prefixLength < 0)
          throw new IllegalArgumentException("prefixLength cannot be less than 0");

        this.minimumSimilarity = minSimilarity;
        this.scale_factor = 1.0f / (1.0f - minimumSimilarity);
        this.searchTerm = term;
        this.field = searchTerm.field();

        //The prefix could be longer than the word.
        //It's kind of silly though.  It means we must match the entire word.
        final int fullSearchTermLength = searchTerm.text().length();
        final int realPrefixLength = prefixLength > fullSearchTermLength ? fullSearchTermLength : prefixLength;

        this.text = searchTerm.text().substring(realPrefixLength);
        this.prefix = searchTerm.text().substring(0, realPrefixLength);

        initializeMaxDistances();
        this.d = initDistanceArray();

        setEnum(reader.terms(new Term(searchTerm.field(), prefix)));
    }

