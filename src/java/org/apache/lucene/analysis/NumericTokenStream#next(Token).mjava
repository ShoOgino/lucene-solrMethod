  // @Override
  /** @deprecated Will be removed in Lucene 3.0 */
  public Token next(final Token reusableToken) {
    assert reusableToken != null;
    if (valSize == 0)
      throw new IllegalStateException("call set???Value() before usage");
    if (shift >= valSize)
      return null;
    
    reusableToken.clear();

    final char[] buffer;
    switch (valSize) {
      case 64:
        buffer = reusableToken.resizeTermBuffer(NumericUtils.LONG_BUF_SIZE);
        reusableToken.setTermLength(NumericUtils.longToPrefixCoded(value, shift, buffer));
        reusableToken.setType((shift == 0) ? TOKEN_TYPE_FULL_PREC_64 : TOKEN_TYPE_LOWER_PREC_64);
        break;
      
      case 32:
        buffer = reusableToken.resizeTermBuffer(NumericUtils.INT_BUF_SIZE);
        reusableToken.setTermLength(NumericUtils.intToPrefixCoded((int) value, shift, buffer));
        reusableToken.setType((shift == 0) ? TOKEN_TYPE_FULL_PREC_32 : TOKEN_TYPE_LOWER_PREC_32);
        break;
      
      default:
        // should not happen
        throw new IllegalArgumentException("valSize must be 32 or 64");
    }

    reusableToken.setPositionIncrement((shift == 0) ? 1 : 0);
    shift += precisionStep;
    return reusableToken;
  }

