  public synchronized boolean obtain() throws IOException {

    if (isLocked()) {
      // We are already locked:
      return false;
    }

    // Ensure that lockDir exists and is a directory.
    if (!lockDir.exists()) {
      if (!lockDir.mkdirs())
        throw new IOException("Cannot create directory: " +
                              lockDir.getAbsolutePath());
    } else if (!lockDir.isDirectory()) {
      throw new IOException("Found regular file where directory expected: " + 
                            lockDir.getAbsolutePath());
    }

    f = new RandomAccessFile(path, "rw");
    try {
      channel = f.getChannel();
      try {
        try {
          lock = channel.tryLock();
        } catch (IOException e) {
          // At least on OS X, we will sometimes get an
          // intermittant "Permission Denied" IOException,
          // which seems to simply mean "you failed to get
          // the lock".  But other IOExceptions could be
          // "permanent" (eg, locking is not supported via
          // the filesystem).  So, we record the failure
          // reason here; the timeout obtain (usually the
          // one calling us) will use this as "root cause"
          // if it fails to get the lock.
          failureReason = e;
        }
      } finally {
        if (lock == null) {
          try {
            channel.close();
          } finally {
            channel = null;
          }
        }
      }
    } finally {
      if (channel == null) {
        try {
          f.close();
        } finally {
          f = null;
        }
      }
    }
    return lock != null;
  }

