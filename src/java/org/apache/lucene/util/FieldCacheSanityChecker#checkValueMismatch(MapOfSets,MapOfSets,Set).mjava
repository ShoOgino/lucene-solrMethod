  /** 
   * Internal helper method used by check that iterates over 
   * valMismatchKeys and generates a Collection of Insanity 
   * instances accordingly.  The MapOfSets are used to populate 
   * the Insanity objects. 
   * @see InsanityType#VALUEMISMATCH
   */
  private Collection checkValueMismatch(MapOfSets valIdToItems,
                                        MapOfSets readerFieldToValIds,
                                        Set valMismatchKeys) {

    final List insanity = new ArrayList(valMismatchKeys.size() * 3);

    if (! valMismatchKeys.isEmpty() ) { 
      // we have multiple values for some ReaderFields

      final Map rfMap = readerFieldToValIds.getMap();
      final Map valMap = valIdToItems.getMap();
      final Iterator mismatchIter = valMismatchKeys.iterator();
      while (mismatchIter.hasNext()) {
        final ReaderField rf = (ReaderField)mismatchIter.next();
        final List badEntries = new ArrayList(valMismatchKeys.size() * 2);
        final Iterator valIter = ((Set)rfMap.get(rf)).iterator();
        while (valIter.hasNext()) {
          Iterator entriesIter = ((Set)valMap.get(valIter.next())).iterator();
          while (entriesIter.hasNext()) {
            badEntries.add(entriesIter.next());
          }
        }

        CacheEntry[] badness = new CacheEntry[badEntries.size()];
        badness = (CacheEntry[]) badEntries.toArray(badness);

        insanity.add(new Insanity(InsanityType.VALUEMISMATCH,
                                  "Multiple distinct value objects for " + 
                                  rf.toString(), badness));
      }
    }
    return insanity;
  }

