  /**
   * Encodes the input byte sequence into the output char sequence.  Before
   * calling this method, ensure that the output CharBuffer has sufficient
   * capacity by calling {@link #getEncodedLength(java.nio.ByteBuffer)}.
   * 
   * @param input The byte sequence to encode
   * @param output Where the char sequence encoding result will go.  The limit
   *  is set to one past the position of the final char.
   * @throws IllegalArgumentException If either the input or the output buffer
   *  is not backed by an array
   */
  public static void encode(ByteBuffer input, CharBuffer output) {
    if (input.hasArray() && output.hasArray()) {
      byte[] inputArray = input.array();
      int inputOffset = input.arrayOffset();
      int inputLength = input.limit() - inputOffset; 
      char[] outputArray = output.array();
      int outputOffset = output.arrayOffset();
      int outputLength = getEncodedLength(input);
      output.limit(outputOffset + outputLength); // Set output final pos + 1
      output.position(0);
      if (inputLength > 0) {
        int inputByteNum = inputOffset;
        int caseNum = 0;
        int outputCharNum = outputOffset;
        CodingCase codingCase;
        for ( ; inputByteNum + CODING_CASES[caseNum].numBytes <= inputLength ;
              ++outputCharNum                                                 ) {
          codingCase = CODING_CASES[caseNum];
          if (2 == codingCase.numBytes) {
            outputArray[outputCharNum]
              = (char)(((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)
                       + (((inputArray[inputByteNum + 1] & 0xFF) >>> codingCase.finalShift)
                          & codingCase.finalMask)
                       & (short)0x7FFF);
          } else { // numBytes is 3
            outputArray[outputCharNum] 
              = (char)(((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)
                       + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift)
                       + (((inputArray[inputByteNum + 2] & 0xFF) >>> codingCase.finalShift) 
                          & codingCase.finalMask)
                       & (short)0x7FFF);          
          }
          inputByteNum += codingCase.advanceBytes;          
          if (++caseNum == CODING_CASES.length) {
            caseNum = 0;
          }
        }
        // Produce final char (if any) and trailing count chars.
        codingCase = CODING_CASES[caseNum];
        
        if (inputByteNum + 1 < inputLength) { // codingCase.numBytes must be 3
          outputArray[outputCharNum++] 
            = (char)((((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)
                      + ((inputArray[inputByteNum + 1] & 0xFF) << codingCase.middleShift))
                     & (short)0x7FFF);
          // Add trailing char containing the number of full bytes in final char
          outputArray[outputCharNum++] = (char)1;
        } else if (inputByteNum < inputLength) {
          outputArray[outputCharNum++] 
            = (char)(((inputArray[inputByteNum] & 0xFF) << codingCase.initialShift)
                     & (short)0x7FFF);
          // Add trailing char containing the number of full bytes in final char
          outputArray[outputCharNum++] = caseNum == 0 ? (char)1 : (char)0;
        } else { // No left over bits - last char is completely filled.
          // Add trailing char containing the number of full bytes in final char
          outputArray[outputCharNum++] = (char)1;
        }
      }
    } else {
      throw new IllegalArgumentException("Arguments must have backing arrays");
    }
  }

