  /**
   * @exception ParseException throw in overridden method to disallow
   */
  protected Query getFieldQuery(String field, String queryText)  throws ParseException {
    // Use the analyzer to get all the tokens, and then build a TermQuery,
    // PhraseQuery, or nothing based on the term count

    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));
    List list = new ArrayList();
    final org.apache.lucene.analysis.Token reusableToken = new org.apache.lucene.analysis.Token();
    org.apache.lucene.analysis.Token nextToken;
    int positionCount = 0;
    boolean severalTokensAtSamePosition = false;

    while (true) {
      try {
        nextToken = source.next(reusableToken);
      }
      catch (IOException e) {
        nextToken = null;
      }
      if (nextToken == null)
        break;
      list.add(nextToken.clone());
      if (nextToken.getPositionIncrement() != 0)
        positionCount += nextToken.getPositionIncrement();
      else
        severalTokensAtSamePosition = true;
    }
    try {
      source.close();
    }
    catch (IOException e) {
      // ignore
    }

    if (list.size() == 0)
      return null;
    else if (list.size() == 1) {
      nextToken = (org.apache.lucene.analysis.Token) list.get(0);
      return newTermQuery(new Term(field, nextToken.term()));
    } else {
      if (severalTokensAtSamePosition) {
        if (positionCount == 1) {
          // no phrase query:
          BooleanQuery q = newBooleanQuery(true);
          for (int i = 0; i < list.size(); i++) {
            nextToken = (org.apache.lucene.analysis.Token) list.get(i);
            Query currentQuery = newTermQuery(
                new Term(field, nextToken.term()));
            q.add(currentQuery, BooleanClause.Occur.SHOULD);
          }
          return q;
        }
        else {
          // phrase query:
          MultiPhraseQuery mpq = newMultiPhraseQuery();
          mpq.setSlop(phraseSlop);
          List multiTerms = new ArrayList();
          int position = -1;
          for (int i = 0; i < list.size(); i++) {
            nextToken = (org.apache.lucene.analysis.Token) list.get(i);
            if (nextToken.getPositionIncrement() > 0 && multiTerms.size() > 0) {
              if (enablePositionIncrements) {
                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
              } else {
                mpq.add((Term[])multiTerms.toArray(new Term[0]));
              }
              multiTerms.clear();
            }
            position += nextToken.getPositionIncrement();
            multiTerms.add(new Term(field, nextToken.term()));
          }
          if (enablePositionIncrements) {
            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
          } else {
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
          }
          return mpq;
        }
      }
      else {
        PhraseQuery pq = newPhraseQuery();
        pq.setSlop(phraseSlop);
        int position = -1;
        for (int i = 0; i < list.size(); i++) {
          nextToken = (org.apache.lucene.analysis.Token) list.get(i);
          if (enablePositionIncrements) {
            position += nextToken.getPositionIncrement();
            pq.add(new Term(field, nextToken.term()),position);
          } else {
            pq.add(new Term(field, nextToken.term()));
          }
        }
        return pq;
      }
    }
  }

