  /**
   * @exception ParseException throw in overridden method to disallow
   */
  protected Query getFieldQuery(String field, String queryText)  throws ParseException {
    // Use the analyzer to get all the tokens, and then build a TermQuery,
    // PhraseQuery, or nothing based on the term count

    TokenStream source = analyzer.tokenStream(field, new StringReader(queryText));
    CachingTokenFilter buffer = new CachingTokenFilter(source);
    TermAttribute termAtt = null;
    PositionIncrementAttribute posIncrAtt = null;
    int numTokens = 0;

    org.apache.lucene.analysis.Token reusableToken = null;
    org.apache.lucene.analysis.Token nextToken = null;


    boolean useNewAPI = TokenStream.useNewAPIDefault();

    if (useNewAPI) {
      boolean success = false;
      try {
        buffer.reset();
        success = true;
      } catch (IOException e) {
        // success==false if we hit an exception
      }
      if (success) {
        if (buffer.hasAttribute(TermAttribute.class)) {
          termAtt = (TermAttribute) buffer.getAttribute(TermAttribute.class);
        }
        if (buffer.hasAttribute(PositionIncrementAttribute.class)) {
          posIncrAtt = (PositionIncrementAttribute) buffer.getAttribute(PositionIncrementAttribute.class);
        }
      }
    } else {
      reusableToken = new org.apache.lucene.analysis.Token();
    }

    int positionCount = 0;
    boolean severalTokensAtSamePosition = false;

    if (useNewAPI) {
      if (termAtt != null) {
        try {
          while (buffer.incrementToken()) {
            numTokens++;
            int positionIncrement = (posIncrAtt != null) ? posIncrAtt.getPositionIncrement() : 1;
            if (positionIncrement != 0) {
              positionCount += positionIncrement;
            } else {
              severalTokensAtSamePosition = true;
            }
          }
        } catch (IOException e) {
          // ignore
        }
      }
    } else {
      while (true) {
        try {
          nextToken = buffer.next(reusableToken);
        }
        catch (IOException e) {
          nextToken = null;
        }
        if (nextToken == null)
          break;
        numTokens++;
        if (nextToken.getPositionIncrement() != 0)
          positionCount += nextToken.getPositionIncrement();
        else
          severalTokensAtSamePosition = true;
      }
    }
    try {
      // rewind the buffer stream
      buffer.reset();

      // close original stream - all tokens buffered
      source.close();
    }
    catch (IOException e) {
      // ignore
    }

    if (numTokens == 0)
      return null;
    else if (numTokens == 1) {
      String term = null;
      try {

        if (useNewAPI) {
          boolean hasNext = buffer.incrementToken();
          assert hasNext == true;
          term = termAtt.term();
        } else {
          nextToken = buffer.next(reusableToken);
          assert nextToken != null;
          term = nextToken.term();
        }
      } catch (IOException e) {
        // safe to ignore, because we know the number of tokens
      }
      return newTermQuery(new Term(field, term));
    } else {
      if (severalTokensAtSamePosition) {
        if (positionCount == 1) {
          // no phrase query:
          BooleanQuery q = newBooleanQuery(true);
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            try {
              if (useNewAPI) {
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                term = termAtt.term();
              } else {
                nextToken = buffer.next(reusableToken);
                assert nextToken != null;
                term = nextToken.term();
              }
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            Query currentQuery = newTermQuery(
                new Term(field, term));
            q.add(currentQuery, BooleanClause.Occur.SHOULD);
          }
          return q;
        }
        else {
          // phrase query:
          MultiPhraseQuery mpq = newMultiPhraseQuery();
          mpq.setSlop(phraseSlop);
          List multiTerms = new ArrayList();
          int position = -1;
          for (int i = 0; i < numTokens; i++) {
            String term = null;
            int positionIncrement = 1;
            try {
              if (useNewAPI) {
                boolean hasNext = buffer.incrementToken();
                assert hasNext == true;
                term = termAtt.term();
                if (posIncrAtt != null) {
                  positionIncrement = posIncrAtt.getPositionIncrement();
                }
              } else {
                nextToken = buffer.next(reusableToken);
                assert nextToken != null;
                term = nextToken.term();
                positionIncrement = nextToken.getPositionIncrement();
              }
            } catch (IOException e) {
              // safe to ignore, because we know the number of tokens
            }

            if (positionIncrement > 0 && multiTerms.size() > 0) {
              if (enablePositionIncrements) {
                mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
              } else {
                mpq.add((Term[])multiTerms.toArray(new Term[0]));
              }
              multiTerms.clear();
            }
            position += positionIncrement;
            multiTerms.add(new Term(field, term));
          }
          if (enablePositionIncrements) {
            mpq.add((Term[])multiTerms.toArray(new Term[0]),position);
          } else {
            mpq.add((Term[])multiTerms.toArray(new Term[0]));
          }
          return mpq;
        }
      }
      else {
        PhraseQuery pq = newPhraseQuery();
        pq.setSlop(phraseSlop);
        int position = -1;


        for (int i = 0; i < numTokens; i++) {
          String term = null;
          int positionIncrement = 1;

          try {
            if (useNewAPI) {

              boolean hasNext = buffer.incrementToken();
              assert hasNext == true;
              term = termAtt.term();
              if (posIncrAtt != null) {
                positionIncrement = posIncrAtt.getPositionIncrement();
              }
            } else {
              nextToken = buffer.next(reusableToken);
              assert nextToken != null;
              term = nextToken.term();
              positionIncrement = nextToken.getPositionIncrement();
            }
          } catch (IOException e) {
            // safe to ignore, because we know the number of tokens
          }

          if (enablePositionIncrements) {
            position += positionIncrement;
            pq.add(new Term(field, term),position);
          } else {
            pq.add(new Term(field, term));
          }
        }
        return pq;
      }
    }
  }

