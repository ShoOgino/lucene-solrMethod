    public void run() {
      
      // First time through the while loop we do the merge
      // that we were started with:
      MergePolicy.OneMerge merge = this.startMerge;
      
      try {

        if (VERBOSE)
          message("  merge thread: start");

        while(true) {
          setRunningMerge(merge);
          writer.merge(merge);

          // Subsequent times through the loop we do any new
          // merge that writer says is necessary:
          merge = writer.getNextMerge();
          if (merge != null) {
            writer.mergeInit(merge);
            if (VERBOSE)
              message("  merge thread: do another merge " + merge.segString(dir));
          } else
            break;
        }

        if (VERBOSE)
          message("  merge thread: done");

      } catch (Throwable exc) {
        // When a merge was aborted & IndexWriter closed,
        // it's possible to get various IOExceptions,
        // NullPointerExceptions, AlreadyClosedExceptions:
        if (merge != null) {
          merge.setException(exc);
          writer.addMergeException(merge);
        }

        if (merge == null || !merge.isAborted()) {
          // If the merge was not aborted then the exception
          // is real
          synchronized(ConcurrentMergeScheduler.this) {
            exceptions.add(exc);
          }
          
          if (!suppressExceptions) {
            // suppressExceptions is normally only set during
            // testing.
            anyExceptions = true;
            throw new MergePolicy.MergeException(exc);
          }
        }
      } finally {
        synchronized(ConcurrentMergeScheduler.this) {
          mergeThreads.remove(this);
          ConcurrentMergeScheduler.this.notifyAll();
        }
      }
    }

