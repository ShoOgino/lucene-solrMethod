  public final synchronized IndexReader reopen() throws CorruptIndexException, IOException {
    ensureOpen();

    if (this.hasChanges || this.isCurrent()) {
      // this has changes, therefore we have the lock and don't need to reopen
      // OR: the index in the directory hasn't changed - nothing to do here
      return this;
    }

    final SegmentInfos.FindSegmentsFile finder = new SegmentInfos.FindSegmentsFile(directory) {

      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
        SegmentInfos infos = new SegmentInfos();
        infos.read(directory, segmentFileName);

        DirectoryIndexReader newReader = doReopen(infos);
        
        if (DirectoryIndexReader.this != newReader) {
          newReader.init(directory, infos, closeDirectory, readOnly);
          newReader.deletionPolicy = deletionPolicy;
        }

        return newReader;
      }
    };

    DirectoryIndexReader reader = null;

    // While trying to reopen, we temporarily mark our
    // closeDirectory as false.  This way any exceptions hit
    // partway while opening the reader, which is expected
    // eg if writer is committing, won't close our
    // directory.  We restore this value below:
    final boolean myCloseDirectory = closeDirectory;
    closeDirectory = false;

    try {
      reader = (DirectoryIndexReader) finder.run();
    } finally {
      if (myCloseDirectory) {
        assert directory instanceof FSDirectory;
        // Restore my closeDirectory
        closeDirectory = true;
        if (reader != null && reader != this) {
          // Success, and a new reader was actually opened
          reader.closeDirectory = true;
          // Clone the directory
          reader.directory = FSDirectory.getDirectory(((FSDirectory) directory).getFile());
        }
      }
    }

    return reader;
  }

