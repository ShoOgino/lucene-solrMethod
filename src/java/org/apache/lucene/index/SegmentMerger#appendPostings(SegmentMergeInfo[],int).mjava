  private final int appendPostings(SegmentMergeInfo[] smis, int n)
       throws IOException {
    int lastDoc = 0;
    int df = 0;					  // number of docs w/ term
    for (int i = 0; i < n; i++) {
      SegmentMergeInfo smi = smis[i];
      SegmentTermPositions postings = smi.postings;
      int base = smi.base;
      int[] docMap = smi.docMap;
      smi.termEnum.termInfo(termInfo);
      postings.seek(termInfo);
      while (postings.next()) {
        int doc;
        if (docMap == null)
          doc = base + postings.doc;		  // no deletions
        else
          doc = base + docMap[postings.doc];	  // re-map around deletions

        if (doc < lastDoc)
          throw new IllegalStateException("docs out of order");

        int docCode = (doc - lastDoc) << 1;	  // use low bit to flag freq=1
        lastDoc = doc;

        int freq = postings.freq;
        if (freq == 1) {
          freqOutput.writeVInt(docCode | 1);	  // write doc & freq=1
        } else {
          freqOutput.writeVInt(docCode);	  // write doc
          freqOutput.writeVInt(freq);		  // write frequency in doc
        }
          
        int lastPosition = 0;			  // write position deltas
        for (int j = 0; j < freq; j++) {
          int position = postings.nextPosition();
          proxOutput.writeVInt(position - lastPosition);
          lastPosition = position;
        }

        df++;
      }
    }
    return df;
  }

