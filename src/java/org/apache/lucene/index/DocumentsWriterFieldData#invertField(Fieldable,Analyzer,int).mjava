  /* Invert one occurrence of one field in the document */
  public void invertField(Fieldable field, Analyzer analyzer, final int maxFieldLength) throws IOException, AbortException {

    if (length>0)
      position += analyzer.getPositionIncrementGap(fieldInfo.name);

    if (!field.isTokenized()) {		  // un-tokenized field
      String stringValue = field.stringValue();
      final int valueLength = stringValue.length();
      Token token = localToken;
      token.clear();
      char[] termBuffer = token.termBuffer();
      if (termBuffer.length < valueLength)
        termBuffer = token.resizeTermBuffer(valueLength);
      stringValue.getChars(0, valueLength, termBuffer, 0);
      token.setTermLength(valueLength);
      token.setStartOffset(offset);
      token.setEndOffset(offset + stringValue.length());
      addPosition(token);
      offset += stringValue.length();
      length++;
    } else {                                  // tokenized field
      final TokenStream stream;
      final TokenStream streamValue = field.tokenStreamValue();

      if (streamValue != null) 
        stream = streamValue;
      else {
        // the field does not have a TokenStream,
        // so we have to obtain one from the analyzer
        final Reader reader;			  // find or make Reader
        final Reader readerValue = field.readerValue();

        if (readerValue != null)
          reader = readerValue;
        else {
          String stringValue = field.stringValue();
          if (stringValue == null)
            throw new IllegalArgumentException("field must have either TokenStream, String or Reader value");
          threadState.stringReader.init(stringValue);
          reader = threadState.stringReader;
        }
          
        // Tokenize field and add to postingTable
        stream = analyzer.reusableTokenStream(fieldInfo.name, reader);
      }

      // reset the TokenStream to the first token
      stream.reset();

      try {
        offsetEnd = offset-1;
        for(;;) {
          Token token = stream.next(localToken);
          if (token == null) break;
          position += (token.getPositionIncrement() - 1);
          // LUCENE-1255: don't allow negative positon
          if (position < 0)
            position = 0;
          addPosition(token);
          if (++length >= maxFieldLength) {
            if (threadState.docWriter.infoStream != null)
              threadState.docWriter.infoStream.println("maxFieldLength " +maxFieldLength+ " reached for field " + fieldInfo.name + ", ignoring following tokens");
            break;
          }
        }
        offset = offsetEnd+1;
      } finally {
        stream.close();
      }
    }

    boost *= field.getBoost();
  }

