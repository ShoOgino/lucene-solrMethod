  private final void write(Directory directory) throws IOException {

    String segmentFileName = getNextSegmentFileName();

    // Always advance the generation on write:
    if (generation == -1) {
      generation = 1;
    } else {
      generation++;
    }

    ChecksumIndexOutput output = new ChecksumIndexOutput(directory.createOutput(segmentFileName));

    boolean success = false;

    try {
      output.writeInt(CURRENT_FORMAT); // write FORMAT
      output.writeLong(++version); // every write changes
                                   // the index
      output.writeInt(counter); // write counter
      output.writeInt(size()); // write infos
      for (int i = 0; i < size(); i++) {
        info(i).write(output);
      }
      final long checksum = output.getChecksum();
      output.writeLong(checksum);
      success = true;
    } finally {
      boolean success2 = false;
      try {
        if (!success) {
          // We hit an exception above; try to close the file
          // but suppress any exception:
          try {
            output.close();
            success2 = true;
          } catch (Throwable t) {
            // Suppress so we keep throwing the original exception
          }
        } else {
          output.close();
          success2 = true;
        }
      } finally {
        if (!success || !success2) {
          try {
            // Try not to leave a truncated segments_N file in
            // the index:
            directory.deleteFile(segmentFileName);
          } catch (Throwable t) {
            // Suppress so we keep throwing the original exception
          }
        }
      }
    }

    try {
      IndexOutput genOutput = directory.createOutput(IndexFileNames.SEGMENTS_GEN);
      try {
        genOutput.writeInt(FORMAT_LOCKLESS);
        genOutput.writeLong(generation);
        genOutput.writeLong(generation);
      } finally {
        genOutput.close();
      }
    } catch (IOException e) {
      // It's OK if we fail to write this file since it's
      // used only as one of the retry fallbacks.
    }
    
    lastGeneration = generation;
  }

