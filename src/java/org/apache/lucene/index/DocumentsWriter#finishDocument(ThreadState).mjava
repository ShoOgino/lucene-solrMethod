  /** Does the synchronized work to finish/flush the
   * inverted document. */
  private synchronized void finishDocument(ThreadState state) throws IOException {

    // Now write the indexed document to the real files.

    if (nextWriteDocID == state.docID) {
      // It's my turn, so write everything now:
      state.isIdle = true;
      nextWriteDocID++;
      state.writeDocument();

      // If any states were waiting on me, sweep through and
      // flush those that are enabled by my write.
      if (numWaiting > 0) {
        while(true) {
          int upto = 0;
          for(int i=0;i<numWaiting;i++) {
            ThreadState s = waitingThreadStates[i];
            if (s.docID == nextWriteDocID) {
              s.isIdle = true;
              nextWriteDocID++;
              s.writeDocument();
            } else
              // Compact as we go
              waitingThreadStates[upto++] = waitingThreadStates[i];
          }
          if (upto == numWaiting) 
            break;
          numWaiting = upto;
        }
      }

      // Now notify any incoming calls to addDocument
      // (above) that are waiting on our line to
      // shrink
      notifyAll();

    } else {
      // Another thread got a docID before me, but, it
      // hasn't finished its processing.  So add myself to
      // the line but don't hold up this thread.
      if (numWaiting == waitingThreadStates.length) {
        ThreadState[] newWaiting = new ThreadState[2*waitingThreadStates.length];
        System.arraycopy(waitingThreadStates, 0, newWaiting, 0, numWaiting);
        waitingThreadStates = newWaiting;
      }
      waitingThreadStates[numWaiting++] = state;
    }
  }

