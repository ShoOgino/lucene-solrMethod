  // Used by near real-time search
  DirectoryReader(IndexWriter writer, SegmentInfos infos, int termInfosIndexDivisor) throws IOException {
    this.directory = writer.getDirectory();
    this.readOnly = true;
    segmentInfos = infos;
    segmentInfosStart = (SegmentInfos) infos.clone();
    this.termInfosIndexDivisor = termInfosIndexDivisor;
    if (!readOnly) {
      // We assume that this segments_N was previously
      // properly sync'd:
      synced.addAll(infos.files(directory, true));
    }

    // IndexWriter synchronizes externally before calling
    // us, which ensures infos will not change; so there's
    // no need to process segments in reverse order
    final int numSegments = infos.size();
    SegmentReader[] readers = new SegmentReader[numSegments];
    final Directory dir = writer.getDirectory();
    int upto = 0;

    for (int i=0;i<numSegments;i++) {
      boolean success = false;
      try {
        final SegmentInfo info = infos.info(upto);
        if (info.dir == dir) {
          readers[upto++] = writer.readerPool.getReadOnlyClone(info, true, termInfosIndexDivisor);
        }
        success = true;
      } finally {
        if (!success) {
          // Close all readers we had opened:
          for(upto--;upto>=0;upto--) {
            try {
              readers[upto].close();
            } catch (Throwable ignore) {
              // keep going - we want to clean up as much as possible
            }
          }
        }
      }
    }

    this.writer = writer;

    if (upto < readers.length) {
      // This means some segments were in a foreign Directory
      SegmentReader[] newReaders = new SegmentReader[upto];
      System.arraycopy(readers, 0, newReaders, 0, upto);
      readers = newReaders;
    }

    initialize(readers);
  }

