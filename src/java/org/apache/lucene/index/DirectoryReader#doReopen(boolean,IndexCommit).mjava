  private synchronized IndexReader doReopen(final boolean openReadOnly, IndexCommit commit) throws CorruptIndexException, IOException {
    ensureOpen();

    assert commit == null || openReadOnly;

    // If we were obtained by writer.getReader(), re-ask the
    // writer to get a new reader.
    if (writer != null) {
      assert readOnly;

      if (!openReadOnly) {
        throw new IllegalArgumentException("a reader obtained from IndexWriter.getReader() can only be reopened with openReadOnly=true (got false)");
      }

      if (commit != null) {
        throw new IllegalArgumentException("a reader obtained from IndexWriter.getReader() cannot currently accept a commit");
      }

      if (!writer.isOpen(true)) {
        throw new AlreadyClosedException("cannot reopen: the IndexWriter this reader was obtained from is now closed");
      }

      // TODO: right now we *always* make a new reader; in
      // the future we could have write make some effort to
      // detect that no changes have occurred
      IndexReader reader = writer.getReader();
      reader.setDisableFakeNorms(getDisableFakeNorms());
      return reader;
    }

    if (commit == null) {
      if (hasChanges) {
        // We have changes, which means we are not readOnly:
        assert readOnly == false;
        // and we hold the write lock:
        assert writeLock != null;
        // so no other writer holds the write lock, which
        // means no changes could have been done to the index:
        assert isCurrent();

        if (openReadOnly) {
          return (IndexReader) clone(openReadOnly);
        } else {
          return this;
        }
      } else if (isCurrent()) {
        if (openReadOnly != readOnly) {
          // Just fallback to clone
          return (IndexReader) clone(openReadOnly);
        } else {
          return this;
        }
      }
    } else {
      if (directory != commit.getDirectory())
        throw new IOException("the specified commit does not match the specified Directory");
      if (segmentInfos != null && commit.getSegmentsFileName().equals(segmentInfos.getCurrentSegmentFileName())) {
        if (readOnly != openReadOnly) {
          // Just fallback to clone
          return (IndexReader) clone(openReadOnly);
        } else {
          return this;
        }
      }
    }

    final SegmentInfos.FindSegmentsFile finder = new SegmentInfos.FindSegmentsFile(directory) {

      protected Object doBody(String segmentFileName) throws CorruptIndexException, IOException {
        SegmentInfos infos = new SegmentInfos();
        infos.read(directory, segmentFileName);
        return doReopen(infos, false, openReadOnly);
      }
    };

    DirectoryReader reader = null;

    /* TODO: Remove this in 3.0 - the directory is then
     * no longer owned by the IndexReader and must not be
     * closed.
     * While trying to reopen, we temporarily mark our
     * closeDirectory as false.  This way any exceptions hit
     * partway while opening the reader, which is expected
     * eg if writer is committing, won't close our
     * directory.  We restore this value below:
     */
    final boolean myCloseDirectory = closeDirectory; // @deprectated
    closeDirectory = false;

    try {
      reader = (DirectoryReader) finder.run(commit);
    } finally {
      if (myCloseDirectory) {
        assert directory instanceof FSDirectory;
        // Restore my closeDirectory
        closeDirectory = true;
        if (reader != null && reader != this) {
          // Success, and a new reader was actually opened
          reader.closeDirectory = true;
          // Clone the directory
          reader.directory = FSDirectory.getDirectory(((FSDirectory) directory).getFile());
        }
      }
    }

    return reader;
  }

