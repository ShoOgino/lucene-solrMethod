  /** Called if we hit an exception when adding docs,
   *  flushing, etc.  This resets our state, discarding any
   *  docs added since last flush. */
  synchronized void abort() throws IOException {

    // Forcefully remove waiting ThreadStates from line
    for(int i=0;i<numWaiting;i++)
      waitingThreadStates[i].isIdle = true;
    numWaiting = 0;

    pauseAllThreads();

    bufferedDeleteTerms.clear();
    numBufferedDeleteTerms = 0;

    try {

      // Discard pending norms:
      final int numField = fieldInfos.size();
      for (int i=0;i<numField;i++) {
        FieldInfo fi = fieldInfos.fieldInfo(i);
        if (fi.isIndexed && !fi.omitNorms) {
          BufferedNorms n = norms[i];
          if (n != null) {
            n.out.reset();
            n.reset();
          }
        }
      }

      // Reset vectors writer
      if (tvx != null) {
        tvx.close();
        tvf.close();
        tvd.close();
        tvx = null;
      }

      // Reset fields writer
      if (fieldsWriter != null) {
        fieldsWriter.close();
        fieldsWriter = null;
      }

      // Reset all postings data
      resetPostingsData();

      // Clear vectors & fields from ThreadStates
      for(int i=0;i<threadStates.length;i++) {
        ThreadState state = threadStates[i];
        if (state.localFieldsWriter != null) {
          state.localFieldsWriter.close();
          state.localFieldsWriter = null;
        }
        state.tvfLocal.reset();
        state.fdtLocal.reset();
      }

      files = null;
    } finally {
      resumeAllThreads();
    }
  }

