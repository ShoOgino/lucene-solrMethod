  /* If any of our segments are using a directory != ours
   * then copy them over.  Currently this is only used by
   * addIndexesNoOptimize(). */
  private synchronized void copyExternalSegments() throws CorruptIndexException, IOException {
    final int numSegments = segmentInfos.size();
    for(int i=0;i<numSegments;i++) {
      SegmentInfo info = segmentInfos.info(i);
      if (info.dir != directory) {
        MergePolicy.OneMerge merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());
        if (registerMerge(merge)) {
          pendingMerges.remove(merge);
          runningMerges.add(merge);
          merge(merge);
        } else
          // This means there is a bug in the
          // MergeScheduler.  MergeSchedulers in general are
          // not allowed to run a merge involving segments
          // external to this IndexWriter's directory in the
          // background because this would put the index
          // into an inconsistent state (where segmentInfos
          // has been written with such external segments
          // that an IndexReader would fail to load).
          throw new MergePolicy.MergeException("segment \"" + info.name + " exists in external directory yet the MergeScheduler executed the merge in a separate thread",
                                               directory);
      }
    }
  }

