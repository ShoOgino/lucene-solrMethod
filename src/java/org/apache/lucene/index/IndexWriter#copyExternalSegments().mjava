  /* If any of our segments are using a directory != ours
   * then copy them over.  Currently this is only used by
   * addIndexesNoOptimize(). */
  private void copyExternalSegments() throws CorruptIndexException, IOException {

    boolean any = false;

    while(true) {
      SegmentInfo info = null;
      MergePolicy.OneMerge merge = null;
      synchronized(this) {
        final int numSegments = segmentInfos.size();
        for(int i=0;i<numSegments;i++) {
          info = segmentInfos.info(i);
          if (info.dir != directory) {
            merge = new MergePolicy.OneMerge(segmentInfos.range(i, 1+i), info.getUseCompoundFile());
            break;
          }
        }
      }

      if (merge != null) {
        if (registerMerge(merge)) {
          pendingMerges.remove(merge);
          runningMerges.add(merge);
          any = true;
          merge(merge);
        } else
          // This means there is a bug in the
          // MergeScheduler.  MergeSchedulers in general are
          // not allowed to run a merge involving segments
          // external to this IndexWriter's directory in the
          // background because this would put the index
          // into an inconsistent state (where segmentInfos
          // has been written with such external segments
          // that an IndexReader would fail to load).
          throw new MergePolicy.MergeException("segment \"" + info.name + " exists in external directory yet the MergeScheduler executed the merge in a separate thread",
                                               directory);
      } else
        // No more external segments
        break;
    }

    if (any)
      // Sometimes, on copying an external segment over,
      // more merges may become necessary:
      mergeScheduler.merge(this);
  }

