  /**
   * Commit changes resulting from delete, undeleteAll, or
   * setNorm operations
   *
   * If an exception is hit, then either no changes or all
   * changes will have been committed to the index
   * (transactional semantics).
   * 
   * @throws IOException
   */
  protected final synchronized void commit() throws IOException{
    if(hasChanges){
      if (deleter == null) {
        // In the MultiReader case, we share this deleter
        // across all SegmentReaders:
        setDeleter(new IndexFileDeleter(segmentInfos, directory));
        deleter.deleteFiles();
      }
      if(directoryOwner){

        // Should not be necessary: no prior commit should
        // have left pending files, so just defensive:
        deleter.clearPendingFiles();

        String oldInfoFileName = segmentInfos.getCurrentSegmentFileName();
        String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();

        // Checkpoint the state we are about to change, in
        // case we have to roll back:
        startCommit();

        boolean success = false;
        try {
          doCommit();
          segmentInfos.write(directory);
          success = true;
        } finally {

          if (!success) {

            // Rollback changes that were made to
            // SegmentInfos but failed to get [fully]
            // committed.  This way this reader instance
            // remains consistent (matched to what's
            // actually in the index):
            rollbackCommit();

            // Erase any pending files that we were going to delete:
            deleter.clearPendingFiles();

            // Remove possibly partially written next
            // segments file:
            deleter.deleteFile(nextSegmentsFileName);

            // Recompute deletable files & remove them (so
            // partially written .del files, etc, are
            // removed):
            deleter.findDeletableFiles();
            deleter.deleteFiles();
          }
        }

        // Attempt to delete all files we just obsoleted:
        deleter.deleteFile(oldInfoFileName);
        deleter.commitPendingFiles();

        if (writeLock != null) {
          writeLock.release();  // release write lock
          writeLock = null;
        }
      }
      else
        doCommit();
    }
    hasChanges = false;
  }

