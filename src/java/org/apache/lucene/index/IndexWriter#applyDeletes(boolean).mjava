  // Called during flush to apply any buffered deletes.  If
  // flushedNewSegment is true then a new segment was just
  // created and flushed from the ram segments, so we will
  // selectively apply the deletes to that new segment.
  private final void applyDeletes(boolean flushedNewSegment) throws CorruptIndexException, IOException {

    if (bufferedDeleteTerms.size() > 0) {
      if (infoStream != null)
        infoStream.println("flush " + numBufferedDeleteTerms + " buffered deleted terms on "
                           + segmentInfos.size() + " segments.");

      if (flushedNewSegment) {
        IndexReader reader = null;
        try {
          // Open readers w/o opening the stored fields /
          // vectors because these files may still be held
          // open for writing by docWriter
          reader = SegmentReader.get(segmentInfos.info(segmentInfos.size() - 1), false);

          // Apply delete terms to the segment just flushed from ram
          // apply appropriately so that a delete term is only applied to
          // the documents buffered before it, not those buffered after it.
          applyDeletesSelectively(bufferedDeleteTerms, reader);
        } finally {
          if (reader != null) {
            try {
              reader.doCommit();
            } finally {
              reader.doClose();
            }
          }
        }
      }

      int infosEnd = segmentInfos.size();
      if (flushedNewSegment) {
        infosEnd--;
      }

      for (int i = 0; i < infosEnd; i++) {
        IndexReader reader = null;
        try {
          reader = SegmentReader.get(segmentInfos.info(i), false);

          // Apply delete terms to disk segments
          // except the one just flushed from ram.
          applyDeletes(bufferedDeleteTerms, reader);
        } finally {
          if (reader != null) {
            try {
              reader.doCommit();
            } finally {
              reader.doClose();
            }
          }
        }
      }

      // Clean up bufferedDeleteTerms.

      // Rollbacks of buffered deletes are based on restoring the old
      // map, so don't modify this one. Rare enough that the gc
      // overhead is almost certainly lower than the alternate, which
      // would be clone to support rollback.

      bufferedDeleteTerms = new HashMap();
      numBufferedDeleteTerms = 0;
    }
  }

