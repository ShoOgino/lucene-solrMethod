  /**
   * Merges the indicated segments, replacing them in the stack with a
   * single segment.
   */

  final void merge(MergePolicy.OneMerge merge)
    throws CorruptIndexException, IOException {

    assert merge.registerDone;
    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;

    boolean success = false;

    try {

      if (merge.info == null)
        mergeInit(merge);

      if (infoStream != null)
        message("now merge\n  merge=" + merge.segString(directory) + "\n  index=" + segString());

      mergeMiddle(merge);

      success = true;
    } finally {
      synchronized(this) {
        try {
          if (!success && infoStream != null)
            message("hit exception during merge");

          mergeFinish(merge);

          // This merge (and, generally, any change to the
          // segments) may now enable new merges, so we call
          // merge policy & update pending merges.
          if (success && !merge.isAborted() && !closed && !closing)
            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);
        } finally {
          runningMerges.remove(merge);
          // Optimize may be waiting on the final optimize
          // merge to finish; and finishMerges() may be
          // waiting for all merges to finish:
          notifyAll();
        }
      }
    }
  }

