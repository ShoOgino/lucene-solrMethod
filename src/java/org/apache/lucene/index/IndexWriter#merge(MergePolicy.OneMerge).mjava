  /**
   * Merges the indicated segments, replacing them in the stack with a
   * single segment.
   */

  final void merge(MergePolicy.OneMerge merge)
    throws CorruptIndexException, IOException {

    assert merge.registerDone;
    assert !merge.optimize || merge.maxNumSegmentsOptimize > 0;

    boolean success = false;

    try {

      try {
        if (merge.info == null)
          mergeInit(merge);

        if (infoStream != null)
          message("now merge\n  merge=" + merge.segString(directory) + "\n  index=" + segString());

        mergeMiddle(merge);
        success = true;
      } catch (MergePolicy.MergeAbortedException e) {
        merge.setException(e);
        addMergeException(merge);
        // We can ignore this exception, unless the merge
        // involves segments from external directories, in
        // which case we must throw it so, for example, the
        // rollbackTransaction code in addIndexes* is
        // executed.
        if (merge.isExternal)
          throw e;
      }
    } finally {
      synchronized(this) {
        try {
          if (!success && infoStream != null)
            message("hit exception during merge");

          mergeFinish(merge);

          // This merge (and, generally, any change to the
          // segments) may now enable new merges, so we call
          // merge policy & update pending merges.
          if (success && !merge.isAborted() && !closed && !closing)
            updatePendingMerges(merge.maxNumSegmentsOptimize, merge.optimize);
        } finally {
          runningMerges.remove(merge);
          // Optimize may be waiting on the final optimize
          // merge to finish; and finishMerges() may be
          // waiting for all merges to finish:
          notifyAll();
        }
      }
    }
  }

