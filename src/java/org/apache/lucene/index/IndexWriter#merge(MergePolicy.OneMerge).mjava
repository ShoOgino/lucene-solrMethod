  /**
   * Merges the indicated segments, replacing them in the stack with a
   * single segment.
   */

  final void merge(MergePolicy.OneMerge merge)
    throws CorruptIndexException, IOException {

    assert merge.registerDone;

    int mergedDocCount;
    boolean success = false;

    try {

      if (merge.info == null)
        mergeInit(merge);

      if (infoStream != null)
        message("now merge\n  merge=" + merge.segString(directory) + "\n  index=" + segString());

      mergedDocCount = mergeMiddle(merge);

      success = true;
    } finally {
      synchronized(this) {
        if (!success && infoStream != null)
          message("hit exception during merge");

        mergeFinish(merge);

        // This merge (and, generally, any change to the
        // segments) may now enable new merges, so we call
        // merge policy & update pending merges.
        if (success && !merge.isAborted() && !closed && !closing)
          updatePendingMerges(merge.optimize);

        runningMerges.remove(merge);

        // Optimize may be waiting on the final optimize
        // merge to finish; and finishMerges() may be
        // waiting for all merges to finish:
        notifyAll();
      }
    }
  }

