  /**
   * Merges all segments from an array of indexes into this index.
   * <p>
   * This is similar to addIndexes(Directory[]). However, no optimize()
   * is called either at the beginning or at the end. Instead, merges
   * are carried out as necessary.
   *
   * <p><b>NOTE:</b> the index in each Directory must not be
   * changed (opened by a writer) while this method is
   * running.  This method does not acquire a write lock in
   * each input Directory, so it is up to the caller to
   * enforce this.
   *
   * <p><b>NOTE:</b> while this is running, any attempts to
   * add or delete documents (with another thread) will be
   * paused until this method completes.
   *
   * <p>
   * This requires this index not be among those to be added, and the
   * upper bound* of those segment doc counts not exceed maxMergeDocs.
   *
   * <p>See {@link #addIndexes(Directory[])} for
   * details on transactional semantics, temporary free
   * space required in the Directory, and non-CFS segments
   * on an Exception.</p>
   * @throws CorruptIndexException if the index is corrupt
   * @throws IOException if there is a low-level IO error
   */
  public void addIndexesNoOptimize(Directory[] dirs)
      throws CorruptIndexException, IOException {

    ensureOpen();

    // Do not allow add docs or deletes while we are running:
    docWriter.pauseAllThreads();

    try {
      if (infoStream != null)
        message("flush at addIndexesNoOptimize");
      flush(true, false, true);

      boolean success = false;

      startTransaction();

      try {

        int docCount = 0;
        synchronized(this) {
          for (int i = 0; i < dirs.length; i++) {
            if (directory == dirs[i]) {
              // cannot add this index: segments may be deleted in merge before added
              throw new IllegalArgumentException("Cannot add this index to itself");
            }

            SegmentInfos sis = new SegmentInfos(); // read infos from dir
            sis.read(dirs[i]);
            for (int j = 0; j < sis.size(); j++) {
              SegmentInfo info = sis.info(j);
              docCount += info.docCount;
              segmentInfos.addElement(info); // add each info
            }
          }
        }

        // Notify DocumentsWriter that the flushed count just increased
        docWriter.updateFlushedDocCount(docCount);

        maybeMerge();

        // If after merging there remain segments in the index
        // that are in a different directory, just copy these
        // over into our index.  This is necessary (before
        // finishing the transaction) to avoid leaving the
        // index in an unusable (inconsistent) state.
        copyExternalSegments();

        success = true;

      } finally {
        if (success) {
          commitTransaction();
        } else {
          rollbackTransaction();
        }
      }
    } catch (OutOfMemoryError oom) {
      hitOOM = true;
      throw oom;
    } finally {
      docWriter.resumeAllThreads();
    }
  }

