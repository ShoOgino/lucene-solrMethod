  /** Returns the merges necessary to optimize the index.
   *  This merge policy defines "optimized" to mean only one
   *  segment in the index, where that segment has no
   *  deletions pending nor separate norms, and it is in
   *  compound file format if the current useCompoundFile
   *  setting is true.  This method returns multiple merges
   *  (mergeFactor at a time) so the {@link MergeScheduler}
   *  in use may make use of concurrency. */
  public MergeSpecification findMergesForOptimize(SegmentInfos infos, IndexWriter writer, int maxNumSegments, Set segmentsToOptimize) throws IOException {
    final Directory dir = writer.getDirectory();
    MergeSpecification spec;
    
    if (!isOptimized(infos, writer, maxNumSegments, segmentsToOptimize)) {

      int numSegments = infos.size();
      while(numSegments > 0) {
        final SegmentInfo info = infos.info(--numSegments);
        if (segmentsToOptimize.contains(info)) {
          numSegments++;
          break;
        }
      }

      if (numSegments > 0) {

        spec = new MergeSpecification();
        while (numSegments > 0) {
        
          final int first;
          if (numSegments > mergeFactor)
            first = numSegments-mergeFactor;
          else
            first = 0;

          if (numSegments > 1 || !isOptimized(writer, infos.info(0)))
            spec.add(new OneMerge(infos.range(first, numSegments), useCompoundFile));

          numSegments -= mergeFactor;
        }

      } else
        spec = null;
    } else
      spec = null;

    return spec;
  }

