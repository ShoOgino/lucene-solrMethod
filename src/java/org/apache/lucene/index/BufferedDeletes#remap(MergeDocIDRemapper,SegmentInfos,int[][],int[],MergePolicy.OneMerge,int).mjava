  // Remaps all buffered deletes based on a completed
  // merge
  synchronized void remap(MergeDocIDRemapper mapper,
                          SegmentInfos infos,
                          int[][] docMaps,
                          int[] delCounts,
                          MergePolicy.OneMerge merge,
                          int mergeDocCount) {

    final HashMap<Term,Num> newDeleteTerms;

    // Remap delete-by-term
    if (terms.size() > 0) {
      newDeleteTerms = new HashMap<Term, Num>();
      for(Entry<Term,Num> entry : terms.entrySet()) {
        Num num = entry.getValue();
        newDeleteTerms.put(entry.getKey(),
                           new Num(mapper.remap(num.getNum())));
      }
    } else 
      newDeleteTerms = null;
    

    // Remap delete-by-docID
    final List<Integer> newDeleteDocIDs;

    if (docIDs.size() > 0) {
      newDeleteDocIDs = new ArrayList<Integer>(docIDs.size());
      for (Integer num : docIDs) {
        newDeleteDocIDs.add(Integer.valueOf(mapper.remap(num.intValue())));
      }
    } else 
      newDeleteDocIDs = null;
    

    // Remap delete-by-query
    final HashMap<Query,Integer> newDeleteQueries;
    
    if (queries.size() > 0) {
      newDeleteQueries = new HashMap<Query, Integer>(queries.size());
      for(Entry<Query,Integer> entry: queries.entrySet()) {
        Integer num = (Integer) entry.getValue();
        newDeleteQueries.put(entry.getKey(),
                             Integer.valueOf(mapper.remap(num.intValue())));
      }
    } else
      newDeleteQueries = null;

    if (newDeleteTerms != null)
      terms = newDeleteTerms;
    if (newDeleteDocIDs != null)
      docIDs = newDeleteDocIDs;
    if (newDeleteQueries != null)
      queries = newDeleteQueries;
  }

