  /** Adds a new <<fieldNumber, termText>, TermInfo> pair to the set.
    Term must be lexicographically greater than all previous Terms added.
    TermInfo pointers must be positive and greater than all previous.*/
  void add(int fieldNumber, char[] termText, int termTextStart, int termTextLength, TermInfo ti)
    throws IOException {

    assert compareToLastTerm(fieldNumber, termText, termTextStart, termTextLength) < 0 || (isIndex && termTextLength == 0 && lastTermTextLength == 0);
    assert ti.freqPointer >= lastTi.freqPointer: "freqPointer out of order (" + ti.freqPointer + " < " + lastTi.freqPointer + ")";
    assert ti.proxPointer >= lastTi.proxPointer: "proxPointer out of order (" + ti.proxPointer + " < " + lastTi.proxPointer + ")";

    if (!isIndex && size % indexInterval == 0)
      other.add(lastFieldNumber, lastTermText, 0, lastTermTextLength, lastTi);                      // add an index term

    writeTerm(fieldNumber, termText, termTextStart, termTextLength);                        // write term

    output.writeVInt(ti.docFreq);                       // write doc freq
    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers
    output.writeVLong(ti.proxPointer - lastTi.proxPointer);

    if (ti.docFreq >= skipInterval) {
      output.writeVInt(ti.skipOffset);
    }

    if (isIndex) {
      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);
      lastIndexPointer = other.output.getFilePointer(); // write pointer
    }

    if (lastTermText.length < termTextLength)
      lastTermText = new char[(int) (termTextLength*1.25)];
    System.arraycopy(termText, termTextStart, lastTermText, 0, termTextLength);
    lastTermTextLength = termTextLength;
    lastFieldNumber = fieldNumber;

    lastTi.set(ti);
    size++;
  }

