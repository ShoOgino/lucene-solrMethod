  /**
   * Merges the named range of segments, replacing them in the stack with a
   * single segment.
   */
  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)
    throws IOException {

    final String mergedName = newSegmentName();
    if (infoStream != null) infoStream.print("merging segments");
    SegmentMerger merger = new SegmentMerger(this, mergedName);
    
    final Vector segmentsToDelete = new Vector();

    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();
    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();

    SegmentInfo newSegment = null;

    int mergedDocCount;

    // This is try/finally to make sure merger's readers are closed:
    try {

      for (int i = minSegment; i < end; i++) {
        SegmentInfo si = sourceSegments.info(i);
        if (infoStream != null)
          infoStream.print(" " + si.name + " (" + si.docCount + " docs)");
        IndexReader reader = SegmentReader.get(si);
        merger.add(reader);
        if ((reader.directory() == this.directory) || // if we own the directory
            (reader.directory() == this.ramDirectory))
          segmentsToDelete.addElement(reader);   // queue segment for deletion
      }

      SegmentInfos rollback = null;
      boolean success = false;

      // This is try/finally to rollback our internal state
      // if we hit exception when doing the merge:
      try {

        mergedDocCount = merger.merge();

        if (infoStream != null) {
          infoStream.println(" into "+mergedName+" ("+mergedDocCount+" docs)");
        }

        newSegment = new SegmentInfo(mergedName, mergedDocCount,
                                     directory, false, true);


        if (sourceSegments == ramSegmentInfos) {
          segmentInfos.addElement(newSegment);
        } else {

          if (!inTransaction) {
            // Now save the SegmentInfo instances that
            // we are replacing:
            rollback = (SegmentInfos) segmentInfos.clone();
          }

          for (int i = end-1; i > minSegment; i--)     // remove old infos & add new
            sourceSegments.remove(i);

          segmentInfos.set(minSegment, newSegment);
        }

        if (!inTransaction) {
          segmentInfos.write(directory);     // commit before deleting
        } else {
          commitPending = true;
        }

        success = true;

      } finally {

        if (success) {
          // The non-ram-segments case is already committed
          // (above), so all the remains for ram segments case
          // is to clear the ram segments:
          if (sourceSegments == ramSegmentInfos) {
            ramSegmentInfos.removeAllElements();
          }
        } else if (!inTransaction) {  

          // Must rollback so our state matches index:

          if (sourceSegments == ramSegmentInfos) {
            // Simple case: newSegment may or may not have
            // been added to the end of our segment infos,
            // so just check & remove if so:
            if (newSegment != null && 
                segmentInfos.size() > 0 && 
                segmentInfos.info(segmentInfos.size()-1) == newSegment) {
              segmentInfos.remove(segmentInfos.size()-1);
            }
          } else if (rollback != null) {
            // Rollback the individual SegmentInfo
            // instances, but keep original SegmentInfos
            // instance (so we don't try to write again the
            // same segments_N file -- write once):
            segmentInfos.clear();
            segmentInfos.addAll(rollback);
          }

          // Delete any partially created files:
          deleter.deleteFile(nextSegmentsFileName);
          deleter.findDeletableFiles();
          deleter.deleteFiles();
        }
      }
    } finally {
      // close readers before we attempt to delete now-obsolete segments
      merger.closeReaders();
    }

    if (!inTransaction) {
      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file
      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments
    } else {
      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file
      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments
    }

    if (useCompoundFile) {

      segmentsInfosFileName = nextSegmentsFileName;
      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();

      Vector filesToDelete;

      boolean success = false;

      try {

        filesToDelete = merger.createCompoundFile(mergedName + ".cfs");
        newSegment.setUseCompoundFile(true);
        if (!inTransaction) {
          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file
        }
        success = true;

      } finally {
        if (!success && !inTransaction) {  
          // Must rollback:
          newSegment.setUseCompoundFile(false);
          deleter.deleteFile(mergedName + ".cfs");
          deleter.deleteFile(nextSegmentsFileName);
        }
      }

      if (!inTransaction) {
        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file
      }

      // We can delete these segments whether or not we are
      // in a transaction because we had just written them
      // above so they can't need protection by the
      // transaction:
      deleter.deleteFiles(filesToDelete);  // delete now-unused segments
    }

    return mergedDocCount;
  }

