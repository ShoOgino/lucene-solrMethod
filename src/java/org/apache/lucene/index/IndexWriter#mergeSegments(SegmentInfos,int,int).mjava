  /**
   * Merges the named range of segments, replacing them in the stack with a
   * single segment.
   */
  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)
    throws IOException {
    final String mergedName = newSegmentName();
    if (infoStream != null) infoStream.print("merging segments");
    SegmentMerger merger = new SegmentMerger(this, mergedName);

    boolean fromRAM = false;
    final Vector segmentsToDelete = new Vector();
    for (int i = minSegment; i < end; i++) {
      SegmentInfo si = sourceSegments.info(i);
      if (infoStream != null)
        infoStream.print(" " + si.name + " (" + si.docCount + " docs)");
      IndexReader reader = SegmentReader.get(si);
      merger.add(reader);
      if ((reader.directory() == this.directory) || // if we own the directory
          (reader.directory() == this.ramDirectory))
        segmentsToDelete.addElement(reader);   // queue segment for deletion
      if (!fromRAM && (reader.directory() == this.ramDirectory)) {
        fromRAM = true;
      }
    }

    int mergedDocCount = merger.merge();

    if (infoStream != null) {
      infoStream.println(" into "+mergedName+" ("+mergedDocCount+" docs)");
    }

    SegmentInfo newSegment = new SegmentInfo(mergedName, mergedDocCount,
        directory);
    if (fromRAM) {
      sourceSegments.removeAllElements();
      if (mergedDocCount > 0)
        segmentInfos.addElement(newSegment);
    } else {
      for (int i = end-1; i > minSegment; i--)     // remove old infos & add new
        sourceSegments.remove(i);
      if (mergedDocCount > 0)
        segmentInfos.set(minSegment, newSegment);
      else
        sourceSegments.remove(minSegment);
    }

    // close readers before we attempt to delete now-obsolete segments
    merger.closeReaders();

    synchronized (directory) {                 // in- & inter-process sync
      new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {
          public Object doBody() throws IOException {
            segmentInfos.write(directory);     // commit before deleting
            return null;
          }
        }.run();
    }
    
    deleteSegments(segmentsToDelete);  // delete now-unused segments

    if (useCompoundFile) {
      final Vector filesToDelete = merger.createCompoundFile(mergedName + ".tmp");
      synchronized (directory) { // in- & inter-process sync
        new Lock.With(directory.makeLock(COMMIT_LOCK_NAME), commitLockTimeout) {
          public Object doBody() throws IOException {
            // make compound file visible for SegmentReaders
            directory.renameFile(mergedName + ".tmp", mergedName + ".cfs");
            return null;
          }
        }.run();
      }

      // delete now unused files of segment 
      deleteFiles(filesToDelete);   
    }

    return mergedDocCount;
  }

