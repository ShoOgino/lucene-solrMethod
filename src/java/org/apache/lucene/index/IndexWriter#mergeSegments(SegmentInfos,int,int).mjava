  /**
   * Merges the named range of segments, replacing them in the stack with a
   * single segment.
   */
  private final int mergeSegments(SegmentInfos sourceSegments, int minSegment, int end)
    throws IOException {

    // We may be called solely because there are deletes
    // pending, in which case doMerge is false:
    boolean doMerge = end > 0;
    final String mergedName = newSegmentName();
    SegmentMerger merger = null;

    final Vector segmentsToDelete = new Vector();

    String segmentsInfosFileName = segmentInfos.getCurrentSegmentFileName();
    String nextSegmentsFileName = segmentInfos.getNextSegmentFileName();

    SegmentInfo newSegment = null;

    int mergedDocCount = 0;

    // This is try/finally to make sure merger's readers are closed:
    try {

      if (doMerge) {
        if (infoStream != null) infoStream.print("merging segments");
        merger = new SegmentMerger(this, mergedName);

        for (int i = minSegment; i < end; i++) {
          SegmentInfo si = sourceSegments.info(i);
          if (infoStream != null)
            infoStream.print(" " + si.name + " (" + si.docCount + " docs)");
          IndexReader reader = SegmentReader.get(si); // no need to set deleter (yet)
          merger.add(reader);
          if ((reader.directory() == this.directory) || // if we own the directory
              (reader.directory() == this.ramDirectory))
            segmentsToDelete.addElement(reader);   // queue segment for deletion
        }
      }

      SegmentInfos rollback = null;
      boolean success = false;

      // This is try/finally to rollback our internal state
      // if we hit exception when doing the merge:
      try {

        if (doMerge) {
          mergedDocCount = merger.merge();

          if (infoStream != null) {
            infoStream.println(" into "+mergedName+" ("+mergedDocCount+" docs)");
          }

          newSegment = new SegmentInfo(mergedName, mergedDocCount,
                                       directory, false, true);
        }

        if (!inTransaction
            && (sourceSegments != ramSegmentInfos || bufferedDeleteTerms.size() > 0)) {
          // Now save the SegmentInfo instances that
          // we are replacing:
          rollback = (SegmentInfos) segmentInfos.clone();
        }

        if (doMerge) {
          if (sourceSegments == ramSegmentInfos) {
            segmentInfos.addElement(newSegment);
          } else {
            for (int i = end-1; i > minSegment; i--)     // remove old infos & add new
              sourceSegments.remove(i);

            segmentInfos.set(minSegment, newSegment);
          }
        }

        if (sourceSegments == ramSegmentInfos) {
          // Should not be necessary: no prior commit should
          // have left pending files, so just defensive:
          deleter.clearPendingFiles();
          maybeApplyDeletes(doMerge);
          doAfterFlush();
        }

        if (!inTransaction) {
          segmentInfos.write(directory);     // commit before deleting
        } else {
          commitPending = true;
        }

        success = true;

      } finally {

        if (success) {
          // The non-ram-segments case is already committed
          // (above), so all the remains for ram segments case
          // is to clear the ram segments:
          if (sourceSegments == ramSegmentInfos) {
            ramSegmentInfos.removeAllElements();
          }
        } else if (!inTransaction) {  

          // Must rollback so our state matches index:

          if (sourceSegments == ramSegmentInfos && 0 == bufferedDeleteTerms.size()) {
            // Simple case: newSegment may or may not have
            // been added to the end of our segment infos,
            // so just check & remove if so:
            if (newSegment != null && 
                segmentInfos.size() > 0 && 
                segmentInfos.info(segmentInfos.size()-1) == newSegment) {
              segmentInfos.remove(segmentInfos.size()-1);
            }
          } else if (rollback != null) {
            // Rollback the individual SegmentInfo
            // instances, but keep original SegmentInfos
            // instance (so we don't try to write again the
            // same segments_N file -- write once):
            segmentInfos.clear();
            segmentInfos.addAll(rollback);
          }

          // Erase any pending files that we were going to delete:
          // i.e. old del files added by SegmentReader.doCommit() 
          deleter.clearPendingFiles();

          // Delete any partially created files:
          deleter.deleteFile(nextSegmentsFileName);
          deleter.findDeletableFiles();
          deleter.deleteFiles();
        }
      }
    } finally {
      // close readers before we attempt to delete now-obsolete segments
      if (doMerge) merger.closeReaders();
    }

    if (!inTransaction) {
      // Attempt to delete all files we just obsoleted:
      deleter.deleteFile(segmentsInfosFileName);    // delete old segments_N file
      deleter.deleteSegments(segmentsToDelete);     // delete now-unused segments
      // Includes the old del files
      deleter.commitPendingFiles();
    } else {
      deleter.addPendingFile(segmentsInfosFileName);    // delete old segments_N file
      deleter.deleteSegments(segmentsToDelete, protectedSegments);     // delete now-unused segments
    }

    if (useCompoundFile && doMerge) {

      segmentsInfosFileName = nextSegmentsFileName;
      nextSegmentsFileName = segmentInfos.getNextSegmentFileName();

      Vector filesToDelete;

      boolean success = false;

      try {

        filesToDelete = merger.createCompoundFile(mergedName + ".cfs");
        newSegment.setUseCompoundFile(true);
        if (!inTransaction) {
          segmentInfos.write(directory);     // commit again so readers know we've switched this segment to a compound file
        }
        success = true;

      } finally {
        if (!success && !inTransaction) {  
          // Must rollback:
          newSegment.setUseCompoundFile(false);
          deleter.deleteFile(mergedName + ".cfs");
          deleter.deleteFile(nextSegmentsFileName);
        }
      }

      if (!inTransaction) {
        deleter.deleteFile(segmentsInfosFileName);  // delete old segments_N file
      }

      // We can delete these segments whether or not we are
      // in a transaction because we had just written them
      // above so they can't need protection by the
      // transaction:
      deleter.deleteFiles(filesToDelete);  // delete now-unused segments
    }

    return mergedDocCount;
  }

