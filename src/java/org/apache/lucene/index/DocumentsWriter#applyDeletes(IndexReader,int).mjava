  // Apply buffered delete terms, queries and docIDs to the
  // provided reader
  private final synchronized boolean applyDeletes(IndexReader reader, int docIDStart)
    throws CorruptIndexException, IOException {

    final int docEnd = docIDStart + reader.maxDoc();
    boolean any = false;

    // Delete by term
    TermDocs docs = reader.termDocs();
    try {
      for (Entry<Term, BufferedDeletes.Num> entry: deletesFlushed.terms.entrySet()) {
        Term term = entry.getKey();
        docs.seek(term);
        int limit = entry.getValue().getNum();
        while (docs.next()) {
          int docID = docs.doc();
          if (docIDStart+docID >= limit)
            break;
          reader.deleteDocument(docID);
          any = true;
        }
      }
    } finally {
      docs.close();
    }

    // Delete by docID
    for (Integer docIdInt : deletesFlushed.docIDs) {
      int docID = docIdInt.intValue();
      if (docID >= docIDStart && docID < docEnd) {
        reader.deleteDocument(docID-docIDStart);
        any = true;
      }
    }

    // Delete by query
    IndexSearcher searcher = new IndexSearcher(reader);
    for (Entry<Query, Integer> entry : deletesFlushed.queries.entrySet()) {
      Query query = entry.getKey();
      int limit = entry.getValue().intValue();
      Weight weight = query.weight(searcher);
      Scorer scorer = weight.scorer(reader, true, false);
      if (scorer != null) {
        while(true)  {
          int doc = scorer.nextDoc();
          if (((long) docIDStart) + doc >= limit)
            break;
          reader.deleteDocument(doc);
          any = true;
        }
      }
    }
    searcher.close();
    return any;
  }

