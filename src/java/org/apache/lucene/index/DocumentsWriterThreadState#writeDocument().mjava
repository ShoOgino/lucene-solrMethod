  /** Move all per-document state that was accumulated in
   *  the ThreadState into the "real" stores. */
  public void writeDocument() throws IOException, AbortException {

    // If we hit an exception while appending to the
    // stored fields or term vectors files, we have to
    // abort all documents since we last flushed because
    // it means those files are possibly inconsistent.
    try {

      docWriter.numDocsInStore++;

      // Append stored fields to the real FieldsWriter:
      docWriter.fieldsWriter.flushDocument(numStoredFields, fdtLocal);
      fdtLocal.reset();

      // Append term vectors to the real outputs:
      final IndexOutput tvx = docWriter.tvx;
      final IndexOutput tvd = docWriter.tvd;
      final IndexOutput tvf = docWriter.tvf;
      if (tvx != null) {
        tvx.writeLong(tvd.getFilePointer());
        tvx.writeLong(tvf.getFilePointer());
        tvd.writeVInt(numVectorFields);
        if (numVectorFields > 0) {
          for(int i=0;i<numVectorFields;i++)
            tvd.writeVInt(vectorFieldNumbers[i]);
          assert 0 == vectorFieldPointers[0];
          long lastPos = vectorFieldPointers[0];
          for(int i=1;i<numVectorFields;i++) {
            long pos = vectorFieldPointers[i];
            tvd.writeVLong(pos-lastPos);
            lastPos = pos;
          }
          tvfLocal.writeTo(tvf);
          tvfLocal.reset();
        }
      }

      // Append norms for the fields we saw:
      for(int i=0;i<numFieldData;i++) {
        DocumentsWriterFieldData fp = fieldDataArray[i];
        if (fp.doNorms) {
          BufferedNorms bn = docWriter.norms[fp.fieldInfo.number];
          assert bn != null;
          assert bn.upto <= docID;
          bn.fill(docID);
          float norm = fp.boost * docWriter.writer.getSimilarity().lengthNorm(fp.fieldInfo.name, fp.length);
          bn.add(norm);
        }
      }
    } catch (Throwable t) {
      // Forcefully idle this threadstate -- its state will
      // be reset by abort()
      isIdle = true;
      throw new AbortException(t, docWriter);
    }

    if (docWriter.bufferIsFull && !docWriter.flushPending) {
      docWriter.flushPending = true;
      doFlushAfter = true;
    }
  }

