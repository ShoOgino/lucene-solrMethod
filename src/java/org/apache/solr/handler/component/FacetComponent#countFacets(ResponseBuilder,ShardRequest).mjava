  private void countFacets(ResponseBuilder rb, ShardRequest sreq) {
    FacetInfo fi = rb._facetInfo;

    for (ShardResponse srsp: sreq.responses) {
      int shardNum = rb.getShardNum(srsp.getShard());
      NamedList facet_counts = (NamedList)srsp.getSolrResponse().getResponse().get("facet_counts");

      // handle facet queries
      NamedList facet_queries = (NamedList)facet_counts.get("facet_queries");
      if (facet_queries != null) {
        for (int i=0; i<facet_queries.size(); i++) {
          String facet_q = (String)facet_queries.getName(i);
          long count = ((Number)facet_queries.getVal(i)).longValue();
          Long prevCount = fi.queryFacets.get(facet_q);
          if (prevCount != null) count += prevCount;
          fi.queryFacets.put(facet_q, count);
        }
      }

      // step through each facet.field, adding results from this shard
      NamedList facet_fields = (NamedList)facet_counts.get("facet_fields");      
      for (DistribFieldFacet dff : fi.topFacets.values()) {
        dff.add(shardNum, (NamedList)facet_fields.get(dff.field), dff.initialLimit);
      }
    }


    //
    // This code currently assumes that there will be only a single
    // request ((with responses from all shards) sent out to get facets...
    // otherwise we would need to wait until all facet responses were received.
    //

    // list of queries to send each shard
    List<String>[] toRefine = new List[rb.shards.length];
    fi._toRefine = toRefine;
    for (int i=0; i<toRefine.length; i++) {
      toRefine[i] = new ArrayList<String>();
    }


    for (DistribFieldFacet dff : fi.topFacets.values()) {
      if (dff.limit <= 0) continue; // no need to check these facets for refinement
      ShardFacetCount[] counts = dff.getSorted();
      int ntop = Math.min(counts.length, dff.offset + dff.limit);
      long smallestCount = counts.length == 0 ? 0 : counts[ntop-1].count;

      for (int i=0; i<counts.length; i++) {
        ShardFacetCount sfc = counts[i];
        String query = null;
        boolean needRefinement = false;

        if (i<ntop) {
          // automatically flag the top values for refinement
          needRefinement = true;
        } else {
          // calculate the maximum value that this term may have
          // and if it is >= smallestCount, then flag for refinement
          long maxCount = sfc.count;
          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {
            OpenBitSet obs = dff.counted[shardNum];
            if (!obs.get(sfc.termNum)) {
              // if missing from this shard, add the max it could be
              maxCount += dff.maxPossible(sfc,shardNum);
            }
          }
          if (maxCount >= smallestCount) {
            // TODO: on a tie, we could check the term values
            needRefinement = true;
          }
        }

        if (needRefinement) {
          // add a query for each shard missing the term that needs refinement
          for (int shardNum=0; shardNum<rb.shards.length; shardNum++) {
            OpenBitSet obs = dff.counted[shardNum];
            if (!obs.get(sfc.termNum) && dff.maxPossible(sfc,shardNum)>0) {
              dff.needRefinements = true;
              if (query==null) query = dff.makeQuery(sfc);
              toRefine[shardNum].add(query);
            }
          }
        }
      }
    }
  }

