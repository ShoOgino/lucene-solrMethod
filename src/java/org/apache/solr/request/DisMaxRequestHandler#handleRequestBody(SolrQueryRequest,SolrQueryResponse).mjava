  public void handleRequestBody(SolrQueryRequest req, SolrQueryResponse rsp) throws Exception
  {
      SolrParams params = req.getParams();
      
      int flags = 0;
      
      SolrIndexSearcher s = req.getSearcher();
      IndexSchema schema = req.getSchema();
            
      Map<String,Float> queryFields = U.parseFieldBoosts(params.getParams(DMP.QF));
      Map<String,Float> phraseFields = U.parseFieldBoosts(params.getParams(DMP.PF));

      float tiebreaker = params.getFloat(DMP.TIE, 0.0f);
            
      int pslop = params.getInt(DMP.PS, 0);
      int qslop = params.getInt(DMP.QS, 0);

      /* a generic parser for parsing regular lucene queries */
      QueryParser p = schema.getSolrQueryParser(null);

      /* a parser for dealing with user input, which will convert
       * things to DisjunctionMaxQueries
       */
      U.DisjunctionMaxQueryParser up =
        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
      up.addAlias(IMPOSSIBLE_FIELD_NAME,
                  tiebreaker, queryFields);
      up.setPhraseSlop(qslop);
      
      /* for parsing sloppy phrases using DisjunctionMaxQueries */
      U.DisjunctionMaxQueryParser pp =
        new U.DisjunctionMaxQueryParser(schema, IMPOSSIBLE_FIELD_NAME);
      pp.addAlias(IMPOSSIBLE_FIELD_NAME,
                  tiebreaker, phraseFields);
      pp.setPhraseSlop(pslop);
            
            
      /* the main query we will execute.  we disable the coord because
       * this query is an artificial construct
       */
      BooleanQuery query = new BooleanQuery(true);

      /* * * Main User Query * * */
      Query parsedUserQuery = null;
      String userQuery = params.get( Q );
      Query altUserQuery = null;
      if( userQuery == null || userQuery.trim().length() < 1 ) {
        // If no query is specified, we may have an alternate
        String altQ = params.get( DMP.ALTQ );
        if (altQ != null) {
          altUserQuery = p.parse(altQ);
          query.add( altUserQuery , Occur.MUST );
        } else {
          throw new SolrException( 400, "missing query string" );
        }
      }
      else {
        // There is a valid query string
        userQuery = U.partialEscape(U.stripUnbalancedQuotes(userQuery)).toString();
            
        String minShouldMatch = params.get(DMP.MM, "100%");
        Query dis = up.parse(userQuery);
        parsedUserQuery = dis;
  
        if (dis instanceof BooleanQuery) {
          BooleanQuery t = new BooleanQuery();
          U.flattenBooleanQuery(t, (BooleanQuery)dis);
          U.setMinShouldMatch(t, minShouldMatch);                
          parsedUserQuery = t;
        } 
        query.add(parsedUserQuery, Occur.MUST);
        

        /* * * Add on Phrases for the Query * * */
              
        /* build up phrase boosting queries */

        /* if the userQuery already has some quotes, stip them out.
         * we've already done the phrases they asked for in the main
         * part of the query, this is to boost docs that may not have
         * matched those phrases but do match looser phrases.
         */
        String userPhraseQuery = userQuery.replace("\"","");
        Query phrase = pp.parse("\"" + userPhraseQuery + "\"");
        if (null != phrase) {
          query.add(phrase, Occur.SHOULD);
        }
      }

            
      /* * * Boosting Query * * */
      String[] boostParams = params.getParams(DMP.BQ);
      List<Query> boostQueries = U.parseQueryStrings(req, boostParams);
      if (null != boostQueries) {
        if(1 == boostQueries.size() && 1 == boostParams.length) {
          /* legacy logic */
          Query f = boostQueries.get(0);
          if (1.0f == f.getBoost() && f instanceof BooleanQuery) {
            /* if the default boost was used, and we've got a BooleanQuery
             * extract the subqueries out and use them directly
             */
            for (Object c : ((BooleanQuery)f).clauses()) {
              query.add((BooleanClause)c);
            }
          } else {
            query.add(f, BooleanClause.Occur.SHOULD);
          }
        } else {
          for(Query f : boostQueries) {
            query.add(f, BooleanClause.Occur.SHOULD);
          }
        }
      }

      /* * * Boosting Functions * * */

      String[] boostFuncs = params.getParams(DMP.BF);
      if (null != boostFuncs && 0 != boostFuncs.length) {
        for (String boostFunc : boostFuncs) {
          if(null == boostFunc || "".equals(boostFunc)) continue;
          List<Query> funcs = U.parseFuncs(schema, boostFunc);
          for (Query f : funcs) {
            query.add(f, Occur.SHOULD);          
          }
        }
      }
            
      /* * * Restrict Results * * */

      List<Query> restrictions = U.parseFilterQueries(req);
            
      /* * * Generate Main Results * * */

      flags |= U.setReturnFields(req,rsp);
      
      DocListAndSet results = new DocListAndSet();
      NamedList facetInfo = null;
      if (params.getBool(FACET,false)) {
        results = s.getDocListAndSet(query, restrictions,
                                     SolrPluginUtils.getSort(req),
                                     req.getStart(), req.getLimit(),
                                     flags);
        facetInfo = getFacetInfo(req, rsp, results.docSet);
      } else {
        results.docList = s.getDocList(query, restrictions,
                                       SolrPluginUtils.getSort(req),
                                       req.getStart(), req.getLimit(),
                                       flags);
      }
      rsp.add("response",results.docList);
      // pre-fetch returned documents
      U.optimizePreFetchDocs(results.docList, query, req, rsp);

      
      if (null != facetInfo) rsp.add("facet_counts", facetInfo);


            
      /* * * Debugging Info * * */

      try {
        NamedList debug = U.doStandardDebug(req, userQuery, query, results.docList);
        if (null != debug) {
          debug.add("altquerystring", altUserQuery);
          if (null != boostQueries) {
            debug.add("boost_queries", boostParams);
            debug.add("parsed_boost_queries", 
                      QueryParsing.toString(boostQueries, req.getSchema()));
          }
          debug.add("boostfuncs", params.getParams(DMP.BF));
          if (null != restrictions) {
            debug.add("filter_queries", params.getParams(FQ));
            debug.add("parsed_filter_queries", 
                      QueryParsing.toString(restrictions, req.getSchema()));
          }
          rsp.add("debug", debug);
        }

      } catch (Exception e) {
        SolrException.logOnce(SolrCore.log,
                              "Exception during debug", e);
        rsp.add("exception_during_debug", SolrException.toStr(e));
      }

      /* * * Highlighting/Summarizing  * * */
      if(HighlightingUtils.isHighlightingEnabled(req) && parsedUserQuery != null) {
        String[] highFields = queryFields.keySet().toArray(new String[0]);
        NamedList sumData =
          HighlightingUtils.doHighlighting(
	       results.docList, 
	       parsedUserQuery.rewrite(req.getSearcher().getReader()), 
	       req, 
	       highFields);
        if(sumData != null)
          rsp.add("highlighting", sumData);
      }
  }

