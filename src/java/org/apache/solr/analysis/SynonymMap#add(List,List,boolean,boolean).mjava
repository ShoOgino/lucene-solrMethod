  /**
   * @param singleMatch  List<String>, the sequence of strings to match
   * @param replacement  List<Token> the list of tokens to use on a match
   * @param includeOrig  sets a flag on this mapping signaling the generation of matched tokens in addition to the replacement tokens
   * @param mergeExisting merge the replacement tokens with any other mappings that exist
   */
  public void add(List singleMatch, List replacement, boolean includeOrig, boolean mergeExisting) {
    SynonymMap currMap = this;
    for (Iterator iter = singleMatch.iterator(); iter.hasNext();) {
      String str = (String)iter.next();
      if (currMap.submap==null) {
        currMap.submap = new HashMap(1);
      }

      SynonymMap map = (SynonymMap)currMap.submap.get(str);
      if (map==null) {
        map = new SynonymMap();
        currMap.submap.put(str, map);
      }

      currMap = map;
    }

    if (currMap.synonyms != null && !mergeExisting) {
      throw new RuntimeException("SynonymFilter: there is already a mapping for " + singleMatch);
    }
    List superset = currMap.synonyms==null ? replacement :
          mergeTokens(Arrays.asList(currMap.synonyms), replacement);
    currMap.synonyms = (Token[])superset.toArray(new Token[superset.size()]);
    if (includeOrig) currMap.flags |= INCLUDE_ORIG;
  }

