  public Token next() throws IOException {
    while (true) {
      // if there are any generated tokens, return them... don't try any
      // matches against them, as we specifically don't want recursion.
      if (replacement!=null && replacement.hasNext()) {
        return (Token)replacement.next();
      }

      // common case fast-path of first token not matching anything
      Token firstTok = nextTok();
      if (firstTok ==null) return null;
      String str = ignoreCase ? firstTok.termText().toLowerCase() : firstTok.termText();
      Object o = map.submap!=null ? map.submap.get(str) : null;
      if (o == null) return firstTok;

      // OK, we matched a token, so find the longest match.

      matched = new LinkedList();

      SynonymMap result = match((SynonymMap)o);

      if (result==null) {
        // no match, simply return the first token read.
        return firstTok;
      }

      // reuse, or create new one each time?
      ArrayList generated = new ArrayList(result.synonyms.length + matched.size() + 1);

      //
      // there was a match... let's generate the new tokens, merging
      // in the matched tokens (position increments need adjusting)
      //
      Token lastTok = matched.isEmpty() ? firstTok : (Token)matched.getLast();
      boolean includeOrig = result.includeOrig();

      Token origTok = includeOrig ? firstTok : null;
      int origPos = firstTok.getPositionIncrement();  // position of origTok in the original stream
      int repPos=0; // curr position in replacement token stream
      int pos=0;  // current position in merged token stream

      for (int i=0; i<result.synonyms.length; i++) {
        Token repTok = result.synonyms[i];
        Token newTok = new Token(repTok.termText(), firstTok.startOffset(), lastTok.endOffset(), firstTok.type());
        repPos += repTok.getPositionIncrement();
        if (i==0) repPos=origPos;  // make position of first token equal to original

        // if necessary, insert original tokens and adjust position increment
        while (origTok != null && origPos <= repPos) {
          origTok.setPositionIncrement(origPos-pos);
          generated.add(origTok);
          pos += origTok.getPositionIncrement();
          origTok = matched.isEmpty() ? null : (Token)matched.removeFirst();
          if (origTok != null) origPos += origTok.getPositionIncrement();
        }

        newTok.setPositionIncrement(repPos - pos);
        generated.add(newTok);
        pos += newTok.getPositionIncrement();
      }

      // finish up any leftover original tokens
      while (origTok!=null) {
        origTok.setPositionIncrement(origPos-pos);
        generated.add(origTok);
        pos += origTok.getPositionIncrement();
        origTok = matched.isEmpty() ? null : (Token)matched.removeFirst();
        if (origTok != null) origPos += origTok.getPositionIncrement();
      }

      // what if we replaced a longer sequence with a shorter one?
      // a/0 b/5 =>  foo/0
      // should I re-create the gap on the next buffered token?

      replacement = generated.iterator();
      // Now return to the top of the loop to read and return the first
      // generated token.. The reason this is done is that we may have generated
      // nothing at all, and may need to continue with more matching logic.
    }
  }

