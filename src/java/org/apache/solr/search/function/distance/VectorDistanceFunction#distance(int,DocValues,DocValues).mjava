  /**
   * Calculate the distance
   *
   * @param doc        The current doc
   * @param dv1 The values from the first MultiValueSource
   * @param dv2 The values from the second MultiValueSource
   * @return The distance
   */
  protected double distance(int doc, DocValues dv1, DocValues dv2) {
    double result = 0;
    //Handle some special cases:
    double [] vals1 = new double[source1.dimension()];
    double [] vals2 = new double[source1.dimension()];
    dv1.doubleVal(doc, vals1);
    dv2.doubleVal(doc, vals2);
    if (power == 0) {
      for (int i = 0; i < vals1.length; i++) {
        result += vals1[i] - vals2[i] == 0 ? 0 :1;
      }

    } else if (power == 1.0) {
      for (int i = 0; i < vals1.length; i++) {
        result += vals1[i] - vals2[i];
      }
    } else if (power == 2.0) {
      for (int i = 0; i < vals1.length; i++) {
        double v = vals1[i] - vals2[i];
        result += v * v;
      }
      result = Math.sqrt(result);
    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infininte norm?
      for (int i = 0; i < vals1.length; i++) {
        result = Math.max(vals1[i], vals2[i]);
      }
    } else {
      for (int i = 0; i < vals1.length; i++) {
        result += Math.pow(vals1[i] - vals2[i], power);
      }
      result = Math.pow(result, oneOverPower);
    }

    return result;
  }

