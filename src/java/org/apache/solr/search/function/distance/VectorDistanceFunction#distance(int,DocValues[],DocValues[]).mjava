  /**
   * Calculate the distance
   *
   * @param doc        The current doc
   * @param docValues1 The values from the first set of value sources
   * @param docValues2 The values from the second set of value sources
   * @return The distance
   */
  protected double distance(int doc, DocValues[] docValues1, DocValues[] docValues2) {
    double result = 0;
    //Handle some special cases:
    if (power == 0) {
      for (int i = 0; i < docValues1.length; i++) {
        //sparseness measure
        result += docValues1[i].doubleVal(doc) - docValues2[i].doubleVal(doc) == 0 ? 0 : 1;
      }
    } else if (power == 1.0) {
      for (int i = 0; i < docValues1.length; i++) {
        result += docValues1[i].doubleVal(doc) - docValues2[i].doubleVal(doc);
      }
    } else if (power == 2.0) {
      for (int i = 0; i < docValues1.length; i++) {
        double v = docValues1[i].doubleVal(doc) - docValues2[i].doubleVal(doc);
        result += v * v;
      }
      result = Math.sqrt(result);
    } else if (power == Integer.MAX_VALUE || Double.isInfinite(power)) {//infininte norm?
      for (int i = 0; i < docValues1.length; i++) {
        //TODO: is this the correct infinite norm?
        result = Math.max(docValues1[i].doubleVal(doc) - docValues2[i].doubleVal(doc), result);
      }

    } else {
      for (int i = 0; i < docValues1.length; i++) {
        result += Math.pow(docValues1[i].doubleVal(doc) - docValues2[i].doubleVal(doc), power);
      }
      result = Math.pow(result, oneOverPower);
    }

    return result;
  }

