  // As the size of this int hashtable is expected to be small
  // (thousands at most), I did not try to keep the rehash function
  // reversible (important to avoid collisions in large hash tables).
  private int rehash(int val) {
    int h,s,v;
    final int comp=~val;

    // don't left shift too far... the only bits
    // that count in the answer are the ones on the right.
    // We want to put more of the bits on the left
    // into the answer.
    // Keep small tables in mind.  We may be only using
    // the first 5 or 6 bits.

    // on the first rehash, use complement instead of val to shift
    // so we don't end up with 0 again if val==0.
    h = val ^ (comp>>8);
    s = h & mask;
    v = table[s];
    if (v==EMPTY || v==val) return s;

    h ^= (v << 17) | (comp >>> 16);   // this is reversible
    s = h & mask;
    v = table[s];
    if (v==EMPTY || v==val) return s;

    h ^= (h << 8) | (comp >>> 25);    // this is reversible
    s = h & mask;
    v = table[s];
    if (v==EMPTY || v==val) return s;

    /**********************
     // Knuth, Thomas Wang, http://www.concentric.net/~Ttwang/tech/inthash.htm
     // This magic number has no common factors with 2^32, and magic/(2^32) approximates
     // the golden ratio.
    private static final int magic = (int)2654435761L;

    h = magic*val;
    s = h & mask;
    v=table[s];
    if (v==EMPTY || v==val) return s;

    // the mult with magic should have thoroughly mixed the bits.
    // add entropy to the right half from the left half.
    h ^= h>>>16;
    s = h & mask;
    v=table[s];
    if (v==EMPTY || v==val) return s;
    *************************/

    // linear scan now... ug.
    final int start=s;
    while (++s<tablesize) {
      v=table[s];
      if (v==EMPTY || v==val) return s;
    }
    s=start;
    while (--s>=0) {
      v=table[s];
      if (v==EMPTY || v==val) return s;
    }
    return s;
  }

