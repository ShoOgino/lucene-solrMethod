  /**
   * Returns null if the sortSpec string doesn't look like a sort specification,
   * or if the sort specification couldn't be converted into a Lucene Sort
   * (because of a field not being indexed or undefined, etc).
   *
   * The form of the sort specification string currently parsed is:
   * SortSpec ::= SingleSort [, SingleSort]* <number>?
   * SingleSort ::= <fieldname> SortDirection
   * SortDirection ::= top | desc | bottom | asc
   *
   * Examples:
   *   top 10                        #take the top 10 by score
   *   desc 10                       #take the top 10 by score
   *   score desc 10                 #take the top 10 by score
   *   weight bottom 10              #sort by weight ascending and take the first 10
   *   weight desc                   #sort by weight descending
   *   height desc,weight desc       #sort by height descending, and use weight descending to break any ties
   *   height desc,weight asc top 20 #sort by height descending, using weight ascending as a tiebreaker
   *
   */
  public static SortSpec parseSort(String sortSpec, IndexSchema schema) {
    if (sortSpec==null || sortSpec.length()==0) return null;

    // I wonder how fast the regex is??? as least we cache the pattern.
    String[] parts = sortSeparator.split(sortSpec.trim(),0);
    if (parts.length == 0) return null;

    ArrayList<SortField> lst = new ArrayList<SortField>();
    int num=-1;

    int pos=0;
    String fn;
    boolean top=true;
    boolean normalSortOnScore=false;

    while (pos < parts.length) {
      String str=parts[pos];
      if ("top".equals(str) || "bottom".equals(str) || "asc".equals(str) || "desc".equals(str)) {
        // if the field name seems to be missing, default to "score".
        // note that this will mess up a field name that has the same name
        // as a sort direction specifier.
        fn="score";
      } else {
        fn=str;
        pos++;
      }

      // get the direction of the sort
      str=parts[pos];
      if ("top".equals(str) || "desc".equals(str)) {
        top=true;
      } else if ("bottom".equals(str) || "asc".equals(str)) {
        top=false;
      }  else {
        return null;  // must not be a sort command
      }

      // get the field to sort on
      // hmmm - should there be a fake/pseudo-field named "score" in the schema?
      if ("score".equals(fn)) {
        if (top) {
          normalSortOnScore=true;
          lst.add(SortField.FIELD_SCORE);
        } else {
          lst.add(new SortField(null, SortField.SCORE, true));
        }
      } else {
        // getField could throw an exception if the name isn't found
        try {
          SchemaField f = schema.getField(fn);
          if (f == null || !f.indexed()) return null;
          lst.add(f.getType().getSortField(f,top));
        } catch (Exception e) {
          return null;
        }
      }
      pos++;

      // If there is a leftover part, assume it is a count
      if (pos+1 == parts.length) {
        try {
          num = Integer.parseInt(parts[pos]);
        } catch (Exception e) {
          return null;
        }
        pos++;
      }
    }

    Sort sort;
    if (normalSortOnScore && lst.size() == 1) {
      // Normalize the default sort on score descending to sort=null
      sort=null;
    } else {
      sort = new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));
    }
    return new SortSpec(sort,num);
  }

