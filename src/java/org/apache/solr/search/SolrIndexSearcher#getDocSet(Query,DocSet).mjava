  /**
   * Returns the set of document ids matching both the query and the filter.
   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
   * If the answer was not cached, it may have been inserted into the cache as a result of this call.
   * <p>
   *
   * @param query
   * @param filter may be null
   * @return DocSet meeting the specified criteria, should <b>not</b> be modified by the caller.
   */
  public DocSet getDocSet(Query query, DocSet filter) throws IOException {
    if (filter==null) return getDocSet(query);

    DocSet first;
    if (filterCache != null) {
      first = (DocSet)filterCache.get(query);
      if (first==null) {
        first = getDocSetNC(query,null);
        filterCache.put(query,first);
      }
      return first.intersection(filter);
    }


    // If there isn't a cache, then do a single filtered query.
    return getDocSetNC(query,filter);


    /******* OLD VERSION that did a filtered query instead of
     * an intersection if the query docset wasn't found in the cache.
     * It made misses != inserts (even if no evictions)
    DocSet first=null;
    if (filterCache != null) {
      first = (DocSet)filterCache.get(query);
      if (first != null) {
        return first.intersection(filter);
      }
    }

    DocSet answer = getDocSetNC(query, filter);
    // nothing is inserted into the cache, because we don't cache materialized filters.
    // Hmmm, we *could* make a hitcollector that made a DocSet out of the query at the
    // same time it was running the filter though...

    // Q: we could call getDocSet(query) and then take the intersection instead of running
    // the query as a filter.  Then it could be cached.
    return answer;
    ****************/
  }

