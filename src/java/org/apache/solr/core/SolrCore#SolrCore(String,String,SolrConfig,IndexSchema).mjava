  /**
   * Creates a new core and register it in the list of cores.
   * If a core with the same name already exists, it will be stopped and replaced by this one.
   *@param dataDir the index directory
   *@param config a solr config instance
   *@param schema a solr schema instance
   */
  public SolrCore(String name, String dataDir, SolrConfig config, IndexSchema schema) {
    synchronized (SolrCore.class) {
      // this is for backward compatibility (and also the reason
      // the sync block is needed)
      instance = this;   // set singleton
      this.name = name;
      SolrResourceLoader loader = config.getResourceLoader();
      if (dataDir ==null) {
        dataDir = config.get("dataDir",loader.getInstanceDir()+"data");
      }

      log.info("["+name+"] Opening new SolrCore at " + loader.getInstanceDir() + ", dataDir="+dataDir);

      if (schema==null) {
        schema = new IndexSchema(config, "schema.xml");
      }

      this.schema = schema;
      this.dataDir = dataDir;
      this.index_path = dataDir + "/" + "index";
      this.solrConfig = config;
      this.startTime = System.currentTimeMillis();
      this.maxWarmingSearchers = config.getInt("query/maxWarmingSearchers",Integer.MAX_VALUE);

      booleanQueryMaxClauseCount();
  
      parseListeners();
  
      initIndex();
      
      initWriters();
      initQParsers();
      
      this.searchComponents = loadSearchComponents( config );

      // Processors initialized before the handlers
      updateProcessors = loadUpdateProcessors();
      reqHandlers = new RequestHandlers(this);
      reqHandlers.initHandlersFromConfig( solrConfig );
  
      // TODO? could select the highlighter implementation
      highlighter = new SolrHighlighter();
      highlighter.initalize( solrConfig );
      
      try {
        // Open the searcher *before* the handler so we don't end up opening
        // one in the middle.
        getSearcher(false,false,null);
  
        updateHandler = createUpdateHandler(
          solrConfig.get("updateHandler/@class", DirectUpdateHandler.class.getName())
        );
      } 
      catch (IOException e) {
        throw new RuntimeException(e);
      }
      
      // Finally tell anyone who wants to know
      loader.inform( loader );
      loader.inform( this );
    }
  }

