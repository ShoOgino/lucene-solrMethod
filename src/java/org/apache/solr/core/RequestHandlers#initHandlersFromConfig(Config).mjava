  /**
   * Read solrconfig.xml and register the appropriate handlers
   * 
   * This function should <b>only</b> be called from the SolrCore constructor.  It is
   * not intended as a public API.
   * 
   * While the normal runtime registration contract is that handlers MUST be initalizad 
   * before they are registered, this function does not do that exactly.
   * 
   * This funciton registers all handlers first and then calls init() for each one.  
   * 
   * This is OK because this function is only called at startup and there is no chance that
   * a handler could be asked to handle a request before it is initalized.
   * 
   * The advantage to this approach is that handlers can know what path they are registered
   * to and what other handlers are avaliable at startup.
   * 
   * Handlers will be registered and initalized in the order they appear in solrconfig.xml
   */
  @SuppressWarnings("unchecked")
  void initHandlersFromConfig( Config config )  
  {
    NodeList nodes = (NodeList)config.evaluate("requestHandler", XPathConstants.NODESET);
    
    if (nodes !=null ) {
      // make sure it only once/handler and that that handlers get initalized in the 
      // order they were defined
      Map<String,NamedList<Object>> names = new LinkedHashMap<String,NamedList<Object>>(); 
      for (int i=0; i<nodes.getLength(); i++) {
        Node node = nodes.item(i);
  
        // In a production environment, we can tolerate an error in some request handlers, 
        // still load the others, and have a working system.
        try {
          String name = DOMUtil.getAttr(node,"name","requestHandler config");
          String className = DOMUtil.getAttr(node,"class","requestHandler config");
          String startup = DOMUtil.getAttr(node,"startup", null );
          NamedList<Object> args = DOMUtil.childNodesToNamedList(node);
  
          // Perhaps lazy load the request handler with a wrapper
          SolrRequestHandler handler = null;
          if( "lazy".equals( startup ) ) {
            log.info("adding lazy requestHandler: " + name + "=" + className);
            handler = new LazyRequestHandlerWrapper( className, args );
          }
          else {
            Class<? extends SolrRequestHandler> clazz = Config.findClass( className, new String[]{} );
            log.info("adding requestHandler: " + name + "=" + className);
            handler = clazz.newInstance();
          }
          
          SolrRequestHandler old = register( name, handler );
          if( old != null ) {
            String msg = "multiple handlers registered on the same path! ignoring: "+old;
            Throwable t = new SolrException( 500, msg );
            SolrConfig.severeErrors.add( t );
            SolrException.logOnce(log,null,t);
          }
          names.put( name, args );
        } 
        catch (Exception e) {
          SolrConfig.severeErrors.add( e );
          SolrException.logOnce(log,null,e);
        }
      }
      
      // Call init() on each handler after they have all been registered
      for( Map.Entry<String, NamedList<Object>> reg : names.entrySet() ) {
        try {
          handlers.get( reg.getKey() ).init( reg.getValue() );
        }
        catch( Exception e ) {
          SolrConfig.severeErrors.add( e );
          SolrException.logOnce(log,null,e);
        }
      }
    }
    
    //
    // Get the default handler and add it in the map under null and empty
    // to act as the default.
    //
    SolrRequestHandler handler = get(RequestHandlers.DEFAULT_HANDLER_NAME);
    if (handler == null) {
      handler = new StandardRequestHandler();
      register(RequestHandlers.DEFAULT_HANDLER_NAME, handler);
    }
    register(null, handler);
    register("", handler);
  }

