  // Converts a base100 sortable number to base10 character form
// returns number of chars written.
// At least 1 char is always written.
  public static int base10kSortableIntToBase10(char[] arr, int start, int end,
                                               char[] out, int offset)
  {
    // Take care of "0" case first.  It's the only number that is represented
    // in one char since we don't chop trailing zeros.
    if (end-start == 1) {
      out[offset]='0';
      return 1;
    }

    int wpos = offset;  // write position
    boolean neg;
    int exp = arr[start++];
    if (exp < ZERO_EXPONENT) {
      neg=true;
      // We don't currently use exp on decoding...
      // exp = ZERO_EXPONENT - exp;
      out[wpos++]='-';
    } else {
      neg=false;
    }

    // since so many values will fall in one char, pull it
    // out of the loop (esp since the first value must
    // be special-cased to not print leading zeros.
    // integer division is still expensive, so it's best to check
    // if you actually need to do it.
    //
    // TIP: write a small function in gcc or cl and see what
    // the optimized assemply output looks like (and which is fastest).
    // In C you can specify "unsigned" which gives the compiler more
    // info than the Java compiler has.
    int val = arr[start++];
    if (neg) val = 9999 - val;

    /***
    if (val < 10) {
      out[wpos++] = (char)(val + '0');
    } else if (val < 100) {
      out[wpos++] = (char)(val/10 + '0');
      out[wpos++] = (char)(val%10 + '0');
    } else if (val < 1000) {
      out[wpos++] = (char)(val/100 + '0');
      out[wpos++] = (char)((val/10)%10 + '0');
      out[wpos++] = (char)(val%10 + '0');
    } else {
      out[wpos++] = (char)(val/1000 + '0');
      out[wpos++] = (char)((val/100)%10 + '0');
      out[wpos++] = (char)((val/10)%10 + '0');
      out[wpos++] = (char)(val % 10 + '0');
    }
    ***/

    if (val < 10) {
      out[wpos++] = (char)(val + '0');
    } else if (val < 100) {
      int div = div10(val);
      int ones = val - mul10(div); // mod 10
      out[wpos++] = (char)(div + '0');
      out[wpos++] = (char)(ones + '0');
    } else if (val < 1000) {
      int div = div10(val);
      int ones = val - mul10(div); // mod 10
      val=div;
      div = div10(val);
      int tens = val - mul10(div); // mod 10
      out[wpos++] = (char)(div + '0');
      out[wpos++] = (char)(tens + '0');
      out[wpos++] = (char)(ones + '0');
    } else {
      int div = div10(val);
      int ones = val - mul10(div); // mod 10
      val=div;
      div = div10(val);
      int tens = val - mul10(div); // mod 10
      val=div;
      div = div10(val);
      int hundreds = val - mul10(div); // mod 10

      out[wpos++] = (char)(div + '0');
      out[wpos++] = (char)(hundreds + '0');
      out[wpos++] = (char)(tens + '0');
      out[wpos++] = (char)(ones + '0');
    }


    while (start < end) {
      val = arr[start++];
      if (neg) val = 9999 - val;

      int div = div10(val);
      int ones = val - mul10(div); // mod 10
      val=div;
      div = div10(val);
      int tens = val - mul10(div); // mod 10
      val=div;
      div = div10(val);
      int hundreds = val - mul10(div); // mod 10

      /***
      int ones = val % 10;
      val /= 10;
      int tens = val!=0 ? val % 10 : 0;
      val /= 10;
      int hundreds = val!=0 ? val % 10 : 0;
      val /= 10;
      int thousands = val!=0 ? val % 10 : 0;
      ***/

      /***
      int thousands = val>=1000 ? val/1000 : 0;
      int hundreds  = val>=100 ? (val/100)%10 : 0;
      int tens      = val>=10 ? (val/10)%10 : 0;
      int ones      = val % 10;
      ***/

      /***
      int thousands =  val/1000;
      int hundreds  = (val/100)%10;
      int tens      = (val/10)%10;
      int ones      = val % 10;
      ***/

      out[wpos++] = (char)(div + '0');
      out[wpos++] = (char)(hundreds + '0');
      out[wpos++] = (char)(tens + '0');
      out[wpos++] = (char)(ones + '0');
    }

    // OPTIONAL: if trailing zeros were truncated, then this is where
    // we would restore them (compare number of chars read vs exponent)

    return wpos-offset;
  }

