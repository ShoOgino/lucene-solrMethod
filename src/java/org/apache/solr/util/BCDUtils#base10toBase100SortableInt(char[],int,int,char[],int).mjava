  /********* FUTURE
    // the zero exponent... exponents above this point are positive
    // and below are negative.
    // It is desirable to make ordinary numbers have a single byte
    // exponent when converted to UTF-8
    // For integers, the exponent will always be >=0, but this format
    // is meant to be valid for floating point numbers as well...
    private static final int ZERO_EXPONENT='a';  // 97

    // if exponent is larger than what can be represented
    // in a single byte (char), then this is the multibyte
    // escape char.
    // UCS-2 surrogates start at 0xD800
    private static final int POSITIVE_EXPONENT_ESCAPE=0x3fff;

    // if exponent is smaller than what can be represented in
    // a single byte, then this is the multibyte escape
    private static final int NEGATIVE_EXPONENT_ESCAPE=1;

    // if number is negative, it starts with this optional value
    // this should not overlap with any exponent values
    private static final int NEGATIVE_SIGN=0;
  **********/

    // WARNING: assumption is that this is a legal int...
    // no validation is done.  [+-]?digit*
    //
    // Normalization of zeros *is* done...
    //  0004, 004, 04, 4 will all end up being equal
    //  0,-0 are normalized to '' (zero length)
    //
    // The value is written to the output buffer
    // from the end to the start.  The return value
    // is the start of the Base100 int in the output buffer.
    //
    // As the output will be smaller than the input, arr and
    // out may refer to the same array if desired.
    //
    public static int base10toBase100SortableInt(char[] arr, int start, int end,
                                                 char[] out, int outend
                                      )
    {
      int wpos=outend;  // write position
      boolean neg=false;
      --end;  // position end pointer *on* the last char

      // read signs and leading zeros
      while (start <= end) {
        char val = arr[start];
        if (val=='-') neg=!neg;
        else if (val>='1' && val<='9') break;
        start++;
      }

      // eat whitespace on RHS?
      outer: while (start <= end) {
        switch(arr[end]) {
          case ' ':
          case '\t':
          case '\n':
          case '\r': end--; break;
          default: break outer;
        }
      }

      int hundreds=0;
      /******************************************************
       * remove RHS zero normalization since it only helps 1 in 100
       * numbers and complicates both encoding and decoding.

      // remove pairs of zeros on the RHS and keep track of
      // the count.
      while (start <= end) {
        char val = arr[end];

        if (val=='0' && start <= end) {
          val=arr[end-1];
          if (val=='0') {
            hundreds++;
            end-=2;
            continue;
          }
        }

        break;
      }
      *************************************************************/


      // now start at the end and work our way forward
      // encoding two base 10 digits into 1 base 100 digit
      while (start <= end) {
        int val = arr[end--];
        val = val - '0';
        if (start <= end) {
          int val2 = arr[end--];
          val = val + (val2 - '0')*10;
        }
        out[--wpos] = neg ? (char)(99-val) : (char)val;
      }

      /****** FUTURE: not needed for this implementation of exponent combined with sign
      // normalize all zeros to positive values
      if (wpos==outend) neg=false;
      ******/

      // adjust exponent by the number of base 100 chars written
      hundreds += outend - wpos;

      // write the exponent and sign combined
      out[--wpos] = neg ? (char)(ZERO_EXPONENT - hundreds) : (char)(ZERO_EXPONENT + hundreds);

      return outend-wpos;  // the length of the base100 int
    }

