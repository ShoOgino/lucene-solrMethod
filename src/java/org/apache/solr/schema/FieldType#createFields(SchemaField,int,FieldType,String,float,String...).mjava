  /**
   * Create multiple fields from a single field and multiple values.  Fields are named as SchemaField.getName() + {@link #POLY_FIELD_SEPARATOR} + i, where
   * i starts at 0.
   * <p/>
   * If the field is stored, then an extra field gets created that contains the storageVal.  It is this field that also
   *
   * @param field The {@link org.apache.solr.schema.SchemaField}
   * @param props The properties to use
   * @param delegatedType An optional type to use.  If null, then field.getType() is used.  Useful for poly fields.
   * @param storageVal If the field stores, then this value will be used for the stored field
   * @param boost The boost to apply to all fields
   * @param externalVals The values to use
   * @return The fields
   */
  protected Fieldable[] createFields(SchemaField field, int props,
                                 FieldType delegatedType, String storageVal,
                                 float boost, String ... externalVals) {
    int n = field.indexed() ? externalVals.length : 0;
    n += field.stored() ? 1 : 0;
    if (delegatedType == null) { //if the type isn't being overriden, then just use the base one
      delegatedType = field.getType();
    }
    Field[] results = new Field[n];
    //Field.Store.NO,Field.Index.NOT_ANALYZED_NO_NORMS, Field.TermVector.NO, true, true

    if (externalVals.length > 0) {
      if (field.indexed()) {
        String name = field.getName() + "_";
        String suffix = POLY_FIELD_SEPARATOR + delegatedType.typeName;

        int len = name.length();
        StringBuilder bldr = new StringBuilder(len + 3 + suffix.length());//should be enough buffer to handle most values of j.
        bldr.append(name);
        for (int j = 0; j < externalVals.length; j++) {
          //SchemaField is final, as is name, so we need to recreate each time
          //put the counter before the separator, b/c dynamic fields can't be asterisks on both the front and the end of the String
          bldr.append(j).append(suffix);
          SchemaField sf = SchemaField.create(bldr.toString(),
                  delegatedType, props, null);
                  //schema.getDynamicField(name  + "_" + j + POLY_FIELD_SEPARATOR + delegatedType.typeName);
                  /**/
          //new SchemaField(name, ft, p, defaultValue )
          //QUESTION: should we allow for vectors, etc?  Not sure that it makes sense
          results[j] = delegatedType.createField(sf, externalVals[j], boost);
          bldr.setLength(len);//cut the builder back to just the length of the prefix, but keep the capacity
        }
      }
      Field.TermVector fieldTermVec = getFieldTermVec(field, storageVal);
      if (field.stored() || fieldTermVec.equals(Field.TermVector.YES)
              || fieldTermVec.equals(Field.TermVector.WITH_OFFSETS)
              || fieldTermVec.equals(Field.TermVector.WITH_POSITIONS)
              || fieldTermVec.equals(Field.TermVector.WITH_POSITIONS_OFFSETS)
      ) {

          //QUESTION: should we allow for vectors, etc?  Not sure that it makes sense
        results[results.length - 1] = createField(field.getName(), storageVal, getFieldStore(field, storageVal),
                Field.Index.NO,
                fieldTermVec, field.omitNorms(), field.omitTf(), boost);
         
      }

    }
    return results;
  }

