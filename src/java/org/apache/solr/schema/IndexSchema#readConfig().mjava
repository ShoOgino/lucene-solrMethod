  private void readConfig() {
    log.info("Reading Solr Schema");

    try {
      /***
      DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
      Document document = builder.parse(getInputStream());
      ***/

      Config config = new Config("schema", getInputStream(), "/schema/");
      Document document = config.getDocument();
      XPath xpath = config.getXPath();

      Node nd = (Node) xpath.evaluate("/schema/@name", document, XPathConstants.NODE);
      if (nd==null) {
        log.warning("schema has no name!");
      } else {
        name = nd.getNodeValue();
        log.info("Schema name=" + name);
      }

      version = config.getFloat("/schema/@version", 1.0f);

      String expression = "/schema/types/fieldtype";
      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);


      for (int i=0; i<nodes.getLength(); i++) {
        Node node = nodes.item(i);
        NamedNodeMap attrs = node.getAttributes();

        String name = DOMUtil.getAttr(attrs,"name","fieldtype error");
        log.finest("reading fieldtype "+name);
        String clsName = DOMUtil.getAttr(attrs,"class", "fieldtype error");
        FieldType ft = (FieldType)Config.newInstance(clsName);
        ft.setTypeName(name);

        expression = "./analyzer[@type='query']";
        Node anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);
        Analyzer queryAnalyzer = readAnalyzer(anode);

        // An analyzer without a type specified, or with type="index"
        expression = "./analyzer[not(@type)] | ./analyzer[@type='index']";
        anode = (Node)xpath.evaluate(expression, node, XPathConstants.NODE);
        Analyzer analyzer = readAnalyzer(anode);

        if (queryAnalyzer==null) queryAnalyzer=analyzer;
        if (analyzer==null) analyzer=queryAnalyzer;
        if (analyzer!=null) {
          ft.setAnalyzer(analyzer);
          ft.setQueryAnalyzer(queryAnalyzer);
        }


        ft.setArgs(this, DOMUtil.toMapExcept(attrs,"name","class"));
        fieldTypes.put(ft.typeName,ft);
        log.finest("fieldtype defined: " + ft);
      }


      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();
      expression = "/schema/fields/field | /schema/fields/dynamicField";
      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);

      for (int i=0; i<nodes.getLength(); i++) {
        Node node = nodes.item(i);

        NamedNodeMap attrs = node.getAttributes();

        String name = DOMUtil.getAttr(attrs,"name","field definition");
        log.finest("reading field def "+name);
        String type = DOMUtil.getAttr(attrs,"type","field " + name);
        String val;

        FieldType ft = fieldTypes.get(type);
        if (ft==null) {
          throw new SolrException(400,"Unknown fieldtype '" + type + "'",false);
        }

        Map<String,String> args = DOMUtil.toMapExcept(attrs, "name", "type");

        SchemaField f = SchemaField.create(name,ft,args);

        if (node.getNodeName().equals("field")) {
          fields.put(f.getName(),f);
          log.fine("field defined: " + f);
        } else if (node.getNodeName().equals("dynamicField")) {
          dFields.add(new DynamicField(f));
          log.fine("dynamic field defined: " + f);
        } else {
          // we should never get here
          throw new RuntimeException("Unknown field type");
        }
      }

    // OK, now sort the dynamic fields largest to smallest size so we don't get
    // any false matches.  We want to act like a compiler tool and try and match
    // the largest string possible.
    Collections.sort(dFields);

    log.finest("Dynamic Field Ordering:" + dFields);

    // stuff it in a normal array for faster access
    dynamicFields = (DynamicField[])dFields.toArray(new DynamicField[dFields.size()]);


    Node node = (Node) xpath.evaluate("/schema/similarity/@class", document, XPathConstants.NODE);
    if (node==null) {
      similarity = new DefaultSimilarity();
      log.fine("using default similarity");
    } else {
      similarity = (Similarity)Config.newInstance(node.getNodeValue().trim());
      log.fine("using similarity " + similarity.getClass().getName());
    }

    node = (Node) xpath.evaluate("/schema/defaultSearchField/text()", document, XPathConstants.NODE);
    if (node==null) {
      log.warning("no default search field specified in schema.");
    } else {
      String defName=node.getNodeValue().trim();
      defaultSearchFieldName = getIndexedField(defName)!=null ? defName : null;
      log.info("default search field is "+defName);
    }

    node = (Node) xpath.evaluate("/schema/uniqueKey/text()", document, XPathConstants.NODE);
    if (node==null) {
      log.warning("no uniqueKey specified in schema.");
    } else {
      uniqueKeyField=getIndexedField(node.getNodeValue().trim());
      uniqueKeyFieldName=uniqueKeyField.getName();
      uniqueKeyFieldType=uniqueKeyField.getType();
      log.info("unique key field: "+uniqueKeyFieldName);
    }

    /////////////// parse out copyField commands ///////////////
    // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
    // expression = "/schema/copyField";

    ArrayList<DynamicCopy> dCopies = new ArrayList<DynamicCopy>();

    expression = "//copyField";
    nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);

      for (int i=0; i<nodes.getLength(); i++) {
        node = nodes.item(i);
        NamedNodeMap attrs = node.getAttributes();

        String source = DOMUtil.getAttr(attrs,"source","copyField definition");

        boolean sourceIsPattern = isWildCard(source);

        String dest = DOMUtil.getAttr(attrs,"dest","copyField definition");
        log.fine("copyField source='"+source+"' dest='"+dest+"'");
        SchemaField d = getField(dest);

        if(sourceIsPattern) {
          dCopies.add(new DynamicCopy(source, d));
        } else {
          // retrieve the field to force an exception if it doesn't exist
          SchemaField f = getField(source);

          SchemaField[] destArr = copyFields.get(source);
          if (destArr==null) {
            destArr=new SchemaField[]{d};
          } else {
            destArr = (SchemaField[])append(destArr,d);
          }
          copyFields.put(source,destArr);
        }
     }

      log.finest("Dynamic Copied Fields:" + dCopies);

      // stuff it in a normal array for faster access
      dynamicCopyFields = (DynamicCopy[])dCopies.toArray(new DynamicCopy[dCopies.size()]);

    } catch (SolrException e) {
      throw e;
    } catch(Exception e) {
      // unexpected exception...
      throw new SolrException(1,"Schema Parsing Failed",e,false);
    }

     analyzer = new SolrIndexAnalyzer();
     queryAnalyzer = new SolrQueryAnalyzer();
  }

