  @Override
  /**
   * Care should be taken in calling this with higher order dimensions for performance reasons.
   */
  public Query getRangeQuery(QParser parser, SchemaField field, String part1, String part2, boolean minInclusive, boolean maxInclusive) {
    //Query could look like: [x1,y1 TO x2,y2] for 2 dimension, but could look like: [x1,y1,z1 TO x2,y2,z2], and can be extrapolated to n-dimensions
    //thus, this query essentially creates a box, cube, etc.
    String[] p1 = DistanceUtils.parsePoint(null, part1, dimension);
    String[] p2 = DistanceUtils.parsePoint(null, part2, dimension);
    BooleanQuery result = new BooleanQuery(true);
    String name = field.getName() + "_";
    String suffix = POLY_FIELD_SEPARATOR + subType.typeName;
    int len = name.length();
    StringBuilder bldr = new StringBuilder(len + 3 + suffix.length());//should be enough buffer to handle most values of j.
    bldr.append(name);
    for (int i = 0; i < dimension; i++) {
      bldr.append(i).append(suffix);
      SchemaField subSF = schema.getField(bldr.toString());
      // points must currently be ordered... should we support specifying any two opposite corner points?

      /*new TermRangeQuery(
     field.getName() + i + POLY_FIELD_SEPARATOR + subType.typeName,
     subType.toInternal(p1[i]),
     subType.toInternal(p2[i]),
     minInclusive, maxInclusive);*/
      result.add(subType.getRangeQuery(parser, subSF, p1[i], p2[i], minInclusive, maxInclusive), BooleanClause.Occur.MUST);
      bldr.setLength(len);
    }
    return result;
  }

