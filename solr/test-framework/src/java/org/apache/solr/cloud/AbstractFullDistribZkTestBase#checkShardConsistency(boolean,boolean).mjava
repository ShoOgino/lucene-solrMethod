  /* Checks shard consistency and optionally checks against the control shard.
   * The test will be failed if differences are found.
   */
  protected void checkShardConsistency(boolean checkVsControl, boolean verbose)
      throws Exception {

    updateMappingsFromZk(jettys, clients);
    
    Set<String> theShards = shardToJetty.keySet();
    String failMessage = null;
    for (String shard : theShards) {
      String shardFailMessage = checkShardConsistency(shard, false, verbose);
      if (shardFailMessage != null && failMessage == null) {
        failMessage = shardFailMessage;
      }
    }
    
    if (failMessage != null) {
      fail(failMessage);
    }

    if (!checkVsControl) return;

    SolrParams q = params("q","*:*","rows","0", "tests","checkShardConsistency(vsControl)");    // add a tag to aid in debugging via logs

    SolrDocumentList controlDocList = controlClient.query(q).getResults();
    long controlDocs = controlDocList.getNumFound();

    SolrDocumentList cloudDocList = cloudClient.query(q).getResults();
    long cloudClientDocs = cloudDocList.getNumFound();




    // now check that the right # are on each shard
    theShards = shardToJetty.keySet();
    int cnt = 0;
    for (String s : theShards) {
      int times = shardToJetty.get(s).size();
      for (int i = 0; i < times; i++) {
        try {
          CloudJettyRunner cjetty = shardToJetty.get(s).get(i);
          ZkNodeProps props = cjetty.info;
          SolrServer client = cjetty.client.solrClient;
          boolean active = props.getStr(ZkStateReader.STATE_PROP).equals(
              ZkStateReader.ACTIVE);
          if (active) {
            SolrQuery query = new SolrQuery("*:*");
            query.set("distrib", false);
            long results = client.query(query).getResults().getNumFound();
            if (verbose) System.err.println(new ZkCoreNodeProps(props)
                .getCoreUrl() + " : " + results);
            if (verbose) System.err.println("shard:"
                + props.getStr(ZkStateReader.SHARD_ID_PROP));
            cnt += results;
            break;
          }
        } catch (Exception e) {
          // if we have a problem, try the next one
          if (i == times - 1) {
            throw e;
          }
        }
      }
    }


    if (controlDocs != cnt || cloudClientDocs != controlDocs) {
      String msg = "document count mismatch.  control=" + controlDocs + " sum(shards)="+ cnt + " cloudClient="+cloudClientDocs;
      log.error(msg);

      // re-execute the query getting ids
      q = params("q","*:*","rows","100000", "fl","id", "tests","checkShardConsistency(vsControl)/getIds");    // add a tag to aid in debugging via logs
      controlDocList = controlClient.query(q).getResults();
      if (controlDocs != controlDocList.getNumFound()) {
        log.error("Something changed! control now " + controlDocList.getNumFound());
      };

      cloudDocList = cloudClient.query(q).getResults();
      if (cloudClientDocs != cloudDocList.getNumFound()) {
        log.error("Something changed! cloudClient now " + cloudDocList.getNumFound());
      };

      Set<Map> differences = showDiff(controlDocList, cloudDocList,"controlDocList","cloudDocList");

      // get versions for the mismatched ids
      StringBuilder ids = new StringBuilder("id:(");
      for (Map doc : differences) {
        ids.append(" "+doc.get("id"));
      }
      ids.append(")");
      
      if (ids.length() > 0) {
        // get versions for those ids that don't match
        q = params("q", ids.toString(), "rows", "100000", "fl", "id,_version_",
            "sort", "id asc", "tests",
            "checkShardConsistency(vsControl)/getVers"); // add a tag to aid in
                                                         // debugging via logs
        
        SolrDocumentList a = controlClient.query(q).getResults();
        SolrDocumentList b = cloudClient.query(q).getResults();
        
        log.error("controlClient :" + a + "\n\tcloudClient :" + b);
      }

      fail(msg);
    }
  }

