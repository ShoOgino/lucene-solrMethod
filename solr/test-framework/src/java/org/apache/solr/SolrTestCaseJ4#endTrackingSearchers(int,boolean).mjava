  public static void endTrackingSearchers(int waitSeconds, boolean failTest) {
     long endNumOpens = SolrIndexSearcher.numOpens.get();
     long endNumCloses = SolrIndexSearcher.numCloses.get();

     // wait a bit in case any ending threads have anything to release
     int retries = 0;
     while (endNumOpens - numOpens != endNumCloses - numCloses) {
       if (retries++ > waitSeconds) {
         break;
       }
       if (retries % 10 == 0) {
         log.info("Waiting for all SolrIndexSearchers to be released at end of test");
        if (retries > 10) {
          TraceFormatting tf = new TraceFormatting();
          Map<Thread,StackTraceElement[]> stacksMap = Thread.getAllStackTraces();
          Set<Entry<Thread,StackTraceElement[]>> entries = stacksMap.entrySet();
          for (Entry<Thread,StackTraceElement[]> entry : entries) {
            String stack = tf.formatStackTrace(entry.getValue());
            System.err.println(entry.getKey().getName() + ":\n" + stack);
          }
        }
       }
       try {
         Thread.sleep(1000);
       } catch (InterruptedException e) {}
       endNumOpens = SolrIndexSearcher.numOpens.get();
       endNumCloses = SolrIndexSearcher.numCloses.get();
     }

     log.info("------------------------------------------------------- Done waiting for all SolrIndexSearchers to be released");
     
     SolrIndexSearcher.numOpens.getAndSet(0);
     SolrIndexSearcher.numCloses.getAndSet(0);

     if (endNumOpens-numOpens != endNumCloses-numCloses) {
       String msg = "ERROR: SolrIndexSearcher opens=" + (endNumOpens-numOpens) + " closes=" + (endNumCloses-numCloses);
       log.error(msg);
       // if it's TestReplicationHandler, ignore it. the test is broken and gets no love
       if ("TestReplicationHandler".equals(RandomizedContext.current().getTargetClass().getSimpleName())) {
         log.warn("TestReplicationHandler wants to fail!: " + msg);
       } else {
         if (failTest) fail(msg);
       }
     }
  }

