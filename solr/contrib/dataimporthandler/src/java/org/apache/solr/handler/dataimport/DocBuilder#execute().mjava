  @SuppressWarnings("unchecked")
  public void execute() {
    List<EntityProcessorWrapper> epwList = null;
    try {
      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);
      config = dataImporter.getConfig();
      final AtomicLong startTime = new AtomicLong(System.nanoTime());
      statusMessages.put(TIME_ELAPSED, new Object() {
        @Override
        public String toString() {
          return getTimeElapsedSince(startTime.get());
        }
      });

      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,
              importStatistics.queryCount);
      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,
              importStatistics.rowsCount);
      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,
              importStatistics.docCount);
      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,
              importStatistics.skipDocCount);

      List<String> entities = reqParams.getEntitiesToRun();

      // Trigger onImportStart
      if (config.getOnImportStart() != null) {
        invokeEventListener(config.getOnImportStart());
      }
      AtomicBoolean fullCleanDone = new AtomicBoolean(false);
      //we must not do a delete of *:* multiple times if there are multiple root entities to be run
      Map<String,Object> lastIndexTimeProps = new HashMap<>();
      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());

      epwList = new ArrayList<>(config.getEntities().size());
      for (Entity e : config.getEntities()) {
        epwList.add(getEntityProcessorWrapper(e));
      }
      for (EntityProcessorWrapper epw : epwList) {
        if (entities != null && !entities.contains(epw.getEntity().getName()))
          continue;
        lastIndexTimeProps.put(epw.getEntity().getName() + "." + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());
        currentEntityProcessorWrapper = epw;
        String delQuery = epw.getEntity().getAllAttributes().get("preImportDeleteQuery");
        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {
          cleanByQuery(delQuery, fullCleanDone);
          doDelta();
          delQuery = epw.getEntity().getAllAttributes().get("postImportDeleteQuery");
          if (delQuery != null) {
            fullCleanDone.set(false);
            cleanByQuery(delQuery, fullCleanDone);
          }
        } else {
          cleanByQuery(delQuery, fullCleanDone);
          doFullDump();
          delQuery = epw.getEntity().getAllAttributes().get("postImportDeleteQuery");
          if (delQuery != null) {
            fullCleanDone.set(false);
            cleanByQuery(delQuery, fullCleanDone);
          }
        }
      }

      if (stop.get()) {
        // Dont commit if aborted using command=abort
        statusMessages.put("Aborted", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).format(new Date()));
        handleError("Aborted", null);
      } else {
        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted
        if (!reqParams.isClean()) {
          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {
            finish(lastIndexTimeProps);
          }
        } else {
          // Finished operation normally, commit now
          finish(lastIndexTimeProps);
        }

        if (config.getOnImportEnd() != null) {
          invokeEventListener(config.getOnImportEnd());
        }
      }

      statusMessages.remove(TIME_ELAPSED);
      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, ""+ importStatistics.docCount.get());
      if(importStatistics.failedDocCount.get() > 0)
        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, ""+ importStatistics.failedDocCount.get());

      statusMessages.put("Time taken", getTimeElapsedSince(startTime.get()));
      if (log.isInfoEnabled()) {
        log.info("Time taken = {}", getTimeElapsedSince(startTime.get()));
      }
    } catch(Exception e)
    {
      throw new RuntimeException(e);
    } finally {
      // Cannot use IOUtils.closeQuietly since DIH relies on exceptions bubbling out of writer.close() to indicate
      // success/failure of the run.
      RuntimeException raisedDuringClose = null;
      try {
        if (writer != null) {
          writer.close();
        }
      } catch (RuntimeException e) {
        if (log.isWarnEnabled()) {
          log.warn("Exception encountered while closing DIHWriter " + writer + "; temporarily suppressing to ensure other DocBuilder elements are closed", e); // logOk
        }
        raisedDuringClose = e;
      }

      if (epwList != null) {
        closeEntityProcessorWrappers(epwList);
      }
      if(reqParams.isDebug()) {
        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;
      }

      if (raisedDuringClose != null) {
        throw raisedDuringClose;
      }
    }
  }

