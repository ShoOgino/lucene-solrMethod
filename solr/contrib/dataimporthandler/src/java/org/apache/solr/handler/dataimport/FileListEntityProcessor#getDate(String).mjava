  /**
   * Get the Date object corresponding to the given string.
   *
   * @param dateStr the date string. It can be a DateMath string or it may have a evaluator function
   * @return a Date instance corresponding to the input string
   */
  private Date getDate(String dateStr) {
    if (dateStr == null)
      return null;

    Matcher m = PLACE_HOLDER_PATTERN.matcher(dateStr);
    if (m.find()) {
      Object o = context.resolve(m.group(1));
      if (o instanceof Date)  return (Date)o;
      dateStr = (String) o;
    } else  {
      dateStr = context.replaceTokens(dateStr);
    }
    m = Evaluator.IN_SINGLE_QUOTES.matcher(dateStr);
    if (m.find()) {
      String expr = m.group(1);
      //TODO refactor DateMathParser.parseMath a bit to have a static method for this logic.
      if (expr.startsWith("NOW")) {
        expr = expr.substring("NOW".length());
      }
      try {
        // DWS TODO: is this TimeZone the right default for us?  Deserves explanation if so.
        return new DateMathParser(TimeZone.getDefault()).parseMath(expr);
      } catch (ParseException exp) {
        throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
                "Invalid expression for date", exp);
      }
    }
    try {
      return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.ROOT).parse(dateStr);
    } catch (ParseException exp) {
      throw new DataImportHandlerException(DataImportHandlerException.SEVERE,
              "Invalid expression for date", exp);
    }
  }

