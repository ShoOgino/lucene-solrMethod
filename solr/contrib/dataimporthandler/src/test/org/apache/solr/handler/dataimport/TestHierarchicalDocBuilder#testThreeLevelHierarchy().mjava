  @Test
  @AwaitsFix(bugUrl = "https://issues.apache.org/jira/browse/SOLR-12801") // this test fails easily under beasting
  public void testThreeLevelHierarchy() throws Exception {
    int parentsNum = 3; //fixed for simplicity of test
    int childrenNum = 0;
    int grandChildrenNum = 0;
    
    final String parentType = "parent";
    final String childType = "child";
    final String grandChildType = "grand_child";

    List<String> parentIds = createDataIterator("select * from PARENT", parentType, parentType, parentsNum);
    Collections.shuffle(parentIds, random());
    final String parentId1 = parentIds.get(0);
    String parentId2 = parentIds.get(1);
    
    //parent 1 children
    int firstParentChildrenNum = 3; //fixed for simplicity of test
    String select = "select * from CHILD where parent_id='" + parentId1 + "'";
    List<String> childrenIds = createDataIterator(select, childType, "child of first parent", firstParentChildrenNum);
    List<String> firstParentChildrenIds = new ArrayList<String>(childrenIds);
    childrenNum += childrenIds.size();
    
    // grand children of first parent first child
    final String childId = childrenIds.get(0);
    String description = "grandchild of first parent, child of " + childId + " child";
    select = "select * from GRANDCHILD where parent_id='" + childId + "'";
    List<String> grandChildrenIds = createDataIterator(select, grandChildType, description, atLeast(2));
    grandChildrenNum += grandChildrenIds.size();
    
    // grand children of first parent second child
    {
      String childId2 = childrenIds.get(1);
      description = "grandchild of first parent, child of " + childId2 + " child";
      select = "select * from GRANDCHILD where parent_id='" + childId2 + "'";
    }
    final List<String> grandChildrenIds2 = createDataIterator(select, grandChildType, description, atLeast(2));
    grandChildrenNum += grandChildrenIds2.size();
    
    List<String> allGrandChildrenIds = new ArrayList<>(grandChildrenIds);
    allGrandChildrenIds.addAll(grandChildrenIds2);
        
    // third children of first parent has no grand children
    
    // parent 2 children (no grand children)   
    select = "select * from CHILD where parent_id='" + parentId2 + "'";
    childrenIds = createDataIterator(select, childType, "child of second parent", atLeast(2));
    childrenNum += childrenIds.size();
    
    // parent 3 has no children and grand children
    
    int totalDocsNum = parentsNum + childrenNum + grandChildrenNum;
    
    String resp = runFullImport(THREE_LEVEL_HIERARCHY_CONFIG);
    String xpath = "//arr[@name='documents']/lst[arr[@name='id']/str='"+parentId1+"']/"+
      "arr[@name='_childDocuments_']/lst[arr[@name='id']/str='"+childId+"']/"+
      "arr[@name='_childDocuments_']/lst[arr[@name='id']/str='"+grandChildrenIds.get(0)+"']";
    String results = TestHarness.validateXPath(resp, 
           xpath);
    assertTrue("Debug documents does not contain child documents\n"+resp+"\n"+ xpath+
                                                        "\n"+results, results == null);
    
    assertTrue("Update request processor processAdd was not called", TestUpdateRequestProcessor.processAddCalled);
    assertTrue("Update request processor processCommit was not callled", TestUpdateRequestProcessor.processCommitCalled);
    assertTrue("Update request processor finish was not called", TestUpdateRequestProcessor.finishCalled);
    
    // very simple asserts to check that we at least have correct num of docs indexed
    assertQ(req("*:*"), "//*[@numFound='" + totalDocsNum + "']");
    assertQ(req("type_s:parent"), "//*[@numFound='" + parentsNum + "']");
    assertQ(req("type_s:child"), "//*[@numFound='" + childrenNum + "']");
    assertQ(req("type_s:grand_child"), "//*[@numFound='" + grandChildrenNum + "']");

    // let's check BlockJoin
    // get first parent by any grand children
    String randomGrandChildId = allGrandChildrenIds.get(random().nextInt(allGrandChildrenIds.size()));
    Query query = createToParentQuery(parentType, FIELD_ID, randomGrandChildId);
    assertSearch(query, FIELD_ID, parentId1);

    // get first parent by any children 
    String randomChildId = firstParentChildrenIds.get(random().nextInt(firstParentChildrenIds.size()));
    query = createToParentQuery(parentType, FIELD_ID, randomChildId);
    assertSearch(query, FIELD_ID, parentId1);
    
    // get parent by children by grand children
    randomGrandChildId = grandChildrenIds.get(random().nextInt(grandChildrenIds.size()));
    ToParentBlockJoinQuery childBlockJoinQuery = createToParentQuery(childType, FIELD_ID, randomGrandChildId);
    ToParentBlockJoinQuery blockJoinQuery = new ToParentBlockJoinQuery(childBlockJoinQuery, createParentFilter(parentType), ScoreMode.Avg);
    assertSearch(blockJoinQuery, FIELD_ID, parentId1);
  }

