  public static <T> CompletableFuture<List<T>> waitForAllSuccessfulResponses(List<CompletableFuture<T>> futures) {
    CompletableFuture<Void> completed = CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]));

    return completed.thenApply(values -> {
        return futures.stream()
          .map(CompletableFuture::join)
          .collect(Collectors.toList());
      }
    ).exceptionally(error -> {
      futures.stream()
          .filter(CompletableFuture::isCompletedExceptionally)
          .forEach(future -> {
            try {
              future.get();
            } catch (Exception exception) {
              log.warn("Error occurred during metrics collection", exception);
            }
          });

      return futures.stream()
          .filter(future -> !(future.isCompletedExceptionally() || future.isCancelled()))
          .map(CompletableFuture::join)
          .collect(Collectors.toList());
      }
    );
  }

