  @Override
  public Query createSpatialQuery(QParser parser, SpatialOptions options) {
    BooleanQuery result = new BooleanQuery();
    double[] point = new double[0];
    try {
      point = DistanceUtils.parseLatitudeLongitude(options.pointStr);
    } catch (InvalidGeoException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
    }
    point[0] = point[0] * DistanceUtils.DEGREES_TO_RADIANS;
    point[1] = point[1] * DistanceUtils.DEGREES_TO_RADIANS;
    //Get the distance
    double[] ur = new double[2];
    double[] ll = new double[2];
    double[] tmp = new double[2];
    //these calculations aren't totally accurate, but it should be good enough
    //TODO: Optimize to do in single calculations.  Would need to deal with poles, prime meridian, etc.
    double [] north = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, 0, tmp, options.radius);
    //This returns the point as radians, but we need degrees b/c that is what the field is stored as
    ur[LAT] = north[LAT] * DistanceUtils.RADIANS_TO_DEGREES;//get it now, as we are going to reuse tmp
    double [] east = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_90_AS_RADS, tmp, options.radius);
    ur[LONG] = east[LONG] * DistanceUtils.RADIANS_TO_DEGREES;
    double [] south = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_180_AS_RADS, tmp, options.radius);
    ll[LAT] = south[LAT] * DistanceUtils.RADIANS_TO_DEGREES;
    double [] west = DistanceUtils.pointOnBearing(point[LAT], point[LONG], options.distance, DistanceUtils.DEG_270_AS_RADS, tmp, options.radius);
    ll[LONG] = west[LONG] * DistanceUtils.RADIANS_TO_DEGREES;
    

    SchemaField subSF;
    Query range;
    //TODO: can we reuse our bearing calculations?
    double angDist = DistanceUtils.angularDistance(options.distance,
            options.radius);//in radians

    //for the poles, do something slightly different
    //Also, note point[LAT] is in radians, but ur and ll are in degrees
    if (point[LAT] + angDist > DistanceUtils.DEG_90_AS_RADS) { //we cross the north pole
      //we don't need a longitude boundary at all

      double minLat = Math.min(ll[LAT], ur[LAT]);
      subSF = subField(options.field, LAT);
      range = subSF.getType().getRangeQuery(parser, subSF,
              String.valueOf(minLat),
              "90", true, true);
      result.add(range, BooleanClause.Occur.MUST);
    } else if (point[LAT] - angDist < -DistanceUtils.DEG_90_AS_RADS) {//we cross the south pole
      subSF = subField(options.field, LAT);
      double maxLat = Math.max(ll[LAT], ur[LAT]);
      range = subSF.getType().getRangeQuery(parser, subSF,
              "-90", String.valueOf(maxLat), true, true);
      result.add(range, BooleanClause.Occur.MUST);
    } else{
        //Latitude
        //we may need to generate multiple queries depending on the range
        //Are we crossing the 180 deg. longitude, if so, we need to do some special things
        if (ll[LONG] > 0.0 && ur[LONG] < 0.0) {
          //TODO: refactor into common code, etc.
          //Now check other side of the Equator
          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {
            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);
          } //check poles
          else {
            subSF = subField(options.field, LAT);
            //not crossing the equator
            range = subSF.getType().getRangeQuery(parser, subSF,
                    String.valueOf(ll[LAT]),
                    String.valueOf(ur[LAT]), true, true);
            result.add(range, BooleanClause.Occur.MUST);
          }
          //Longitude
          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], "180.0", "-180.0");

        } else if (ll[LONG] < 0.0 && ur[LONG] > 0.0) {//prime meridian (0 degrees
          //Now check other side of the Equator
          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {
            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);
          } else {
            subSF = subField(options.field, LAT);
            //not crossing the equator
            range = subSF.getType().getRangeQuery(parser, subSF,
                    String.valueOf(ll[LAT]),
                    String.valueOf(ur[LAT]), true, true);
            result.add(range, BooleanClause.Occur.MUST);
          }
          //Longitude
          addMeridianBoundary(parser, options, result, ur[LONG], ll[LONG], "0.0", ".0");

        } else {// we are all in the Eastern or Western hemi
          //Now check other side of the Equator
          if (ll[LAT] < 0.0 && ur[LAT] > 0.0) {
            addEquatorialBoundary(parser, options, result, ur[LAT], ll[LAT]);
          } else {//we are all in either the Northern or the Southern Hemi.
            //TODO: nice to move this up so that it is the first thing and we can avoid the extra checks since
            //this is actually the most likely case
            subSF = subField(options.field, LAT);
            range = subSF.getType().getRangeQuery(parser, subSF,
                    String.valueOf(ll[LAT]),
                    String.valueOf(ur[LAT]), true, true);
            result.add(range, BooleanClause.Occur.MUST);

          }
          //Longitude, all in the same hemi
          subSF = subField(options.field, LONG);
          range = subSF.getType().getRangeQuery(parser, subSF,
                  String.valueOf(ll[LONG]),
                  String.valueOf(ur[LONG]), true, true);
          result.add(range, BooleanClause.Occur.MUST);
        }
      }

      return result;
    }

