  /**
   * Actually run the query
   */
  @Override
  public void process(ResponseBuilder rb) throws IOException
  {
    SolrQueryRequest req = rb.req;
    SolrQueryResponse rsp = rb.rsp;
    SolrParams params = req.getParams();
    if (!params.getBool(COMPONENT_NAME, true)) {
      return;
    }
    SolrIndexSearcher searcher = req.getSearcher();

    if (rb.getQueryCommand().getOffset() < 0) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "'start' parameter cannot be negative");
    }

    // -1 as flag if not set.
    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );

    // Optional: This could also be implemented by the top-level searcher sending
    // a filter that lists the ids... that would be transparent to
    // the request handler, but would be more expensive (and would preserve score
    // too if desired).
    String ids = params.get(ShardParams.IDS);
    if (ids != null) {
      SchemaField idField = req.getSchema().getUniqueKeyField();
      List<String> idArr = StrUtils.splitSmart(ids, ",", true);
      int[] luceneIds = new int[idArr.size()];
      int docs = 0;
      for (int i=0; i<idArr.size(); i++) {
        int id = req.getSearcher().getFirstMatch(
                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));
        if (id >= 0)
          luceneIds[docs++] = id;
      }

      DocListAndSet res = new DocListAndSet();
      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);
      if (rb.isNeedDocSet()) {
        List<Query> queries = new ArrayList<Query>();
        queries.add(rb.getQuery());
        List<Query> filters = rb.getFilters();
        if (filters != null) queries.addAll(filters);
        res.docSet = searcher.getDocSet(queries);
      }
      rb.setResults(res);
      
      ResultContext ctx = new ResultContext();
      ctx.docs = rb.getResults().docList;
      ctx.query = null; // anything?
      rsp.add("response", ctx);
      return;
    }

    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();
    cmd.setTimeAllowed(timeAllowed);
    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();

    //
    // grouping / field collapsing
    //
    boolean doGroup = params.getBool(GroupParams.GROUP, false);
    if (doGroup) {
      try {
        Grouping grouping = new Grouping(searcher, result, cmd);

        String[] fields = params.getParams(GroupParams.GROUP_FIELD);
        String[] funcs = params.getParams(GroupParams.GROUP_FUNC);
        String[] queries = params.getParams(GroupParams.GROUP_QUERY);
        String groupSortStr = params.get(GroupParams.GROUP_SORT);
        boolean main = params.getBool(GroupParams.GROUP_MAIN, false);
        String format = params.get(GroupParams.GROUP_FORMAT);
        Grouping.Format defaultFormat = "simple".equals(format) ? Grouping.Format.Simple : Grouping.Format.Grouped; 

        // groupSort defaults to sort
        Sort groupSort = groupSortStr == null ? cmd.getSort() : QueryParsing.parseSort(groupSortStr, req);

        int limitDefault = cmd.getLen(); // this is normally from "rows"
        int groupOffsetDefault = params.getInt(GroupParams.GROUP_OFFSET, 0);
        int docsPerGroupDefault = params.getInt(GroupParams.GROUP_LIMIT, 1);

        // temporary: implement all group-by-field as group-by-func
        if (funcs == null) {
          funcs = fields;
        } else if (fields != null) {
          // catenate functions and fields
          String[] both = new String[fields.length + funcs.length];
          System.arraycopy(fields, 0, both, 0, fields.length);
          System.arraycopy(funcs, 0, both, fields.length, funcs.length);
          funcs = both;
        }


        if (funcs != null) {
          for (String groupByStr : funcs) {
            QParser parser = QParser.getParser(groupByStr, "func", rb.req);
            Query q = parser.getQuery();
            Grouping.CommandFunc gc = grouping.new CommandFunc();
            gc.groupSort = groupSort;

            if (q instanceof FunctionQuery) {
              gc.groupBy = ((FunctionQuery)q).getValueSource();
            } else {
              gc.groupBy = new QueryValueSource(q, 0.0f);
            }
            gc.key = groupByStr;
            gc.numGroups = limitDefault;
            gc.docsPerGroup = docsPerGroupDefault;
            gc.groupOffset = groupOffsetDefault;
            gc.offset = cmd.getOffset();
            gc.sort = cmd.getSort();
            gc.format = defaultFormat;

            if (main) {
              gc.main = true;
              gc.format = Grouping.Format.Simple;
              main = false;
            }

            if (gc.format == Grouping.Format.Simple) {
              gc.groupOffset = 0;  // doesn't make sense
            }

            grouping.add(gc);
          }
        }

        if (queries != null) {
          for (String groupByStr : queries) {
            QParser parser = QParser.getParser(groupByStr, null, rb.req);
            Query gq = parser.getQuery();
            Grouping.CommandQuery gc = grouping.new CommandQuery();
            gc.query = gq;
            gc.groupSort = groupSort;
            gc.key = groupByStr;
            gc.numGroups = limitDefault;
            gc.docsPerGroup = docsPerGroupDefault;
            gc.groupOffset = groupOffsetDefault;

            // these two params will only be used if this is for the main result set
            gc.offset = cmd.getOffset();
            gc.numGroups = limitDefault;

            gc.format = defaultFormat;            

            if (main) {
              gc.main = true;
              gc.format = Grouping.Format.Simple;
              main = false;
            }
            if (gc.format == Grouping.Format.Simple) {
              gc.docsPerGroup = gc.numGroups;  // doesn't make sense to limit to one
              gc.groupOffset = gc.offset;
            }

            grouping.add(gc);
          }
        }


        if (rb.doHighlights || rb.isDebug()) {
          // we need a single list of the returned docs
          cmd.setFlags(SolrIndexSearcher.GET_DOCLIST);
        }

        // searcher.search(result,cmd);
        grouping.execute();
        rb.setResult( result );
        rsp.add("grouped", result.groupedResults);
        // TODO: get "hits" a different way to log

        if (grouping.mainResult != null) {
          ResultContext ctx = new ResultContext();
          ctx.docs = grouping.mainResult;
          ctx.query = null; // TODO? add the query?
          rsp.add("response", ctx);
          rsp.getToLog().add("hits", grouping.mainResult.matches());
        }

        return;

      } catch (ParseException e) {
        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);
      }
    }

    // normal search result
    searcher.search(result,cmd);
    rb.setResult( result );


    ResultContext ctx = new ResultContext();
    ctx.docs = rb.getResults().docList;
    ctx.query = rb.getQuery();
    rsp.add("response", ctx);
    rsp.getToLog().add("hits", rb.getResults().docList.matches());

    doFieldSortValues(rb, searcher);
    doPrefetch(rb);
  }

