  public static ReturnFields getReturnFields(String fl, SolrQueryRequest req)
  {
    ReturnFields rf = new ReturnFields();
    rf.wantsScore = false;
    rf.fields = new LinkedHashSet<String>(); // order is important for CSVResponseWriter
    boolean allFields = false;

    DocTransformers augmenters = new DocTransformers();
    if (fl != null) {
      // TODO - this could become more efficient if widely used.
      String[] flst = SolrPluginUtils.split(fl);
      if (flst.length > 0 && !(flst.length==1 && flst[0].length()==0)) {
        IndexSchema schema = req.getSchema();
        for (String name : flst) {
          if( "*".equals( name ) ) {
            allFields = true;
          }
          else if( SCORE.equals( name ) ) {
            rf.fields.add( name );
            rf.wantsScore = true;
            augmenters.addTransformer( new ScoreAugmenter( SCORE ) );
          }
          else {
            rf.fields.add( name );

            // Check if it is a real score
            SchemaField sf = schema.getFieldOrNull( name );
            if( sf == null ) {
              // not a field name, but possibly return value
              if( DOCID.equals( name ) ) {
                augmenters.addTransformer( new DocIdAugmenter( DOCID ) );
              }
              else if( SHARD.equals( name ) ) {
                String id = "getshardid???";
                augmenters.addTransformer( new ValueAugmenter( SHARD, id ) );
              }
              else if( EXPLAIN.equals( name ) ) {
                augmenters.addTransformer( new ExplainAugmenter( EXPLAIN ) );
              }
              else if( name.startsWith( "{!func}") ) {
                // help?  not sure how to parse a ValueSorce
                // -- not to mention, we probably want to reuse existing ones!
                augmenters.addTransformer( new ValueAugmenter( name, "TODO:"+name ) );
//                try {
//                  String func = name.substring( "{!func}".length() );
//                  SolrParams local = null;
//                  FunctionQParser p = new FunctionQParser( func, local, req.getParams(), req );
//                  Query q = p.parse();
//                  ValueSource vs = p.parseValueSource();
//                  AtomicReaderContext ctx = new AtomicReaderContext( req.getSearcher().getIndexReader() );
//                  Map mmm = null; // ?????
//                  DocValues values = p.parseValueSource().getValues( mmm, ctx );
//                  augmenters.addAugmenter( new DocValuesAugmenter( name, values ) );
//                }
//                catch( Exception ex ) {
//                  throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,
//                      "Unable to parse augmented field: "+name, ex );
//                }
              }
              else { 
                // maybe throw an exception?
//                throw new SolrException( org.apache.solr.common.SolrException.ErrorCode.BAD_REQUEST,
//                    "Unknown Return Field: "+name );
              }
            }
          }
        }
      }
    }
    
    // Legacy behavior? "score" == "*,score"
    if( rf.fields.size() == 1 && rf.wantsScore ) {
      allFields = true;
    }
    
    if( allFields || rf.fields.isEmpty() ) {
      rf.fields = null;
    }
    
    if( augmenters.size() == 1 ) {
      rf.transformer = augmenters.getTransformer(0);
    }
    else if( augmenters.size() > 1 ) {
      rf.transformer = augmenters;
    }
    return rf;
  }

