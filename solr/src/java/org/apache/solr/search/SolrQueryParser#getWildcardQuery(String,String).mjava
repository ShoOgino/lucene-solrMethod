  protected Query getWildcardQuery(String field, String termStr) throws ParseException {
    // *:* -> MatchAllDocsQuery
    if ("*".equals(field) && "*".equals(termStr)) {
      return newMatchAllDocsQuery();
    }
    
    // can we use reversed wildcards in this field?
    String type = schema.getFieldType(field).getTypeName();
    ReversedWildcardFilterFactory factory = leadingWildcards.get(type);
    if (factory != null) {
      if (factory.shouldReverse(termStr)) {
        int len = termStr.length();
        char[] chars = new char[len+1];
        chars[0] = factory.getMarkerChar();      
        termStr.getChars(0, len, chars, 1);
        ReversedWildcardFilter.reverse(chars, 1, len);
        termStr = new String(chars);
      } else { 
        // reverse wildcardfilter is active: remove false positives
        Term term = new Term(field, termStr);
        // fsa representing the query
        Automaton a = WildcardQuery.toAutomaton(term);
        // fsa representing false positives (markerChar*)
        Automaton falsePositives = BasicOperations.concatenate(
            BasicAutomata.makeChar(factory.getMarkerChar()), 
            BasicAutomata.makeAnyString());
        return new AutomatonQuery(term, BasicOperations.minus(a, falsePositives)) {
          // override toString so its completely transparent
          @Override
          public String toString(String field) {
            StringBuilder buffer = new StringBuilder();
            if (!getField().equals(field)) {
              buffer.append(getField());
              buffer.append(":");
            }
            buffer.append(term.text());
            buffer.append(ToStringUtils.boost(getBoost()));
            return buffer.toString();
          }
        };
      }
    }
    Query q = super.getWildcardQuery(field, termStr);
    if (q instanceof WildcardQuery) {
      // use a constant score query to avoid overflowing clauses
      WildcardQuery wildcardQuery = new WildcardQuery(((WildcardQuery)q).getTerm());
      return  wildcardQuery; 
    }
    return q;
  }

