  /**
   * Returns the set of document ids matching all queries.
   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
   * If the answer was not cached, it may have been inserted into the cache as a result of this call.
   * This method can handle negative queries.
   * <p>
   * The DocSet returned should <b>not</b> be modified.
   */
  public DocSet getDocSet(List<Query> queries) throws IOException {
    if (queries==null) return null;
    if (queries.size()==1) return getDocSet(queries.get(0));
    DocSet answer=null;

    boolean[] neg = new boolean[queries.size()];
    DocSet[] sets = new DocSet[queries.size()];

    int smallestIndex = -1;
    int smallestCount = Integer.MAX_VALUE;
    for (int i=0; i<sets.length; i++) {
      Query q = queries.get(i);
      Query posQuery = QueryUtils.getAbs(q);
      sets[i] = getPositiveDocSet(posQuery);
      // Negative query if absolute value different from original
      if (q==posQuery) {
        neg[i] = false;
        // keep track of the smallest positive set.
        // This optimization is only worth it if size() is cached, which it would
        // be if we don't do any set operations.
        int sz = sets[i].size();
        if (sz<smallestCount) {
          smallestCount=sz;
          smallestIndex=i;
          answer = sets[i];
        }
      } else {
        neg[i] = true;
      }
    }

    // if no positive queries, start off with all docs
    if (answer==null) answer = getPositiveDocSet(matchAllDocsQuery);

    // do negative queries first to shrink set size
    for (int i=0; i<sets.length; i++) {
      if (neg[i]) answer = answer.andNot(sets[i]);
    }

    for (int i=0; i<sets.length; i++) {
      if (!neg[i] && i!=smallestIndex) answer = answer.intersection(sets[i]);
    }

    return answer;
  }

