  /**
   * Returns null if the sortSpec is the standard sort desc.
   * <p/>
   * <p>
   * The form of the sort specification string currently parsed is:
   * </p>
   * <pre>>
   * SortSpec ::= SingleSort [, SingleSort]*
   * SingleSort ::= <fieldname> SortDirection
   * SortDirection ::= top | desc | bottom | asc
   * </pre>
   * Examples:
   * <pre>
   *   score desc               #normal sort by score (will return null)
   *   weight bottom            #sort by weight ascending
   *   weight desc              #sort by weight descending
   *   height desc,weight desc  #sort by height descending, and use weight descending to break any ties
   *   height desc,weight asc   #sort by height descending, using weight ascending as a tiebreaker
   * </pre>
   */
  public static Sort parseSort(String sortSpec, IndexSchema schema) {
    if (sortSpec == null || sortSpec.length() == 0) return null;
    char[] chars = sortSpec.toCharArray();
    int i = 0;
    StringBuilder buffer = new StringBuilder(sortSpec.length());
    String sort = null;
    String order = null;
    int functionDepth = 0;
    boolean score = true;
    List<SortField> lst = new ArrayList<SortField>(5);
    boolean needOrder = false;
    while (i < chars.length) {
      if (Character.isWhitespace(chars[i]) && functionDepth == 0) {
        if (buffer.length() == 0) {
          //do nothing
        } else {
          if (needOrder == false) {
            sort = buffer.toString().trim();
            buffer.setLength(0);
            needOrder = true;
          } else {
            order = buffer.toString().trim();
            buffer.setLength(0);
            needOrder = false;
          }
        }
      } else if (chars[i] == '(' && functionDepth >= 0) {
        buffer.append(chars[i]);
        functionDepth++;
      } else if (chars[i] == ')' && functionDepth > 0) {
        buffer.append(chars[i]);
        functionDepth--;//close up one layer
      } else if (chars[i] == ',' && functionDepth == 0) {//can either be a separator of sort declarations, or a separator in a function
        //we have a separator between sort declarations,
        // We may need an order still, but then evaluate it, as we should have everything we need
        if (needOrder == true && buffer.length() > 0){
          order = buffer.toString().trim();
          buffer.setLength(0);
          needOrder = false;
        }
        score = processSort(schema, sort, order, lst);
        sort = null;
        order = null;
        buffer.setLength(0);//get ready for the next one, if there is one
      } else if (chars[i] == ',' && functionDepth > 0) {
        //we are in a function
        buffer.append(chars[i]);
      } else {
        //just a regular old char, add it to the buffer
        buffer.append(chars[i]);
      }
      i++;
    }
    if (buffer.length() > 0 && needOrder){//see if we have anything left, at most it should be an order
      order = buffer.toString().trim();
      buffer.setLength(0);
      needOrder = false;
    }

    //do some sanity checks
    if (functionDepth != 0){
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unable to parse sort spec, mismatched parentheses: " + sortSpec);
    }
    if (buffer.length() > 0){//there's something wrong, as everything should have been parsed by now
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Unable to parse sort spec: " + sortSpec);
    }
    if (needOrder == false && sort != null && sort.equals("") == false && order != null && order.equals("") == false){//handle the last declaration
      score = processSort(schema, sort, order, lst);
    }
    //If the normal case (by score desc) do nothing
    if (lst.size() == 1 && score == true && lst.get(0).getReverse() == false) {
      return null; // do normal scoring...
    }
    return new Sort((SortField[]) lst.toArray(new SortField[lst.size()]));
  }

