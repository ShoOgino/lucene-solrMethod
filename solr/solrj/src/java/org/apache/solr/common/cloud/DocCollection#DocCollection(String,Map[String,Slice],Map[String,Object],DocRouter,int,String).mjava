  /**
   * @param name  The name of the collection
   * @param slices The logical shards of the collection.  This is used directly and a copy is not made.
   * @param props  The properties of the slice.  This is used directly and a copy is not made.
   */
  public DocCollection(String name, Map<String, Slice> slices, Map<String, Object> props, DocRouter router, int zkVersion, String znode) {
    super(props==null ? props = new HashMap<String,Object>() : props);
    this.znodeVersion = zkVersion;
    this.name = name;

    this.slices = slices;
    this.activeSlices = new HashMap<>();
    Object replicationFactorObject = (Object) props.get(ZkStateReader.REPLICATION_FACTOR);
    if (replicationFactorObject != null) {
      this.replicationFactor = Integer.parseInt(replicationFactorObject.toString());
    } else {
      this.replicationFactor = null;
    }
    Object maxShardsPerNodeObject = (Object) props.get(ZkStateReader.MAX_SHARDS_PER_NODE);
    if (maxShardsPerNodeObject != null) {
      this.maxShardsPerNode = Integer.parseInt(maxShardsPerNodeObject.toString());
    } else {
      this.maxShardsPerNode = null;
    }
    Object autoAddReplicasObject = (Object) props.get(ZkStateReader.AUTO_ADD_REPLICAS);
    if (autoAddReplicasObject != null) {
      this.autoAddReplicas = Boolean.parseBoolean(autoAddReplicasObject.toString());
    } else {
      this.autoAddReplicas = false;
    }

    Iterator<Map.Entry<String, Slice>> iter = slices.entrySet().iterator();

    while (iter.hasNext()) {
      Map.Entry<String, Slice> slice = iter.next();
      if (slice.getValue().getState() == Slice.State.ACTIVE)
        this.activeSlices.put(slice.getKey(), slice.getValue());
    }
    this.router = router;
    this.znode = znode == null? ZkStateReader.CLUSTER_STATE : znode;
    assert name != null && slices != null;
  }

