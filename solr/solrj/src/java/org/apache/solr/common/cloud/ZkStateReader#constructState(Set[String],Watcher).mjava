  private ClusterState constructState(Set<String> ln, Watcher watcher)
      throws KeeperException, InterruptedException {
    Stat stat = new Stat();
    byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);
    ClusterState loadedData = ClusterState.load(stat.getVersion(), data, ln,
        CLUSTER_STATE);
    Map<String,ClusterState.CollectionRef> result = new LinkedHashMap<>();
    result.putAll(loadedData.getCollectionStates());// first load all
                                                    // collections in
                                                    // clusterstate.json
    for (String s : getIndividualColls()) {
      synchronized (this) {
        if (watchedCollections.contains(s)) {
          DocCollection live = getCollectionLive(this, s);
          if (live != null) {
            watchedCollectionStates.put(s, live);
            // if it is a watched collection, add too
            result.put(s, new ClusterState.CollectionRef(live));
          }
        } else {
          // if it is not collection, then just create a reference which can fetch
          // the collection object just in time from ZK
          // this is also cheap (lazy loaded) so we put it inside the synchronized
          // block although it is not required
          final String collName = s;
          result.put(s, new ClusterState.CollectionRef(null) {
            @Override
            public DocCollection get() {
              return getCollectionLive(ZkStateReader.this, collName);
            }

            @Override
            public boolean isLazilyLoaded() { return true; }
          });
        }
      }
    }
    return new ClusterState(ln, result, stat.getVersion());
  }

