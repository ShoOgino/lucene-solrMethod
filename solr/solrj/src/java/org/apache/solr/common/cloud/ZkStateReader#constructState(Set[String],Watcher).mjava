  private ClusterState constructState(Set<String> ln, Watcher watcher) throws KeeperException, InterruptedException {
    Stat stat = new Stat();
    byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);
    ClusterState loadedData = ClusterState.load(stat.getVersion(), data, ln, CLUSTER_STATE);

    // first load all collections in /clusterstate.json (i.e. stateFormat=1)
    Map<String, ClusterState.CollectionRef> result = new LinkedHashMap<>(loadedData.getCollectionStates());

    for (String s : getStateFormat2CollectionNames()) {
      synchronized (this) {
        if (watchedCollections.contains(s)) {
          DocCollection live = getCollectionLive(this, s);
          if (live != null) {
            updateWatchedCollection(live);
            // if it is a watched collection, add too
            result.put(s, new ClusterState.CollectionRef(live));
          }
        } else {
          // if it is not collection, then just create a reference which can fetch
          // the collection object just in time from ZK
          // this is also cheap (lazy loaded) so we put it inside the synchronized
          // block although it is not required
          final String collName = s;
          result.put(s, new ClusterState.CollectionRef(null) {
            @Override
            public DocCollection get() {
              return getCollectionLive(ZkStateReader.this, collName);
            }

            @Override
            public boolean isLazilyLoaded() {
              return true;
            }
          });
        }
      }
    }
    return new ClusterState(ln, result, stat.getVersion());
  }

