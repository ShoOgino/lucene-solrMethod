  @SuppressWarnings("rawtypes")
  private static List<FieldWriter> getReflectData(Class c) throws IllegalAccessException {
    boolean sameClassLoader = c.getClassLoader() == Utils.class.getClassLoader();
    //we should not cache the class references of objects loaded from packages because they will not get garbage collected
    //TODO fix that later
    List<FieldWriter> reflectData = sameClassLoader ? storedReflectData.get(c): null;
    if(reflectData == null) {
      ArrayList<FieldWriter> l = new ArrayList<>();
      MethodHandles.Lookup lookup = MethodHandles.publicLookup();
      for (Field field : lookup.accessClass(c).getFields()) {
        JsonProperty prop = field.getAnnotation(JsonProperty.class);
        if (prop == null) continue;
        int modifiers = field.getModifiers();
        if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers)) {
          String fname = prop.value().isEmpty() ? field.getName() : prop.value();
          final VarHandle vhandle = lookup.unreflectVarHandle(field);
          if (field.getType() == int.class) {
            l.add((ew, inst) -> ew.put(fname, (int) vhandle.get(inst)));
          } else if (field.getType() == long.class) {
            l.add((ew, inst) -> ew.put(fname, (long) vhandle.get(inst)));
          } else if (field.getType() == boolean.class) {
            l.add((ew, inst) -> ew.put(fname, (boolean) vhandle.get(inst)));
          } else if (field.getType() == double.class) {
            l.add((ew, inst) -> ew.put(fname, (double) vhandle.get(inst)));
          } else if (field.getType() == float.class) {
            l.add((ew, inst) -> ew.put(fname, (float) vhandle.get(inst)));
          } else {
            l.add((ew, inst) -> ew.put(fname, vhandle.get(inst)));
          }
        }}

      if(sameClassLoader){
        storedReflectData.put(c, reflectData = Collections.unmodifiableList(new ArrayList<>(l)));
      }
    }
    return reflectData;
  }

