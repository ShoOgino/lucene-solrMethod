  /**
   * Refresh legacy (shared) clusterstate.json
   */
  private void refreshLegacyClusterState(Watcher watcher) throws KeeperException, InterruptedException {
    try {
      final Stat stat = new Stat();
      final byte[] data = zkClient.getData(CLUSTER_STATE, watcher, stat, true);
      final ClusterState loadedData = ClusterState.load(stat.getVersion(), data, emptySet(), CLUSTER_STATE);
      synchronized (getUpdateLock()) {
        if (this.legacyClusterStateVersion >= stat.getVersion()) {
          // Nothing to do, someone else updated same or newer.
          return;
        }
        Set<String> liveNodes = this.liveNodes; // volatile read
        for (Map.Entry<String, CollectionWatch> watchEntry : this.collectionWatches.entrySet()) {
          String coll = watchEntry.getKey();
          CollectionWatch collWatch = watchEntry.getValue();
          ClusterState.CollectionRef ref = this.legacyCollectionStates.get(coll);
          if (ref == null)
            continue;
          // legacy collections are always in-memory
          DocCollection oldState = ref.get();
          DocCollection newState = loadedData.getCollectionStates().get(coll).get();
          if (!collWatch.stateWatchers.isEmpty()
              && !Objects.equals(oldState, newState)) {
            notifyStateWatchers(liveNodes, coll, newState);
          }
        }
        this.legacyCollectionStates = loadedData.getCollectionStates();
        this.legacyClusterStateVersion = stat.getVersion();
      }
    } catch (KeeperException.NoNodeException e) {
      // Ignore missing legacy clusterstate.json.
      synchronized (getUpdateLock()) {
        this.legacyCollectionStates = emptyMap();
        this.legacyClusterStateVersion = 0;
      }
    }
  }

