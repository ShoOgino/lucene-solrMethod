    /**
     * Refresh collection properties from ZK and leave a watch for future changes. Updates the properties in
     * watchedCollectionProps with the results of the refresh. Optionally notifies watchers
     */
    void refreshAndWatch(boolean notifyWatchers) {
      try {
        synchronized (coll) { // We only have one PropsWatcher instance per collection, so it's fine to sync on coll
          Map<String, String> properties = fetchCollectionProperties(coll, this);
          watchedCollectionProps.put(coll, properties);
          /*
           * Note that if two events were fired close to each other and the second one arrived first, we would read the collectionprops.json
           * twice for the same data and notify watchers (in case of notifyWatchers==true) twice for the same data, however it's guaranteed
           * that after processing both events, watchedCollectionProps will have the latest data written to ZooKeeper and that the watchers
           * won't be called with out of order data
           * 
           */
          if (notifyWatchers) {
            notifyPropsWatchers(coll, properties);
          }
        }
      } catch (KeeperException.SessionExpiredException | KeeperException.ConnectionLossException e) {
        log.warn("ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]", e.getMessage());
      } catch (KeeperException e) {
        log.error("Lost collection property watcher for {} due to ZK error", coll, e);
        throw new ZooKeeperException(ErrorCode.SERVER_ERROR, "A ZK error has occurred", e);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.error("Lost collection property watcher for {} due to the thread being interrupted", coll, e);
      }
    }

