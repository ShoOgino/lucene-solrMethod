  /**
   * @param name      name of the condition
   * @param val       value of the condition
   * @param isRuleVal is this provided in the rule
   * @return actual validated value
   */
  public static Object validate(String name, Object val, boolean isRuleVal) {
    if (val == null) return null;
    ValidateInfo info = validatetypes.get(name);
    if (info == null && name.startsWith(ImplicitSnitch.SYSPROP)) info = validatetypes.get("STRING");
    if (info == null) throw new RuntimeException("Unknown type :" + name);
    if (info.type == Double.class) {
      Double num = parseDouble(name, val);
      if (isRuleVal) {
        if (info.min != null)
          if (Double.compare(num, (Double) info.min) == -1)
            throw new RuntimeException(name + ": " + val + " must be greater than " + info.min);
        if (info.max != null)
          if (Double.compare(num, (Double) info.max) == 1)
            throw new RuntimeException(name + ": " + val + " must be less than " + info.max);
      }
      return num;
    } else if (info.type == Long.class) {
      Long num = parseLong(name, val);
      if (isRuleVal) {
        if (info.min != null)
          if (num < info.min.longValue())
            throw new RuntimeException(name + ": " + val + " must be greater than " + info.min);
        if (info.max != null)
          if (num > info.max.longValue())
            throw new RuntimeException(name + ": " + val + " must be less than " + info.max);
      }
      return num;
    } else if (info.type == String.class) {
      if (isRuleVal && info.vals != null && !info.vals.contains(val))
        throw new RuntimeException(name + ": " + val + " must be one of " + StrUtils.join(info.vals, ','));
      return val;
    } else {
      throw new RuntimeException("Invalid type ");
    }
  }

