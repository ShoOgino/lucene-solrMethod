    /**
     * Given a session (this one), creates a new one for placement simulations that retains all the relevant information,
     * whether or not that info already made it to Zookeeper.
     */
    public Session cloneToNewSession(SolrCloudManager cloudManager) {
      NodeStateProvider nodeStateProvider = cloudManager.getNodeStateProvider();
      ClusterStateProvider clusterStateProvider = cloudManager.getClusterStateProvider();

      List<String> nodes = new ArrayList<>(clusterStateProvider.getLiveNodes());

      // Copy all collections from old session, even those not yet in ZK state
      Set<String> collections = new HashSet<>(this.collections);

      // (shallow) copy the expanded clauses
      List<Clause> expandedClauses = new ArrayList<>(this.expandedClauses);

      List<Row> matrix = new ArrayList<>(nodes.size());
      Map<String, Row> copyNodes = new HashMap<>();
      for (Row oldRow: this.matrix) {
        copyNodes.put(oldRow.node, oldRow.copy());
      }
      for (String node : nodes) {
        // Do we have a row for that node in this session? If yes, reuse without trying to fetch from cluster state (latest changes might not be there)
        Row newRow = copyNodes.get(node);
        if (newRow == null) {
          // Dealing with a node that doesn't exist in this Session. Need to create related data from scratch.
          // We pass null for the Session in purpose. The current (this) session in not the correct one for this Row.
          // The correct session will be set when we build the new Session instance at the end of this method.
          newRow = new Row(node, this.policy.getParams(), this.policy.getPerReplicaAttributes(), null, nodeStateProvider, cloudManager);
          // Get info for collections on that node
          Set<String> collectionsOnNewNode = nodeStateProvider.getReplicaInfo(node, Collections.emptyList()).keySet();
          collections.addAll(collectionsOnNewNode);

          // Adjust policies to take into account new collections
          for (String collection : collectionsOnNewNode) {
            // We pass this.policy but it is not modified so will not impact this session being cloned
            addClausesForCollection(this.policy, expandedClauses, clusterStateProvider, collection);
          }
        }
        matrix.add(newRow);
      }

      if (nodes.size() > 0) {
        //if any collection has 'withCollection' irrespective of the node, the NodeStateProvider returns a map value
        Map<String, Object> vals = nodeStateProvider.getNodeValues(nodes.get(0), Collections.singleton("withCollection"));
        if (!vals.isEmpty() && vals.get("withCollection") != null) {
          @SuppressWarnings({"unchecked"})
          Map<String, String> withCollMap = (Map<String, String>) vals.get("withCollection");
          if (!withCollMap.isEmpty()) {
            @SuppressWarnings({"unchecked"})
            Clause withCollClause = new Clause((Map<String,Object>)Utils.fromJSONString("{withCollection:'*' , node: '#ANY'}") ,
                new Condition(NODE.tagName, "#ANY", Operand.EQUAL, null, null),
                new Condition(WITH_COLLECTION.tagName,"*" , Operand.EQUAL, null, null), true, null, false
            );
            expandedClauses.add(withCollClause);
          }
        }
      }

      Collections.sort(expandedClauses);

      Session newSession = new Session(nodes, cloudManager, matrix, collections, expandedClauses,
          nodeStateProvider, this.policy, this.transaction);
      newSession.applyRules();

      return newSession;
    }

