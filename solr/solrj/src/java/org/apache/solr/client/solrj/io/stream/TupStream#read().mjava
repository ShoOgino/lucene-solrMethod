  public Tuple read() throws IOException {

    if(finished) {
      Map<String,Object> m = new HashMap<>();
      m.put("EOF", true);
      return new Tuple(m);
    } else {
      finished = true;
      Map<String, Object> values = new HashMap<>();
      
      // add all string based params
      // these could come from the context, or they will just be treated as straight strings
      for(Entry<String,String> param : stringParams.entrySet()){
        if(streamContext.getLets().containsKey(param.getValue())){
          values.put(param.getKey(), streamContext.getLets().get(param.getValue()));
        }
        else{
          values.put(param.getKey(), param.getValue());
        }
      }
      
      // add all evaluators
      for(Entry<String,StreamEvaluator> param : evaluatorParams.entrySet()){
        values.put(param.getKey(), param.getValue().evaluateOverContext());
      }
      
      // Add all streams
      for(Entry<String,TupleStream> param : streamParams.entrySet()){
        
        try{
          List<Tuple> streamTuples = new ArrayList();
          // open the stream, closed in finally block
          param.getValue().open();
          
          // read all values from stream (memory expensive)
          Tuple streamTuple = param.getValue().read();
          while(!streamTuple.EOF){
            streamTuples.add(streamTuple);
            streamTuple = param.getValue().read();
          }
          
          values.put(param.getKey(), streamTuples);
        }
        finally{
          // safely close the stream
          param.getValue().close();
        }        
      }

      Tuple tup = new Tuple(values);
      tup.fieldNames = fieldNames;
      tup.fieldLabels = fieldLabels;
      return tup;
    }
  }

