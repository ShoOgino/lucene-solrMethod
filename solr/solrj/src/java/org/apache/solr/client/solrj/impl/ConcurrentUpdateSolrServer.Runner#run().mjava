    public void run() {
      runnerLock.lock();

      // info is ok since this should only happen once for each thread
      log.info("starting runner: {}", this);
      HttpPost method = null;
      HttpResponse response = null;
      try {
        while (!queue.isEmpty()) {
          try {
            final UpdateRequest updateRequest = queue.poll(250,
                TimeUnit.MILLISECONDS);
            if (updateRequest == null)
              break;

            final boolean isXml = ClientUtils.TEXT_XML.equals(server.requestWriter
                .getUpdateContentType());

            final ModifiableSolrParams origParams = new ModifiableSolrParams(updateRequest.getParams());

            EntityTemplate template = new EntityTemplate(new ContentProducer() {

              public void writeTo(OutputStream out) throws IOException {
                try {
                  if (isXml) {
                    out.write("<stream>".getBytes("UTF-8")); // can be anything
                  }
                  UpdateRequest req = updateRequest;
                  while (req != null) {
                    SolrParams currentParams = new ModifiableSolrParams(req.getParams());
                    if (!origParams.toNamedList().equals(currentParams.toNamedList())) {
                      queue.add(req); // params are different, push back to queue
                      break;
                    }
                    
                    server.requestWriter.write(req, out);
                    if (isXml) {
                      // check for commit or optimize
                      SolrParams params = req.getParams();
                      if (params != null) {
                        String fmt = null;
                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {
                          fmt = "<optimize waitSearcher=\"%s\" waitFlush=\"%s\" />";
                        } else if (params.getBool(UpdateParams.COMMIT, false)) {
                          fmt = "<commit waitSearcher=\"%s\" waitFlush=\"%s\" />";
                        }
                        if (fmt != null) {
                          byte[] content = String.format(
                              fmt,
                              params.getBool(UpdateParams.WAIT_SEARCHER, false)
                                  + "").getBytes("UTF-8");
                          out.write(content);
                        }
                      }
                    }
                    out.flush();
                    req = queue.poll(250, TimeUnit.MILLISECONDS);
                  }
                  if (isXml) {
                    out.write("</stream>".getBytes("UTF-8"));
                  }

                } catch (InterruptedException e) {
                  e.printStackTrace();
                }
              }
            });
            
            // The parser 'wt=' and 'version=' params are used instead of the
            // original params
            ModifiableSolrParams requestParams = new ModifiableSolrParams(origParams);
            requestParams.set(CommonParams.WT, server.parser.getWriterType());
            requestParams.set(CommonParams.VERSION, server.parser.getVersion());

            final String path = isXml ? "/update" : "/update/javabin";

            method = new HttpPost(server.getBaseURL() + path
                + ClientUtils.toQueryString(requestParams, false));
            method.setEntity(template);
            method.addHeader("User-Agent", HttpSolrServer.AGENT);
            response = server.getHttpClient().execute(method);
            int statusCode = response.getStatusLine().getStatusCode();
            log.info("Status for: "
                + updateRequest.getDocuments().get(0).getFieldValue("id")
                + " is " + statusCode);
            if (statusCode != HttpStatus.SC_OK) {
              StringBuilder msg = new StringBuilder();
              msg.append(response.getStatusLine().getReasonPhrase());
              msg.append("\n\n");
              msg.append("\n\n");
              msg.append("request: ").append(method.getURI());
              handleError(new Exception(msg.toString()));
            }
          } finally {
            try {
              if (response != null) {
                response.getEntity().getContent().close();
              }
            } catch (Exception ex) {
            }
          }
        }
      } catch (Throwable e) {
        handleError(e);
      } finally {

        // remove it from the list of running things unless we are the last
        // runner and the queue is full...
        // in which case, the next queue.put() would block and there would be no
        // runners to handle it.
        // This case has been further handled by using offer instead of put, and
        // using a retry loop
        // to avoid blocking forever (see request()).
        synchronized (runners) {
          if (runners.size() == 1 && queue.remainingCapacity() == 0) {
            // keep this runner alive
            scheduler.execute(this);
          } else {
            runners.remove(this);
          }
        }

        log.info("finished: {}", this);
        runnerLock.unlock();
      }
    }

