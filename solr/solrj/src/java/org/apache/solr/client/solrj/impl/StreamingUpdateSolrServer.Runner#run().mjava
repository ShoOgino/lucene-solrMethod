    public void run() {
      runnerLock.lock();

      // info is ok since this should only happen once for each thread
      log.info( "starting runner: {}" , this );
      PostMethod method = null;
      try {
        while (!queue.isEmpty())  {
          try {
            final UpdateRequest updateRequest = queue.poll(250, TimeUnit.MILLISECONDS);
            if (updateRequest == null) break;
            RequestEntity request = new RequestEntity() {
              // we don't know the length
              public long getContentLength() { return -1; }
              public String getContentType() { return requestWriter.getUpdateContentType(); }
              public boolean isRepeatable()  { return false; }

              public void writeRequest(OutputStream out) throws IOException {
                try {
                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {
                    out.write("<stream>".getBytes("UTF-8")); // can be anything
                  }
                  UpdateRequest req = updateRequest;
                  while (req != null) {
                    requestWriter.write(req, out);
                    if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {
                      // check for commit or optimize
                      SolrParams params = req.getParams();
                      if (params != null) {
                        String fmt = null;
                        if (params.getBool(UpdateParams.OPTIMIZE, false)) {
                          fmt = "<optimize waitSearcher=\"%s\" waitFlush=\"%s\" />";
                        } else if (params.getBool(UpdateParams.COMMIT, false)) {
                          fmt = "<commit waitSearcher=\"%s\" waitFlush=\"%s\" />";
                        }
                        if (fmt != null) {
                          byte[] content = String.format(fmt,
                              params.getBool(UpdateParams.WAIT_SEARCHER, false) + "").getBytes("UTF-8");
                          out.write(content);
                        }
                      }
                    }
                    out.flush();
                    req = queue.poll(250, TimeUnit.MILLISECONDS);
                  }
                  if (ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType())) {
                    out.write("</stream>".getBytes("UTF-8"));
                  }
                  out.flush();
                } catch (InterruptedException e) {
                  e.printStackTrace();
                }
              }
            };

            String path = ClientUtils.TEXT_XML.equals(requestWriter.getUpdateContentType()) ? "/update" : "/update/javabin";

            method = new PostMethod(_baseURL+path );
            method.setRequestEntity( request );
            method.setFollowRedirects( false );
            method.addRequestHeader( "User-Agent", AGENT );
            
            int statusCode = getHttpClient().executeMethod(method);
            log.info("Status for: " + updateRequest.getDocuments().get(0).getFieldValue("id") + " is " + statusCode);
            if (statusCode != HttpStatus.SC_OK) {
              StringBuilder msg = new StringBuilder();
              msg.append( method.getStatusLine().getReasonPhrase() );
              msg.append( "\n\n" );
              msg.append( method.getStatusText() );
              msg.append( "\n\n" );
              msg.append("request: ").append(method.getURI());
              handleError( new Exception( msg.toString() ) );
            }
          } finally {
            try {
              // make sure to release the connection
              if(method != null)
                method.releaseConnection();
            }
            catch( Exception ex ){}
          }
        }
      }
      catch (Throwable e) {
        handleError( e );
      }
      finally {

        // remove it from the list of running things unless we are the last runner and the queue is full...
        // in which case, the next queue.put() would block and there would be no runners to handle it.
        // This case has been further handled by using offer instead of put, and using a retry loop
        // to avoid blocking forever (see request()).
        synchronized (runners) {
          if (runners.size() == 1 && queue.remainingCapacity() == 0) {
           // keep this runner alive
           scheduler.execute(this);
          } else {
            runners.remove( this );
          }
        }

        log.info( "finished: {}" , this );
        runnerLock.unlock();
      }
    }

