  protected Object normalizeOutputType(Object value) {
    if(null == value){
      return null;
    } else if (value instanceof VectorFunction) {
      return value;
    } else if(value instanceof BigDecimal){
      BigDecimal bd = (BigDecimal)value;
      if(bd.signum() == 0 || bd.scale() <= 0 || bd.stripTrailingZeros().scale() <= 0){
        try{
          return bd.longValueExact();
        }
        catch(ArithmeticException e){
          // value was too big for a long, so use a double which can handle scientific notation
        }
      }
      
      return bd.doubleValue();
    }
    else if(value instanceof Double){
      if(Double.isNaN((Double)value)){
        return value;
      }
      
      // could be a long so recurse back in as a BigDecimal
      return normalizeOutputType(new BigDecimal((Double)value));
    }
    else if(value instanceof Number){
      return normalizeOutputType(new BigDecimal(((Number)value).toString()));
    }
    else if(value instanceof List){
      // normalize each value in the list
      return ((List<?>)value).stream().map(innerValue -> normalizeOutputType(innerValue)).collect(Collectors.toList());
    } else if(value instanceof Tuple && value.getClass().getEnclosingClass() == null) {
      //If its a tuple and not a inner class that has extended tuple, which is done in a number of cases so that mathematical models
      //can be contained within a tuple.

      Tuple tuple = (Tuple)value;
      Map map = new HashMap();
      for(Object o : tuple.fields.keySet()) {
        Object v = tuple.fields.get(o);
        map.put(o, normalizeOutputType(v));
      }
      return new Tuple(map);
    }
    else{
      // anything else can just be returned as is
      return value;
    }

  }

