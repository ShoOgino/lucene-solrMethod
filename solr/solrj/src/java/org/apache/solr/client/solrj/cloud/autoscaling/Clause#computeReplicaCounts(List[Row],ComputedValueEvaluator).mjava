  private Map<String, Map<String, Map<String, ReplicaCount>>> computeReplicaCounts(List<Row> allRows,
                                                                                   ComputedValueEvaluator computedValueEvaluator) {
    Map<String, Map<String, Map<String, ReplicaCount>>> collVsShardVsTagVsCount = new HashMap<>();
    for (Row row : allRows) {
      computedValueEvaluator.node = row.node;
      for (Map.Entry<String, Map<String, List<ReplicaInfo>>> colls : row.collectionVsShardVsReplicas.entrySet()) {
        String collectionName = colls.getKey();
        if (!collection.isPass(collectionName)) continue;
        Map<String, Map<String, ReplicaCount>> collMap = collVsShardVsTagVsCount.computeIfAbsent(collectionName, s -> new HashMap<>());
        for (Map.Entry<String, List<ReplicaInfo>> shards : colls.getValue().entrySet()) {
          String shardName = shards.getKey();
          if (ANY.equals(shard.val)) shardName = ANY;
          if (!shard.isPass(shardName)) break;
          Map<String, ReplicaCount> tagVsCount = collMap.computeIfAbsent(shardName, s -> new HashMap<>());
          Object tagVal = row.getVal(tag.name);
          computedValueEvaluator.collName = collectionName;
          computedValueEvaluator.shardName = shardName;
          SealedClause sealedClause = getSealedClause(computedValueEvaluator);
          Condition t = sealedClause.getTag();
          if (t.varType.meta.isNodeSpecificVal()) {
            boolean pass = t.getOperand().match(t.val, tagVal) == TestStatus.PASS;
            tagVsCount.computeIfAbsent(row.node, s -> new ReplicaCount());
            if(pass) {
              tagVsCount.get(row.node).increment(shards.getValue());
            }
          } else {
            boolean pass = sealedClause.getTag().isPass(tagVal);
            tagVsCount.computeIfAbsent(pass ? String.valueOf(tagVal) : "", s -> new ReplicaCount());
            if (pass) {
              tagVsCount.get(String.valueOf(tagVal)).increment(shards.getValue());
            }
          }
        }
      }
    }

    if (this.getTag().op != LESS_THAN && this.getTag().varType == Type.NODE) {
      collVsShardVsTagVsCount.forEach((coll, shardVsNodeVsCount) ->
          shardVsNodeVsCount.forEach((shard, nodeVsCount) -> {
            for (Row row : allRows) {
              if (!nodeVsCount.containsKey(row.node)) {
                nodeVsCount.put(row.node, new ReplicaCount());
              }
            }
          }));
    }
    return collVsShardVsTagVsCount;
  }

