  @Override
  public NamedList<Object> request(SolrRequest request) throws SolrServerException, IOException {
    connect();

    CloudState cloudState = zkStateReader.getCloudState();

    String collection = request.getParams().get("collection", defaultCollection);

    // TODO: allow multiple collections to be specified via comma separated list

    Map<String,Slice> slices = cloudState.getSlices(collection);
    Set<String> liveNodes = cloudState.getLiveNodes();

    // IDEA: have versions on various things... like a global cloudState version
    // or shardAddressVersion (which only changes when the shards change)
    // to allow caching.

    // build a map of unique nodes
    // TODO: allow filtering by group, role, etc
    Map<String,ZkNodeProps> nodes = new HashMap<String,ZkNodeProps>();
    List<String> urlList = new ArrayList<String>();
    for (Slice slice : slices.values()) {
      for (ZkNodeProps nodeProps : slice.getShards().values()) {
        String node = nodeProps.get(ZkStateReader.NODE_NAME);
        if (!liveNodes.contains(node)) continue;
        if (nodes.put(node, nodeProps) == null) {
          String url = nodeProps.get(ZkStateReader.URL_PROP);
          urlList.add(url);
        }
      }
    }

    Collections.shuffle(urlList, rand);
    // System.out.println("########################## MAKING REQUEST TO " + urlList);
    // TODO: set distrib=true if we detected more than one shard?
    LBHttpSolrServer.Req req = new LBHttpSolrServer.Req(request, urlList);
    LBHttpSolrServer.Rsp rsp = lbServer.request(req);
    return rsp.getResponse();
  }

