  // there are 2 modes of compare.
  // recursive, it uses the precision to tie & when there is a tie use the next preference to compare
  // in non-recursive mode, precision is not taken into consideration and sort is done on actual value
  int compare(Row r1, Row r2, boolean useApprox) {
    Object o1 = useApprox ? r1.cells[idx].approxVal : r1.cells[idx].val;
    Object o2 = useApprox ? r2.cells[idx].approxVal : r2.cells[idx].val;
    int result = 0;
    if (o1 instanceof Long && o2 instanceof Long) result = ((Long) o1).compareTo((Long) o2);
    else if (o1 instanceof Double && o2 instanceof Double) {
      result = compareWithTolerance((Double) o1, (Double) o2, useApprox ? 1f : 0.01f);
    } else if (!o1.getClass().getName().equals(o2.getClass().getName())) {
      throw new RuntimeException("Unable to compare " + o1 + " of type: " + o1.getClass().getName() + " from " + r1.cells[idx].toString() + " and " + o2 + " of type: " + o2.getClass().getName() + " from " + r2.cells[idx].toString());
    }
    return result == 0 ?
        (next == null ? 0 :
            next.compare(r1, r2, useApprox)) : sort.sortval * result;
  }

