  public List<Object> evaluate(Tuple tuple) throws IOException {
    List<Object> list = new ArrayList<>();
    for(StreamEvaluator subEvaluator : subEvaluators) {
      Object value = subEvaluator.evaluate(tuple);
      
      // if we want sorting but the evaluated value is not comparable then we have an error
      if(null != sortOrder && !(value instanceof Comparable<?>)){
        String message = String.format(Locale.ROOT,"Failed to evaluate to a comparable object - evaluator '%s' resulted in type '%s' and value '%s'",
            subEvaluator.toExpression(constructingFactory),
            value.getClass().getName(),
            value.toString());
        throw new IOException(message);
      }
      
      list.add(value);
    }
    
    if(null != sortOrder){
      // Because of the type checking above we know that the value is at least Comparable
      Comparator<Comparable> comparator = "asc".equals(sortOrder) ? (left,right) -> left.compareTo(right) : (left,right) -> right.compareTo(left);
      list = list.stream().map(value -> (Comparable<Object>)value).sorted(comparator).collect(Collectors.toList());
    }

    return list;
  }

