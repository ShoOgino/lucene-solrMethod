  protected Collection setupWithCollectionTargetNodes(Set<String> collections, Set<Pair<String, String>> s, String withCollection) {
    Collection originalTargetNodesCopy = null;
    if (withCollection != null) {
      if (log.isDebugEnabled()) {
        HashSet<String> set = new HashSet<>(collections);
        s.forEach(kv -> set.add(kv.first()));
        log.debug("Identified withCollection = {} for collection: {}", withCollection, set);
      }

      originalTargetNodesCopy = Utils.getDeepCopy((Collection) hints.get(Hint.TARGET_NODE), 10, true);

      Set<String> withCollectionNodes = new HashSet<>();

      for (Row row : getMatrix()) {
        row.forEachReplica(r -> {
          if (withCollection.equals(r.getCollection()) &&
              "shard1".equals(r.getShard())) {
            withCollectionNodes.add(r.getNode());
          }
        });
      }

      if (originalTargetNodesCopy != null && !originalTargetNodesCopy.isEmpty()) {
        // find intersection of the set of target nodes with the set of 'withCollection' nodes
        Set<String> set = (Set<String>) hints.computeIfAbsent(Hint.TARGET_NODE, h -> new HashSet<>());
        set.retainAll(withCollectionNodes);
        if (set.isEmpty()) {
          // no nodes common between the sets, we have no choice but to restore the original target node hint
          hints.put(Hint.TARGET_NODE, originalTargetNodesCopy);
        }
      } else if (originalTargetNodesCopy == null) {
        hints.put(Hint.TARGET_NODE, withCollectionNodes);
      }
    }
    return originalTargetNodesCopy;
  }

