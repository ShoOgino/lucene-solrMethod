    /**
     * <p>Method returning an available session that can be used for {@link Status#COMPUTING}, either from the
     * {@link #sessionWrapperSet} cache or by creating a new one. The status of the returned session is set to {@link Status#COMPUTING}.</p>
     *
     * Some waiting is done in two cases:
     * <ul>
     *   <li>A candidate session is present in {@link #sessionWrapperSet} but is still {@link Status#COMPUTING}, a random wait
     *   is observed to see if the session gets freed to save a session creation and allow session reuse,</li>
     *   <li>It is necessary to create a new session but there are already sessions in the process of being created, a
     *   random wait is observed (if no waiting already occurred waiting for a session to become free) before creation
     *   takes place, just in case one of the created sessions got used then {@link #returnSession(SessionWrapper)} in the meantime.</li>
     * </ul>
     *
     * The random wait prevents the "thundering herd" effect when all threads needing a session at the same time create a new
     * one even though some differentiated waits could have led to better reuse and less session creations.
     *
     * @param allowWait usually <code>true</code> except in tests that know there's no point in waiting because nothing
     *                  will happen...
     */
    public SessionWrapper get(SolrCloudManager cloudManager, boolean allowWait) throws IOException, InterruptedException {
      TimeSource timeSource = cloudManager.getTimeSource();
      long oldestUpdateTimeNs = TimeUnit.SECONDS.convert(timeSource.getTimeNs(), TimeUnit.NANOSECONDS) - SESSION_EXPIRY;
      int zkVersion = cloudManager.getDistribStateManager().getAutoScalingConfig().getZkVersion();

      synchronized (lockObj) {
        SessionWrapper sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);

        // Best case scenario: an available session
        if (sw != null) {
          if (log.isDebugEnabled()) {
            log.debug("reusing session {}", sw.getCreateTime());
          }
          return sw;
        }

        // Wait for a while before deciding what to do if waiting could help...
        if ((creationsInProgress != 0 || hasCandidateSession(zkVersion, oldestUpdateTimeNs)) && allowWait) {
          // Either an existing session might be returned and become usable while we wait, or a session in the process of being
          // created might finish creation, be used then returned and become usable. So we wait.
          // wait 1 to 10 secs. Random to help spread wakeups.
          long waitForMs = (long) (Math.random() * 9 * 1000) + 1000;

          if (log.isDebugEnabled()) {
            log.debug("No sessions are available, all busy COMPUTING (or {} creations in progress). starting wait of {}ms",
                creationsInProgress, waitForMs);
          }
          long waitStart = time(timeSource, MILLISECONDS);
          try {
            lockObj.wait(waitForMs);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
          }
          if (log.isDebugEnabled()) {
            log.debug("out of waiting. wait of {}ms, actual time elapsed {}ms", waitForMs, timeElapsed(timeSource, waitStart, MILLISECONDS));
          }

          // We've waited, now we can either reuse immediately an available session, or immediately create a new one
          sw = getAvailableSession(zkVersion, oldestUpdateTimeNs);

          // Second best case scenario: an available session
          if (sw != null) {
            if (log.isDebugEnabled()) {
              log.debug("reusing session {} after wait", sw.getCreateTime());
            }
            return sw;
          }
        }

        // We're going to create a new Session OUTSIDE of the critical section because session creation can take quite some time
        creationsInProgress++;
      }

      SessionWrapper newSessionWrapper = null;
      try {
        if (log.isDebugEnabled()) {
          log.debug("Creating a new session");
        }
        Policy.Session session = cloudManager.getDistribStateManager().getAutoScalingConfig().getPolicy().createSession(cloudManager);
        newSessionWrapper = new SessionWrapper(session, this);
        if (log.isDebugEnabled()) {
          log.debug("New session created, {}", newSessionWrapper.getCreateTime());
        }
        return newSessionWrapper;
      } finally {
        synchronized (lockObj) {
          creationsInProgress--;

          if (newSessionWrapper != null) {
            // Session created successfully
            sessionWrapperSet.add(newSessionWrapper);
          }
        }
      }
    }

