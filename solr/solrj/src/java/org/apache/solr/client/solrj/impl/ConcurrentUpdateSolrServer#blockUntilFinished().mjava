  public synchronized void blockUntilFinished() {
    lock = new CountDownLatch(1);
    try {
      // Wait until no runners are running
      for (;;) {
        Runner runner;
        synchronized (runners) {
          runner = runners.peek();
        }

        if ((runner == null && queue.isEmpty()) || scheduler.isTerminated())
          break;
        
        if (runner != null) {
          runner.runnerLock.lock();
          runner.runnerLock.unlock();
        } else if (!queue.isEmpty()) {
          // failsafe - should not be necessary, but a good
          // precaution to ensure blockUntilFinished guarantees
          // all updates are emptied from the queue regardless of
          // any bugs around starting or retaining runners
          Runner r = new Runner();
          runners.add(r);
          scheduler.execute(r);
        }
      }
    } finally {
      lock.countDown();
      lock = null;
    }
  }

