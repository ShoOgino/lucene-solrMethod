    public SessionWrapper get(SolrCloudManager cloudManager) throws IOException, InterruptedException {
      TimeSource timeSource = cloudManager.getTimeSource();
      synchronized (lockObj) {
        if (sessionWrapper.status == Status.NULL ||
            TimeUnit.SECONDS.convert(timeSource.getTime() - sessionWrapper.lastUpdateTime, TimeUnit.NANOSECONDS) > SESSION_EXPIRY) {
          //no session available or the session is expired
          return createSession(cloudManager);
        } else {
          long waitStart = time(timeSource, MILLISECONDS);
          //the session is not expired
          log.debug("reusing a session {}", this.sessionWrapper.createTime);
          if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {
            this.sessionWrapper.status = Status.COMPUTING;
            return sessionWrapper;
          } else {
            //status= COMPUTING it's being used for computing. computing is
            log.debug("session being used. waiting... current time {} ", time(timeSource, MILLISECONDS));
            try {
              lockObj.wait(10 * 1000);//wait for a max of 10 seconds
            } catch (InterruptedException e) {
              log.info("interrupted... ");
            }
            log.debug("out of waiting curr-time:{} time-elapsed {}", time(timeSource, MILLISECONDS), timeElapsed(timeSource, waitStart, MILLISECONDS));
            // now this thread has woken up because it got timed out after 10 seconds or it is notified after
            //the session was returned from another COMPUTING operation
            if (this.sessionWrapper.status == Status.UNUSED || this.sessionWrapper.status == Status.EXECUTING) {
              log.debug("Wait over. reusing the existing session ");
              this.sessionWrapper.status = Status.COMPUTING;
              return sessionWrapper;
            } else {
              //create a new Session
              return createSession(cloudManager);
            }
          }
        }
      }
    }

