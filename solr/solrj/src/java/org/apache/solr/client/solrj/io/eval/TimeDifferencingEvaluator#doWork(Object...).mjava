  @Override
  public Object doWork(Object... values) throws IOException {
    if (!(1 == values.length ||  values.length == 2)){
      throw new IOException(String.format(Locale.ROOT,"%s(...) only works with 1 or 2 values but %d were provided", constructingFactory.getFunctionName(getClass()), values.length));
    }
    List<Number> timeseriesValues = (List<Number> )values[0];
    Number lagValue = 1;

    if(1 == values.length) {
      if (!(timeseriesValues instanceof List<?>)) {
        throw new IOException(String.format(Locale.ROOT, "Invalid expression %s - found type %s for the first value, expecting a List", toExpression(constructingFactory), values[0].getClass().getSimpleName()));
      }
      if (!(timeseriesValues.size() > 1)) {
        throw new IOException(String.format(Locale.ROOT, "Invalid expression %s - found list size of %s for the first value, expecting a List of size > 0.", toExpression(constructingFactory), timeseriesValues.size()));
      }
    }
    if(2 == values.length) {
      lagValue = (Number) values[1];
      if(!(lagValue instanceof Number)){
        throw new IOException(String.format(Locale.ROOT, "Invalid expression %s - found type %s for the second value, expecting a Number", toExpression(constructingFactory), values[1].getClass().getSimpleName()));
      }
      if (lagValue.intValue() >  timeseriesValues.size()) {
        throw new IOException(String.format(Locale.ROOT, "Invalid expression %s - found a lag size of %s for the second value, the first value has a List size of %s, expecting a lag value less than the List size", toExpression(constructingFactory), lagValue.intValue(), timeseriesValues.size()));
      }
    }
    final int lag = lagValue.intValue();
    return IntStream.range(lag, timeseriesValues.size())
        .mapToObj(n -> (timeseriesValues.get(n).doubleValue()-timeseriesValues.get(n-lag).doubleValue()))
        .collect(Collectors.toList());
  }

