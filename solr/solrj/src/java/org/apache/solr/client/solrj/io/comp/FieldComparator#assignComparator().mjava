  /*
   * What're we doing here messing around with lambdas for the comparator logic?
   * We want the compare(...) function to run as fast as possible because it will be called many many
   * times over the lifetime of this object. For that reason we want to limit the number of comparisons
   * taking place in the compare(...) function. Because this class supports both ascending and
   * descending comparisons and the logic for each is slightly different, we want to do the 
   *   if(ascending){ compare like this } else { compare like this }
   * check only once - we can do that in the constructor of this class, create a lambda, and then execute 
   * that lambda in the compare function. A little bit of branch prediction savings right here.
   */
  private void assignComparator(){
    if(ComparatorOrder.DESCENDING == order){
      comparator = new ComparatorLambda() {
        public int compare(Tuple leftTuple, Tuple rightTuple) {
          Comparable leftComp = (Comparable)leftTuple.get(leftField);
          Comparable rightComp = (Comparable)rightTuple.get(rightField);
          return rightComp.compareTo(leftComp);
        }
      };
    }
    else{
      comparator = new ComparatorLambda() {
        public int compare(Tuple leftTuple, Tuple rightTuple) {
          Comparable leftComp = (Comparable)leftTuple.get(leftField);
          Comparable rightComp = (Comparable)rightTuple.get(rightField);
          return leftComp.compareTo(rightComp);
        }
      };
    }
  }

