  /*
   * What're we doing here messing around with lambdas for the comparator logic?
   * We want the compare(...) function to run as fast as possible because it will be called many many
   * times over the lifetime of this object. For that reason we want to limit the number of comparisons
   * taking place in the compare(...) function. Because this class supports both ascending and
   * descending comparisons and the logic for each is slightly different, we want to do the 
   *   if(ascending){ compare like this } else { compare like this }
   * check only once - we can do that in the constructor of this class, create a lambda, and then execute 
   * that lambda in the compare function. A little bit of branch prediction savings right here.
   */
  private void assignComparator(){
    if(ComparatorOrder.DESCENDING == order){
      // What black magic is this type intersection??
      // Because this class is serializable we need to make sure the lambda is also serializable.
      // This can be done by providing this type intersection on the definition of the lambda.
      // Why not do it in the lambda interface? Functional Interfaces don't allow extends clauses
      comparator = (ComparatorLambda & Serializable)(leftTuple, rightTuple) -> {
        Comparable leftComp = (Comparable)leftTuple.get(leftField);
        Comparable rightComp = (Comparable)rightTuple.get(rightField);
        return rightComp.compareTo(leftComp);
      };
    }
    else{
      // See above for black magic reasoning.
      comparator = (ComparatorLambda & Serializable)(leftTuple, rightTuple) -> {
        Comparable leftComp = (Comparable)leftTuple.get(leftField);
        Comparable rightComp = (Comparable)rightTuple.get(rightField);
        return leftComp.compareTo(rightComp);
      };
    }
  }

