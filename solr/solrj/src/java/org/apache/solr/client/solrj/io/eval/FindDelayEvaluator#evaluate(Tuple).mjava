  public Number evaluate(Tuple tuple) throws IOException {

    if(subEvaluators.size() != 2) {
      throw new IOException("Finddelay evaluator expects 2 parameters found: "+subEvaluators.size());
    }

    StreamEvaluator colEval1 = subEvaluators.get(0);
    StreamEvaluator colEval2 = subEvaluators.get(1);

    List<Number> numbers1 = (List<Number>)colEval1.evaluate(tuple);
    List<Number> numbers2 = (List<Number>)colEval2.evaluate(tuple);
    double[] column1 = new double[numbers1.size()];
    double[] column2 = new double[numbers2.size()];

    for(int i=0; i<numbers1.size(); i++) {
      column1[i] = numbers1.get(i).doubleValue();
    }

    //Reverse the second column.
    //The convolve function will reverse it back.
    //This allows correlation to be represented using the convolution math.
    int rIndex=0;
    for(int i=numbers2.size()-1; i>=0; i--) {
      column2[rIndex++] = numbers2.get(i).doubleValue();
    }

    double[] convolution = MathArrays.convolve(column1, column2);
    double max = -Double.MAX_VALUE;
    double maxIndex = -1;

    for(int i=0; i< convolution.length; i++) {
      double abs = Math.abs(convolution[i]);
      if(abs > max) {
        max = abs;
        maxIndex = i;
      }
    }

    return (maxIndex+1)-column2.length;
  }

