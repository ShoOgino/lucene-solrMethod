  /**
   * Uses the supplied HttpClient to send documents to the Solr server.
   * 
   * @deprecated use {@link Builder} instead.  This will soon be a
   * protected method, and will only be available for use in implementing subclasses.
   */
  @Deprecated
  public ConcurrentUpdateSolrClient(String solrServerUrl,
                                    HttpClient client, int queueSize, int threadCount, ExecutorService es, boolean streamDeletes) {
    this.internalHttpClient = (client == null);
    this.client = new HttpSolrClient.Builder(solrServerUrl)
        .withHttpClient(client)
        .build();
    this.client.setFollowRedirects(false);
    queue = new LinkedBlockingQueue<>(queueSize);
    this.threadCount = threadCount;
    runners = new LinkedList<>();
    this.streamDeletes = streamDeletes;
    
    if (es != null) {
      scheduler = es;
      shutdownExecutor = false;
    } else {
      scheduler = ExecutorUtil.newMDCAwareCachedThreadPool(new SolrjNamedThreadFactory("concurrentUpdateScheduler"));
      shutdownExecutor = true;
    }
    
    if (log.isDebugEnabled()) {
      pollInterrupts = new AtomicInteger();
      pollExits = new AtomicInteger();
      blockLoops = new AtomicInteger();
      emptyQueueLoops = new AtomicInteger();
    }
  }

