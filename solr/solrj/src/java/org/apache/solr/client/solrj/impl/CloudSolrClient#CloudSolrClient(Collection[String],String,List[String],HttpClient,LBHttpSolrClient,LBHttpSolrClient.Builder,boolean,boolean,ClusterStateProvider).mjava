  /**
   * Create a new client object that connects to Zookeeper and is always aware
   * of the SolrCloud state. If there is a fully redundant Zookeeper quorum and
   * SolrCloud has enough replicas for every shard in a collection, there is no
   * single point of failure. Updates will be sent to shard leaders by default.
   *
   * @param zkHosts
   *          A Java Collection (List, Set, etc) of HOST:PORT strings, one for
   *          each host in the zookeeper ensemble. Note that with certain
   *          Collection types like HashSet, the order of hosts in the final
   *          connect string may not be in the same order you added them.
   *          Provide only one of solrUrls or zkHosts.
   * @param chroot
   *          A chroot value for zookeeper, starting with a forward slash. If no
   *          chroot is required, use null.
   * @param solrUrls
   *          A list of Solr URLs to configure the underlying {@link HttpClusterStateProvider}, which will
   *          use of the these URLs to fetch the list of live nodes for this Solr cluster. Provide only
   *          one of solrUrls or zkHosts.
   * @param httpClient
   *          the {@link HttpClient} instance to be used for all requests. The provided httpClient should use a
   *          multi-threaded connection manager.  If null, a default HttpClient will be used.
   * @param lbSolrClient
   *          LBHttpSolrClient instance for requests.  If null, a default LBHttpSolrClient will be used.
   * @param lbHttpSolrClientBuilder
   *          LBHttpSolrClient builder to construct the LBHttpSolrClient. If null, a default builder will be used.
   * @param updatesToLeaders
   *          If true, sends updates to shard leaders.
   * @param directUpdatesToLeadersOnly
   *          If true, sends direct updates to shard leaders only.
   */
  private CloudSolrClient(Collection<String> zkHosts,
                          String chroot,
                          List<String> solrUrls,
                          HttpClient httpClient,
                          LBHttpSolrClient lbSolrClient,
                          LBHttpSolrClient.Builder lbHttpSolrClientBuilder,
                          boolean updatesToLeaders,
                          boolean directUpdatesToLeadersOnly,
                          ClusterStateProvider stateProvider

  ) {
    if (stateProvider == null) {
      if (zkHosts != null && solrUrls != null) {
        throw new IllegalArgumentException("Both zkHost(s) & solrUrl(s) have been specified. Only specify one.");
      }
      if (zkHosts != null) {
        this.stateProvider = new ZkClientClusterStateProvider(zkHosts, chroot);
      } else if (solrUrls != null && !solrUrls.isEmpty()) {
        try {
          this.stateProvider = new HttpClusterStateProvider(solrUrls, httpClient);
        } catch (Exception e) {
          throw new RuntimeException("Couldn't initialize a HttpClusterStateProvider (is/are the "
              + "Solr server(s), "  + solrUrls + ", down?)", e);
        }
      } else {
        throw new IllegalArgumentException("Both zkHosts and solrUrl cannot be null.");
      }
    } else {
      this.stateProvider = stateProvider;
    }
    this.clientIsInternal = httpClient == null;
    this.shutdownLBHttpSolrServer = lbSolrClient == null;
    if(lbHttpSolrClientBuilder != null) lbSolrClient = lbHttpSolrClientBuilder.build();
    if(lbSolrClient != null) httpClient = lbSolrClient.getHttpClient();
    this.myClient = httpClient == null ? HttpClientUtil.createClient(null) : httpClient;
    if (lbSolrClient == null) lbSolrClient = createLBHttpSolrClient(myClient);
    this.lbClient = lbSolrClient;
    this.updatesToLeaders = updatesToLeaders;
    this.directUpdatesToLeadersOnly = directUpdatesToLeadersOnly;
  }

