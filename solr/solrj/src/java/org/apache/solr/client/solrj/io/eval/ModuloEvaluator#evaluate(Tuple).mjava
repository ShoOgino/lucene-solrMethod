  @Override
  public Number evaluate(Tuple tuple) throws IOException {
    
    List<BigDecimal> results = evaluateAll(tuple);
    
    // we're still doing these checks because if we ever add an array-flatten evaluator, 
    // two found in the constructor could become != 2
    if(2 != results.size()){
      String message = null;
      if(1 == results.size()){
        message = String.format(Locale.ROOT,"%s(...) only works with a 2 values (numerator,denominator) but 1 was provided", constructingFactory.getFunctionName(getClass())); 
      }
      else{
        message = String.format(Locale.ROOT,"%s(...) only works with a 2 values (numerator,denominator) but %d were provided", constructingFactory.getFunctionName(getClass()), results.size());
      }
      throw new IOException(message);
    }
    
    BigDecimal numerator = results.get(0);
    BigDecimal denominator = results.get(1);
    
    if(null == numerator){
      throw new IOException(String.format(Locale.ROOT,"Unable to %s(...) with a null numerator", constructingFactory.getFunctionName(getClass())));
    }
    
    if(null == denominator){
      throw new IOException(String.format(Locale.ROOT,"Unable to %s(...) with a null denominator", constructingFactory.getFunctionName(getClass())));
    }
    
    if(0 == denominator.compareTo(BigDecimal.ZERO)){
      throw new IOException(String.format(Locale.ROOT,"Unable to %s(...) with a 0 denominator", constructingFactory.getFunctionName(getClass())));
    }
    
    return normalizeType(numerator.remainder(denominator, MathContext.DECIMAL64));
  }

