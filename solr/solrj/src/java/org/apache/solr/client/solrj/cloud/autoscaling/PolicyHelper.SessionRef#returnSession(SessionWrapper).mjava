    /**
     * Computing is over for this session and it may contain a new session with new state
     * The session can be used by others while the caller is performing operations
     *
     */
    private void returnSession(SessionWrapper sessionWrapper) {
      TimeSource timeSource = sessionWrapper.session.cloudManager.getTimeSource();
      synchronized (lockObj) {
        sessionWrapper.status = Status.EXECUTING;
        log.info("returnSession, curr-time {} sessionWrapper.createTime {}, this.sessionWrapper.createTime {} ", time(timeSource, MILLISECONDS),
            sessionWrapper.createTime,
            this.sessionWrapper.createTime);
        if (sessionWrapper.createTime == this.sessionWrapper.createTime) {
          //this session was used for computing new operations and this can now be used for other
          // computing
          this.sessionWrapper = sessionWrapper;

          //one thread who is waiting for this need to be notified.
          lockObj.notify();
        } else {
          log.info("create time NOT SAME {} ", SessionWrapper.DEF_INST.createTime);
          //else just ignore it
        }
      }

    }

