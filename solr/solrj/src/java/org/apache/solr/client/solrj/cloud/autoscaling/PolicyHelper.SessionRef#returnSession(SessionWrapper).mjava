    /**
     * Computing is over for this session and it may contain a new session with new state
     * The session can be used by others while the caller is performing operations
     */
    private void returnSession(SessionWrapper sessionWrapper) {
      boolean present;
      synchronized (lockObj) {
        sessionWrapper.status = Status.EXECUTING;
        present = sessionWrapperSet.contains(sessionWrapper);

        // wake up single thread waiting for a session return (ok if not woken up, wait is short)
        // Important to wake up a single one, otherwise of multiple waiting threads, all but one will immediately create new sessions
        lockObj.notify();
      }

      // Logging
      if (present) {
        if (log.isDebugEnabled()) {
          log.debug("returnSession {}", sessionWrapper.getCreateTime());
        }
      } else {
        log.warn("returning unknown session {} ", sessionWrapper.getCreateTime());
      }
    }

