  public Policy(Map<String, Object> jsonMap) {

    clusterPreferences = ((List<Map<String, Object>>) jsonMap.getOrDefault(CLUSTER_PREFERENCE, emptyList())).stream()
        .map(Preference::new)
        .collect(toList());
    for (int i = 0; i < clusterPreferences.size() - 1; i++) {
      Preference preference = clusterPreferences.get(i);
      preference.next = clusterPreferences.get(i + 1);
    }
    if (clusterPreferences.isEmpty()) {
      clusterPreferences.add(new Preference((Map<String, Object>) Utils.fromJSONString("{minimize : cores, precision:1}")));
    }
    SortedSet<String> paramsOfInterest = new TreeSet<>();
    for (Preference preference : clusterPreferences) {
      if (paramsOfInterest.contains(preference.name.name())) {
        throw new RuntimeException(preference.name + " is repeated");
      }
      paramsOfInterest.add(preference.name.toString());
    }
    this.params = new ArrayList<>(paramsOfInterest);

    clusterPolicy = ((List<Map<String, Object>>) jsonMap.getOrDefault(CLUSTER_POLICY, emptyList())).stream()
        .map(Clause::new)
        .filter(clause -> {
          clause.addTags(params);
          return true;
        })
        .collect(Collectors.toList());

    ((Map<String, List<Map<String, Object>>>) jsonMap.getOrDefault("policies", emptyMap())).forEach((s, l1) ->
        this.policies.put(s, l1.stream()
            .map(Clause::new)
            .filter(clause -> {
              if (!clause.isPerCollectiontag())
                throw new RuntimeException(clause.globalTag.name + " is only allowed in 'cluster-policy'");
              clause.addTags(params);
              return true;
            })
            .sorted()
            .collect(toList())));
  }

