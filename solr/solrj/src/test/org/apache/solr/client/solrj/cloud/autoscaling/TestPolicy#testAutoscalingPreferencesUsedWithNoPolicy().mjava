  @SuppressWarnings({"unchecked", "rawtypes"})
  public void testAutoscalingPreferencesUsedWithNoPolicy() throws IOException, InterruptedException {
    Map<String, Object> m = (Map<String, Object>) loadFromResource("testAutoscalingPreferencesUsedWithNoPolicy.json");
    fixRequiredProps(m);
    Map clusterState = (Map) m.remove("clusterstate");

    Map replicaInfo = (Map) m.get("replicaInfo");
    replicaInfo.forEach((node, val) -> {
      Map m1 = (Map) val;
      m1.forEach((coll, val2) -> {
        Map m2 = (Map) val2;
        m2.forEach((shard, val3) -> {
          List l3 = (List) val3;
          for (int i = 0; i < l3.size(); i++) {
            Object o = l3.get(i);
            Map m3 = (Map) o;
            String name = m3.keySet().iterator().next().toString();
            m3 = (Map) m3.get(name);
            Replica.Type type = Replica.Type.get((String) m3.get("type"));
            l3.set(i, new ReplicaInfo(name, name
                , coll.toString(), shard.toString(), type, (String) node, m3));
          }
        });

      });
    });
    @SuppressWarnings({"unchecked"})
    AutoScalingConfig asc = m.containsKey("autoscalingJson") ? new AutoScalingConfig((Map<String, Object>) m.get("autoscalingJson")) : new AutoScalingConfig(Collections.emptyMap());
    DelegatingCloudManager cloudManager = new DelegatingCloudManager(null) {

      @Override
      public DistribStateManager getDistribStateManager() {
        return new DelegatingDistribStateManager(null) {
          @Override
          public AutoScalingConfig getAutoScalingConfig() {
            return asc;
          }
        };
      }

      @Override
      public ClusterStateProvider getClusterStateProvider() {
        return new DelegatingClusterStateProvider(null) {
          @Override
          @SuppressWarnings({"unchecked"})
          public Set<String> getLiveNodes() {
            return new HashSet<>((Collection<String>) m.get("liveNodes"));
          }

          @Override
          public ClusterState getClusterState() {
            return ClusterState.createFromCollectionMap(0, clusterState, getLiveNodes());
          }

          @Override
          public Map<String, Object> getClusterProperties() {
            return Collections.singletonMap("defaults", Collections.singletonMap("cluster", Collections.singletonMap(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, false)));
          }
        };
      }

      @Override
      public NodeStateProvider getNodeStateProvider() {
        return new DelegatingNodeStateProvider(null) {
          @Override
          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {
            @SuppressWarnings({"unchecked"})
            Map<String, Object> result = (Map<String, Object>) Utils.getObjectByPath(m, false, Arrays.asList("nodeValues", node));
            return result == null ? new HashMap<>() : result;
          }

          @Override
          public Map<String, Map<String, List<ReplicaInfo>>> getReplicaInfo(String node, Collection<String> keys) {
            @SuppressWarnings({"unchecked"})
            Map<String, Map<String, List<ReplicaInfo>>> result = (Map<String, Map<String, List<ReplicaInfo>>>) Utils.getObjectByPath(m, false, Arrays.asList("replicaInfo", node));
            return result == null ? new HashMap<>() : result;
          }
        };
      }
    };

    Assign.AssignRequest assignRequest = new Assign.AssignRequestBuilder()
        .forCollection("c1")
        .forShard(Collections.singletonList("s1"))
        .assignNrtReplicas(1)
        .build();
    Assign.AssignStrategyFactory assignStrategyFactory = new Assign.AssignStrategyFactory(cloudManager);
    ClusterState state = cloudManager.getClusterStateProvider().getClusterState();
    DocCollection collection = state.getCollection("c1");
    Assign.AssignStrategy assignStrategy = assignStrategyFactory.create(state, collection);
    List<ReplicaPosition> replicaPositions = assignStrategy.assign(cloudManager, assignRequest);

    assertEquals(1, replicaPositions.size());
    ReplicaPosition replicaPosition = replicaPositions.get(0);
    assertEquals("node3:8985", replicaPosition.node); // only node3:8985 has enough space to handle the new replica
    assertEquals("s1", replicaPosition.shard); // sanity check
  }

