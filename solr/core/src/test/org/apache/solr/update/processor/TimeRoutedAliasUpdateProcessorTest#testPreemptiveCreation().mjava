  @Test
  @Slow
  public void testPreemptiveCreation() throws Exception {
    String configName = getSaferTestName();
    createConfigSet(configName);

    final int numShards = 1 ;
    final int numReplicas = 1 ;
    CollectionAdminRequest.createTimeRoutedAlias(alias, "2017-10-23T00:00:00Z", "+1DAY", timeField,
        CollectionAdminRequest.createCollection("_unused_", configName, numShards, numReplicas)
            .setMaxShardsPerNode(numReplicas)).setPreemptiveCreateWindow("3HOUR")
        .process(solrClient);

    // cause some collections to be created
    assertUpdateResponse(solrClient.add(alias,
        sdoc("id","1","timestamp_dt", "2017-10-25T00:00:00Z")
    ));
    assertUpdateResponse(solrClient.commit(alias));

    // wait for all the collections to exist...
    waitCol("2017-10-23", numShards); // This one should have already existed from the alias creation
    waitCol("2017-10-24", numShards); // Create 1
    waitCol("2017-10-25", numShards); // Create 2nd synchronously (ensure this is not broken)

    // normal update, nothing special, no collection creation required.
    List<String> cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(3,cols.size());

    assertNumDocs("2017-10-23", 0);
    assertNumDocs("2017-10-24", 0);
    assertNumDocs("2017-10-25", 1);

    // cause some collections to be created

    ModifiableSolrParams params = params();
    assertUpdateResponse(add(alias, Arrays.asList(
        sdoc("id", "2", "timestamp_dt", "2017-10-24T00:00:00Z"),
        sdoc("id", "3", "timestamp_dt", "2017-10-25T00:00:00Z"),
        sdoc("id", "4", "timestamp_dt", "2017-10-23T00:00:00Z"),
        sdoc("id", "5", "timestamp_dt", "2017-10-25T23:00:00Z")), // should cause preemptive creation
        params));
    assertUpdateResponse(solrClient.commit(alias));

    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(3,cols.size());
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 3);

    assertUpdateResponse(add(alias, Collections.singletonList(
        sdoc("id", "6", "timestamp_dt", "2017-10-25T23:01:00Z")), // might cause duplicate preemptive creation
        params));
    assertUpdateResponse(solrClient.commit(alias));

    waitCol("2017-10-26", numShards);
    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(4,cols.size());
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 4);
    assertNumDocs("2017-10-26", 0);

    // now test with pre-create window longer than time slice, and forcing multiple creations.
    CollectionAdminRequest.setAliasProperty(alias)
        .addProperty(TimeRoutedAlias.ROUTER_PREEMPTIVE_CREATE_MATH, "3DAY").process(solrClient);

    assertUpdateResponse(add(alias, Collections.singletonList(
        sdoc("id", "7", "timestamp_dt", "2017-10-25T23:01:00Z")), // should cause preemptive creation now
        params));
    assertUpdateResponse(solrClient.commit(alias));
    waitCol("2017-10-27", numShards);

    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(5,cols.size()); // only one created in async case
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 5);
    assertNumDocs("2017-10-26", 0);
    assertNumDocs("2017-10-27", 0);

    assertUpdateResponse(add(alias, Collections.singletonList(
        sdoc("id", "8", "timestamp_dt", "2017-10-25T23:01:00Z")), // should cause preemptive creation now
        params));
    assertUpdateResponse(solrClient.commit(alias));
    waitCol("2017-10-27", numShards);
    waitCol("2017-10-28", numShards);

    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(6,cols.size()); // Subsequent documents continue to create up to limit
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 6);
    assertNumDocs("2017-10-26", 0);
    assertNumDocs("2017-10-27", 0);
    assertNumDocs("2017-10-28", 0);

    QueryResponse resp;
    resp = solrClient.query(alias, params(
        "q", "*:*",
        "rows", "10"));
    assertEquals(8, resp.getResults().getNumFound());

    assertUpdateResponse(add(alias, Arrays.asList(
        sdoc("id", "9", "timestamp_dt", "2017-10-27T23:01:00Z"), // should cause preemptive creation

        // If these are not ignored properly this test will fail during cleanup with a message about router.name being
        // required. This happens because the test finishes while overseer threads are still trying to invoke maintain
        // after the @After method has deleted collections and emptied out the aliases.... this leaves the maintain
        // command cloning alias properties Aliases.EMPTY and thus not getting a value from router.name
        // (normally router.name == 'time') The check for non-blank router.name  happens to be the first validation.
        // There is a small chance this could slip through without a fail occasionally, but it was 100% with just one
        // of these.
        sdoc("id", "10", "timestamp_dt", "2017-10-28T23:01:00Z"),  // should be ignored due to in progress creation
        sdoc("id", "11", "timestamp_dt", "2017-10-28T23:02:00Z"),  // should be ignored due to in progress creation
        sdoc("id", "12", "timestamp_dt", "2017-10-28T23:03:00Z")), // should be ignored due to in progress creation
        params));
    assertUpdateResponse(solrClient.commit(alias));
    waitCol("2017-10-29", numShards);

    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(7,cols.size());
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 6);
    assertNumDocs("2017-10-26", 0);
    assertNumDocs("2017-10-27", 1);
    assertNumDocs("2017-10-28", 3); // should get through even though preemptive creation ignored it.
    assertNumDocs("2017-10-29", 0);

    resp = solrClient.query(alias, params(
        "q", "*:*",
        "rows", "0"));
    assertEquals(12, resp.getResults().getNumFound());

    // Sych creation with an interval longer than the time slice for the alias..
    assertUpdateResponse(add(alias, Collections.singletonList(
        sdoc("id", "13", "timestamp_dt", "2017-10-30T23:03:00Z")), // lucky?
        params));
    assertUpdateResponse(solrClient.commit(alias));
    waitCol("2017-10-30", numShards);
    waitCol("2017-10-31", numShards); // spooky! async case arising in middle of sync creation!!

    cols = new CollectionAdminRequest.ListAliases().process(solrClient).getAliasesAsLists().get(alias);
    assertEquals(9,cols.size());
    assertNumDocs("2017-10-23", 1);
    assertNumDocs("2017-10-24", 1);
    assertNumDocs("2017-10-25", 6);
    assertNumDocs("2017-10-26", 0);
    assertNumDocs("2017-10-27", 1);
    assertNumDocs("2017-10-28", 3); // should get through even though preemptive creation ignored it.
    assertNumDocs("2017-10-29", 0);
    assertNumDocs("2017-10-30", 1);
    assertNumDocs("2017-10-31", 0);

    resp = solrClient.query(alias, params(
        "q", "*:*",
        "rows", "0"));
    assertEquals(13, resp.getResults().getNumFound());

  }

