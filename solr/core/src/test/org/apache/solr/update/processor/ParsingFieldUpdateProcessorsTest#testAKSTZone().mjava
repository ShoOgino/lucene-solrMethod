  // this test has had problems when the JDK timezone is Americas/Metlakatla
  public void testAKSTZone() throws IOException {
    final String dateFormat = "EEE MMM d HH:mm:ss z yyyy";
    final String inputString = "Thu Nov 13 04:35:51 AKST 2008"; // asctime + timezone1

    final long expectTs = 1226583351000L;
    assertEquals(expectTs,
        DateTimeFormatter.ofPattern(dateFormat, Locale.ENGLISH)
            .withZone(ZoneId.of("UTC")).parse(inputString, Instant::from).toEpochMilli());

    // ensure english locale and root locale return the same date
    assertEquals(expectTs, DateTimeFormatter.ofPattern(dateFormat, Locale.ENGLISH)
            .withZone(ZoneId.of("UTC")).parse(inputString, Instant::from).toEpochMilli(),
        DateTimeFormatter.ofPattern(dateFormat, Locale.ENGLISH)
            .withZone(ZoneId.of("UTC")).parse(inputString, Instant::from).toEpochMilli());

    assertParsedDate(inputString, Date.from(Instant.ofEpochMilli(expectTs)), "parse-date-patterns-default-config");

    // We might also test AKDT, but a bug in Java 9 (not in 8) causes this to fail
    //assertParsedDate("Fri Oct 7 05:14:15 AKDT 2005", Date.from(inst20051007131415()), "parse-date-patterns-default-config"); // with timezone (not asctime) in DST
    // see https://bugs.openjdk.java.net/browse/JDK-8189784
  }

