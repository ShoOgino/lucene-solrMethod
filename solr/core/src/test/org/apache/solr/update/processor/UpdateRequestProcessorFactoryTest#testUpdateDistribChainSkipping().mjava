  public void testUpdateDistribChainSkipping() throws Exception {

    final int EXPECTED_CHAIN_LENGTH = 5;
    SolrCore core = h.getCore();
    for (final String name : Arrays.asList("distrib-chain-explicit",
                                           "distrib-chain-implicit",
                                           "distrib-chain-noop")) {

      UpdateRequestProcessor proc;
      List<UpdateRequestProcessor> procs;
      
      UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(name);
      assertNotNull(name, chain);

      // either explicitly, or because of injection
      assertEquals(name + " chain length: " + chain.toString(), EXPECTED_CHAIN_LENGTH,
                   chain.getFactories().length);

      // test a basic (non distrib) chain
      proc = chain.createProcessor(req(), new SolrQueryResponse());
      procs = procToList(proc);
      assertEquals(name + " procs size: " + procs.toString(),
                   // -1 = NoOpDistributingUpdateProcessorFactory produces no processor
                   EXPECTED_CHAIN_LENGTH - ("distrib-chain-noop".equals(name) ? 1 : 0),
                   procs.size());
      
      // Custom comes first in all three of our chains
      assertTrue(name + " first processor isn't a CustomUpdateRequestProcessor: " + procs.toString(),
                 ( // compare them both just because i'm going insane and the more checks the better
                   proc instanceof CustomUpdateRequestProcessor
                   && procs.get(0) instanceof CustomUpdateRequestProcessor));

      // Log should always come second in our chain.
      assertNotNull(name + " proc.next is null", proc.next);
      assertNotNull(name + " second proc is null", procs.get(1));

      assertTrue(name + " second proc isn't LogUpdateProcessor: " + procs.toString(),
                 ( // compare them both just because i'm going insane and the more checks the better
                   proc.next instanceof LogUpdateProcessor
                   && procs.get(1) instanceof LogUpdateProcessor));

      // fetch the distributed version of this chain
      proc = chain.createProcessor(req(DISTRIB_UPDATE_PARAM, "non_blank_value"),
                                   new SolrQueryResponse());
      procs = procToList(proc);
      assertNotNull(name + " (distrib) chain produced null proc", proc);
      assertFalse(name + " (distrib) procs is empty", procs.isEmpty());

      // for these 3 (distrib) chains, the first proc should always be LogUpdateProcessor
      assertTrue(name + " (distrib) first proc should be LogUpdateProcessor because of @RunAllways: "
                 + procs.toString(),
                 ( // compare them both just because i'm going insane and the more checks the better
                   proc instanceof LogUpdateProcessor
                   && procs.get(0) instanceof LogUpdateProcessor));

      // for these 3 (distrib) chains, the last proc should always be RunUpdateProcessor
      assertTrue(name + " (distrib) last processor isn't a RunUpdateProcessor: " + procs.toString(),
                 procs.get(procs.size()-1) instanceof RunUpdateProcessor );

      // either 1 proc was droped in distrib mode, or 1 for the "implicit" chain
      assertEquals(name + " (distrib) chain has wrong length: " + procs.toString(),
                   // -1 = all chains lose CustomUpdateRequestProcessorFactory
                   // -1 = distrib-chain-noop: NoOpDistributingUpdateProcessorFactory produces no processor
                   // -1 = distrib-chain-implicit: does RemoveBlank before distrib
                   EXPECTED_CHAIN_LENGTH - ( "distrib-chain-explicit".equals(name) ? 1 : 2),
                   procs.size());
    }

  }

