  @Test
  public void testArrnvpWriterOverridesAllWrites() {
    // List rather than Set because two not-overridden methods could share name but not signature
    final List<String> methodsExpectedNotOverriden = new ArrayList<>(14);
    methodsExpectedNotOverriden.add("writeResponse");
    methodsExpectedNotOverriden.add("writeKey");
    methodsExpectedNotOverriden.add("writeNamedListAsMapMangled");
    methodsExpectedNotOverriden.add("writeNamedListAsMapWithDups");
    methodsExpectedNotOverriden.add("writeNamedListAsArrMap");
    methodsExpectedNotOverriden.add("writeNamedListAsArrArr");
    methodsExpectedNotOverriden.add("writeNamedListAsFlat");
    methodsExpectedNotOverriden.add("writeEndDocumentList");
    methodsExpectedNotOverriden.add("writeMapOpener");
    methodsExpectedNotOverriden.add("writeMapSeparator");
    methodsExpectedNotOverriden.add("writeMapCloser");
    methodsExpectedNotOverriden.add("public void org.apache.solr.response.JSONWriter.writeArray(java.lang.String,java.util.List) throws java.io.IOException");
    methodsExpectedNotOverriden.add("writeArrayOpener");
    methodsExpectedNotOverriden.add("writeArraySeparator");
    methodsExpectedNotOverriden.add("writeArrayCloser");
    methodsExpectedNotOverriden.add("public void org.apache.solr.response.JSONWriter.writeMap(org.apache.solr.common.MapWriter) throws java.io.IOException");
    methodsExpectedNotOverriden.add("public void org.apache.solr.response.JSONWriter.writeIterator(org.apache.solr.common.IteratorWriter) throws java.io.IOException");

    final Class<?> subClass = ArrayOfNamedValuePairJSONWriter.class;
    final Class<?> superClass = subClass.getSuperclass();

    for (final Method superClassMethod : superClass.getDeclaredMethods()) {
      final String methodName = superClassMethod.getName();
      final String methodFullName = superClassMethod.toString();
      if (!methodName.startsWith("write")) continue;

      final int modifiers = superClassMethod.getModifiers();
      if (Modifier.isFinal(modifiers)) continue;
      if (Modifier.isStatic(modifiers)) continue;
      if (Modifier.isPrivate(modifiers)) continue;

      final boolean expectOverriden = !methodsExpectedNotOverriden.contains(methodName)
          && !methodsExpectedNotOverriden.contains(methodFullName);

      try {
        final Method subClassMethod = subClass.getDeclaredMethod(
            superClassMethod.getName(),
            superClassMethod.getParameterTypes());

        if (expectOverriden) {
          assertEquals("getReturnType() difference",
              superClassMethod.getReturnType(),
              subClassMethod.getReturnType());
        } else {
          fail(subClass + " must not override '" + superClassMethod + "'");
        }
      } catch (NoSuchMethodException e) {
        if (expectOverriden) {
          fail(subClass + " needs to override '" + superClassMethod + "'");
        } else {
          assertTrue(methodName+" not found in remaining "+methodsExpectedNotOverriden, methodsExpectedNotOverriden.remove(methodName)|| methodsExpectedNotOverriden.remove(methodFullName));
        }
      }
    }

    assertTrue("methodsExpected NotOverriden but NotFound instead: "+methodsExpectedNotOverriden,
        methodsExpectedNotOverriden.isEmpty());
  }

