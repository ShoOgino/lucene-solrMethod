  private void createAndTest(final String coll, final boolean legacy) throws Exception {

    // First, just insure that core.properties file gets created with coreNodeName and all other mandatory parameters.
    final String legacyString = Boolean.toString(legacy);
    final String legacyAnti = Boolean.toString(!legacy);
    CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyString).process(cluster.getSolrClient());
    ClusterProperties props = new ClusterProperties(zkClient());

    assertEquals("Value of legacyCloud cluster prop unexpected", legacyString,
        props.getClusterProperty(ZkStateReader.LEGACY_CLOUD, legacyAnti));

    CollectionAdminRequest.createCollection(coll, "conf", 1, 1)
        .setMaxShardsPerNode(1)
        .process(cluster.getSolrClient());
    
    cluster.waitForActiveCollection(coll, 1, 1);
    
    assertTrue(ClusterStateUtil.waitForAllActiveAndLiveReplicas(cluster.getSolrClient().getZkStateReader(), 120000));
    
    // Insure all mandatory properties are there.
    checkMandatoryProps(coll);

    checkCollectionActive(coll);
    // The fixes for SOLR-11503 insure that creating a collection has coreNodeName whether legacyCloud is true or false,
    // we still need to test repairing a properties file that does _not_ have coreNodeName set, the second part of
    // the fix.

    // First, remove the coreNodeName from cluster.properties and write it out it.
    removePropertyFromAllReplicas(coll, "coreNodeName");

    // Now restart Solr, this should repair the removal on core load no matter the value of legacyCloud
    JettySolrRunner jetty = cluster.getJettySolrRunner(0);
    jetty.stop();
    
    cluster.waitForJettyToStop(jetty);
    
    jetty.start();
    
    cluster.waitForAllNodes(30);
    
    checkMandatoryProps(coll);
    checkCollectionActive(coll);
  }

