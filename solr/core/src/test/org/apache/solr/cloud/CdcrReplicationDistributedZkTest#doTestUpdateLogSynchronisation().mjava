  /**
   * Check that the update logs are synchronised between leader and non-leader nodes
   */
  public void doTestUpdateLogSynchronisation() throws Exception {
    this.clearSourceCollection();
    this.clearTargetCollection();

    // buffering is enabled by default, so disable it
    this.invokeCdcrAction(shardToLeaderJetty.get(SOURCE_COLLECTION).get(SHARD1), CdcrParams.CdcrAction.DISABLEBUFFER);
    this.waitForCdcrStateReplication(SOURCE_COLLECTION);

    this.invokeCdcrAction(shardToLeaderJetty.get(SOURCE_COLLECTION).get(SHARD1), CdcrParams.CdcrAction.START);
    this.waitForCdcrStateReplication(SOURCE_COLLECTION);

    for (int i = 0; i < 50; i++) {
      // will perform a commit for every document and will create one tlog file per commit
      index(SOURCE_COLLECTION, getDoc(id, Integer.toString(i)));
    }

    // wait a bit for the replication to complete
    this.waitForReplicationToComplete(SOURCE_COLLECTION, SHARD1);
    this.waitForReplicationToComplete(SOURCE_COLLECTION, SHARD2);

    commit(TARGET_COLLECTION);

    // Stop CDCR
    this.invokeCdcrAction(shardToLeaderJetty.get(SOURCE_COLLECTION).get(SHARD1), CdcrParams.CdcrAction.STOP);
    this.waitForCdcrStateReplication(SOURCE_COLLECTION);

    assertEquals(50, getNumDocs(SOURCE_COLLECTION));
    assertEquals(50, getNumDocs(TARGET_COLLECTION));

    // some of the tlogs should be trimmed, we must have less than 50 tlog files on both leader and non-leader
    assertNumberOfTlogFiles(SOURCE_COLLECTION, 50);

    for (int i = 50; i < 100; i++) {
      index(SOURCE_COLLECTION, getDoc(id, Integer.toString(i)));
    }

    // at this stage, we should have created one tlog file per document, and some of them must have been cleaned on the
    // leader since we are not buffering and replication is stopped, (we should have exactly 10 tlog files on the leader
    // and 11 on the non-leader)
    // the non-leader must have synchronised its update log with its leader
    assertNumberOfTlogFiles(SOURCE_COLLECTION, 50);
  }

