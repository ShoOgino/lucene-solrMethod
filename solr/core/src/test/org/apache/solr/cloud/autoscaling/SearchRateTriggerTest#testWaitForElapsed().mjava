  @Test
  public void testWaitForElapsed() throws Exception {
    SolrResourceLoader loader = cluster.getJettySolrRunner(0).getCoreContainer().getResourceLoader();
    CloudSolrClient solrClient = cluster.getSolrClient();
    SolrZkClient zkClient = solrClient.getZkStateReader().getZkClient();
    SolrCloudManager cloudManager = new SolrClientCloudManager(new ZkDistributedQueueFactory(zkClient), solrClient) {
      @Override
      public NodeStateProvider getNodeStateProvider() {
        return new SolrClientNodeStateProvider(solrClient) {
          @Override
          public Map<String, Object> getNodeValues(String node, Collection<String> tags) {
            Map<String, Object> values = super.getNodeValues(node, tags);
            values.keySet().forEach(k -> {
              values.replace(k, mockRate.get());
            });
            return values;
          }
        };
      }
    };
    TimeSource timeSource = cloudManager.getTimeSource();
    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,
        "conf", 2, 2);
    create.setMaxShardsPerNode(1);
    create.process(solrClient);
    CloudUtil.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS, clusterShape(2, 4));

    long waitForSeconds = 5 + random().nextInt(5);
    Map<String, Object> props = createTriggerProps(Arrays.asList(COLL1, COLL2), waitForSeconds, 1.0, 0.1);
    final List<TriggerEvent> events = new ArrayList<>();

    try (SearchRateTrigger trigger = new SearchRateTrigger("search_rate_trigger1")) {
      trigger.configure(loader, cloudManager, props);
      trigger.init();
      trigger.setProcessor(noFirstRunProcessor);
      trigger.run();
      trigger.setProcessor(event -> events.add(event));

      // set mock rates
      mockRate.set(2.0);
      TimeOut timeOut = new TimeOut(waitForSeconds + 2, TimeUnit.SECONDS, timeSource);
      // simulate ScheduledTriggers
      while (!timeOut.hasTimedOut()) {
        trigger.run();
        timeSource.sleep(1000);
      }
      // violation persisted longer than waitFor - there should be events
      assertTrue(events.toString(), events.size() > 0);
      TriggerEvent event = events.get(0);
      assertEquals(event.toString(), TriggerEventType.SEARCHRATE, event.eventType);
      Map<String, Object> hotNodes, hotCollections, hotShards;
      List<ReplicaInfo> hotReplicas;
      hotNodes = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_NODES);
      hotCollections = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_COLLECTIONS);
      hotShards = (Map<String, Object>)event.properties.get(SearchRateTrigger.HOT_SHARDS);
      hotReplicas = (List<ReplicaInfo>)event.properties.get(SearchRateTrigger.HOT_REPLICAS);
      assertTrue("no hot nodes?", hotNodes.isEmpty());
      assertFalse("no hot collections?", hotCollections.isEmpty());
      assertFalse("no hot shards?", hotShards.isEmpty());
      assertFalse("no hot replicas?", hotReplicas.isEmpty());
    }

    mockRate.set(0.0);
    events.clear();

    try (SearchRateTrigger trigger = new SearchRateTrigger("search_rate_trigger2")) {
      trigger.configure(loader, cloudManager, props);
      trigger.init();
      trigger.setProcessor(noFirstRunProcessor);
      trigger.run();
      trigger.setProcessor(event -> events.add(event));

      mockRate.set(2.0);
      trigger.run();
      // waitFor not elapsed
      assertTrue(events.toString(), events.isEmpty());
      Thread.sleep(1000);
      trigger.run();
      assertTrue(events.toString(), events.isEmpty());
      Thread.sleep(1000);
      mockRate.set(0.0);
      trigger.run();
      Thread.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds - 2, TimeUnit.SECONDS));
      trigger.run();

      // violations persisted shorter than waitFor - there should be no events
      assertTrue(events.toString(), events.isEmpty());

    }
  }

