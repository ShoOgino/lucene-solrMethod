  /**
   * Creates and starts a given number of servers.
   */
  protected List<String> startServers(int nServer) throws Exception {
    String temporaryCollection = "tmp_collection";

    for (int i = 1; i <= nServer; i++) {
      // give everyone there own solrhome
      File jettyDir = createTempDir("jetty").toFile();
      jettyDir.mkdirs();
      setupJettySolrHome(jettyDir);
      JettySolrRunner jetty = createJetty(jettyDir, null, "shard" + i);
      jettys.add(jetty);
    }

    try (SolrClient client = createCloudClient(temporaryCollection)) {
      assertEquals(0, CollectionAdminRequest
          .createCollection(temporaryCollection, shardCount, 1)
          .setCreateNodeSet("")
          .process(client).getStatus());
      for (int i = 0; i < jettys.size(); i++) {
        assertTrue(CollectionAdminRequest
            .addReplicaToShard(temporaryCollection, "shard"+((i % shardCount) + 1))
            .setNode(jettys.get(i).getNodeName())
            .process(client).isSuccess());
      }
    }

    ZkStateReader zkStateReader = jettys.get(0).getCoreContainer().getZkController().getZkStateReader();

    // now wait till we see the leader for each shard
    for (int i = 1; i <= shardCount; i++) {
      this.printLayout();
      zkStateReader.getLeaderRetry(temporaryCollection, "shard" + i, 15000);
    }

    // store the node names
    List<String> nodeNames = new ArrayList<>();
    for (Slice shard : zkStateReader.getClusterState().getCollection(temporaryCollection).getSlices()) {
      for (Replica replica : shard.getReplicas()) {
        nodeNames.add(replica.getNodeName());
      }
    }

    this.waitForRecoveriesToFinish(temporaryCollection,zkStateReader, true);
    // delete the temporary collection - we will create our own collections later
    this.deleteCollection(temporaryCollection);
    this.waitForCollectionToDisappear(temporaryCollection);
    System.clearProperty("collection");

    return nodeNames;
  }

