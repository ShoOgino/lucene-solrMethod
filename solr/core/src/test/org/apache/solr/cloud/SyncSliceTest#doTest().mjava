  @Override
  public void doTest() throws Exception {
    
    handle.clear();
    handle.put("QTime", SKIPVAL);
    handle.put("timestamp", SKIPVAL);
    
    waitForThingsToLevelOut();

    del("*:*");
    List<String> skipServers = new ArrayList<String>();
    int docId = 0;
    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,
        "to come to the aid of their country.");
    
    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,
        "old haven was blue.");
    
    skipServers.add(shardToJetty.get("shard1").get(1).url + "/");
    
    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,
        "but the song was fancy.");
    
    skipServers.add(shardToJetty.get("shard1").get(2).url + "/");
    
    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,
        "under the moon and over the lake");
    
    commit();
    
    waitForRecoveriesToFinish(false);

    // shard should be inconsistent
    String shardFailMessage = checkShardConsistency("shard1", true);
    assertNotNull(shardFailMessage);
    
    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set("action", CollectionAction.SYNCSHARD.toString());
    params.set("collection", "collection1");
    params.set("shard", "shard1");
    SolrRequest request = new QueryRequest(params);
    request.setPath("/admin/collections");
    
    String baseUrl = ((HttpSolrServer) shardToJetty.get("shard1").get(2).client.solrClient)
        .getBaseURL();
    baseUrl = baseUrl.substring(0, baseUrl.length() - "collection1".length());
    
    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);
    baseServer.request(request);
    
    waitForThingsToLevelOut();
    
    checkShardConsistency(false, true);
    
    long cloudClientDocs = cloudClient.query(new SolrQuery("*:*")).getResults().getNumFound();
    assertEquals(4, cloudClientDocs);
    
    
    // kill the leader - new leader could have all the docs or be missing one
    CloudJettyRunner leaderJetty = shardToLeaderJetty.get("shard1");
    
    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader
    
    // this doc won't be on one node
    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,
        "to come to the aid of their country.");
    
    
    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();
    jetties.addAll(shardToJetty.get("shard1"));
    jetties.remove(leaderJetty);
    assertEquals(shardCount - 1, jetties.size());
    
    chaosMonkey.killJetty(leaderJetty);

    // we are careful to make sure the downed node is no longer in the state,
    // because on some systems (especially freebsd w/ blackhole enabled), trying
    // to talk to a downed node causes grief
    waitToSeeDownInCloudState(leaderJetty, jetties);

    waitForThingsToLevelOut();
    
    checkShardConsistency(false, true);
    
    cloudClientDocs = cloudClient.query(new SolrQuery("*:*")).getResults().getNumFound();
    assertEquals(5, cloudClientDocs);
    
    CloudJettyRunner deadJetty = leaderJetty;
    
    // let's get the latest leader
    while (deadJetty == leaderJetty) {
      updateMappingsFromZk(this.jettys, this.clients);
      leaderJetty = shardToLeaderJetty.get("shard1");
    }
    
    // bring back dead node
    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore
    
    // give a moment to be sure it has started recovering
    Thread.sleep(2000);
    
    waitForThingsToLevelOut();
    waitForRecoveriesToFinish(false);
    
    skipServers = getRandomOtherJetty(leaderJetty, null);
    
    // skip list should be 
    
    //System.out.println("leader:" + leaderJetty.url);
    //System.out.println("skip list:" + skipServers);
    
    // we are skipping the leader and one node
    assertEquals(1, skipServers.size());
    
    // more docs than can peer sync
    for (int i = 0; i < 300; i++) {
      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,
          "to come to the aid of their country.");
    }
    
    commit();
    
    waitForRecoveriesToFinish(false);
    
    // shard should be inconsistent
    shardFailMessage = checkShardConsistency("shard1", true);
    assertNotNull(shardFailMessage);
    
    
    jetties = new HashSet<CloudJettyRunner>();
    jetties.addAll(shardToJetty.get("shard1"));
    jetties.remove(leaderJetty);
    assertEquals(shardCount - 1, jetties.size());

    
    // kill the current leader
    chaosMonkey.killJetty(leaderJetty);
    
    waitToSeeDownInCloudState(leaderJetty, jetties);
    
    Thread.sleep(4000);
    
    waitForRecoveriesToFinish(false);
    
    
    // TODO: for now, we just check consistency -
    // there will be 305 or 5 docs depending on who
    // becomes the leader - eventually we want that to
    // always be the 305
    //checkShardConsistency(true, true);
    checkShardConsistency(false, true);
    
  }

