  /**
   * Compare top level stats in response with stats from pivot constraint
   */
  private void assertPivotStats(String message, PivotField constraint, QueryResponse response) {

    if (null == constraint.getFieldStatsInfo()) {
      // no stats for this pivot, nothing to check

      // TODO: use a trace param to know if/how-many to expect ?
      log.info("No stats to check for => " + message);
      return;
    }
    
    Map<String, FieldStatsInfo> actualFieldStatsInfoMap = response.getFieldStatsInfo();

    for (FieldStatsInfo pivotStats : constraint.getFieldStatsInfo().values()) {
      String statsKey = pivotStats.getName();

      FieldStatsInfo actualStats = actualFieldStatsInfoMap.get(statsKey);

      if (actualStats == null) {
        // handle case for not found stats (using stats query)
        //
        // these has to be a special case check due to the legacy behavior of "top level" 
        // StatsComponent results being "null" (and not even included in the 
        // getFieldStatsInfo() Map due to specila SolrJ logic) 

        log.info("Requested stats missing in verification query, pivot stats: " + pivotStats);
        assertEquals("Special Count", 0L, pivotStats.getCount().longValue());
        assertEquals("Special Missing", 
                     constraint.getCount(), pivotStats.getMissing().longValue());

      } else {
        // regular stats, compare everything...

        assert actualStats != null;
        String msg = " of " + statsKey + " => " + message;

        // no wiggle room, these should always be exactly equals, regardless of field type
        assertEquals("Count" + msg, pivotStats.getCount(), actualStats.getCount());
        assertEquals("Missing" + msg, pivotStats.getMissing(), actualStats.getMissing());
        assertEquals("Min" + msg, pivotStats.getMin(), actualStats.getMin());
        assertEquals("Max" + msg, pivotStats.getMax(), actualStats.getMax());

        // precision loss can affect these in some field types depending on shards used
        // and the order that values are accumulated
        assertNumerics("Sum" + msg, pivotStats.getSum(), actualStats.getSum());
        assertNumerics("Mean" + msg, pivotStats.getMean(), actualStats.getMean());
        assertNumerics("Stddev" + msg, pivotStats.getStddev(), actualStats.getStddev());
        assertNumerics("SumOfSquares" + msg, 
                      pivotStats.getSumOfSquares(), actualStats.getSumOfSquares());
      }
    }

    if (constraint.getFieldStatsInfo().containsKey("sk2")) { // cheeseball hack
      // if "sk2" was one of hte stats we computed, then we must have also seen
      // sk1 or sk3 because of the way the tags are fixed
      assertEquals("had stats sk2, but not another stat?", 
                   2, constraint.getFieldStatsInfo().size());
    } else {
      // if we did not see "sk2", then 1 of the others must be alone
      assertEquals("only expected 1 stat",
                   1, constraint.getFieldStatsInfo().size());
      assertTrue("not sk1 or sk3", 
                 constraint.getFieldStatsInfo().containsKey("sk1") ||
                 constraint.getFieldStatsInfo().containsKey("sk3"));
    }

  }

