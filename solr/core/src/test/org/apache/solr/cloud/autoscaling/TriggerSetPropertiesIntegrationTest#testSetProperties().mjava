  /** 
   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get
   * expected behavior 
   */
  public void testSetProperties() throws Exception {
    final JettySolrRunner runner = cluster.getJettySolrRunner(0);
    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();
    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();
    
    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {
      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());
      scheduledTriggers.setAutoScalingConfig(config);

      // Setup a trigger that records the timestamp of each time it was run
      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full
      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);
      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, "mock-timestamper") {
        @Override
        public void run() {
          log.info("Running {} in {}", this.getName(), Thread.currentThread().getName());
          timestamps.offer(timeSource.getTimeNs());
        }
      };

      log.info("Configuring simple scheduler and adding trigger: {}", t1.getName());
      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());
      scheduledTriggers.add(t1);

      waitForAndDiffTimestamps("conf(default delay)",
                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,
                               timestamps);
      
      log.info("Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}", t1.getName());
      config = config.withProperties(Collections.singletonMap
                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));
      scheduledTriggers.setAutoScalingConfig(config);
      timestamps.clear();

      waitForAndDiffTimestamps("conf(four sec delay)", 
                               4, TimeUnit.SECONDS, 
                               timestamps);
      
      log.info("Removing trigger: {}", t1.getName());
      scheduledTriggers.remove(t1.getName());
      
      log.info("Reconfiguing scheduler to use default props");
      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);
      scheduledTriggers.setAutoScalingConfig(config);

                 
      assertTrue("Test sanity check, need default thread pool to be at least 3 so we can" +
                 "test lowering it by 2", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);
      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;
      final int reducedThreadPoolSize = numTriggers - 2;
      
      // Setup X instances of a trigger that:
      //  - records it's name as being run
      //    - skipping all remaining execution if it's name has already been recorded
      //  - records the name of the thread that ran it
      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)
      // ...to test that the scheduler will add new threads as needed, up to the configured limit
      //
      // NOTE: the reason we need X unique instances is because the scheduler won't "re-run" a single
      // trigger while a previouss "run" is still in process
      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);
      
      // Use a cyclic barrier gated by an atomic ref so we can swap it out later
      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));
      
      // variables for tracking state as we go
      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),
      //       so we we can ensure we are reading a consistent view
      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());
      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());
      final AtomicLong fails = new AtomicLong(0);

      // Use a semaphore to track when each trigger *finishes* so our test thread
      // can know when to check & clear the tracking state
      final Semaphore completionSemaphore = new Semaphore(numTriggers);
      
      for (int i = 0; i < numTriggers; i++) {
        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,
                                                      "mock-blocking-trigger-" + i)  {
          @Override
          public void run() {
            log.info("Running {} in {}", this.getName(), Thread.currentThread().getName());
            CyclicBarrier barrier = null;
            synchronized (latch) {
              if (triggerNames.add(this.getName())) {
                log.info("{}: No-Op since we've already recorded a run", this.getName());
                return;
              }
              threadNames.add(Thread.currentThread().getName());
              barrier = latch.get();
            }
            
            try {
              log.info("{}: waiting on barrier to hog a thread", this.getName());
              barrier.await(30, TimeUnit.SECONDS);
              completionSemaphore.release();
            } catch (Exception e) {
              fails.incrementAndGet();
              log.error(this.getName() + ": failure waiting on cyclic barrier: " + e.toString(), e);
            }
          }
        };

        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());
        triggerList.add(trigger);
        completionSemaphore.acquire();
        log.info("Adding trigger {} to scheduler", trigger.getName());
        scheduledTriggers.add(trigger);
      }
      
      log.info("Waiting on semaphore for all triggers to signal completion...");
      assertTrue("Timed out waiting for semaphore count to be released",
                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));
                                                
      synchronized (latch) {
        assertEquals("Unexpected number of trigger names found: " + triggerNames.toString(),
                     numTriggers, triggerNames.size());
        assertEquals("Unexpected number of thread ames found: " + threadNames.toString(),
                     numTriggers, threadNames.size());
        assertEquals("Unexpected number of trigger fails recorded, check logs?",
                     0, fails.get());

        // before releasing the latch, clear the state and update our config to use a lower number of threads
        log.info("Updating scheduler config to use {} threads", reducedThreadPoolSize);
        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,
                                                                reducedThreadPoolSize));
        scheduledTriggers.setAutoScalingConfig(config);

        log.info("Updating cyclic barrier and clearing test state so triggers will 'run' again");
        latch.set(new CyclicBarrier(reducedThreadPoolSize));
        threadNames.clear();
        triggerNames.clear();
      }
      
      log.info("Waiting on semaphore for all triggers to signal completion...");
      assertTrue("Timed out waiting for semaphore count to be released",
                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));
      
      synchronized (latch) {
        assertEquals("Unexpected number of trigger names found: " + triggerNames.toString(),
                     numTriggers, triggerNames.size());
        assertEquals("Unexpected number of thread names found: " + threadNames.toString(),
                    reducedThreadPoolSize, threadNames.size());
        assertEquals("Unexpected number of trigger fails recorded, check logs?",
                     0, fails.get());
      }
    }
  }

