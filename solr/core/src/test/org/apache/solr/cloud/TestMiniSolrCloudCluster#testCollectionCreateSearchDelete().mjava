  protected void testCollectionCreateSearchDelete() throws Exception {

    File solrXml = new File(SolrTestCaseJ4.TEST_HOME(), "solr-no-core.xml");
    Builder jettyConfig = JettyConfig.builder();
    jettyConfig.waitForLoadingCoresToFinish(null);
    MiniSolrCloudCluster miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir().toFile(), solrXml, jettyConfig.build());

    final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();

    try {
      assertNotNull(miniCluster.getZkServer());
      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();
      assertEquals(NUM_SERVERS, jettys.size());
      for (JettySolrRunner jetty : jettys) {
        assertTrue(jetty.isRunning());
      }

      // shut down a server
      JettySolrRunner stoppedServer = miniCluster.stopJettySolrRunner(0);
      assertTrue(stoppedServer.isStopped());
      assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());

      // create a server
      JettySolrRunner startedServer = miniCluster.startJettySolrRunner();
      assertTrue(startedServer.isRunning());
      assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());

      // create collection
      String collectionName = "testSolrCloudCollection";
      String configName = "solrCloudCollectionConfig";
      File configDir = new File(SolrTestCaseJ4.TEST_HOME() + File.separator + "collection1" + File.separator + "conf");
      miniCluster.uploadConfigDir(configDir, configName);

      Map<String, String> collectionProperties = new HashMap<>();
      collectionProperties.put(CoreDescriptor.CORE_CONFIG, "solrconfig-tlog.xml");
      collectionProperties.put("solr.tests.maxBufferedDocs", "100000");
      collectionProperties.put("solr.tests.ramBufferSizeMB", "100");
      // use non-test classes so RandomizedRunner isn't necessary
      collectionProperties.put("solr.tests.mergePolicy", "org.apache.lucene.index.TieredMergePolicy");
      collectionProperties.put("solr.tests.mergeScheduler", "org.apache.lucene.index.ConcurrentMergeScheduler");
      collectionProperties.put("solr.directoryFactory", "solr.RAMDirectoryFactory");
      final String asyncId = (random().nextBoolean() ? null : "asyncId("+collectionName+".create)="+random().nextInt());
      miniCluster.createCollection(collectionName, NUM_SHARDS, REPLICATION_FACTOR, configName, asyncId, collectionProperties);
      if (asyncId != null) {
        assertEquals("did not see async createCollection completion", "completed", AbstractFullDistribZkTestBase.getRequestStateAfterCompletion(asyncId, 330, cloudSolrClient));
      }

      try (SolrZkClient zkClient = new SolrZkClient
          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);
          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {
        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);

        // modify/query collection
        cloudSolrClient.setDefaultCollection(collectionName);
        SolrInputDocument doc = new SolrInputDocument();
        doc.setField("id", "1");
        cloudSolrClient.add(doc);
        cloudSolrClient.commit();
        SolrQuery query = new SolrQuery();
        query.setQuery("*:*");
        QueryResponse rsp = cloudSolrClient.query(query);
        assertEquals(1, rsp.getResults().getNumFound());

        // remove a server not hosting any replicas
        zkStateReader.updateClusterState(true);
        ClusterState clusterState = zkStateReader.getClusterState();
        HashMap<String, JettySolrRunner> jettyMap = new HashMap<String, JettySolrRunner>();
        for (JettySolrRunner jetty : miniCluster.getJettySolrRunners()) {
          String key = jetty.getBaseUrl().toString().substring((jetty.getBaseUrl().getProtocol() + "://").length());
          jettyMap.put(key, jetty);
        }
        Collection<Slice> slices = clusterState.getSlices(collectionName);
        // track the servers not host repliacs
        for (Slice slice : slices) {
          jettyMap.remove(slice.getLeader().getNodeName().replace("_solr", "/solr"));
          for (Replica replica : slice.getReplicas()) {
            jettyMap.remove(replica.getNodeName().replace("_solr", "/solr"));
          }
        }
        assertTrue("Expected to find a node without a replica", jettyMap.size() > 0);
        JettySolrRunner jettyToStop = jettyMap.entrySet().iterator().next().getValue();
        jettys = miniCluster.getJettySolrRunners();
        for (int i = 0; i < jettys.size(); ++i) {
          if (jettys.get(i).equals(jettyToStop)) {
            miniCluster.stopJettySolrRunner(i);
            assertEquals(NUM_SERVERS - 1, miniCluster.getJettySolrRunners().size());
          }
        }

        // now restore the original state so that this function could be called multiple times
        
        // re-create a server (to restore original NUM_SERVERS count)
        startedServer = miniCluster.startJettySolrRunner();
        assertTrue(startedServer.isRunning());
        assertEquals(NUM_SERVERS, miniCluster.getJettySolrRunners().size());
        Thread.sleep(15000);
        try {
          cloudSolrClient.query(query);
          fail("Expected exception on query because collection should not be ready - we have turned on async core loading");
        } catch (SolrServerException e) {
          SolrException rc = (SolrException) e.getRootCause();
          assertTrue(rc.code() >= 500 && rc.code() < 600);
        } catch (SolrException e) {
          assertTrue(e.code() >= 500 && e.code() < 600);
        }

        // delete the collection we created earlier
        miniCluster.deleteCollection(collectionName);
        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);
      }
    }
    finally {
      miniCluster.shutdown();
    }
  }

