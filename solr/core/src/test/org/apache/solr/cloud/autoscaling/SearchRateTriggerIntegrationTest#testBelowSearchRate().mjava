  @Test
  public void testBelowSearchRate() throws Exception {
    CloudSolrClient solrClient = cluster.getSolrClient();
    String COLL1 = "belowRate_collection";
    // replicationFactor == 2
    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,
        "conf", 1, 2);
    create.process(solrClient);
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 2));

    // add a couple of spare replicas above RF. Use different types.
    // these additional replicas will be placed on other nodes in the cluster
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.NRT));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.TLOG));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.PULL));

    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 5));

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-trigger' : {" +
       "'name' : 'search_rate_trigger2'," +
       "'event' : 'searchRate'," +
       "'waitFor' : '" + waitForSeconds + "s'," +
       "'enabled' : false," +
       "'collections' : '" + COLL1 + "'," +
       "'aboveRate' : 1.0," +
       "'aboveNodeRate' : 1.0," +
       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero
       // even when no external requests were made .. but it's hard to predict exactly
       // what it will be.  use an insanely high rate so all shards/nodes are suspect
       // and produce an Op regardless of how much internal traffic is produced...
       "'belowRate' : 1.0," +
       "'belowNodeRate' : 1.0," +
       // ...but do absolutely nothing to nodes except generate an 'NONE' Op
       "'belowNodeOp' : 'none'," +
       "'actions' : [" +
       "{'name':'compute','class':'" + ComputePlanAction.class.getName() + "'}," +
       "{'name':'execute','class':'" + ExecutePlanAction.class.getName() + "'}" +
       "]" +
       "}}");

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'started'," +
       "'trigger' : 'search_rate_trigger2'," +
       "'stage' : ['STARTED']," +
       "'class' : '" + StartedProcessingListener.class.getName() + "'" +
       "}" +
       "}");

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'srt'," +
       "'trigger' : 'search_rate_trigger2'," +
       "'stage' : ['FAILED','SUCCEEDED']," +
       "'afterAction': ['compute', 'execute']," +
       "'class' : '" + CapturingTriggerListener.class.getName() + "'" +
       "}" +
       "}");
    listenerEventLatch = new CountDownLatch(3);
    
    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'finished'," +
       "'trigger' : 'search_rate_trigger2'," +
       "'stage' : ['SUCCEEDED']," +
       "'class' : '" + FinishedProcessingListener.class.getName() + "'" +
       "}" +
       "}");

    // Explicitly Do Nothing Here

    // enable the trigger
    final String resumeTriggerCommand = "{ 'resume-trigger' : { 'name' : 'search_rate_trigger2' } }";
    CloudTestUtils.assertAutoScalingRequest(cloudManager, resumeTriggerCommand);

    assertTrue("The trigger did not start in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("The trigger did not finish in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("the listener should have recorded all events w/in a reasonable amount of time",
               listenerEventLatch.await(60, TimeUnit.SECONDS));

    // suspend the trigger
    final String suspendTriggerCommand = "{ 'suspend-trigger' : { 'name' : 'search_rate_trigger2' } }";
    CloudTestUtils.assertAutoScalingRequest(cloudManager, suspendTriggerCommand);

    List<CapturedEvent> events = listenerEvents.get("srt");
    assertEquals(events.toString(), 3, events.size());
    CapturedEvent ev = events.get(0);
    assertEquals(ev.toString(), "compute", ev.actionName);
    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);
    assertNotNull("there should be some requestedOps: " + ev.toString(), ops);
    // 5 cold nodes, 3 cold replicas
    assertEquals(ops.toString(), 5 + 3, ops.size());
    AtomicInteger coldNodes = new AtomicInteger();
    AtomicInteger coldReplicas = new AtomicInteger();
    ops.forEach(op -> {
      if (op.getAction().equals(CollectionParams.CollectionAction.NONE)) {
        coldNodes.incrementAndGet();
      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {
        coldReplicas.incrementAndGet();
      } else {
        fail("unexpected op: " + op);
      }
    });
    assertEquals("cold nodes", 5, coldNodes.get());
    assertEquals("cold replicas", 3, coldReplicas.get());

    // now the collection should be down to RF = 2
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 2));

    listenerEvents.clear();
    listenerEventLatch = new CountDownLatch(3);
    finished = new CountDownLatch(1);
    started = new CountDownLatch(1);

    // resume trigger
    CloudTestUtils.assertAutoScalingRequest(cloudManager, resumeTriggerCommand);

    assertTrue("The trigger did not start in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("The trigger did not finish in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("the listener should have recorded all events w/in a reasonable amount of time",
               listenerEventLatch.await(60, TimeUnit.SECONDS));

    // suspend the trigger
    CloudTestUtils.assertAutoScalingRequest(cloudManager, suspendTriggerCommand);

    // there should be only coldNode ops now, and no coldReplica ops since searchable RF == collection RF

    events = listenerEvents.get("srt");
    assertEquals(events.toString(), 3, events.size());

    ev = events.get(0);
    assertEquals(ev.toString(), "compute", ev.actionName);
    ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);
    assertNotNull("there should be some requestedOps: " + ev.toString(), ops);
    assertEquals(ops.toString(), 2, ops.size());
    assertEquals(ops.toString(), CollectionParams.CollectionAction.NONE, ops.get(0).getAction());
    assertEquals(ops.toString(), CollectionParams.CollectionAction.NONE, ops.get(1).getAction());


    listenerEvents.clear();
    listenerEventLatch = new CountDownLatch(3);
    finished = new CountDownLatch(1);
    started = new CountDownLatch(1);

    log.info("## test single replicas.");

    // now allow single replicas
    CloudTestUtils.assertAutoScalingRequest
      (cloudManager,
       "{" +
       "'set-trigger' : {" +
       "'name' : 'search_rate_trigger2'," +
       "'event' : 'searchRate'," +
       "'waitFor' : '" + waitForSeconds + "s'," +
       "'enabled' : true," +
       "'collections' : '" + COLL1 + "'," +
       "'aboveRate' : 1.0," +
       "'aboveNodeRate' : 1.0," +
       "'belowRate' : 1.0," + // same excessively high values
       "'belowNodeRate' : 1.0," +
       "'minReplicas' : 1," + // NEW: force lower replicas
       "'belowNodeOp' : 'none'," + // still do nothing to nodes
       "'actions' : [" +
       "{'name':'compute','class':'" + ComputePlanAction.class.getName() + "'}," +
       "{'name':'execute','class':'" + ExecutePlanAction.class.getName() + "'}" +
       "]" +
       "}}");

    assertTrue("The trigger did not start in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("The trigger did not finish in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("the listener should have recorded all events w/in a reasonable amount of time",
               listenerEventLatch.await(60, TimeUnit.SECONDS));

    // suspend the trigger
    CloudTestUtils.assertAutoScalingRequest(cloudManager, suspendTriggerCommand);

    events = listenerEvents.get("srt");
    assertEquals(events.toString(), 3, events.size());

    ev = events.get(0);
    assertEquals(ev.toString(), "compute", ev.actionName);
    ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);
    assertNotNull("there should be some requestedOps: " + ev.toString(), ops);

    assertTrue(ops.toString(), ops.size() > 0);
    AtomicInteger coldNodes2 = new AtomicInteger();
    ops.forEach(op -> {
      if (op.getAction().equals(CollectionParams.CollectionAction.NONE)) {
        coldNodes2.incrementAndGet();
      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {
        // ignore
      } else {
        fail("unexpected op: " + op);
      }
    });

    assertEquals("coldNodes: " +ops.toString(), 2, coldNodes2.get());

    // now the collection should be at RF == 1, with one additional PULL replica
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 1));
  }

