  /**
   * Test a specific sequence of problematic events:
   * <ul>
   *  <li>create a collection with autoAddReplicas=<b>false</b></li>
   *  <li>stop a nodeX in use by the collection</li>
   *  <li>re-start nodeX</li>
   *  <li>set autoAddReplicas=<b>true</b></li>
   *  <li>re-stop nodeX</li>
   * </ul>
   */
  @Test
  @AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/SOLR-13811")
  public void testRapidStopStartStopWithPropChange() throws Exception {

    // This is the collection we'll be focused on in our testing...
    final String COLLECTION = "test_stoptwice";
    // This is a collection we'll use as a "marker" to ensure we "wait" for the
    // autoAddReplicas logic (via NodeLostTrigger) to kick in at least once before proceeding...
    final String ALT_COLLECTION = "test_dummy";
    
    final ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();
    final JettySolrRunner jetty1 = cluster.getJettySolrRunner(1);
    final JettySolrRunner jetty2 = cluster.getJettySolrRunner(2);

    if (log.isInfoEnabled()) {
      log.info("Creating {} using jetty1:{}/{} and jetty2:{}/{}", COLLECTION,
          jetty1.getNodeName(), jetty1.getLocalPort(),
          jetty2.getNodeName(), jetty2.getLocalPort());
    }
             
    CollectionAdminRequest.createCollection(COLLECTION, "conf", 2, 2)
      .setCreateNodeSet(jetty1.getNodeName()+","+jetty2.getNodeName())
      .setAutoAddReplicas(false) // NOTE: false
      .setMaxShardsPerNode(2)
      .process(cluster.getSolrClient());

    if (log.isInfoEnabled()) {
      log.info("Creating {} using jetty1:{}/{} and jetty2:{}/{}", ALT_COLLECTION,
          jetty1.getNodeName(), jetty1.getLocalPort(),
          jetty2.getNodeName(), jetty2.getLocalPort());
    }

    CollectionAdminRequest.createCollection(ALT_COLLECTION, "conf", 2, 2)
      .setCreateNodeSet(jetty1.getNodeName()+","+jetty2.getNodeName())
      .setAutoAddReplicas(true) // NOTE: true
      .setMaxShardsPerNode(2)
      .process(cluster.getSolrClient());
    
    cluster.waitForActiveCollection(COLLECTION, 2, 4);
    cluster.waitForActiveCollection(ALT_COLLECTION, 2, 4);

    JettySolrRunner lostJetty = random().nextBoolean() ? jetty1 : jetty2;
    String lostNodeName = lostJetty.getNodeName();
    List<Replica> replacedHdfsReplicas = getReplacedSharedFsReplicas(COLLECTION, zkStateReader, lostNodeName);

    if (log.isInfoEnabled()) {
      log.info("Stopping random node: {} / {}", lostNodeName, lostJetty.getLocalPort());
    }
    lostJetty.stop();
    
    cluster.waitForJettyToStop(lostJetty);
    waitForNodeLeave(lostNodeName);
    
    // ensure that our marker collection indicates that the autoAddReplicas logic
    // has detected the down node and done some processing
    waitForState(ALT_COLLECTION + "=(2,4) w/o down replicas",
                 ALT_COLLECTION, clusterShapeNoDownReplicas(2,4), 90, TimeUnit.SECONDS);

    waitForState(COLLECTION + "=(2,2)", COLLECTION, clusterShape(2, 2));

    if (log.isInfoEnabled()) {
      log.info("Re-starting (same) random node: {} / {}", lostNodeName, lostJetty.getLocalPort());
    }
    lostJetty.start();
    // save time, don't bother waiting for lostJetty to start until after updating collection prop...
    
    log.info("Modifying {} to use autoAddReplicas", COLLECTION);
    new CollectionAdminRequest.AsyncCollectionAdminRequest(CollectionParams.CollectionAction.MODIFYCOLLECTION) {
      @Override
      public SolrParams getParams() {
        ModifiableSolrParams params = (ModifiableSolrParams) super.getParams();
        params.set("collection", COLLECTION);
        params.set("autoAddReplicas", true);
        return params;
      }
    }.process(cluster.getSolrClient());

    // make sure lostJetty is fully up before stopping again...
    waitForNodeLive(lostJetty);

    if (log.isInfoEnabled()) {
      log.info("Re-Stopping (same) random node: {} / {}", lostNodeName, lostJetty.getLocalPort());
    }
    lostJetty.stop();
    
    cluster.waitForJettyToStop(lostJetty);
    waitForNodeLeave(lostNodeName);

    // TODO: this is the problematic situation...
    // wether or not NodeLostTrigger noticed that lostJetty was re-started and shutdown *again*
    // and that the new auoAddReplicas=true since the last time lostJetty was shutdown is respected
    waitForState(COLLECTION + "=(2,4) w/o down replicas",
                 COLLECTION, clusterShapeNoDownReplicas(2,4), 90, TimeUnit.SECONDS);
    checkSharedFsReplicasMovedCorrectly(replacedHdfsReplicas, zkStateReader, COLLECTION);

    if (log.isInfoEnabled()) {
      log.info("Re-Re-starting (same) random node: {} / {}", lostNodeName, lostJetty.getLocalPort());
    }
    lostJetty.start();
    
    waitForNodeLive(lostJetty);
    
    assertTrue("Timeout waiting for all live and active",
               ClusterStateUtil.waitForAllActiveAndLiveReplicas(zkStateReader, 90000));
  }

