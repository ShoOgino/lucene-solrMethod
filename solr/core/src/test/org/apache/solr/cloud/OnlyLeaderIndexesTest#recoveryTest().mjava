  public void recoveryTest() throws Exception {
    CloudSolrClient cloudClient = cluster.getSolrClient();
    new UpdateRequest()
        .deleteByQuery("*:*")
        .commit(cluster.getSolrClient(), COLLECTION);
    new UpdateRequest()
        .add(sdoc("id", "3"))
        .add(sdoc("id", "4"))
        .commit(cloudClient, COLLECTION);
    // Replica recovery
    new UpdateRequest()
        .add(sdoc("id", "5"))
        .process(cloudClient, COLLECTION);
    JettySolrRunner solrRunner = getSolrRunner(false).get(0);
    ChaosMonkey.stop(solrRunner);
    new UpdateRequest()
        .add(sdoc("id", "6"))
        .process(cloudClient, COLLECTION);
    ChaosMonkey.start(solrRunner);
    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),
        false, true, 30);
    // We skip peerSync, so replica will always trigger commit on leader
    checkShardConsistency(4, 20);

    // LTR can be kicked off, so waiting for replicas recovery
    new UpdateRequest()
        .add(sdoc("id", "7"))
        .commit(cloudClient, COLLECTION);
    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),
        false, true, 30);
    checkShardConsistency(5, 20);

    // More Replica recovery testing
    new UpdateRequest()
        .add(sdoc("id", "8"))
        .process(cloudClient, COLLECTION);
    checkRTG(3,8, cluster.getJettySolrRunners());
    DirectUpdateHandler2.commitOnClose = false;
    ChaosMonkey.stop(solrRunner);
    DirectUpdateHandler2.commitOnClose = true;
    ChaosMonkey.start(solrRunner);
    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),
        false, true, 30);
    checkRTG(3,8, cluster.getJettySolrRunners());
    checkShardConsistency(6, 20);

    // Test replica recovery apply buffer updates
    Semaphore waitingForBufferUpdates = new Semaphore(0);
    Semaphore waitingForReplay = new Semaphore(0);
    RecoveryStrategy.testing_beforeReplayBufferingUpdates = () -> {
      try {
        waitingForReplay.release();
        waitingForBufferUpdates.acquire();
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    };
    ChaosMonkey.stop(solrRunner);
    ChaosMonkey.start(solrRunner);
    waitingForReplay.acquire();
    new UpdateRequest()
        .add(sdoc("id", "9"))
        .add(sdoc("id", "10"))
        .process(cloudClient, COLLECTION);
    waitingForBufferUpdates.release();
    RecoveryStrategy.testing_beforeReplayBufferingUpdates = null;
    AbstractDistribZkTestBase.waitForRecoveriesToFinish(COLLECTION, cluster.getSolrClient().getZkStateReader(),
        false, true, 30);
    checkRTG(3,10, cluster.getJettySolrRunners());
    checkShardConsistency(6, 20);
    for (SolrCore solrCore : getSolrCore(false)) {
      RefCounted<IndexWriter> iwRef = solrCore.getUpdateHandler().getSolrCoreState().getIndexWriter(null);
      assertFalse("IndexWriter at replicas must not see updates ", iwRef.get().hasUncommittedChanges());
      iwRef.decref();
    }
  }

