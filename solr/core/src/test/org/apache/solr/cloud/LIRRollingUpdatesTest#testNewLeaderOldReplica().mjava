  public void testNewLeaderOldReplica() throws Exception {
    // in case of new leader & old replica, new leader can still put old replica into LIR

    String collection = "testNewLeaderOldReplica";
    CollectionAdminRequest.createCollection(collection, 1, 2)
        .setCreateNodeSet("")
        .process(cluster.getSolrClient());
    Properties oldLir = new Properties();
    oldLir.setProperty("lirVersion", "old");

    CollectionAdminRequest
        .addReplicaToShard(collection, "shard1")
        .setNode(cluster.getJettySolrRunner(0).getNodeName())
        .process(cluster.getSolrClient());
    waitForState("Timeout waiting for shard1 become active", collection, (liveNodes, collectionState) -> {
      Slice shard1 = collectionState.getSlice("shard1");
      if (shard1.getReplicas().size() == 1 && shard1.getLeader() != null) return true;
      return false;
    });

    CollectionAdminRequest
        .addReplicaToShard(collection, "shard1")
        .setProperties(oldLir)
        .setNode(cluster.getJettySolrRunner(1).getNodeName())
        .process(cluster.getSolrClient());

    Slice shard1 = getCollectionState(collection).getSlice("shard1");
    Replica notLeader = shard1.getReplicas(x -> x != shard1.getLeader()).get(0);
    Replica leader = shard1.getLeader();

    assertTrue(runInOldLIRMode(collection, "shard1", notLeader));
    assertFalse(runInOldLIRMode(collection, "shard1", leader));

    addDocs(collection, 2, 0);
    getProxyForReplica(notLeader).close();
    getProxyForReplica(leader).close();

    JettySolrRunner leaderJetty = getJettyForReplica(leader);
    addDoc(collection, 2, leaderJetty);
    waitForState("Replica " + notLeader.getName() + " is not put as DOWN", collection,
        (liveNodes, collectionState) ->
            collectionState.getSlice("shard1").getReplica(notLeader.getName()).getState() == Replica.State.DOWN);
    // wait a little bit
    Thread.sleep(500);
    getProxyForReplica(notLeader).reopen();
    getProxyForReplica(leader).reopen();

    waitForState("Timeout waiting for recovering", collection, clusterShape(1, 2));
    assertDocsExistInAllReplicas(Collections.singletonList(notLeader), collection, 0, 2);

    // ensure that after recovery, the upgraded replica will clean its LIR status cause it is no longer needed
    assertFalse(cluster.getSolrClient().getZkStateReader().getZkClient().exists(
        ZkController.getLeaderInitiatedRecoveryZnodePath(collection, "shard1", notLeader.getName()), true));
    // ensure that, leader should not register other replica's term
    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collection, "shard1", cluster.getZkClient())) {
      assertFalse(zkShardTerms.getTerms().containsKey(notLeader.getName()));
    }
    CollectionAdminRequest.deleteCollection(collection).process(cluster.getSolrClient());
  }

