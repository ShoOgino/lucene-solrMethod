  /**
   * Simulate running a shard leader election. This operation is a no-op if a leader already exists.
   * If a new leader is elected the cluster state is saved.
   * @param collections list of affected collections
   * @param saveClusterState if true then save cluster state regardless of changes.
   */
  private synchronized void simRunLeaderElection(Collection<String> collections, boolean saveClusterState) throws Exception {
    ClusterState state = getClusterState();
    AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);

    state.forEachCollection(dc -> {
      if (!collections.contains(dc.getName())) {
        return;
      }
      dc.getSlices().forEach(s -> {
        Replica leader = s.getLeader();
        if (leader == null || !liveNodes.contains(leader.getNodeName())) {
          LOG.trace("Running leader election for " + dc.getName() + " / " + s.getName());
          if (s.getReplicas().isEmpty()) { // no replicas - punt
            return;
          }
          // mark all replicas as non-leader (probably not necessary) and collect all active and live
          List<ReplicaInfo> active = new ArrayList<>();
          s.getReplicas().forEach(r -> {
            AtomicReference<ReplicaInfo> riRef = new AtomicReference<>();
            // find our ReplicaInfo for this replica
            nodeReplicaMap.get(r.getNodeName()).forEach(info -> {
              if (info.getName().equals(r.getName())) {
                riRef.set(info);
              }
            });
            ReplicaInfo ri = riRef.get();
            if (ri == null) {
              throw new IllegalStateException("-- could not find ReplicaInfo for replica " + r);
            }
            synchronized (ri) {
              if (ri.getVariables().remove(ZkStateReader.LEADER_PROP) != null) {
                stateChanged.set(true);
              }
              if (r.isActive(liveNodes.get())) {
                active.add(ri);
              } else { // if it's on a node that is not live mark it down
                if (!liveNodes.contains(r.getNodeName())) {
                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());
                }
              }
            }
          });
          if (active.isEmpty()) {
            LOG.warn("-- can't find any active replicas for " + dc.getName() + " / " + s.getName());
            return;
          }
          // pick first active one
          ReplicaInfo ri = null;
          for (ReplicaInfo a : active) {
            if (!a.getType().equals(Replica.Type.PULL)) {
              ri = a;
              break;
            }
          }
          if (ri == null) {
            LOG.warn("-- can't find any suitable replica type for " + dc.getName() + " / " + s.getName());
            return;
          }
          synchronized (ri) {
            ri.getVariables().put(ZkStateReader.LEADER_PROP, "true");
          }
          stateChanged.set(true);
          LOG.debug("-- elected new leader for " + dc.getName() + " / " + s.getName() + ": " + ri);
        } else {
          LOG.trace("-- already has leader for {} / {}", dc.getName(), s.getName());
        }
      });
    });
    if (saveClusterState || stateChanged.get()) {
      collectionsStatesRef.set(null);
    }
  }

