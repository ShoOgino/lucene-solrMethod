  @Test
  @BadApple(bugUrl="https://issues.apache.org/jira/browse/SOLR-12028") // 21-May-2018
  public void testDeleteNode() throws Exception {
    CloudSolrClient solrClient = cluster.getSolrClient();
    String COLL1 = "deleteNode_collection";
    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,
        "conf", 1, 2);

    create.process(solrClient);
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 2));

    // add a couple of spare replicas above RF. Use different types to verify that only
    // searchable replicas are considered
    // these additional replicas will be placed on other nodes in the cluster
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.NRT));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.TLOG));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.PULL));

    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 5));

    String setTriggerCommand = "{" +
        "'set-trigger' : {" +
        "'name' : 'search_rate_trigger3'," +
        "'event' : 'searchRate'," +
        "'waitFor' : '" + waitForSeconds + "s'," +
        "'enabled' : false," +
        "'collections' : '" + COLL1 + "'," +
        "'aboveRate' : 1.0," +
        "'belowRate' : 0.1," +
        // set limits to node rates
        "'aboveNodeRate' : 1.0," +
        "'belowNodeRate' : 0.1," +
        // allow deleting all spare replicas
        "'minReplicas' : 1," +
        // allow requesting all deletions in one event
        "'maxOps' : 10," +
        // delete underutilised nodes
        "'belowNodeOp' : 'DELETENODE'," +
        "'actions' : [" +
        "{'name':'compute','class':'" + ComputePlanAction.class.getName() + "'}," +
        "{'name':'execute','class':'" + ExecutePlanAction.class.getName() + "'}" +
        "]" +
        "}}";
    SolrRequest req = createAutoScalingRequest(SolrRequest.METHOD.POST, setTriggerCommand);
    NamedList<Object> response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    String setListenerCommand = "{" +
        "'set-listener' : " +
        "{" +
        "'name' : 'started'," +
        "'trigger' : 'search_rate_trigger3'," +
        "'stage' : ['STARTED']," +
        "'class' : '" + StartedProcessingListener.class.getName() + "'" +
        "}" +
        "}";
    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);
    response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    setListenerCommand = "{" +
        "'set-listener' : " +
        "{" +
        "'name' : 'srt'," +
        "'trigger' : 'search_rate_trigger3'," +
        "'stage' : ['FAILED','SUCCEEDED']," +
        "'afterAction': ['compute', 'execute']," +
        "'class' : '" + CapturingTriggerListener.class.getName() + "'" +
        "}" +
        "}";
    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);
    response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    setListenerCommand = "{" +
        "'set-listener' : " +
        "{" +
        "'name' : 'finished'," +
        "'trigger' : 'search_rate_trigger3'," +
        "'stage' : ['SUCCEEDED']," +
        "'class' : '" + FinishedProcessingListener.class.getName() + "'" +
        "}" +
        "}";
    req = createAutoScalingRequest(SolrRequest.METHOD.POST, setListenerCommand);
    response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));

    // enable the trigger
    String resumeTriggerCommand = "{" +
        "'resume-trigger' : {" +
        "'name' : 'search_rate_trigger3'" +
        "}" +
        "}";
    req = createAutoScalingRequest(SolrRequest.METHOD.POST, resumeTriggerCommand);
    response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    timeSource.sleep(TimeUnit.MILLISECONDS.convert(waitForSeconds + 1, TimeUnit.SECONDS));

    boolean await = started.await(20, TimeUnit.SECONDS);
    assertTrue("The trigger did not fire at all", await);
    await = finished.await(90, TimeUnit.SECONDS);
    assertTrue("The trigger did not finish processing", await);

    // suspend the trigger
    String suspendTriggerCommand = "{" +
        "'suspend-trigger' : {" +
        "'name' : 'search_rate_trigger3'" +
        "}" +
        "}";
    req = createAutoScalingRequest(SolrRequest.METHOD.POST, suspendTriggerCommand);
    response = solrClient.request(req);
    assertEquals(response.get("result").toString(), "success");

    timeSource.sleep(5000);

    List<CapturedEvent> events = listenerEvents.get("srt");
    assertEquals(events.toString(), 3, events.size());

    CapturedEvent ev = events.get(0);
    assertEquals(ev.toString(), "compute", ev.actionName);
    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);
    assertNotNull("there should be some requestedOps: " + ev.toString(), ops);
    // 4 DELETEREPLICA, 4 DELETENODE
    assertEquals(ops.toString(), 8, ops.size());
    AtomicInteger replicas = new AtomicInteger();
    AtomicInteger nodes = new AtomicInteger();
    ops.forEach(op -> {
      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {
        replicas.incrementAndGet();
      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {
        nodes.incrementAndGet();
      } else {
        fail("unexpected op: " + op);
      }
    });
    assertEquals(ops.toString(), 4, replicas.get());
    assertEquals(ops.toString(), 4, nodes.get());
    // check status
    ev = events.get(1);
    assertEquals(ev.toString(), "execute", ev.actionName);
    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get("properties.responses");
    assertNotNull(ev.toString(), responses);
    assertEquals(responses.toString(), 8, responses.size());
    replicas.set(0);
    nodes.set(0);
    responses.forEach(m -> {
      if (m.get("success") != null) {
        replicas.incrementAndGet();
      } else if (m.get("status") != null) {
        NamedList<Object> status = (NamedList<Object>)m.get("status");
        if ("completed".equals(status.get("state"))) {
          nodes.incrementAndGet();
        } else {
          fail("unexpected DELETENODE status: " + m);
        }
      } else {
        fail("unexpected status: " + m);
      }
    });

    assertEquals(responses.toString(), 4, replicas.get());
    assertEquals(responses.toString(), 4, nodes.get());

    // we are left with one searchable replica
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 1));
  }

