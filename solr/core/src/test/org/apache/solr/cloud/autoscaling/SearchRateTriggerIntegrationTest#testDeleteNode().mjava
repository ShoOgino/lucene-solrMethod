  @Test
  @AwaitsFix(bugUrl="https://issues.apache.org/jira/browse/SOLR-13163") 
  public void testDeleteNode() throws Exception {
    CloudSolrClient solrClient = cluster.getSolrClient();
    String COLL1 = "deleteNode_collection";
    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(COLL1,
        "conf", 1, 2);

    create.process(solrClient);
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 2));

    // add a couple of spare replicas above RF. Use different types to verify that only
    // searchable replicas are considered
    // these additional replicas will be placed on other nodes in the cluster
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.NRT));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.TLOG));
    solrClient.request(CollectionAdminRequest.addReplicaToShard(COLL1, "shard1", Replica.Type.PULL));

    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 5));

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-trigger' : {" +
       "'name' : 'search_rate_trigger3'," +
       "'event' : 'searchRate'," +
       "'waitFor' : '" + waitForSeconds + "s'," +
       "'enabled' : false," +
       "'collections' : '" + COLL1 + "'," +
       "'aboveRate' : 1.0," +
       "'aboveNodeRate' : 1.0," +
       // RecoveryStrategy calls /admin/ping, which calls /select so the rate may not be zero
       // even when no external requests were made .. but it's hard to predict exactly
       // what it will be.  use an insanely high rate so all shards/nodes are suspect
       // and produce an Op regardless of how much internal traffic is produced...
       "'belowRate' : 1.0," +
       "'belowNodeRate' : 1.0," +
       // ...our Ops should be to delete underutilised nodes...
       "'belowNodeOp' : 'DELETENODE'," +
       // ...allow deleting all spare replicas...
       "'minReplicas' : 1," +
       // ...and allow requesting all deletions in one event.
       "'maxOps' : 10," +
       "'actions' : [" +
       "{'name':'compute','class':'" + ComputePlanAction.class.getName() + "'}," +
       "{'name':'execute','class':'" + ExecutePlanAction.class.getName() + "'}" +
       "]" +
       "}}");

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'started'," +
       "'trigger' : 'search_rate_trigger3'," +
       "'stage' : ['STARTED']," +
       "'class' : '" + StartedProcessingListener.class.getName() + "'" +
       "}" +
       "}");

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'srt'," +
       "'trigger' : 'search_rate_trigger3'," +
       "'stage' : ['FAILED','SUCCEEDED']," +
       "'afterAction': ['compute', 'execute']," +
       "'class' : '" + CapturingTriggerListener.class.getName() + "'" +
       "}" +
       "}");
    listenerEventLatch = new CountDownLatch(3);

    CloudTestUtils.assertAutoScalingRequest
      (cloudManager, 
       "{" +
       "'set-listener' : " +
       "{" +
       "'name' : 'finished'," +
       "'trigger' : 'search_rate_trigger3'," +
       "'stage' : ['SUCCEEDED']," +
       "'class' : '" + FinishedProcessingListener.class.getName() + "'" +
       "}" +
       "}");
    
    // Explicitly Do Nothing Here
    
    // enable the trigger
    CloudTestUtils.assertAutoScalingRequest
      (cloudManager,
       "{" +
       "'resume-trigger' : {" +
       "'name' : 'search_rate_trigger3'" +
       "}" +
       "}");

    assertTrue("The trigger did not start in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("The trigger did not finish in a reasonable amount of time",
               started.await(60, TimeUnit.SECONDS));
    
    assertTrue("the listener should have recorded all events w/in a reasonable amount of time",
               listenerEventLatch.await(60, TimeUnit.SECONDS));
    
    // suspend the trigger
    CloudTestUtils.assertAutoScalingRequest
      (cloudManager,
       "{" +
       "'suspend-trigger' : {" +
       "'name' : 'search_rate_trigger3'" +
       "}" +
       "}");

    List<CapturedEvent> events = listenerEvents.get("srt");
    assertEquals(events.toString(), 3, events.size());

    CapturedEvent ev = events.get(0);
    assertEquals(ev.toString(), "compute", ev.actionName);
    List<TriggerEvent.Op> ops = (List<TriggerEvent.Op>)ev.event.getProperty(TriggerEvent.REQUESTED_OPS);
    assertNotNull("there should be some requestedOps: " + ev.toString(), ops);
    // 4 DELETEREPLICA, 4 DELETENODE (minReplicas==1 & leader should be protected)
    assertEquals(ops.toString(), 4 + 4, ops.size());
    // The above assert can fail with actual==9 because all 5 nodes are resulting in a DELETENODE
    // Which is problemtatic for 2 reasons:
    //  1) it means that the leader node has not been protected from the 'belowNodeOp':'DELETENODE'
    //     - definitely a bug that needs fixed
    //  2) it suggests that minReplicas isn't being respected by 'belowNodeOp':'DELETENODE'
    //     - something that needs more rigerous testing
    //     - ie: if belowRate==0 && belowNodeRate==1 && minReplicas==2, will leader + 1 be protected?
    //
    // In general, to adequately trust testing of 'belowNodeOp':'DELETENODE' we should also test:
    //  - some nodes with multiple replicas of the shard to ensure best nodes are picked
    //  - node nodes hosting replicas of multiple shards/collection, only some of which are belowNodeRate



    AtomicInteger replicas = new AtomicInteger();
    AtomicInteger nodes = new AtomicInteger();
    ops.forEach(op -> {
      if (op.getAction().equals(CollectionParams.CollectionAction.DELETEREPLICA)) {
        replicas.incrementAndGet();
      } else if (op.getAction().equals(CollectionParams.CollectionAction.DELETENODE)) {
        nodes.incrementAndGet();
      } else {
        fail("unexpected op: " + op);
      }
    });
    assertEquals(ops.toString(), 4, replicas.get());
    assertEquals(ops.toString(), 4, nodes.get());
    // check status
    ev = events.get(1);
    assertEquals(ev.toString(), "execute", ev.actionName);
    List<NamedList<Object>> responses = (List<NamedList<Object>>)ev.context.get("properties.responses");
    assertNotNull(ev.toString(), responses);
    assertEquals(responses.toString(), 8, responses.size());
    replicas.set(0);
    nodes.set(0);
    responses.forEach(m -> {
      if (m.get("success") != null) {
        replicas.incrementAndGet();
      } else if (m.get("status") != null) {
        Object status = m.get("status");
        String state;
        if (status instanceof Map) {
          state = (String)((Map)status).get("state");
        } else if (status instanceof NamedList) {
          state = (String)((NamedList)status).get("state");
        } else {
          throw new IllegalArgumentException("unsupported status format: " + status.getClass().getName() + ", " + status);
        }
        if ("completed".equals(state)) {
          nodes.incrementAndGet();
        } else {
          fail("unexpected DELETENODE status: " + m);
        }
      } else {
        fail("unexpected status: " + m);
      }
    });

    assertEquals(responses.toString(), 4, replicas.get());
    assertEquals(responses.toString(), 4, nodes.get());

    // we are left with one searchable replica
    CloudTestUtils.waitForState(cloudManager, COLL1, 60, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(1, 1));
  }

