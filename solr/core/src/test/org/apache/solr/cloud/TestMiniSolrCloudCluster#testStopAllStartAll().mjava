  @Test
  public void testStopAllStartAll() throws Exception {

    final String collectionName = "testStopAllStartAllCollection";

    final MiniSolrCloudCluster miniCluster = createMiniSolrCloudCluster();

    try {
      assertNotNull(miniCluster.getZkServer());
      List<JettySolrRunner> jettys = miniCluster.getJettySolrRunners();
      assertEquals(NUM_SERVERS, jettys.size());
      for (JettySolrRunner jetty : jettys) {
        assertTrue(jetty.isRunning());
      }

      createCollection(miniCluster, collectionName, null, null, Boolean.TRUE, null);
      final CloudSolrClient cloudSolrClient = miniCluster.getSolrClient();
      cloudSolrClient.setDefaultCollection(collectionName);
      final SolrQuery query = new SolrQuery("*:*");
      final SolrInputDocument doc = new SolrInputDocument();

      try (SolrZkClient zkClient = new SolrZkClient
          (miniCluster.getZkServer().getZkAddress(), AbstractZkTestCase.TIMEOUT, 45000, null);
          ZkStateReader zkStateReader = new ZkStateReader(zkClient)) {
        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);

        // modify collection
        final int numDocs = 1 + random().nextInt(10);
        for (int ii = 1; ii <= numDocs; ++ii) {
          doc.setField("id", ""+ii);
          cloudSolrClient.add(doc);
          if (ii*2 == numDocs) cloudSolrClient.commit();
        }
        cloudSolrClient.commit();
        // query collection
        {
          final QueryResponse rsp = cloudSolrClient.query(query);
          assertEquals(numDocs, rsp.getResults().getNumFound());
        }

        // the test itself
        zkStateReader.updateClusterState();
        final ClusterState clusterState = zkStateReader.getClusterState();

        final HashSet<Integer> leaderIndices = new HashSet<Integer>();
        final HashSet<Integer> followerIndices = new HashSet<Integer>();
        {
          final HashMap<String,Boolean> shardLeaderMap = new HashMap<String,Boolean>();
          for (final Slice slice : clusterState.getSlices(collectionName)) {
            for (final Replica replica : slice.getReplicas()) {
              shardLeaderMap.put(replica.getNodeName().replace("_solr", "/solr"), Boolean.FALSE);
            }
            shardLeaderMap.put(slice.getLeader().getNodeName().replace("_solr", "/solr"), Boolean.TRUE);
          }
          for (int ii = 0; ii < jettys.size(); ++ii) {
            final URL jettyBaseUrl = jettys.get(ii).getBaseUrl();
            final String jettyBaseUrlString = jettyBaseUrl.toString().substring((jettyBaseUrl.getProtocol() + "://").length());
            final Boolean isLeader = shardLeaderMap.get(jettyBaseUrlString);
            if (Boolean.TRUE.equals(isLeader)) {
              leaderIndices.add(new Integer(ii));
            } else if (Boolean.FALSE.equals(isLeader)) {
              followerIndices.add(new Integer(ii));
            } // else neither leader nor follower i.e. node without a replica (for our collection)
          }
        }
        final List<Integer> leaderIndicesList = new ArrayList<Integer>(leaderIndices);
        final List<Integer> followerIndicesList = new ArrayList<Integer>(followerIndices);

        // first stop the followers (in no particular order)
        Collections.shuffle(followerIndicesList, random());
        for (Integer ii : followerIndicesList) {
          if (!leaderIndices.contains(ii)) {
            miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));
          }
        }

        // then stop the leaders (again in no particular order)
        Collections.shuffle(leaderIndicesList, random());
        for (Integer ii : leaderIndicesList) {
          miniCluster.stopJettySolrRunner(jettys.get(ii.intValue()));
        }

        // calculate restart order
        final List<Integer> restartIndicesList = new ArrayList<Integer>();
        Collections.shuffle(leaderIndicesList, random());
        restartIndicesList.addAll(leaderIndicesList);
        Collections.shuffle(followerIndicesList, random());
        restartIndicesList.addAll(followerIndicesList);
        if (random().nextBoolean()) Collections.shuffle(restartIndicesList, random());

        // and then restart jettys in that order
        for (Integer ii : restartIndicesList) {
          final JettySolrRunner jetty = jettys.get(ii.intValue());
          if (!jetty.isRunning()) {
            miniCluster.startJettySolrRunner(jetty);
            assertTrue(jetty.isRunning());
          }
        }
        AbstractDistribZkTestBase.waitForRecoveriesToFinish(collectionName, zkStateReader, true, true, 330);

        zkStateReader.updateClusterState();

        // re-query collection
        {
          final QueryResponse rsp = cloudSolrClient.query(query);
          assertEquals(numDocs, rsp.getResults().getNumFound());
        }

        // delete the collection we created earlier
        miniCluster.deleteCollection(collectionName);
        AbstractDistribZkTestBase.waitForCollectionToDisappear(collectionName, zkStateReader, true, true, 330);
      }
    }
    finally {
      miniCluster.shutdown();
    }
  }

