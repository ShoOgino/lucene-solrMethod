  @Test
  public void testTargetCollectionNotAvailable() throws Exception {
    createCollections();

    // send start action to first shard
    CdcrTestsUtil.cdcrStart(sourceSolrClient);

    assertNotSame(null, CdcrTestsUtil.waitForClusterToSync
        (sourceSolrClient.query(new SolrQuery(ALL_Q)).getResults().getNumFound(), targetSolrClient));

    // sleep for a bit to ensure that replicator threads are started
    Thread.sleep(3000);

    target.deleteAllCollections();

    CdcrTestsUtil.indexRandomDocs(6, sourceSolrClient);
    assertEquals(6L, sourceSolrClient.query(new SolrQuery(ALL_Q)).getResults().getNumFound());

    // we need to wait until the replicator thread is triggered
    int cnt = 15; // timeout after 15 seconds
    AssertionError lastAssertionError = null;
    while (cnt > 0) {
      try {
        QueryResponse rsp = CdcrTestsUtil.invokeCdcrAction(sourceSolrClient, CdcrParams.CdcrAction.ERRORS);
        @SuppressWarnings({"rawtypes"})
        NamedList collections = (NamedList) ((NamedList) rsp.getResponse().get(CdcrParams.ERRORS)).getVal(0);
        @SuppressWarnings({"rawtypes"})
        NamedList errors = (NamedList) collections.get(TARGET_COLLECTION);
        assertTrue(0 < (Long) errors.get(CdcrParams.CONSECUTIVE_ERRORS));
        @SuppressWarnings({"rawtypes"})
        NamedList lastErrors = (NamedList) errors.get(CdcrParams.LAST);
        assertNotNull(lastErrors);
        assertTrue(0 < lastErrors.size());
        deleteCollections();
        return;
      } catch (AssertionError e) {
        lastAssertionError = e;
        cnt--;
        Thread.sleep(1000);
      }
    }

    deleteCollections();
    throw new AssertionError("Timeout while trying to assert replication errors", lastAssertionError);
  }

