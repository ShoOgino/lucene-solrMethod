  private long doTestNodeLost(int waitFor, long killDelay, int minIgnored) throws Exception {
    SolrClient solrClient = cluster.simGetSolrClient();
    assertAutoScalingRequest
      ( "{" +
        "'set-trigger' : {" +
        "'name' : 'node_lost_trigger3'," +
        "'event' : 'nodeLost'," +
        "'waitFor' : '" + waitFor + "s'," +
        "'enabled' : true," +
        "'actions' : [" +
        "{'name':'start','class':'" + StartTriggerAction.class.getName() + "'}," +
        "{'name':'compute','class':'" + ComputePlanAction.class.getName() + "'}," +
        "{'name':'execute','class':'" + ExecutePlanAction.class.getName() + "'}," +
        "{'name':'test','class':'" + FinishTriggerAction.class.getName() + "'}" +
        "]" +
        "}}");

    assertAutoScalingRequest
      ( "{" +
        "'set-listener' : " +
        "{" +
        "'name' : 'failures'," +
        "'trigger' : 'node_lost_trigger3'," +
        "'stage' : ['FAILED']," +
        "'class' : '" + TestTriggerListener.class.getName() + "'" +
        "}" +
        "}");

    assertAutoscalingUpdateComplete();

    // create a collection with 1 replica per node
    String collectionName = "testNodeLost";
    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName,
        "conf", NUM_NODES / 5, NUM_NODES / 10);
    create.setMaxShardsPerNode(5);
    create.setAutoAddReplicas(false);
    create.process(solrClient);

    log.info("Ready after " + CloudTestUtils.waitForState(cluster, collectionName, 60 * NUM_NODES, TimeUnit.SECONDS,
        CloudTestUtils.clusterShape(NUM_NODES / 5, NUM_NODES / 10, false, true)) + " ms");

    // start killing nodes
    int numNodes = NUM_NODES / 5;
    List<String> nodes = new ArrayList<>(cluster.getLiveNodesSet().get());
    for (int i = 0; i < numNodes; i++) {
      // this may also select a node where a replica is moved to, so the total number of
      // MOVEREPLICA may vary
      cluster.simRemoveNode(nodes.get(i), false);
      cluster.getTimeSource().sleep(killDelay);
    }
    // wait for the trigger to fire and complete at least once
    assertTrue("Trigger did not finish even after await()ing an excessive amount of time",
               triggerFinishedLatch.await(60, TimeUnit.SECONDS));
               
    List<SolrInputDocument> systemColl = cluster.simGetSystemCollection();
    int startedEventPos = -1;

    for (int i = 0; i < systemColl.size(); i++) {
      SolrInputDocument d = systemColl.get(i);
      if (!"node_lost_trigger3".equals(d.getFieldValue("event.source_s"))) {
        continue;
      }
      if ("NODELOST".equals(d.getFieldValue("event.type_s")) &&
          "STARTED".equals(d.getFieldValue("stage_s"))) {
        startedEventPos = i;
        break;
      }

    }
    
    // TODO we may not even have a .system collection because the message of node going down is interrupted on the executor
    // by the OverseerTriggerThread executors being interrupted on Overseer restart

      if (systemColl.size() > 0) {
        return 0;
      }
      assertTrue("no STARTED event: " + systemColl + ", " +
          "waitFor=" + waitFor + ", killDelay=" + killDelay + ", minIgnored=" + minIgnored,
          startedEventPos > -1);
    SolrInputDocument startedEvent = systemColl.get(startedEventPos);
    // we can expect some failures when target node in MOVEREPLICA has been killed
    // between when the event processing started and the actual moment of MOVEREPLICA execution
    // wait until started == (finished + failed)
    TimeOut timeOut = new TimeOut(20 * waitFor * NUM_NODES, TimeUnit.SECONDS, cluster.getTimeSource());
    while (!timeOut.hasTimedOut()) {
      if (triggerStartedCount.get() == triggerFinishedCount.get()) {
        break;
      }
      log.debug("started=" + triggerStartedCount.get() + ", finished=" + triggerFinishedCount.get() +
          ", failed=" + listenerEvents.size());
      timeOut.sleep(1000);
    }
    if (timeOut.hasTimedOut()) {
      if (triggerStartedCount.get() > triggerFinishedCount.get() + listenerEvents.size()) {
        fail("did not finish processing all events in time: started=" + triggerStartedCount.get() + ", finished=" + triggerFinishedCount.get() +
            ", failed=" + listenerEvents.size());
      }
    }
    int ignored = 0;
    int lastIgnoredPos = startedEventPos;
    for (int i = startedEventPos + 1; i < systemColl.size(); i++) {
      SolrInputDocument d = systemColl.get(i);
      if (!"node_lost_trigger3".equals(d.getFieldValue("event.source_s"))) {
        continue;
      }
      if ("NODELOST".equals(d.getFieldValue("event.type_s"))) {
        if ("IGNORED".equals(d.getFieldValue("stage_s"))) {
          ignored++;
          lastIgnoredPos = i;
        }
      }
    }
    assertTrue("should be at least " + minIgnored + " IGNORED events, " +
            "waitFor=" + waitFor + ", killDelay=" + killDelay + ", minIgnored=" + minIgnored,
            ignored >= minIgnored);
    // make sure some replicas have been moved
    assertTrue("no MOVEREPLICA ops? " +
            "waitFor=" + waitFor + ", killDelay=" + killDelay + ", minIgnored=" + minIgnored,
            cluster.simGetOpCount("MOVEREPLICA") > 0);

    if (listenerEvents.isEmpty()) {
      // no failed movements - verify collection shape
      log.info("Ready after " + CloudTestUtils.waitForState(cluster, collectionName, 20 * NUM_NODES, TimeUnit.SECONDS,
          CloudTestUtils.clusterShape(NUM_NODES / 5, NUM_NODES / 10, false, true)) + " ms");
    } else {
      cluster.getTimeSource().sleep(NUM_NODES * 100);
    }

    int count = 50;
    SolrInputDocument finishedEvent = null;
    long lastNumOps = cluster.simGetOpCount("MOVEREPLICA");
    while (count-- > 0) {
      cluster.getTimeSource().sleep(waitFor * 10000);
      long currentNumOps = cluster.simGetOpCount("MOVEREPLICA");
      if (currentNumOps == lastNumOps) {
        int size = systemColl.size() - 1;
        for (int i = size; i > lastIgnoredPos; i--) {
          SolrInputDocument d = systemColl.get(i);
          if (!"node_lost_trigger3".equals(d.getFieldValue("event.source_s"))) {
            continue;
          }
          if ("SUCCEEDED".equals(d.getFieldValue("stage_s"))) {
            finishedEvent = d;
            break;
          }
        }
        break;
      } else {
        lastNumOps = currentNumOps;
      }
    }

    assertTrue("did not finish processing changes, " +
            "waitFor=" + waitFor + ", killDelay=" + killDelay + ", minIgnored=" + minIgnored,
            finishedEvent != null);
    Long delta = 0L;
    if (startedEvent != null) {
      delta = (Long) finishedEvent.getFieldValue("event.time_l")
          - (Long) startedEvent.getFieldValue("event.time_l");
      delta = TimeUnit.NANOSECONDS.toMillis(delta);
      log.info("#### System stabilized after " + delta + " ms");
    }
    long ops = cluster.simGetOpCount("MOVEREPLICA");
    long expectedMinOps = 40;
    if (!listenerEvents.isEmpty()) {
      expectedMinOps = 20;
    }
    assertTrue("unexpected number (" + expectedMinOps + ") of MOVEREPLICA ops: " + ops + ", " +
            "waitFor=" + waitFor + ", killDelay=" + killDelay + ", minIgnored=" + minIgnored,
            ops >= expectedMinOps);
    return delta;
  }

