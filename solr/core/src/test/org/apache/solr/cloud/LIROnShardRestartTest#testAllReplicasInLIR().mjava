  public void testAllReplicasInLIR() throws Exception {
    String collection = "allReplicasInLIR";
    CollectionAdminRequest.createCollection(collection, 1, 3)
        .process(cluster.getSolrClient());
    cluster.getSolrClient().add(collection, new SolrInputDocument("id", "1"));
    cluster.getSolrClient().add(collection, new SolrInputDocument("id", "2"));
    cluster.getSolrClient().commit(collection);

    DocCollection docCollection = getCollectionState(collection);
    Slice shard1 = docCollection.getSlice("shard1");
    Replica newLeader = shard1.getReplicas(rep -> !rep.getName().equals(shard1.getLeader().getName())).get(random().nextInt(2));
    JettySolrRunner jettyOfNewLeader = cluster.getJettySolrRunners().stream()
        .filter(jetty -> jetty.getNodeName().equals(newLeader.getNodeName()))
        .findAny().get();
    assertNotNull(jettyOfNewLeader);

    // randomly add too many docs to peer sync to one replica so that only one random replica is the valid leader
    // the versions don't matter, they just have to be higher than what the last 2 docs got
    try (HttpSolrClient client = getHttpSolrClient(jettyOfNewLeader.getBaseUrl().toString())) {
      ModifiableSolrParams params = new ModifiableSolrParams();
      params.set(DistributingUpdateProcessorFactory.DISTRIB_UPDATE_PARAM, DistributedUpdateProcessor.DistribPhase.FROMLEADER.toString());

      for (int i = 0; i < 101; i++) {
        UpdateRequest ureq = new UpdateRequest();
        ureq.setParams(new ModifiableSolrParams(params));
        ureq.add(sdoc("id", 3 + i, "_version_", Long.MAX_VALUE - 1 - i));
        ureq.process(client, collection);
      }
      client.commit(collection);
    }

    ChaosMonkey.stop(cluster.getJettySolrRunners());
    assertTrue("Timeout waiting for all not live",
        ClusterStateUtil.waitForAllReplicasNotLive(cluster.getSolrClient().getZkStateReader(), 45000));

    try (ZkShardTerms zkShardTerms = new ZkShardTerms(collection, "shard1", cluster.getZkClient())) {
      for (Replica replica : docCollection.getReplicas()) {
        zkShardTerms.removeTerm(replica.getName());
      }
    }

    Map<String,Object> stateObj = Utils.makeMap();
    stateObj.put(ZkStateReader.STATE_PROP, "down");
    stateObj.put("createdByNodeName", "test");
    stateObj.put("createdByCoreNodeName", "test");
    byte[] znodeData = Utils.toJSON(stateObj);

    for (Replica replica : docCollection.getReplicas()) {
      try {
        cluster.getZkClient().makePath("/collections/" + collection + "/leader_initiated_recovery/shard1/" + replica.getName(),
            znodeData, true);
      } catch (KeeperException.NodeExistsException e) {

      }
    }

    ChaosMonkey.start(cluster.getJettySolrRunners());
    waitForState("Timeout waiting for active replicas", collection, clusterShape(1, 3));

    assertEquals(103, cluster.getSolrClient().query(collection, new SolrQuery("*:*")).getResults().getNumFound());


    // now expire each node
    for (Replica replica : docCollection.getReplicas()) {
      try {
        // todo remove the condition for skipping leader after SOLR-12166 is fixed
        if (newLeader.getName().equals(replica.getName())) continue;

        cluster.getZkClient().makePath("/collections/" + collection + "/leader_initiated_recovery/shard1/" + replica.getName(),
            znodeData, true);
      } catch (KeeperException.NodeExistsException e) {

      }
    }

    // only 2 replicas join the election and all of them are in LIR state, no one should win the election
    List<String> oldElectionNodes = getElectionNodes(collection, "shard1", cluster.getZkClient());

    for (JettySolrRunner jetty : cluster.getJettySolrRunners()) {
      expire(jetty);
    }

    TimeOut timeOut = new TimeOut(60, TimeUnit.SECONDS, TimeSource.CURRENT_TIME);
    while (!timeOut.hasTimedOut()) {
      List<String> electionNodes = getElectionNodes(collection, "shard1", cluster.getZkClient());
      electionNodes.retainAll(oldElectionNodes);
      if (electionNodes.isEmpty()) break;
    }
    assertFalse("Timeout waiting for replicas rejoin election", timeOut.hasTimedOut());
    try {
      waitForState("Timeout waiting for active replicas", collection, clusterShape(1, 3));
    } catch (Throwable th) {
      String electionPath = "/collections/allReplicasInLIR/leader_elect/shard1/election/";
      List<String> children = zkClient().getChildren(electionPath, null, true);
      LOG.info("Election queue {}", children);
      throw th;
    }

    assertEquals(103, cluster.getSolrClient().query(collection, new SolrQuery("*:*")).getResults().getNumFound());

    CollectionAdminRequest.deleteCollection(collection).process(cluster.getSolrClient());
  }

