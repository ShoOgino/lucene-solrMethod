  public void testSetLimits() throws Exception {
    FastLRUCache<String, Accountable> cache = new FastLRUCache<>();
    Map<String, String> params = new HashMap<>();
    params.put("size", "6");
    params.put("maxRamMB", "8");
    CacheRegenerator cr = new NoOpRegenerator();
    Object o = cache.init(params, null, cr);
    SolrMetricsContext solrMetricsContext = new SolrMetricsContext(metricManager, registry, "foo");
    cache.initializeMetrics(solrMetricsContext, scope);
    for (int i = 0; i < 6; i++) {
      cache.put("" + i, new Accountable() {
        @Override
        public long ramBytesUsed() {
          return 1024 * 1024;
        }
      });
    }
    // no evictions yet
    assertEquals(6, cache.size());
    // this also sets minLimit = 4
    cache.setMaxSize(5);
    // should not happen yet - evictions are triggered by put
    assertEquals(6, cache.size());
    cache.put("6", new Accountable() {
      @Override
      public long ramBytesUsed() {
        return 1024 * 1024;
      }
    });
    // should evict to minLimit
    assertEquals(4, cache.size());

    // modify ram limit
    cache.setMaxRamMB(3);
    // should not happen yet - evictions are triggered by put
    assertEquals(4, cache.size());
    // this evicts down to 3MB * 0.8, ie. ramLowerWaterMark
    cache.put("7", new Accountable() {
      @Override
      public long ramBytesUsed() {
        return 0;
      }
    });
    assertEquals(3, cache.size());
    assertNotNull("5", cache.get("5"));
    assertNotNull("6", cache.get("6"));
    assertNotNull("7", cache.get("7"));

    // scale up

    cache.setMaxRamMB(4);
    cache.put("8", new Accountable() {
      @Override
      public long ramBytesUsed() {
        return 1024 * 1024;
      }
    });
    assertEquals(4, cache.size());

    cache.setMaxSize(10);
    for (int i = 0; i < 6; i++) {
      cache.put("new" + i, new Accountable() {
        @Override
        public long ramBytesUsed() {
          return 0;
        }
      });
    }
    assertEquals(10, cache.size());
  }

