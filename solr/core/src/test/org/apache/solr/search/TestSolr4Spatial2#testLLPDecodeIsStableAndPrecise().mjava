  @Test @Repeat(iterations = 10)
  public void testLLPDecodeIsStableAndPrecise() throws Exception {
    // test that LatLonPointSpatialField decode of docValue will round-trip (re-index then re-decode) to the same value
    @SuppressWarnings({"resource", "IOResourceOpenedButNotSafelyClosed"})
    SolrClient client = new EmbeddedSolrServer(h.getCore());// do NOT close it; it will close Solr

    final String fld = "llp_1_dv_dvasst";
    String ptOrig = GeoTestUtil.nextLatitude() + "," + GeoTestUtil.nextLongitude();
    assertU(adoc("id", "0", fld, ptOrig));
    assertU(commit());
    // retrieve it (probably less precision
    String ptDecoded1 = (String) client.query(params("q", "id:0")).getResults().get(0).get(fld);
    // now write it back
    assertU(adoc("id", "0", fld, ptDecoded1));
    assertU(commit());
    // retrieve it and hopefully the same
    String ptDecoded2 = (String) client.query(params("q", "id:0")).getResults().get(0).get(fld);
    assertEquals("orig:" + ptOrig, ptDecoded1, ptDecoded2);

    // test that the representation is pretty accurate
    final Point ptOrigObj = SpatialUtils.parsePoint(ptOrig, SpatialContext.GEO);
    final Point ptDecodedObj = SpatialUtils.parsePoint(ptDecoded1, SpatialContext.GEO);
    double deltaCentimeters = SpatialContext.GEO.calcDistance(ptOrigObj, ptDecodedObj) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;
//    //See javadocs of LatLonDocValuesField
//    final Point absErrorPt = SpatialContext.GEO.getShapeFactory().pointXY(8.381903171539307E-8, 4.190951585769653E-8);
//    double deltaCentimetersMax
//        = SpatialContext.GEO.calcDistance(absErrorPt, 0,0) * DistanceUtils.DEG_TO_KM * 1000.0 * 100.0;
//    //  equals 1.0420371840922256   which is a bit lower than what we're able to do

    assertTrue("deltaCm too high: " + deltaCentimeters, deltaCentimeters < 1.33);
  }

