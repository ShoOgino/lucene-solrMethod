  @Test
  public void testStressLuceneNRT() throws Exception {
    // update variables
    final int commitPercent = 10;
    final int softCommitPercent = 50; // what percent of the commits are soft
    final int deletePercent = 8;
    final int deleteByQueryPercent = 4;
    final int ndocs = 100;
    int nWriteThreads = 10;
    final int maxConcurrentCommits = 2;   // number of committers at a time... needed if we want to avoid commit errors due to exceeding the max
    final boolean tombstones = false;

    // query variables
    final AtomicLong operations = new AtomicLong(10000000);  // number of query operations to perform in total       // TODO: temporarily high due to lack of stability
    int nReadThreads = 10;

    initModel(ndocs);

    final AtomicInteger numCommitting = new AtomicInteger();

    List<Thread> threads = new ArrayList<Thread>();

    RAMDirectory dir = new RAMDirectory();
    final IndexWriter writer = new IndexWriter(dir, new IndexWriterConfig(Version.LUCENE_40, new WhitespaceAnalyzer(Version.LUCENE_40)));
    writer.commit();
    reader = IndexReader.open(dir);

    for (int i=0; i<nWriteThreads; i++) {
      Thread thread = new Thread("WRITER"+i) {
        Random rand = new Random(random.nextInt());

        @Override
        public void run() {
          try {
            while (operations.get() > 0) {
              int oper = rand.nextInt(100);

              if (oper < commitPercent) {
                if (numCommitting.incrementAndGet() <= maxConcurrentCommits) {
                  Map<Integer,Long> newCommittedModel;
                  long version;
                  IndexReader oldReader;

                  synchronized(TestRealTimeGet.this) {
                    newCommittedModel = new HashMap<Integer,Long>(model);  // take a snapshot
                    version = snapshotCount++;
                    oldReader = reader;
                    oldReader.incRef();  // increment the reference since we will use this for reopening
                  }

                  IndexReader newReader;
                  if (rand.nextInt(100) < softCommitPercent) {
                    // assertU(h.commit("softCommit","true"));
                    newReader = oldReader.reopen(writer, true);
                  } else {
                    // assertU(commit());
                    writer.commit();
                    newReader = oldReader.reopen();
                  }

                  synchronized(TestRealTimeGet.this) {
                    // install the new reader if it's newest (and check the current version since another reader may have already been installed)
                    if (newReader.getVersion() > reader.getVersion()) {
                      reader.decRef();
                      reader = newReader;

                      // install this snapshot only if it's newer than the current one
                      if (version >= committedModelClock) {
                        committedModel = newCommittedModel;
                        committedModelClock = version;
                      }

                    } else if (newReader != oldReader) {
                      // if the same reader, don't decRef.
                      newReader.decRef();
                    }

                    oldReader.decRef();
                  }
                }
                numCommitting.decrementAndGet();
                continue;
              }


              int id = rand.nextInt(ndocs);
              Object sync = syncArr[id];

              // set the lastId before we actually change it sometimes to try and
              // uncover more race conditions between writing and reading
              boolean before = rand.nextBoolean();
              if (before) {
                lastId = id;
              }

              // We can't concurrently update the same document and retain our invariants of increasing values
              // since we can't guarantee what order the updates will be executed.
              synchronized (sync) {
                Long val = model.get(id);
                long nextVal = Math.abs(val)+1;

                if (oper < commitPercent + deletePercent) {
                  // assertU("<delete><id>" + id + "</id></delete>");

                  // add tombstone first
                  if (tombstones) {
                    Document d = new Document();
                    d.add(new Field("id","-"+Integer.toString(id), Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));
                    d.add(new Field(field, Long.toString(nextVal), Field.Store.YES, Field.Index.NO));
                    writer.updateDocument(new Term("id", "-"+Integer.toString(id)), d);
                  }

                  writer.deleteDocuments(new Term("id",Integer.toString(id)));
                  model.put(id, -nextVal);
                } else if (oper < commitPercent + deletePercent + deleteByQueryPercent) {
                  //assertU("<delete><query>id:" + id + "</query></delete>");

                  // add tombstone first
                  if (tombstones) {
                    Document d = new Document();
                    d.add(new Field("id","-"+Integer.toString(id), Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));
                    d.add(new Field(field, Long.toString(nextVal), Field.Store.YES, Field.Index.NO));
                    writer.updateDocument(new Term("id", "-"+Integer.toString(id)), d);
                  }

                  writer.deleteDocuments(new TermQuery(new Term("id", Integer.toString(id))));
                  model.put(id, -nextVal);
                } else {
                  // assertU(adoc("id",Integer.toString(id), field, Long.toString(nextVal)));
                  Document d = new Document();
                  d.add(new Field("id",Integer.toString(id), Field.Store.YES, Field.Index.NOT_ANALYZED_NO_NORMS));
                  d.add(new Field(field, Long.toString(nextVal), Field.Store.YES, Field.Index.NO));
                  writer.updateDocument(new Term("id", Integer.toString(id)), d);

                  if (tombstones) {
                    // remove tombstone after new addition (this should be optional?)
                    writer.deleteDocuments(new Term("id","-"+Integer.toString(id)));
                  }

                  model.put(id, nextVal);
                }
              }

              if (!before) {
                lastId = id;
              }
            }
          } catch (Exception  ex) {
            throw new RuntimeException(ex);
          }
        }
      };

      threads.add(thread);
    }


    for (int i=0; i<nReadThreads; i++) {
      Thread thread = new Thread("READER"+i) {
        Random rand = new Random(random.nextInt());

        @Override
        public void run() {
          try {
            while (operations.decrementAndGet() >= 0) {
              // bias toward a recently changed doc
              int id = rand.nextInt(100) < 25 ? lastId : rand.nextInt(ndocs);

              // when indexing, we update the index, then the model
              // so when querying, we should first check the model, and then the index

              long val;

              synchronized(TestRealTimeGet.this) {
                val = committedModel.get(id);
              }


              IndexReader r;
              synchronized(TestRealTimeGet.this) {
                r = reader;
                r.incRef();
              }

              //  sreq = req("wt","json", "q","id:"+Integer.toString(id), "omitHeader","true");
              IndexSearcher searcher = new IndexSearcher(r);
              Query q = new TermQuery(new Term("id",Integer.toString(id)));
              TopDocs results = searcher.search(q, 1);

              if (results.totalHits == 0 && tombstones) {
                // if we couldn't find the doc, look for it's tombstone
                q = new TermQuery(new Term("id","-"+Integer.toString(id)));
                results = searcher.search(q, 1);
                if (results.totalHits == 0) {
                  if (val == -1L) {
                    // expected... no doc was added yet
                    continue;
                  }
                  fail("No documents or tombstones found for id " + id + ", expected at least " + val);
                }
              }

              if (results.totalHits == 0 && !tombstones) {
                // nothing to do - we can't tell anything from a deleted doc without tombstones
              } else {
                assertEquals(1, results.totalHits);   // we should have found the document, or it's tombstone
                Document doc = searcher.doc(results.scoreDocs[0].doc);
                long foundVal = Long.parseLong(doc.get(field));
                if (foundVal < Math.abs(val)) {
                  System.out.println("model_val="+val+" foundVal="+foundVal);
                }
                assertTrue(foundVal >= Math.abs(val));
              }

              r.decRef();
            }
          }
          catch (Throwable e) {
            operations.set(-1L);
            SolrException.log(log,e);
            fail(e.toString());
          }
        }
      };

      threads.add(thread);
    }


    for (Thread thread : threads) {
      thread.start();
    }

    for (Thread thread : threads) {
      thread.join();
    }

    writer.close();
    reader.close();

  }

