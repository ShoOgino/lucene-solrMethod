  /**
   * Test that minShouldMatch applies to Optional terms only
   */
  public void testMinShouldMatchOptional() throws Exception {
    assertQ("test minShouldMatch (top level optional terms only)",
        req("q", "stocks oil gold", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold))~1)
            "qf", "text_sw",
            "mm", "50%",
            "defType", "edismax")
        , "*[count(//doc)=4]");
    
    assertQ("test minShouldMatch (top level optional and negative terms mm=50%)",
        req("q", "stocks oil gold -stockade", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~1)
            "qf", "text_sw",
            "mm", "50%",
            "defType", "edismax")
        , "*[count(//doc)=3]");

    assertQ("test minShouldMatch (top level optional and negative terms mm=100%)",
        req("q", "stocks gold -stockade", // +(((text_sw:stock) (text_sw:oil) (text_sw:gold) -(text_sw:stockad))~2)
            "qf", "text_sw",
            "mm", "100%",
            "defType", "edismax")
        , "*[count(//doc)=1]");

    assertQ("test minShouldMatch (top level required terms only)",
        req("q", "stocks AND oil", // +(+(text_sw:stock) +(text_sw:oil))
            "qf", "text_sw",
            "mm", "50%",
            "defType", "edismax")
        , "*[count(//doc)=1]");

    assertQ("test minShouldMatch (top level optional and required terms)",
        req("q", "oil gold +stocks", // +(((text_sw:oil) (text_sw:gold) +(text_sw:stock))~1)
            "qf", "text_sw",
            "mm", "50%",
            "defType", "edismax")
        , "*[count(//doc)=3]");

    assertQ("test minShouldMatch (top level optional with explicit OR and parens)",
        req("q", "(snake OR stocks) oil",
            "qf", "text_sw",
            "mm", "100%",
            "defType", "edismax")
        , "*[count(//doc)=2]");

    // The results for these two appear odd, but are correct as per BooleanQuery processing.
    // See: http://searchhub.org/2011/12/28/why-not-and-or-and-not/
    // Non-parenthesis OR/AND precedence is not true to abstract boolean logic in solr when q.op = AND
    //   and when q.op = OR all three clauses are top-level and optional so mm takes over
    assertQ("test minShouldMatch (top level optional with explicit OR without parens)",
        req("q", "snake OR stocks oil",
            "qf", "text_sw",
            "q.op", "OR",
            "mm", "100%",
            "defType", "edismax")
        , "*[count(//doc)=0]");
    assertQ("test minShouldMatch (top level optional with explicit OR without parens)",
        req("q", "snake OR stocks oil",
            "qf", "text_sw",
            "q.op", "AND",
            "mm", "100%",
            "defType", "edismax")
        , "*[count(//doc)=0]");
  }

