  public void testMaxIdleTime() throws Exception {
    int IDLE_TIME_SEC = 600;
    long IDLE_TIME_NS = TimeUnit.NANOSECONDS.convert(IDLE_TIME_SEC, TimeUnit.SECONDS);
    CountDownLatch sweepFinished = new CountDownLatch(1);
    ConcurrentLRUCache<String, Accountable> cache = new ConcurrentLRUCache<>(6, 5, 5, 6, false, false, null, IDLE_TIME_SEC) {
      @Override
      public void markAndSweep() {
        super.markAndSweep();
        sweepFinished.countDown();
      }
    };
    long currentTime = TimeSource.NANO_TIME.getEpochTimeNs();
    for (int i = 0; i < 4; i++) {
      cache.putCacheEntry(new ConcurrentLRUCache.CacheEntry<>("" + i, new Accountable() {
        @Override
        public long ramBytesUsed() {
          return 1024 * 1024;
        }
      }, currentTime, 0));
    }
    // no evictions yet
    assertEquals(4, cache.size());
    assertEquals("markAndSweep spurious run", 1, sweepFinished.getCount());
    cache.putCacheEntry(new ConcurrentLRUCache.CacheEntry<>("4", new Accountable() {
      @Override
      public long ramBytesUsed() {
        return 0;
      }
    }, currentTime - IDLE_TIME_NS * 2, 0));
    boolean await = sweepFinished.await(10, TimeUnit.SECONDS);
    assertTrue("did not evict entries in time", await);
    assertEquals(4, cache.size());
    assertNull(cache.get("4"));
  }

