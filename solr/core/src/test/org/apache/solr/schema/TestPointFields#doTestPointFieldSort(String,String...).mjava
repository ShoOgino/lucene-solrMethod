  /**
   * For each value, creates a doc with that value in the specified field and then asserts that
   * asc/desc sorts on that field succeeds and that the docs are in the (relatively) expected order
   *
   * @param field name of field to sort on
   * @param values list of values in ascending order
   */
  private void doTestPointFieldSort(String field, String... values) throws Exception {
    assert values != null && 2 <= values.length;

    // TODO: need to add sort missing coverage...
    //
    // idea: accept "null" as possible value for sort missing tests ?
    //
    // need to account for possibility that multiple nulls will be in non deterministic order
    // always using secondary sort on id seems prudent ... handles any "dups" in values[]
    
    final List<SolrInputDocument> docs = new ArrayList<>(values.length);
    final String[] ascXpathChecks = new String[values.length + 1];
    final String[] descXpathChecks = new String[values.length + 1];
    ascXpathChecks[values.length] = "//*[@numFound='" + values.length + "']";
    descXpathChecks[values.length] = "//*[@numFound='" + values.length + "']";
    
    for (int i = values.length-1; i >= 0; i--) {
      docs.add(sdoc("id", String.valueOf(i), field, String.valueOf(values[i])));
      // reminder: xpath array indexes start at 1
      ascXpathChecks[i]= "//result/doc["+ (1 + i)+"]/str[@name='id'][.='"+i+"']";
      descXpathChecks[i]= "//result/doc["+ (values.length - i) +"]/str[@name='id'][.='"+i+"']";
    }
    
    // ensure doc add order doesn't affect results
    Collections.shuffle(docs, random());
    for (SolrInputDocument doc : docs) {
      assertU(adoc(doc));
    }
    assertU(commit());

    assertQ(req("q", "*:*", "fl", "id", "sort", field + " asc"), 
            ascXpathChecks);
    assertQ(req("q", "*:*", "fl", "id", "sort", field + " desc"), 
            descXpathChecks);

        
    clearIndex();
    assertU(commit());
  }

