  /**
   * Simulate a rotate of JWK key in IdP.
   * Validating of JWK signature will fail since we still use old cached JWK set.
   * Using a mock {@link HttpsJwks} we validate that plugin calls refresh() and then passes validation
   */
  @Test
  public void invalidSigRefreshJwk() throws JoseException {
    RsaJsonWebKey rsaJsonWebKey2 = RsaJwkGenerator.generateJwk(2048);
    rsaJsonWebKey2.setKeyId("k2");
    HashMap<String, Object> testJwkWrong = new HashMap<>();
    testJwkWrong.put("kty", rsaJsonWebKey2.getKeyType());
    testJwkWrong.put("e", BigEndianBigInteger.toBase64Url(rsaJsonWebKey2.getRsaPublicKey().getPublicExponent()));
    testJwkWrong.put("use", rsaJsonWebKey2.getUse());
    testJwkWrong.put("kid", rsaJsonWebKey2.getKeyId());
    testJwkWrong.put("alg", rsaJsonWebKey2.getAlgorithm());
    testJwkWrong.put("n", BigEndianBigInteger.toBase64Url(rsaJsonWebKey2.getRsaPublicKey().getModulus()));
    JsonWebKey wrongJwk = JsonWebKey.Factory.newJwk(testJwkWrong);

    // Configure our mock plugin with URL as jwk source
    JsonWebKey correctJwk = JsonWebKey.Factory.newJwk(testJwk);
    plugin = new MockJwksUrlPlugin(wrongJwk, correctJwk);
    HashMap<String, Object> pluginConfigJwkUrl = new HashMap<>();
    pluginConfigJwkUrl.put("class", "org.apache.solr.security.JWTAuthPlugin");
    pluginConfigJwkUrl.put("jwkUrl", "dummy");
    plugin.init(pluginConfigJwkUrl);

    // Validate that plugin will call refresh() on invalid signature, then the call succeeds
    assertFalse(((MockJwksUrlPlugin)plugin).isRefreshCalled());
    JWTAuthPlugin.JWTAuthenticationResponse resp = plugin.authenticate(testHeader);
    assertTrue(resp.isAuthenticated());
    assertTrue(((MockJwksUrlPlugin)plugin).isRefreshCalled());
  }

