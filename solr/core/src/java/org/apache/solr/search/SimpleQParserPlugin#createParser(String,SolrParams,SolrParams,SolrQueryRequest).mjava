  /** Returns a QParser that will create a query by using Lucene's SimpleQueryParser. */
  @Override
  public QParser createParser(String qstr, SolrParams localParams, SolrParams params, SolrQueryRequest req) {
    // Some of the parameters may come in through localParams, so combine them with params.
    SolrParams defaultParams = SolrParams.wrapDefaults(localParams, params);

    // This will be used to specify what fields and boosts will be used by SimpleQueryParser.
    Map<String, Float> queryFields = SolrPluginUtils.parseFieldBoosts(defaultParams.get(SimpleParams.QF));

    if (queryFields.isEmpty()) {
      // It qf is not specified setup up the queryFields map to use the defaultField.
      String defaultField = QueryParsing.getDefaultField(req.getSchema(), defaultParams.get(CommonParams.DF));

      if (defaultField == null) {
        // A query cannot be run without having a field or set of fields to run against.
        throw new IllegalStateException("Neither " + SimpleParams.QF + ", " + CommonParams.DF
            + ", nor the default search field are present.");
      }

      queryFields.put(defaultField, 1.0F);
    }
    else {
      for (Map.Entry<String, Float> queryField : queryFields.entrySet()) {
        if (queryField.getValue() == null) {
          // Some fields may be specified without a boost, so default the boost to 1.0 since a null value
          // will not be accepted by SimpleQueryParser.
          queryField.setValue(1.0F);
        }
      }
    }

    // Setup the operations that are enabled for the query.
    int enabledOps = 0;
    String opParam = defaultParams.get(SimpleParams.QO);

    if (opParam == null) {
      // All operations will be enabled.
      enabledOps = -1;
    } else {
      // Parse the specified enabled operations to be used by the query.
      String[] operations = opParam.split(",");

      for (String operation : operations) {
        Integer enabledOp = OPERATORS.get(operation.trim().toUpperCase(Locale.ROOT));

        if (enabledOp != null) {
          enabledOps |= enabledOp;
        }
      }
    }

    // Create a SimpleQueryParser using the analyzer from the schema.
    final IndexSchema schema = req.getSchema();
    final SimpleQueryParser parser = new SimpleQueryParser(req.getSchema().getAnalyzer(), queryFields, enabledOps) {
      // Override newPrefixQuery to provide a multi term analyzer for prefix queries run against TextFields.
      @Override
      protected Query newPrefixQuery(String text) {
        BooleanQuery bq = new BooleanQuery(true);

        for (Map.Entry<String, Float> entry : weights.entrySet()) {
          String field = entry.getKey();
          FieldType type = schema.getFieldType(field);
          Query prefix;

          if (type instanceof TextField) {
            // If the field type is a TextField then use the multi term analyzer.
            Analyzer analyzer = ((TextField)type).getMultiTermAnalyzer();
            String term = TextField.analyzeMultiTerm(field, text, analyzer).utf8ToString();
            prefix = new PrefixQuery(new Term(field, term));
          } else {
            // If the type is *not* a TextField don't do any analysis.
            prefix = new PrefixQuery(new Term(entry.getKey(), text));
          }

          prefix.setBoost(entry.getValue());
          bq.add(prefix, BooleanClause.Occur.SHOULD);
        }

        return simplify(bq);
      }
    };

    // Set the default operator to be either 'AND' or 'OR' for the query.
    QueryParser.Operator defaultOp = QueryParsing.getQueryParserDefaultOperator(req.getSchema(), defaultParams.get(QueryParsing.OP));

    if (defaultOp == QueryParser.Operator.AND) {
      parser.setDefaultOperator(BooleanClause.Occur.MUST);
    }

    // Return a QParser that wraps a SimpleQueryParser.
    return new QParser(qstr, localParams, params, req) {
      public Query parse() throws SyntaxError {
        return parser.parse(qstr);
      }
    };
  }

