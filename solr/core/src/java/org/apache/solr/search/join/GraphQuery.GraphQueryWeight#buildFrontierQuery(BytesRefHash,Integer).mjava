    /**
     * This return a query that represents the documents that match the next hop in the query.
     * 
     * collectorTerms - the terms that represent the edge ids for the current frontier.
     * frontierSize - the size of the frontier query (number of unique edges)
     *  
     */
    public FrontierQuery buildFrontierQuery(BytesRefHash collectorTerms, Integer frontierSize) {
      if (collectorTerms == null || collectorTerms.size() == 0) {
        // return null if there are no terms (edges) to traverse.
        return null;
      } else {
        // Create a query
        Query q = null;

        // TODO: see if we should dynamically select this based on the frontier size.
        if (useAutn) {
          // build an automaton based query for the frontier.
          Automaton autn = buildAutomaton(collectorTerms);
          AutomatonQuery autnQuery = new AutomatonQuery(new Term(fromField), autn);
          q = autnQuery;
        } else {
          List<BytesRef> termList = new ArrayList<>(collectorTerms.size());
          for (int i = 0 ; i < collectorTerms.size(); i++) {
            BytesRef ref = new BytesRef();
            collectorTerms.get(i, ref);
            termList.add(ref);
          }
          q = new TermInSetQuery(fromField, termList);
        }
        
        // If there is a filter to be used while crawling the graph, add that.
        if (traversalFilter != null) {
          BooleanQuery.Builder builder = new BooleanQuery.Builder();
          builder.add(q, Occur.MUST);
          builder.add(traversalFilter, Occur.MUST);
          q = builder.build();
        } 
        // return the new query. 
        FrontierQuery frontier = new FrontierQuery(q, frontierSize);
        return frontier;
      }
    }

