  private SimpleOrderedMap<Object> refineBucket(Object bucketVal, boolean skip, Map<String,Object> facetInfo) throws IOException {
    // TODO: refactor this repeated code from above
    Comparable start = calc.getValue(bucketVal.toString());
    Comparable end = calc.getValue(freq.end.toString());
    EnumSet<FacetParams.FacetRangeInclude> include = freq.include;

    String gap = freq.gap.toString();

    Comparable low = calc.getValue(bucketVal.toString());
    Comparable high = calc.addGap(low, gap);
    if (end.compareTo(high) < 0) {
      if (freq.hardend) {
        high = end;
      } else {
        end = high;
      }
    }
    if (high.compareTo(low) < 0) {
      throw new SolrException
          (SolrException.ErrorCode.BAD_REQUEST,
              "range facet infinite loop (is gap negative? did the math overflow?)");
    }
    if (high.compareTo(low) == 0) {
      throw new SolrException
          (SolrException.ErrorCode.BAD_REQUEST,
              "range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: " + low + " + " + gap + " = " + high );
    }

    boolean incLower =
        (include.contains(FacetParams.FacetRangeInclude.LOWER) ||
            (include.contains(FacetParams.FacetRangeInclude.EDGE) &&
                0 == low.compareTo(start)));
    boolean incUpper =
        (include.contains(FacetParams.FacetRangeInclude.UPPER) ||
            (include.contains(FacetParams.FacetRangeInclude.EDGE) &&
                0 == high.compareTo(end)));

    Range range = new Range(calc.buildRangeLabel(low), low, high, incLower, incUpper);


    // now refine this range

    SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();
    bucket.add("val", range.label);
    
    Query domainQ = sf.getType().getRangeQuery(null, sf, range.low == null ? null : calc.formatValue(range.low), range.high==null ? null : calc.formatValue(range.high), range.includeLower, range.includeUpper);
    fillBucket(bucket, domainQ, null, skip, facetInfo);

    return bucket;
  }

