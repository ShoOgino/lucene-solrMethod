  /**
   * Returns the set of document ids matching all queries.
   * This method is cache-aware and attempts to retrieve the answer from the cache if possible.
   * If the answer was not cached, it may have been inserted into the cache as a result of this call.
   * This method can handle negative queries.
   * <p>
   * The DocSet returned should <b>not</b> be modified.
   */
  public DocSet getDocSet(List<Query> queries) throws IOException {
    ProcessedFilter pf = getProcessedFilter(null, queries);
    if (pf.answer != null) return pf.answer;


    DocSetCollector setCollector = new DocSetCollector(maxDoc()>>6, maxDoc());
    Collector collector = setCollector;
    if (pf.postFilter != null) {
      pf.postFilter.setLastDelegate(collector);
      collector = pf.postFilter;
    }

    final AtomicReaderContext[] leaves = leafContexts;


    for (int i=0; i<leaves.length; i++) {
      final AtomicReaderContext leaf = leaves[i];
      final AtomicReader reader = leaf.reader();
      final Bits liveDocs = reader.getLiveDocs();   // TODO: the filter may already only have liveDocs...
      DocIdSet idSet = null;
      if (pf.filter != null) {
        idSet = pf.filter.getDocIdSet(leaf, liveDocs);
        if (idSet == null) continue;
      }
      DocIdSetIterator idIter = null;
      if (idSet != null) {
        idIter = idSet.iterator();
        if (idIter == null) continue;
      }

      collector.setNextReader(leaf);
      int max = reader.maxDoc();

      if (idIter == null) {
        for (int docid = 0; docid<max; docid++) {
          if (liveDocs != null && !liveDocs.get(docid)) continue;
          collector.collect(docid);
        }
      } else {
        for (int docid = -1; (docid = idIter.advance(docid+1)) < max; ) {
          collector.collect(docid);
        }
      }
    }

    return setCollector.getDocSet();
  }

