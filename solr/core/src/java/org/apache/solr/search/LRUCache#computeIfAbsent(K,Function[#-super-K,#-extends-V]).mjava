  @Override
  public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
    synchronized (map) {
      if (getState() == State.LIVE) {
        lookups++;
        stats.lookups.increment();
      }
      AtomicBoolean newEntry = new AtomicBoolean();
      CacheValue<V> entry = map.computeIfAbsent(key, k -> {
        V value = mappingFunction.apply(k);
        // preserve the semantics of computeIfAbsent
        if (value == null) {
          return null;
        }
        CacheValue<V> cacheValue = new CacheValue<>(value, timeSource.getEpochTimeNs());
        if (getState() == State.LIVE) {
          stats.inserts.increment();
        }
        if (syntheticEntries) {
          if (cacheValue.createTime < oldestEntry) {
            oldestEntry = cacheValue.createTime;
          }
        }
        // increment local inserts regardless of state???
        // it does make it more consistent with the current size...
        inserts++;

        // important to calc and add new ram bytes first so that removeEldestEntry can compare correctly
        long keySize = RamUsageEstimator.sizeOfObject(key, QUERY_DEFAULT_RAM_BYTES_USED);
        long valueSize = RamUsageEstimator.sizeOfObject(cacheValue, QUERY_DEFAULT_RAM_BYTES_USED);
        ramBytesUsed += keySize + valueSize + LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;
        newEntry.set(true);
        return cacheValue;
      });
      if (!newEntry.get()) {
        if (getState() == State.LIVE) {
          hits++;
          stats.hits.increment();
        }
      }
      return entry != null ? entry.value : null;
    }
  }

