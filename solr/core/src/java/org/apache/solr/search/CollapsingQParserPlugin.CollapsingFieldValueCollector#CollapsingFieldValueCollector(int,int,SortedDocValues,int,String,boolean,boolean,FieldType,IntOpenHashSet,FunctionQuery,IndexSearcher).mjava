    public CollapsingFieldValueCollector(int maxDoc,
                                         int segments,
                                         SortedDocValues values,
                                         int nullPolicy,
                                         String field,
                                         boolean max,
                                         boolean needsScores,
                                         FieldType fieldType,
                                         IntOpenHashSet boostDocs,
                                         FunctionQuery funcQuery, IndexSearcher searcher) throws IOException{

      this.maxDoc = maxDoc;
      this.contexts = new AtomicReaderContext[segments];
      this.values = values;
      int valueCount = values.getValueCount();
      this.nullPolicy = nullPolicy;
      this.needsScores = needsScores;
      this.boostDocs = boostDocs;
      if(funcQuery != null) {
        this.fieldValueCollapse =  new ValueSourceCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs, funcQuery, searcher);
      } else {
        if(fieldType instanceof TrieIntField) {
          this.fieldValueCollapse = new IntValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs);
        } else if(fieldType instanceof TrieLongField) {
          this.fieldValueCollapse =  new LongValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs);
        } else if(fieldType instanceof TrieFloatField) {
          this.fieldValueCollapse =  new FloatValueCollapse(maxDoc, field, nullPolicy, new int[valueCount], max, this.needsScores, boostDocs);
        } else {
          throw new IOException("min/max must be either TrieInt, TrieLong or TrieFloat.");
        }
      }
    }

