  @Override
  public Object init(Map args, Object persistence, CacheRegenerator regenerator) {
    super.init(args, regenerator);
    String str = (String)args.get(SIZE_PARAM);
    this.maxSize = str==null ? 1024 : Integer.parseInt(str);
    str = (String)args.get("initialSize");
    initialSize = Math.min(str==null ? 1024 : Integer.parseInt(str), maxSize);
    str = (String) args.get(MAX_RAM_MB_PARAM);
    this.maxRamBytes = str == null ? Long.MAX_VALUE : (long) (Double.parseDouble(str) * 1024L * 1024L);
    str = (String) args.get(MAX_IDLE_TIME_PARAM);
    if (str == null) {
      maxIdleTimeNs = Long.MAX_VALUE;
    } else {
      int maxIdleTime = Integer.parseInt(str);
      if (maxIdleTime > 0) {
        maxIdleTimeNs = TimeUnit.NANOSECONDS.convert(Integer.parseInt(str), TimeUnit.SECONDS);
      } else {
        maxIdleTimeNs = Long.MAX_VALUE;
      }
    }
    description = generateDescription();

    map = new LinkedHashMap<K, CacheValue<V>>(initialSize, 0.75f, true) {
        @Override
        protected boolean removeEldestEntry(Map.Entry eldest) {
          // remove items older than maxIdleTimeNs
          if (maxIdleTimeNs != Long.MAX_VALUE) {
            long idleCutoff = timeSource.getEpochTimeNs() - maxIdleTimeNs;
            if (oldestEntry < idleCutoff) {
              long currentOldestEntry = Long.MAX_VALUE;
              Iterator<Map.Entry<K, CacheValue<V>>> iterator = entrySet().iterator();
              while (iterator.hasNext()) {
                Map.Entry<K, CacheValue<V>> entry = iterator.next();
                if (entry.getValue().createTime < idleCutoff) {
                  long bytesToDecrement = RamUsageEstimator.sizeOfObject(entry.getKey(), QUERY_DEFAULT_RAM_BYTES_USED);
                  bytesToDecrement += RamUsageEstimator.sizeOfObject(entry.getValue(), QUERY_DEFAULT_RAM_BYTES_USED);
                  bytesToDecrement += LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;
                  ramBytesUsed -= bytesToDecrement;
                  iterator.remove();
                  evictions++;
                  evictionsIdleTime++;
                  stats.evictionsIdleTime.increment();
                  stats.evictions.increment();
                } else {
                  if (syntheticEntries) {
                    // no guarantee on the actual create time - make a full sweep
                    if (currentOldestEntry > entry.getValue().createTime) {
                      currentOldestEntry = entry.getValue().createTime;
                    }
                  } else {
                    // iterator is sorted by insertion order (and time)
                    // so we can quickly terminate the sweep
                    currentOldestEntry = entry.getValue().createTime;
                    break;
                  }
                }
              }
              if (currentOldestEntry != Long.MAX_VALUE) {
                oldestEntry = currentOldestEntry;
              }
            }
          }
          if (ramBytesUsed > getMaxRamBytes()) {
            Iterator<Map.Entry<K, CacheValue<V>>> iterator = entrySet().iterator();
            do {
              Map.Entry<K, CacheValue<V>> entry = iterator.next();
              long bytesToDecrement = RamUsageEstimator.sizeOfObject(entry.getKey(), QUERY_DEFAULT_RAM_BYTES_USED);
              bytesToDecrement += RamUsageEstimator.sizeOfObject(entry.getValue(), QUERY_DEFAULT_RAM_BYTES_USED);
              bytesToDecrement += LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;
              ramBytesUsed -= bytesToDecrement;
              iterator.remove();
              evictions++;
              evictionsRamUsage++;
              stats.evictions.increment();
              stats.evictionsRamUsage.increment();
            } while (iterator.hasNext() && ramBytesUsed > getMaxRamBytes());
          } else if (size() > getMaxSize()) {
            Iterator<Map.Entry<K, CacheValue<V>>> iterator = entrySet().iterator();
            do {
              Map.Entry<K, CacheValue<V>> entry = iterator.next();
              long bytesToDecrement = RamUsageEstimator.sizeOfObject(entry.getKey(), QUERY_DEFAULT_RAM_BYTES_USED);
              bytesToDecrement += RamUsageEstimator.sizeOfObject(entry.getValue(), QUERY_DEFAULT_RAM_BYTES_USED);
              bytesToDecrement += LINKED_HASHTABLE_RAM_BYTES_PER_ENTRY;
              ramBytesUsed -= bytesToDecrement;
              // increment evictions regardless of state.
              // this doesn't need to be synchronized because it will
              // only be called in the context of a higher level synchronized block.
              iterator.remove();
              evictions++;
              stats.evictions.increment();
            } while (iterator.hasNext() && size() > getMaxSize());
          }
          // must return false according to javadocs of removeEldestEntry if we're modifying
          // the map ourselves
          return false;
        }
      };

    if (persistence==null) {
      // must be the first time a cache of this type is being created
      persistence = new CumulativeStats();
    }

    stats = (CumulativeStats)persistence;

    return persistence;
  }

