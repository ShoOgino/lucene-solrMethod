  /**
   * Builds the necessary collector chain (via delegate wrapping) and executes the query 
   * against it.  This method takes into consideration both the explicitly provided collector 
   * and postFilter as well as any needed collector wrappers for dealing with options 
   * specified in the QueryCOmmand.
   */
  private void buildAndRunCollectorChain(QueryResult qr, Query query,
      Collector collector, QueryCommand cmd, DelegatingCollector postFilter) throws IOException {
    
    final boolean terminateEarly = cmd.getTerminateEarly();
    if (terminateEarly) {
      collector = new EarlyTerminatingCollector(collector, cmd.getLen());
    }

    final long timeAllowed = cmd.getTimeAllowed();
    if( timeAllowed > 0 ) {
      collector = new TimeLimitingCollector(collector, TimeLimitingCollector.getGlobalCounter(), timeAllowed);
    }
    
    if (postFilter != null) {
      postFilter.setLastDelegate(collector);
      collector = postFilter;
    }

    try {
      super.search(query, collector);
    } catch (TimeLimitingCollector.TimeExceededException | ExitableDirectoryReader.ExitingReaderException x) {
      log.warn("Query: " + query + "; " + x.getMessage());
      qr.setPartialResults(true);
    } catch (EarlyTerminatingCollectorException etce) {
      if (collector instanceof DelegatingCollector) {
        ((DelegatingCollector) collector).finish();
      }
      throw etce;
    }
    if (collector instanceof DelegatingCollector) {
      ((DelegatingCollector) collector).finish();
    }
  }

