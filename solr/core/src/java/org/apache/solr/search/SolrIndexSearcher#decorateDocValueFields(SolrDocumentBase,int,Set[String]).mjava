  /**
   * This will fetch and add the docValues fields to a given SolrDocument/SolrInputDocument
   *
   * @param doc
   *          A SolrDocument or SolrInputDocument instance where docValues will be added
   * @param docid
   *          The lucene docid of the document to be populated
   * @param fields
   *          The list of docValues fields to be decorated
   */
  public void decorateDocValueFields(@SuppressWarnings("rawtypes") SolrDocumentBase doc, int docid, Set<String> fields)
      throws IOException {
    final int subIndex = ReaderUtil.subIndex(docid, leafContexts);
    final int localId = docid - leafContexts.get(subIndex).docBase;
    final LeafReader leafReader = leafContexts.get(subIndex).reader();
    for (String fieldName : fields) {
      final SchemaField schemaField = schema.getFieldOrNull(fieldName);
      if (schemaField == null || !schemaField.hasDocValues() || doc.containsKey(fieldName)) {
        log.warn("Couldn't decorate docValues for field: [{}], schemaField: [{}]", fieldName, schemaField);
        continue;
      }

      if (schemaField.multiValued()) {
        final SortedSetDocValues values = leafReader.getSortedSetDocValues(fieldName);
        if (values != null && values.getValueCount() > 0) {
          if (values.advance(localId) == localId) {
            final List<Object> outValues = new LinkedList<Object>();
            for (long ord = values.nextOrd(); ord != SortedSetDocValues.NO_MORE_ORDS; ord = values.nextOrd()) {
              final BytesRef value = values.lookupOrd(ord);
              outValues.add(schemaField.getType().toObject(schemaField, value));
            }
            assert outValues.size() > 0;
            doc.addField(fieldName, outValues);
          }
        }
      } else {
        final DocValuesType dvType = fieldInfos.fieldInfo(fieldName).getDocValuesType();
        switch (dvType) {
          case NUMERIC:
            final NumericDocValues ndv = leafReader.getNumericDocValues(fieldName);
            if (ndv == null) {
              continue;
            }
            Long val;
            if (ndv.advance(localId) == localId) {
              val = ndv.longValue();
            } else {
              continue;
            }
            Object newVal = val;
            if (schemaField.getType() instanceof TrieIntField) {
              newVal = val.intValue();
            } else if (schemaField.getType() instanceof TrieFloatField) {
              newVal = Float.intBitsToFloat(val.intValue());
            } else if (schemaField.getType() instanceof TrieDoubleField) {
              newVal = Double.longBitsToDouble(val);
            } else if (schemaField.getType() instanceof TrieDateField) {
              newVal = new Date(val);
            } else if (schemaField.getType() instanceof EnumField) {
              newVal = ((EnumField) schemaField.getType()).intValueToStringValue(val.intValue());
            }
            doc.addField(fieldName, newVal);
            break;
          case BINARY:
            BinaryDocValues bdv = leafReader.getBinaryDocValues(fieldName);
            if (bdv == null) {
              continue;
            }
            BytesRef value;
            if (bdv.advance(localId) == localId) {
              value = BytesRef.deepCopyOf(bdv.binaryValue());
            } else {
              continue;
            }
            doc.addField(fieldName, value);
            break;
          case SORTED:
            SortedDocValues sdv = leafReader.getSortedDocValues(fieldName);
            if (sdv == null) {
              continue;
            }
            if (sdv.advance(localId) == localId) {
              final BytesRef bRef = sdv.binaryValue();
              // Special handling for Boolean fields since they're stored as 'T' and 'F'.
              if (schemaField.getType() instanceof BoolField) {
                doc.addField(fieldName, schemaField.getType().toObject(schemaField, bRef));
              } else {
                doc.addField(fieldName, bRef.utf8ToString());
              }
            }
            break;
          case SORTED_NUMERIC:
            throw new AssertionError("SORTED_NUMERIC not supported yet!");
          case SORTED_SET:
            throw new AssertionError("SORTED_SET fields should be multi-valued!");
          case NONE:
            break;
        }
      }
    }
  }

