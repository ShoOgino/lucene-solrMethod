  @Override
  public Object getMergedResult() {
    SimpleOrderedMap result = new SimpleOrderedMap();

    if (numBuckets != null) {
      int removed = 0;
      if (freq.mincount > 1) {
        for (FacetBucket bucket : buckets.values()) {
          if (bucket.count < freq.mincount) removed++;
        }
      }
      result.add("numBuckets", ((Number)numBuckets.getMergedResult()).longValue() - removed);

      // TODO: we can further increase this estimate.
      // If not sorting by count, use a simple ratio to scale
      // If sorting by count desc, then add up the highest_possible_missing_count from each shard
    }

    sortBuckets();

    int first = (int)freq.offset;
    int end = freq.limit >=0 ? first + (int) freq.limit : Integer.MAX_VALUE;
    int last = Math.min(sortedBuckets.size(), end);

    List<SimpleOrderedMap> resultBuckets = new ArrayList<>(Math.max(0, (last - first)));

    /** this only works if there are no filters (like mincount)
    for (int i=first; i<last; i++) {
      FacetBucket bucket = sortedBuckets.get(i);
      resultBuckets.add( bucket.getMergedBucket() );
    }
    ***/

    // TODO: change effective offsets + limits at shards...

    int off = (int)freq.offset;
    int lim = freq.limit >= 0 ? (int)freq.limit : Integer.MAX_VALUE;
    for (FacetBucket bucket : sortedBuckets) {
      if (bucket.getCount() < freq.mincount) {
        continue;
      }

      if (off > 0) {
        --off;
        continue;
      }

      if (resultBuckets.size() >= lim) {
        break;
      }

      resultBuckets.add( bucket.getMergedBucket() );
    }


    result.add("buckets", resultBuckets);
    if (missingBucket != null) {
      result.add("missing", missingBucket.getMergedBucket());
    }
    if (allBuckets != null) {
      result.add("allBuckets", allBuckets.getMergedBucket());
    }

    return result;
  }

