  /**
   * Create any required collections and return the name of the collection to which the current document should be sent.
   *
   * @param docTimestamp the date for the document taken from the field specified in the TRA config
   * @param cmd The initial calculated destination collection.
   * @return The name of the proper destination collection for the document which may or may not be a
   *         newly created collection
   */
  private String createCollectionsIfRequired(Instant docTimestamp, AddUpdateCommand cmd) {
    // Even though it is possible that multiple requests hit this code in the 1-2 sec that
    // it takes to create a collection, it's an established anti-pattern to feed data with a very large number
    // of client connections. This in mind, we only guard against spamming the overseer within a batch of
    // updates. We are intentionally tolerating a low level of redundant requests in favor of simpler code. Most
    // super-sized installations with many update clients will likely be multi-tenant and multiple tenants
    // probably don't write to the same alias. As such, we have deferred any solution to the "many clients causing
    // collection creation simultaneously" problem until such time as someone actually has that problem in a
    // real world use case that isn't just an anti-pattern.
    Map.Entry<Instant, String> candidateCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());
    String candidateCollectionName = candidateCollectionDesc.getValue();
    try {
      switch (typeOfCreationRequired(docTimestamp, candidateCollectionDesc.getKey())) {
        case SYNCHRONOUS:
          // This next line blocks until all collections required by the current document have been created
          return createAllRequiredCollections(docTimestamp, cmd.getPrintableId(), candidateCollectionDesc);
        case ASYNC_PREEMPTIVE:
          if (preemptiveCreationExecutor == null) {
            // It's important not to add code between here and the prior call to findCandidateGivenTimestamp()
            // in processAdd() that invokes updateParsedCollectionAliases(). Doing so would update parsedCollectionsDesc
            // and create a race condition. We are relying on the fact that get(0) is returning the head of the parsed
            // collections that existed when candidateCollectionDesc was created. If this class updates it's notion of
            // parsedCollectionsDesc since candidateCollectionDesc was chosen, we could create collection n+2
            // instead of collection n+1.
            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();

            // This line does not block and the document can be added immediately
            preemptiveAsync(() -> createNextCollection(mostRecentCollName));
          }
          return candidateCollectionName;
        case NONE:
          return candidateCollectionName; // could use fall through, but fall through is fiddly for later editors.
        default:
          throw unknownCreateType();
      }
      // do nothing if creationType == NONE
    } catch (SolrException e) {
      throw e;
    } catch (Exception e) {
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
    }
  }

