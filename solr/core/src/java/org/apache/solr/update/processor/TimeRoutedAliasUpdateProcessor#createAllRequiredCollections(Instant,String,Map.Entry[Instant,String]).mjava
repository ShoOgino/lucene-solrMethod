  /**
   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp
   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate
   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most
   * recent collection. This assumption is checked when the command is executed in the overseer. When this method
   * finds that all collections required have been created it returns the (possibly new) most recent collection.
   * The return value is ignored by the calling code in the async preemptive case.
   *
   * @param docTimestamp the timestamp from the document that determines routing
   * @param printableId an identifier for the add command used in error messages
   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be
   *                             the most recent collection in all cases where this method is invoked.
   * @return The latest collection, including collections created during maintenance
   */
  private String createAllRequiredCollections( Instant docTimestamp, String printableId,
                                               Map.Entry<Instant, String> targetCollectionDesc) {
    do {
      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {
        case NONE:
          return targetCollectionDesc.getValue(); // we don't need another collection
        case ASYNC_PREEMPTIVE:
          // can happen when preemptive interval is longer than one time slice
          if (!preemptiveCreateOnceAlready) {
            String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();
            preemptiveAsync(() -> createNextCollection(mostRecentCollName));
            return targetCollectionDesc.getValue();
          }
        case SYNCHRONOUS:
          createNextCollection(targetCollectionDesc.getValue()); // *should* throw if fails for some reason but...
          if (!updateParsedCollectionAliases()) { // thus we didn't make progress...
            // this is not expected, even in known failure cases, but we check just in case
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
                "We need to create a new time routed collection but for unknown reasons were unable to do so.");
          }
          // then retry the loop ... have to do find again in case other requests also added collections
          // that were made visible when we called updateParsedCollectionAliases()
          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, printableId);
          break;
        default:
          throw unknownCreateType();
      }
    } while (true);
  }

