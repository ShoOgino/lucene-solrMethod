  private void createCollectionAfter(String mostRecentCollName) {
    // Invoke ROUTEDALIAS_CREATECOLL (in the Overseer, locked by alias name).  It will create the collection
    //   and update the alias contingent on the most recent collection name being the same as
    //   what we think so here, otherwise it will return (without error).
    // To avoid needless concurrent communication with the Overseer from this JVM, we
    //   maintain a Semaphore from an alias name keyed ConcurrentHashMap.
    //   Alternatively a Lock or CountDownLatch could have been used but they didn't seem
    //   to make it any easier.

    final Semaphore semaphore = aliasToSemaphoreMap.computeIfAbsent(getAliasName(), n -> new Semaphore(1));
    if (semaphore.tryAcquire()) {
      try {
        final String operation = CollectionParams.CollectionAction.ROUTEDALIAS_CREATECOLL.toLower();
        Map<String, Object> msg = new HashMap<>();
        msg.put(Overseer.QUEUE_OPERATION, operation);
        msg.put(CollectionParams.NAME, getAliasName());
        msg.put(RoutedAliasCreateCollectionCmd.IF_MOST_RECENT_COLL_NAME, mostRecentCollName);
        SolrQueryResponse rsp = new SolrQueryResponse();
        try {
          this.collHandler.handleResponse(
              operation,
              new ZkNodeProps(msg),
              rsp);
          if (rsp.getException() != null) {
            throw rsp.getException();
          } // otherwise don't care about the response.  It's possible no collection was created because
          //  of a race and that's okay... we'll ultimately retry any way.

          // Ensure our view of the aliases has updated. If we didn't do this, our zkStateReader might
          //  not yet know about the new alias (thus won't see the newly added collection to it), and we might think
          //  we failed.
          zkController.getZkStateReader().aliasesHolder.update();
        } catch (RuntimeException e) {
          throw e;
        } catch (Exception e) {
          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
        }
      } finally {
        semaphore.release(); // to signal we're done to anyone waiting on it
      }

    } else {
      // Failed to acquire permit because another URP instance on this JVM is creating a collection.
      // So wait till it's available
      log.debug("Collection creation is already in progress so we'll wait then try again.");
      try {
        if (semaphore.tryAcquire(DEFAULT_COLLECTION_OP_TIMEOUT, TimeUnit.MILLISECONDS)) {
          semaphore.release(); // we don't actually want a permit so give it back
          // return to continue...
        } else {
          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
              "Waited too long for another update thread to be done with collection creation.");
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
            "Interrupted waiting on collection creation.", e); // if we were interrupted, give up.
      }
    }
  }

