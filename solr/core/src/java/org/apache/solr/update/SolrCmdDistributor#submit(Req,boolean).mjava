  private void submit(final Req req, boolean isCommit) {
    if (req.synchronous) {
      blockAndDoRetries();

      try (HttpSolrClient client = new HttpSolrClient.Builder(req.node.getUrl()).withHttpClient(clients.getHttpClient()).build()) {
        client.request(req.uReq);
      } catch (Exception e) {
        try {
          // if false, then the node is probably not "live" anymore
          // and we do not need to send a recovery message
          Throwable rootCause = SolrException.getRootCause(e);
          log.error("Setting up to try to start recovery on replica {}", req.node.getUrl(), rootCause);
          req.cmd.getReq().getCore().getCoreContainer().getZkController().ensureReplicaInLeaderInitiatedRecovery(
              req.cmd.getReq().getCore().getCoreContainer(),
              req.node.getCollection(),
              req.node.getShardId(),
              req.node.getNodeProps(),
              req.cmd.getReq().getCore().getCoreDescriptor(),
              false /* forcePublishState */
          );
        } catch (Exception exc) {
          Throwable setLirZnodeFailedCause = SolrException.getRootCause(exc);
          log.error("Leader failed to set replica " +
              req.node.getUrl() + " state to DOWN due to: " + setLirZnodeFailedCause, setLirZnodeFailedCause);
        }
      }
      
      return;
    }
    
    if (log.isDebugEnabled()) {
      log.debug("sending update to "
          + req.node.getUrl() + " retry:"
          + req.retries + " " + req.cmd + " params:" + req.uReq.getParams());
    }
    
    if (isCommit) {
      // a commit using ConncurrentUpdateSolrServer is not async,
      // so we make it async to prevent commits from happening
      // serially across multiple nodes
      pending.add(completionService.submit(() -> {
        doRequest(req);
        return null;
      }));
    } else {
      doRequest(req);
    }
  }

