  /** Returns true if peer sync was successful, meaning that this core may not be considered to have the latest updates
   *  when considering the last N updates between it and it's peers.
   *  A commit is not performed.
   */
  public boolean sync() {
    if (ulog == null) {
      return false;
    }

    log.info(msg() + "START replicas=" + replicas + " nUpdates=" + nUpdates);

    if (debug) {
      if (startingVersions != null) {
        log.debug(msg() + "startingVersions=" + startingVersions.size() + " " + startingVersions);
      }
    }

    // Fire off the requests before getting our own recent updates (for better concurrency)
    // This also allows us to avoid getting updates we don't need... if we got our updates and then got their updates, they would
    // have newer stuff that we also had (assuming updates are going on and are being forwarded).
    for (String replica : replicas) {
      requestVersions(replica);
    }

    recentUpdates = ulog.getRecentUpdates();
    try {
      ourUpdates = recentUpdates.getVersions(nUpdates);
    } finally {
      recentUpdates.close();
    }

    Collections.sort(ourUpdates, absComparator);

    if (startingVersions != null) {
      if (startingVersions.size() == 0) {
        // no frame of reference to tell of we've missed updates
        return false;
      }
      Collections.sort(startingVersions, absComparator);

      ourLowThreshold = percentile(startingVersions, 0.8f);
      ourHighThreshold = percentile(startingVersions, 0.2f);

      // now make sure that the starting updates overlap our updates
      // there shouldn't be reorders, so any overlap will do.

      long smallestNewUpdate = Math.abs(ourUpdates.get(ourUpdates.size()-1));

      if (Math.abs(startingVersions.get(0)) < smallestNewUpdate) {
        log.warn(msg() + "too many updates received since start - startingUpdates no longer overlaps with our currentUpdates");
        return false;
      }

      // let's merge the lists
      List<Long> newList = new ArrayList(ourUpdates);
      for (Long ver : startingVersions) {
        if (Math.abs(ver) < smallestNewUpdate) {
          newList.add(ver);
        }
      }

      ourUpdates = newList;
    }  else {

      if (ourUpdates.size() > 0) {
        ourLowThreshold = percentile(ourUpdates, 0.8f);
        ourHighThreshold = percentile(ourUpdates, 0.2f);
      }  else {
        // we have no versions and hence no frame of reference to tell if we can use a peers
        // updates to bring us into sync
        log.info(msg() + "DONE.  We have no versions.  sync failed.");
        return false;
      }
    }

    ourUpdateSet = new HashSet<Long>(ourUpdates);
    requestedUpdateSet = new HashSet<Long>(ourUpdates);

    for(;;) {
      ShardResponse srsp = shardHandler.takeCompletedOrError();
      if (srsp == null) break;
      boolean success = handleResponse(srsp);
      if (!success) {
        log.info(msg() +  "DONE. sync failed");
        shardHandler.cancelAll();
        return false;
      }
    }

    log.info(msg() +  "DONE. sync succeeded");
    return true;
  }

