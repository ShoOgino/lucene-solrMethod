  @Override
  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {
    MDCLoggingContext.setCoreDescriptor(cd);
    try {
      if (SKIP_AUTO_RECOVERY) {
        log.warn("Skipping recovery according to sys prop solrcloud.skip.autorecovery");
        return;
      }
      
      // check before we grab the lock
      if (cc.isShutDown()) {
        log.warn("Skipping recovery because Solr is shutdown");
        return;
      }
      
      synchronized (recoveryLock) {
        // to be air tight we must also check after lock
        if (cc.isShutDown()) {
          log.warn("Skipping recovery because Solr is shutdown");
          return;
        }
        log.info("Running recovery - first canceling any ongoing recovery");
        cancelRecovery();
        
        while (recoveryRunning) {
          try {
            recoveryLock.wait(1000);
          } catch (InterruptedException e) {
          
          }
          // check again for those that were waiting
          if (cc.isShutDown()) {
            log.warn("Skipping recovery because Solr is shutdown");
            return;
          }
          if (closed) return;
        }
        
        // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for
        // local tlog recovery)
        boolean recoveringAfterStartup = recoveryStrat == null;
        
        recoveryThrottle.minimumWaitBetweenActions();
        recoveryThrottle.markAttemptingAction();
        
        recoveryStrat = new RecoveryStrategy(cc, cd, this);
        recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);
        recoveryStrat.start();
        recoveryRunning = true;
      }
    } finally {
      MDCLoggingContext.clear();
    }
  }

