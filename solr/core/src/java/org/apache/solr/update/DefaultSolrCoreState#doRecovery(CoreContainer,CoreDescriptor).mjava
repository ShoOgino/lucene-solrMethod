  @Override
  public void doRecovery(CoreContainer cc, CoreDescriptor cd) {
    if (SKIP_AUTO_RECOVERY) {
      log.warn("Skipping recovery according to sys prop solrcloud.skip.autorecovery");
      return;
    }
    
    // check before we grab the lock
    if (cc.isShutDown()) {
      log.warn("Skipping recovery because Solr is close");
      return;
    }
    
    synchronized (recoveryLock) {
      // to be air tight we must also check after lock
      if (cc.isShutDown()) {
        log.warn("Skipping recovery because Solr is close");
        return;
      }
      log.info("Running recovery - first canceling any ongoing recovery");
      cancelRecovery();
      
      while (recoveryRunning) {
        try {
          recoveryLock.wait(1000);
        } catch (InterruptedException e) {

        }
        // check again for those that were waiting
        if (cc.isShutDown()) {
          log.warn("Skipping recovery because Solr is close");
          return;
        }
        if (closed) return;
      }

      // if true, we are recovering after startup and shouldn't have (or be receiving) additional updates (except for local tlog recovery)
      boolean recoveringAfterStartup = recoveryStrat == null;

      recoveryStrat = new RecoveryStrategy(cc, cd, this);
      recoveryStrat.setRecoveringAfterStartup(recoveringAfterStartup);
      recoveryStrat.start();
      recoveryRunning = true;
    }
    
  }

