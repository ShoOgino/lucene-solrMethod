  @Override
  public void commit(CommitUpdateCommand cmd) throws IOException {
    IndexWriter writer = solrCoreState.getIndexWriter(core);
    if (cmd.optimize) {
      optimizeCommands.incrementAndGet();
    } else {
      commitCommands.incrementAndGet();
      if (cmd.expungeDeletes) expungeDeleteCommands.incrementAndGet();
    }

    Future[] waitSearcher = null;
    if (cmd.waitSearcher) {
      waitSearcher = new Future[1];
    }

    boolean error=true;
    try {
      // only allow one hard commit to proceed at once
      if (!cmd.softCommit) {
        commitLock.lock();
      }

      log.info("start "+cmd);

      if (cmd.optimize) {
        writer.optimize(cmd.maxOptimizeSegments);
      } else if (cmd.expungeDeletes) {
        writer.expungeDeletes();
      }

      if (!cmd.softCommit) {
        synchronized (this) { // sync is currently needed to prevent preCommit from being called between preSoft and postSoft... see postSoft comments.
          ulog.preCommit(cmd);
        }

        // SolrCore.verbose("writer.commit() start writer=",writer);
        writer.commit();
        // SolrCore.verbose("writer.commit() end");
        numDocsPending.set(0);
        callPostCommitCallbacks();
      } else {
        callPostSoftCommitCallbacks();
      }


      if (cmd.optimize) {
        callPostOptimizeCallbacks();
      }


        if (cmd.softCommit) {
          // ulog.preSoftCommit();
          synchronized (this) {
            ulog.preSoftCommit(cmd);
            core.getSearcher(true,false,waitSearcher, true);
            ulog.postSoftCommit(cmd);
          }
          // ulog.postSoftCommit();
        } else {
          synchronized (this) {
            ulog.preSoftCommit(cmd);
            core.getSearcher(true,false,waitSearcher);
            ulog.postSoftCommit(cmd);
          }
          ulog.postCommit(cmd); // postCommit currently means new searcher has also been opened
        }


      // reset commit tracking

      if (cmd.softCommit) {
        softCommitTracker.didCommit();
      } else {
        commitTracker.didCommit();
      }
      
      log.info("end_commit_flush");

      error=false;
    }
    finally {
      if (!cmd.softCommit) {
        commitLock.unlock();
      }

      addCommands.set(0);
      deleteByIdCommands.set(0);
      deleteByQueryCommands.set(0);
      numErrors.set(error ? 1 : 0);
    }

    // if we are supposed to wait for the searcher to be registered, then we should do it
    // outside any synchronized block so that other update operations can proceed.
    if (waitSearcher!=null && waitSearcher[0] != null) {
       try {
        waitSearcher[0].get();
      } catch (InterruptedException e) {
        SolrException.log(log,e);
      } catch (ExecutionException e) {
        SolrException.log(log,e);
      }
    }
  }

