  private boolean handleVersionsWithRanges(ShardResponse srsp, List<Long> otherVersions, SyncShardRequest sreq,
      boolean completeList, long otherHigh, long otherHighest) {
    // we may endup asking for updates for too many versions, causing 2MB post payload limit. Construct a range of
    // versions to request instead of asking individual versions
    List<String> rangesToRequest = new ArrayList<>();

    // construct ranges to request
    // both ourUpdates and otherVersions are sorted with highest range first
    // may be we can create another reverse the lists and avoid confusion
    int ourUpdatesIndex = ourUpdates.size() - 1;
    int otherUpdatesIndex = otherVersions.size() - 1;
    long totalRequestedVersions = 0;

    while (otherUpdatesIndex >= 0) {
      // we have run out of ourUpdates, pick up all the remaining versions from the other versions
      if (ourUpdatesIndex < 0) {
        String range = otherVersions.get(otherUpdatesIndex) + "..." + otherVersions.get(0);
        rangesToRequest.add(range);
        totalRequestedVersions += otherUpdatesIndex + 1;
        break;
      }

      // stop when the entries get old enough that reorders may lead us to see updates we don't need
      if (!completeList && Math.abs(otherVersions.get(otherUpdatesIndex)) < ourLowThreshold) break;

      if (ourUpdates.get(ourUpdatesIndex).longValue() == otherVersions.get(otherUpdatesIndex).longValue()) {
        ourUpdatesIndex--;
        otherUpdatesIndex--;
      } else if (Math.abs(ourUpdates.get(ourUpdatesIndex)) < Math.abs(otherVersions.get(otherUpdatesIndex))) {
        ourUpdatesIndex--;
      } else {
        long rangeStart = otherVersions.get(otherUpdatesIndex);
        while ((otherUpdatesIndex < otherVersions.size())
            && (Math.abs(otherVersions.get(otherUpdatesIndex)) < Math.abs(ourUpdates.get(ourUpdatesIndex)))) {
          otherUpdatesIndex--;
          totalRequestedVersions++;
        }
        // construct range here
        rangesToRequest.add(rangeStart + "..." + otherVersions.get(otherUpdatesIndex + 1));
      }
    }

    // TODO, do we really need to hold on to all the ranges we requested 
    // keeping track of totalRequestedUpdates should suffice for verification
    sreq.requestedRanges = rangesToRequest;
    sreq.totalRequestedUpdates = totalRequestedVersions;

    if (rangesToRequest.isEmpty()) {
      log.info(msg() + " No additional versions requested. ourLowThreshold=" + ourLowThreshold + " otherHigh="
          + otherHigh + " ourHighest=" + ourHighest + " otherHighest=" + otherHighest);

      // we had (or already requested) all the updates referenced by the replica

      // If we requested updates from another replica, we can't compare fingerprints yet with this replica, we need to
      // defer
      if (doFingerprint) {
        sreq.doFingerprintComparison = true;
      }

      return true;
    }

    if (totalRequestedVersions > maxUpdates) {
      log.info(msg() + " Failing due to needing too many updates:" + maxUpdates);
      return false;
    }

    String rangesToRequestStr = rangesToRequest.stream().collect(Collectors.joining(","));
    return requestUpdates(srsp, rangesToRequestStr, totalRequestedVersions);
  }

