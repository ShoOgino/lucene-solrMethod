  private void doNormalUpdate(AddUpdateCommand cmd) throws IOException {
    Term updateTerm;
    Term idTerm = new Term(cmd.isBlock() ? "_root_" : idField.getName(), cmd.getIndexedId());
    boolean del = false;
    if (cmd.updateTerm == null) {
      updateTerm = idTerm;
    } else {
      // this is only used by the dedup update processor
      del = true;
      updateTerm = cmd.updateTerm;
    }

    RefCounted<IndexWriter> iw = solrCoreState.getIndexWriter(core);
    try {
      IndexWriter writer = iw.get();

      if (cmd.isBlock()) {
        writer.updateDocuments(updateTerm, cmd);
      } else {
        Document luceneDocument = cmd.getLuceneDocument();
        // SolrCore.verbose("updateDocument",updateTerm,luceneDocument,writer);
        writer.updateDocument(updateTerm, luceneDocument);
      }
      // SolrCore.verbose("updateDocument",updateTerm,"DONE");

      if (del) { // ensure id remains unique
        BooleanQuery.Builder bq = new BooleanQuery.Builder();
        bq.add(new BooleanClause(new TermQuery(updateTerm),
            Occur.MUST_NOT));
        bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));
        writer.deleteDocuments(new DeleteByQueryWrapper(bq.build(), core.getLatestSchema()));
      }
    } finally {
      iw.decref();
    }

    // Add to the transaction log *after* successfully adding to the
    // index, if there was no error.
    // This ordering ensures that if we log it, it's definitely been
    // added to the the index.
    // This also ensures that if a commit sneaks in-between, that we
    // know everything in a particular
    // log version was definitely committed.
    synchronized (solrCoreState.getUpdateLock()) {
      if (ulog != null) ulog.add(cmd);
    }
  }

