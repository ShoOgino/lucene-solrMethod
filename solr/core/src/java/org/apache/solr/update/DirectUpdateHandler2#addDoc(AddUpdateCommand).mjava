  @Override
  public int addDoc(AddUpdateCommand cmd) throws IOException {
    IndexWriter writer = solrCoreState.getIndexWriter(core);
    addCommands.incrementAndGet();
    addCommandsCumulative.incrementAndGet();
    int rc=-1;

    // if there is no ID field, don't overwrite
    if( idField == null ) {
      cmd.overwrite = false;
    }


    try {

      if (cmd.overwrite) {

        // Check for delete by query commands newer (i.e. reordered).  This should always be null on a leader
        List<UpdateLog.DBQ> deletesAfter = null;
        if (ulog != null && cmd.version > 0) {
          deletesAfter = ulog.getDBQNewer(cmd.version);
        }

        if (deletesAfter != null) {
          List<Query> dbqList = new ArrayList<Query>(deletesAfter.size());
          for (UpdateLog.DBQ dbq : deletesAfter) {
            try {
              DeleteUpdateCommand tmpDel = new DeleteUpdateCommand(cmd.req);
              tmpDel.query = dbq.q;
              tmpDel.version = -dbq.version;
              dbqList.add( getQuery(tmpDel) );
            } catch (Exception e) {
              log.error("Exception parsing reordered query : " + dbq, e);
            }
          }

          addAndDelete(cmd, dbqList);
        } else {
          // normal update

          Term updateTerm;
          Term idTerm = new Term(idField.getName(), cmd.getIndexedId());
          boolean del = false;
          if (cmd.updateTerm == null) {
            updateTerm = idTerm;
          } else {
            del = true;
            updateTerm = cmd.updateTerm;
          }

          Document luceneDocument = cmd.getLuceneDocument();
          // SolrCore.verbose("updateDocument",updateTerm,luceneDocument,writer);
          writer.updateDocument(updateTerm, luceneDocument, schema.getAnalyzer());
          // SolrCore.verbose("updateDocument",updateTerm,"DONE");


          if(del) { // ensure id remains unique
            BooleanQuery bq = new BooleanQuery();
            bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));
            bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));
            writer.deleteDocuments(bq);
          }


          // Add to the transaction log *after* successfully adding to the index, if there was no error.
          // This ordering ensures that if we log it, it's definitely been added to the the index.
          // This also ensures that if a commit sneaks in-between, that we know everything in a particular
          // log version was definitely committed.
          if (ulog != null) ulog.add(cmd);
        }

      } else {
        // allow duplicates
        writer.addDocument(cmd.getLuceneDocument(), schema.getAnalyzer());
        if (ulog != null) ulog.add(cmd);
      }


      if ((cmd.getFlags() & UpdateCommand.IGNORE_AUTOCOMMIT) == 0) {
        commitTracker.addedDocument( -1 );
        softCommitTracker.addedDocument( cmd.commitWithin );
      }

      rc = 1;
    } finally {
      if (rc!=1) {
        numErrors.incrementAndGet();
        numErrorsCumulative.incrementAndGet();
      } else {
        numDocsPending.incrementAndGet();
      }
    }

    return rc;
  }

