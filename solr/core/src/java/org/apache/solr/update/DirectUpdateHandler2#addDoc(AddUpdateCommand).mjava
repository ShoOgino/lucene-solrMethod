  @Override
  public int addDoc(AddUpdateCommand cmd) throws IOException {
    IndexWriter writer = indexWriterProvider.getIndexWriter(core);
    addCommands.incrementAndGet();
    addCommandsCumulative.incrementAndGet();
    int rc=-1;

    // if there is no ID field, don't overwrite
    if( idField == null ) {
      cmd.overwrite = false;
    }


    try {
      commitTracker.addedDocument( cmd.commitWithin );
      softCommitTracker.addedDocument( -1 ); // TODO: support commitWithin with soft update

      if (cmd.overwrite) {
        Term updateTerm;
        Term idTerm = new Term(idField.getName(), cmd.getIndexedId());
        boolean del = false;
        if (cmd.updateTerm == null) {
          updateTerm = idTerm;
        } else {
          del = true;
          updateTerm = cmd.updateTerm;
        }

        writer.updateDocument(updateTerm, cmd.getLuceneDocument());
        if(del) { // ensure id remains unique
          BooleanQuery bq = new BooleanQuery();
          bq.add(new BooleanClause(new TermQuery(updateTerm), Occur.MUST_NOT));
          bq.add(new BooleanClause(new TermQuery(idTerm), Occur.MUST));
          writer.deleteDocuments(bq);
        }
      } else {
        // allow duplicates
        writer.addDocument(cmd.getLuceneDocument());
      }

      // Add to the transaction log *after* successfully adding to the index, if there was no error.
      // This ordering ensures that if we log it, it's definitely been added to the the index.
      // This also ensures that if a commit sneaks in-between, that we know everything in a particular
      // log version was definitely committed.
      ulog.add(cmd);

      rc = 1;
    } finally {
      if (rc!=1) {
        numErrors.incrementAndGet();
        numErrorsCumulative.incrementAndGet();
      } else {
        numDocsPending.incrementAndGet();
      }
    }

    return rc;
  }

