  private void remoteQuery(String coreUrl, HttpServletRequest req,
      SolrQueryRequest solrReq, HttpServletResponse resp) throws IOException {
    HttpRequestBase method = null;
    HttpEntity httpEntity = null;
    boolean success = false;
    try {
      String urlstr = coreUrl;
      
      String queryString = req.getQueryString();
      
      urlstr += queryString == null ? "" : "?" + queryString;
      
      URL url = new URL(urlstr);
      boolean isPostOrPutRequest = "POST".equals(req.getMethod()) || "PUT".equals(req.getMethod());

      if ("GET".equals(req.getMethod())) {
        method = new HttpGet(urlstr);
      }
      else if ("HEAD".equals(req.getMethod())) {
        method = new HttpHead(urlstr);
      }
      else if (isPostOrPutRequest) {
        HttpEntityEnclosingRequestBase entityRequest =
          "POST".equals(req.getMethod()) ? new HttpPost(urlstr) : new HttpPut(urlstr);
        HttpEntity entity = new InputStreamEntity(req.getInputStream(), req.getContentLength());
        entityRequest.setEntity(entity);
        method = entityRequest;
      }
      else {
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
          "Unexpected method type: " + req.getMethod());
      }

      for (Enumeration<String> e = req.getHeaderNames(); e.hasMoreElements();) {
        String headerName = e.nextElement();
        method.addHeader(headerName, req.getHeader(headerName));
      }
      // These headers not supported for HttpEntityEnclosingRequests
      if (method instanceof HttpEntityEnclosingRequest) {
        method.removeHeaders(TRANSFER_ENCODING_HEADER);
        method.removeHeaders(CONTENT_LENGTH_HEADER);
      }

      final HttpResponse response = httpClient.execute(method);
      int httpStatus = response.getStatusLine().getStatusCode();
      httpEntity = response.getEntity();

      resp.setStatus(httpStatus);
      for (HeaderIterator responseHeaders = response.headerIterator(); responseHeaders.hasNext();) {
        Header header = responseHeaders.nextHeader();

        // We pull out these two headers below because they can cause chunked
        // encoding issues with Tomcat
        if (header != null && !header.getName().equals(TRANSFER_ENCODING_HEADER)
          && !header.getName().equals(CONNECTION_HEADER)) {
            resp.addHeader(header.getName(), header.getValue());
        }
      }

      if (httpEntity != null) {
        if (httpEntity.getContentEncoding() != null) resp.setCharacterEncoding(httpEntity.getContentEncoding().getValue());
        if (httpEntity.getContentType() != null) resp.setContentType(httpEntity.getContentType().getValue());

        InputStream is = httpEntity.getContent();
        OutputStream os = resp.getOutputStream();
        try {
          IOUtils.copyLarge(is, os);
          os.flush();
        } finally {
          IOUtils.closeQuietly(os);   // TODO: I thought we weren't supposed to explicitly close servlet streams
          IOUtils.closeQuietly(is);
        }
      }
      success = true;
    } catch (IOException e) {
      sendError(null, solrReq, req, resp, new SolrException(
          SolrException.ErrorCode.SERVER_ERROR,
          "Error trying to proxy request for url: " + coreUrl, e));
    } finally {
      EntityUtils.consumeQuietly(httpEntity);
      if (method != null && !success) {
        method.abort();
      }
    }

  }

