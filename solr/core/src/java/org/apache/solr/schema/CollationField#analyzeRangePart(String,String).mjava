  /**
   * analyze the range with the analyzer, instead of the collator.
   * because jdk collators might not be thread safe (when they are
   * its just that all methods are synced), this keeps things 
   * simple (we already have a threadlocal clone in the reused TS)
   */
  private BytesRef analyzeRangePart(String field, String part) {     
    try (TokenStream source = analyzer.tokenStream(field, part)) {
      source.reset();    
      TermToBytesRefAttribute termAtt = source.getAttribute(TermToBytesRefAttribute.class);
      BytesRef bytes = termAtt.getBytesRef();

      // we control the analyzer here: most errors are impossible
      if (!source.incrementToken())
        throw new IllegalArgumentException("analyzer returned no terms for range part: " + part);
      termAtt.fillBytesRef();
      assert !source.incrementToken();
      
      source.end();
      return BytesRef.deepCopyOf(bytes);
    } catch (IOException e) {
      throw new RuntimeException("Unable to analyze range part: " + part, e);
    }
  }

