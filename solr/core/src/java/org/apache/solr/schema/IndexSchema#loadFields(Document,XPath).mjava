  /** 
   * Loads fields and dynamic fields.
   * 
   * @return a map from field name to explicit required value  
   */ 
  protected synchronized Map<String,Boolean> loadFields(Document document, XPath xpath) throws XPathExpressionException {
    // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
    Map<String,Boolean> explicitRequiredProp = new HashMap<String,Boolean>();
    
    ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();

    //                  /schema/fields/field | /schema/fields/dynamicField
    String expression = stepsToPath(SCHEMA, FIELDS, FIELD)
           + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);
    NodeList nodes = (NodeList)xpath.evaluate(expression, document, XPathConstants.NODESET);

    for (int i=0; i<nodes.getLength(); i++) {
      Node node = nodes.item(i);

      NamedNodeMap attrs = node.getAttributes();

      String name = DOMUtil.getAttr(attrs, NAME, "field definition");
      log.trace("reading field def "+name);
      String type = DOMUtil.getAttr(attrs, TYPE, "field " + name);

      FieldType ft = fieldTypes.get(type);
      if (ft==null) {
        throw new SolrException
            (ErrorCode.BAD_REQUEST, "Unknown " + FIELD_TYPE + " '" + type + "' specified on field " + name);
      }

      Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);
      if (null != args.get(REQUIRED)) {
        explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));
      }

      SchemaField f = SchemaField.create(name,ft,args);

      if (node.getNodeName().equals(FIELD)) {
        SchemaField old = fields.put(f.getName(),f);
        if( old != null ) {
          String msg = "[schema.xml] Duplicate field definition for '"
            + f.getName() + "' [[["+old.toString()+"]]] and [[["+f.toString()+"]]]";
          throw new SolrException(ErrorCode.SERVER_ERROR, msg );
        }
        log.debug("field defined: " + f);
        if( f.getDefaultValue() != null ) {
          log.debug(name+" contains default value: " + f.getDefaultValue());
          fieldsWithDefaultValue.add( f );
        }
        if (f.isRequired()) {
          log.debug(name+" is required in this schema");
          requiredFields.add(f);
        }
      } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {
        if( f.getDefaultValue() != null ) {
          throw new SolrException(ErrorCode.SERVER_ERROR,
                                  DYNAMIC_FIELD + " can not have a default value: " + name);
        }
        if ( f.isRequired() ) {
          throw new SolrException(ErrorCode.SERVER_ERROR,
                                  DYNAMIC_FIELD + " can not be required: " + name);
        }
        if (isValidFieldGlob(name)) {
          // make sure nothing else has the same path
          addDynamicField(dFields, f);
        } else {
          String msg = "Dynamic field name '" + name 
              + "' should have either a leading or a trailing asterisk, and no others.";
          throw new SolrException(ErrorCode.SERVER_ERROR, msg);
        }
      } else {
        // we should never get here
        throw new RuntimeException("Unknown field type");
      }
    }

    //fields with default values are by definition required
    //add them to required fields, and we only have to loop once
    // in DocumentBuilder.getDoc()
    requiredFields.addAll(fieldsWithDefaultValue);

    // OK, now sort the dynamic fields largest to smallest size so we don't get
    // any false matches.  We want to act like a compiler tool and try and match
    // the largest string possible.
    Collections.sort(dFields);

    log.trace("Dynamic Field Ordering:" + dFields);

    // stuff it in a normal array for faster access
    dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);

    return explicitRequiredProp;
  }

