  private void readSchema(InputSource is) {
    log.info("Reading Solr Schema");

    try {
      // pass the config resource loader to avoid building an empty one for no reason:
      // in the current case though, the stream is valid so we wont load the resource by name
      Config schemaConf = new Config(loader, SCHEMA, is, SLASH+SCHEMA+SLASH);
      Document document = schemaConf.getDocument();
      final XPath xpath = schemaConf.getXPath();
      final List<SchemaAware> schemaAware = new ArrayList<SchemaAware>();
      String expression = stepsToPath(SCHEMA, AT + NAME);
      Node nd = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
      if (nd==null) {
        log.warn("schema has no name!");
      } else {
        name = nd.getNodeValue();
        log.info("Schema " + NAME + "=" + name);
      }

      //                      /schema/@version
      expression = stepsToPath(SCHEMA, AT + VERSION);
      version = schemaConf.getFloat(expression, 1.0f);


      // load the Field Types

      final FieldTypePluginLoader typeLoader 
        = new FieldTypePluginLoader(this, fieldTypes, schemaAware);

      //               /schema/types/fieldtype | /schema/types/fieldType 
      expression =     stepsToPath(SCHEMA, TYPES, FIELD_TYPE.toLowerCase(Locale.ROOT)) // backcompat(?) 
          + XPATH_OR + stepsToPath(SCHEMA, TYPES, FIELD_TYPE);
      NodeList nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);
      typeLoader.load( loader, nodes );

      // load the Fields

      // Hang on to the fields that say if they are required -- this lets us set a reasonable default for the unique key
      Map<String,Boolean> explicitRequiredProp = new HashMap<String, Boolean>();
      ArrayList<DynamicField> dFields = new ArrayList<DynamicField>();

      //               /schema/fields/field | /schema/fields/dynamicField
      expression =     stepsToPath(SCHEMA, FIELDS, FIELD)
          + XPATH_OR + stepsToPath(SCHEMA, FIELDS, DYNAMIC_FIELD);
      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);

      for (int i=0; i<nodes.getLength(); i++) {
        Node node = nodes.item(i);

        NamedNodeMap attrs = node.getAttributes();

        String name = DOMUtil.getAttr(attrs, NAME, "field definition");
        log.trace("reading field def "+name);
        String type = DOMUtil.getAttr(attrs, TYPE, "field " + name);

        FieldType ft = fieldTypes.get(type);
        if (ft==null) {
          throw new SolrException
              (ErrorCode.BAD_REQUEST, "Unknown " + FIELD_TYPE + " '" + type + "' specified on field " + name);
        }

        Map<String,String> args = DOMUtil.toMapExcept(attrs, NAME, TYPE);
        if (null != args.get(REQUIRED)) {
          explicitRequiredProp.put(name, Boolean.valueOf(args.get(REQUIRED)));
        }

        SchemaField f = SchemaField.create(name,ft,args);

        if (node.getNodeName().equals(FIELD)) {
          SchemaField old = fields.put(f.getName(),f);
          if( old != null ) {
            String msg = "[schema.xml] Duplicate field definition for '"
              + f.getName() + "' [[["+old.toString()+"]]] and [[["+f.toString()+"]]]";
            throw new SolrException(ErrorCode.SERVER_ERROR, msg );
          }
          log.debug("field defined: " + f);
          if( f.getDefaultValue() != null ) {
            log.debug(name+" contains default value: " + f.getDefaultValue());
            fieldsWithDefaultValue.add( f );
          }
          if (f.isRequired()) {
            log.debug(name+" is required in this schema");
            requiredFields.add(f);
          }
        } else if (node.getNodeName().equals(DYNAMIC_FIELD)) {
          if (isValidFieldGlob(name)) {
            // make sure nothing else has the same path
            addDynamicField(dFields, f);
          } else {
            String msg = "Dynamic field name '" + name 
                + "' should have either a leading or a trailing asterisk, and no others.";
            throw new SolrException(ErrorCode.SERVER_ERROR, msg);
          }
        } else {
          // we should never get here
          throw new RuntimeException("Unknown field type");
        }
      }
      
      //fields with default values are by definition required
      //add them to required fields, and we only have to loop once
      // in DocumentBuilder.getDoc()
      requiredFields.addAll(getFieldsWithDefaultValue());


      // OK, now sort the dynamic fields largest to smallest size so we don't get
      // any false matches.  We want to act like a compiler tool and try and match
      // the largest string possible.
      Collections.sort(dFields);

      log.trace("Dynamic Field Ordering:" + dFields);

      // stuff it in a normal array for faster access
      dynamicFields = dFields.toArray(new DynamicField[dFields.size()]);

      expression = stepsToPath(SCHEMA, SIMILARITY); //   /schema/similarity
      Node node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
      similarityFactory = readSimilarity(loader, node);
      if (similarityFactory == null) {
        similarityFactory = new DefaultSimilarityFactory();
      } else {
        isExplicitSimilarity = true;
      }
      if (similarityFactory instanceof SchemaAware) {
        ((SchemaAware)similarityFactory).inform(this);
      } else {
        // if the sim factory isn't schema aware, then we are responsible for
        // erroring if a field type is trying to specify a sim.
        for (FieldType ft : fieldTypes.values()) {
          if (null != ft.getSimilarity()) {
            String msg = "FieldType '" + ft.getTypeName()
                + "' is configured with a similarity, but the global similarity does not support it: " 
                + similarityFactory.getClass();
            log.error(msg);
            throw new SolrException(ErrorCode.SERVER_ERROR, msg);
          }
        }
      }
      similarity = similarityFactory.getSimilarity();

      //                      /schema/defaultSearchField/@text()
      expression = stepsToPath(SCHEMA, DEFAULT_SEARCH_FIELD, TEXT_FUNCTION);
      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
      if (node==null) {
        log.debug("no default search field specified in schema.");
      } else {
        defaultSearchFieldName=node.getNodeValue().trim();
        // throw exception if specified, but not found or not indexed
        if (defaultSearchFieldName!=null) {
          SchemaField defaultSearchField = getFields().get(defaultSearchFieldName);
          if ((defaultSearchField == null) || !defaultSearchField.indexed()) {
            String msg =  "default search field '" + defaultSearchFieldName + "' not defined or not indexed" ;
            throw new SolrException(ErrorCode.SERVER_ERROR, msg);
          }
        }
        log.info("default search field in schema is "+defaultSearchFieldName);
      }

      //                      /schema/solrQueryParser/@defaultOperator
      expression = stepsToPath(SCHEMA, SOLR_QUERY_PARSER, AT + DEFAULT_OPERATOR);
      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
      if (node==null) {
        log.debug("using default query parser operator (OR)");
      } else {
        isExplicitQueryParserDefaultOperator = true;
        queryParserDefaultOperator=node.getNodeValue().trim();
        log.info("query parser default operator is "+queryParserDefaultOperator);
      }

      //                      /schema/uniqueKey/text()
      expression = stepsToPath(SCHEMA, UNIQUE_KEY, TEXT_FUNCTION);
      node = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);
      if (node==null) {
        log.warn("no " + UNIQUE_KEY + " specified in schema.");
      } else {
        uniqueKeyField=getIndexedField(node.getNodeValue().trim());
        if (null != uniqueKeyField.getDefaultValue()) {
          String msg = UNIQUE_KEY + " field ("+uniqueKeyFieldName+
              ") can not be configured with a default value ("+
              uniqueKeyField.getDefaultValue()+")";
          log.error(msg);
          throw new SolrException(ErrorCode.SERVER_ERROR, msg);
        }

        if (!uniqueKeyField.stored()) {
          log.warn(UNIQUE_KEY + " is not stored - distributed search and MoreLikeThis will not work");
        }
        if (uniqueKeyField.multiValued()) {
          String msg = UNIQUE_KEY + " field ("+uniqueKeyFieldName+
              ") can not be configured to be multivalued";
          log.error(msg);
          throw new SolrException(ErrorCode.SERVER_ERROR, msg);
        }
        uniqueKeyFieldName=uniqueKeyField.getName();
        uniqueKeyFieldType=uniqueKeyField.getType();
        log.info("unique key field: "+uniqueKeyFieldName);
      
        // Unless the uniqueKeyField is marked 'required=false' then make sure it exists
        if( Boolean.FALSE != explicitRequiredProp.get( uniqueKeyFieldName ) ) {
          uniqueKeyField.required = true;
          requiredFields.add(uniqueKeyField);
        }
      }                

      /////////////// parse out copyField commands ///////////////
      // Map<String,ArrayList<SchemaField>> cfields = new HashMap<String,ArrayList<SchemaField>>();
      // expression = "/schema/copyField";
    
      dynamicCopyFields = new DynamicCopy[] {};
      expression = "//" + COPY_FIELD;
      nodes = (NodeList) xpath.evaluate(expression, document, XPathConstants.NODESET);

      for (int i=0; i<nodes.getLength(); i++) {
        node = nodes.item(i);
        NamedNodeMap attrs = node.getAttributes();

        String source = DOMUtil.getAttr(attrs, SOURCE, COPY_FIELD + " definition");
        String dest   = DOMUtil.getAttr(attrs, DESTINATION,  COPY_FIELD + " definition");
        String maxChars = DOMUtil.getAttr(attrs, MAX_CHARS);
        int maxCharsInt = CopyField.UNLIMITED;
        if (maxChars != null) {
          try {
            maxCharsInt = Integer.parseInt(maxChars);
          } catch (NumberFormatException e) {
            log.warn("Couldn't parse " + MAX_CHARS + " attribute for " + COPY_FIELD + " from "
                    + source + " to " + dest + " as integer. The whole field will be copied.");
          }
        }

        if (dest.equals(uniqueKeyFieldName)) {
          String msg = UNIQUE_KEY + " field ("+uniqueKeyFieldName+
            ") can not be the " + DESTINATION + " of a " + COPY_FIELD + "(" + SOURCE + "=" +source+")";
          log.error(msg);
          throw new SolrException(ErrorCode.SERVER_ERROR, msg);
          
        }

        registerCopyField(source, dest, maxCharsInt);
      }
      
      for (Map.Entry<SchemaField, Integer> entry : copyFieldTargetCounts.entrySet()) {
        if (entry.getValue() > 1 && !entry.getKey().multiValued())  {
          log.warn("Field " + entry.getKey().name + " is not multivalued "+
              "and destination for multiple " + COPY_FIELDS + " ("+
              entry.getValue()+")");
        }
      }

      //Run the callbacks on SchemaAware now that everything else is done
      for (SchemaAware aware : schemaAware) {
        aware.inform(this);
      }
    } catch (SolrException e) {
      throw e;
    } catch(Exception e) {
      // unexpected exception...
      throw new SolrException(ErrorCode.SERVER_ERROR, "Schema Parsing Failed: " + e.getMessage(), e);
    }

    // create the field analyzers
    refreshAnalyzers();
  }

