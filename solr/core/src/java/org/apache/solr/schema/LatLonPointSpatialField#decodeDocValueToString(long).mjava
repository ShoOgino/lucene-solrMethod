  /**
   * Decodes the docValues number into latitude and longitude components, formatting as "lat,lon".
   * The encoding is governed by {@code LatLonDocValuesField}.  The decimal output representation is reflective
   * of the available precision.
   * @param value Non-null; stored location field data
   * @return Non-null; "lat, lon" with 6 decimal point precision
   */
  public static String decodeDocValueToString(long value) {
    final double latDouble = GeoEncodingUtils.decodeLatitude((int) (value >> 32));
    final double lonDouble = GeoEncodingUtils.decodeLongitude((int) (value & 0xFFFFFFFFL));
    // 7 decimal places maximizes our available precision to just over a centimeter; we have a test for it.
    // CEILING round-trips (decode then re-encode then decode to get identical results). Others did not. It also
    //   reverses the "floor" that occurs when we encode.
    BigDecimal latitudeDecoded = BigDecimal.valueOf(latDouble).setScale(7, CEILING);
    BigDecimal longitudeDecoded = BigDecimal.valueOf(lonDouble).setScale(7, CEILING);
    return latitudeDecoded.stripTrailingZeros().toPlainString() + ","
        + longitudeDecoded.stripTrailingZeros().toPlainString();
    // return ((float)latDouble) + "," + ((float)lonDouble);  crude but not quite as accurate
  }

