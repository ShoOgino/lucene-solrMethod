  public ManagedIndexSchema addFieldTypes(List<FieldType> fieldTypeList) {
    if (!isMutable) {
      String msg = "This ManagedIndexSchema is not mutable.";
      log.error(msg);
      throw new SolrException(ErrorCode.SERVER_ERROR, msg);    
    }

    ManagedIndexSchema newSchema = shallowCopy(true);

    // we shallow copied fieldTypes, but since we're changing them, we need to do a true
    // deep copy before adding the new field types
    HashMap<String,FieldType> clone =
        (HashMap<String,FieldType>)((HashMap<String,FieldType>)newSchema.fieldTypes).clone();
    newSchema.fieldTypes = clone;

    // do a first pass to validate the field types don't exist already
    for (FieldType fieldType : fieldTypeList) {    
      String typeName = fieldType.getTypeName();
      if (newSchema.getFieldTypeByName(typeName) != null) {
        throw new FieldExistsException(ErrorCode.BAD_REQUEST,
            "Field type '" + typeName + "' already exists!");
      }
      
      newSchema.fieldTypes.put(typeName, fieldType);
    }

    // Run the callbacks on SchemaAware now that everything else is done
    for (SchemaAware aware : newSchema.schemaAware)
      aware.inform(newSchema);
    
    // looks good for the add, notify ResoureLoaderAware objects
    for (FieldType fieldType : fieldTypeList) {      
          
      // must inform any sub-components used in the 
      // tokenizer chain if they are ResourceLoaderAware    
      if (fieldType.supportsAnalyzers()) {
        Analyzer indexAnalyzer = fieldType.getIndexAnalyzer();
        if (indexAnalyzer != null && indexAnalyzer instanceof TokenizerChain)
          informResourceLoaderAwareObjectsInChain((TokenizerChain)indexAnalyzer);
        
        Analyzer queryAnalyzer = fieldType.getQueryAnalyzer();
        // ref comparison is correct here (vs. equals) as they may be the same
        // object in which case, we don't need to inform twice ... however, it's
        // actually safe to call inform multiple times on an object anyway
        if (queryAnalyzer != null && 
            queryAnalyzer != indexAnalyzer && 
            queryAnalyzer instanceof TokenizerChain)
          informResourceLoaderAwareObjectsInChain((TokenizerChain)queryAnalyzer);

        // if fieldType is a TextField, it might have a multi-term analyzer
        if (fieldType instanceof TextField) {
          TextField textFieldType = (TextField)fieldType;
          Analyzer multiTermAnalyzer = textFieldType.getMultiTermAnalyzer();
          if (multiTermAnalyzer != null && multiTermAnalyzer != indexAnalyzer &&
              multiTermAnalyzer != queryAnalyzer && multiTermAnalyzer instanceof TokenizerChain)
            informResourceLoaderAwareObjectsInChain((TokenizerChain)multiTermAnalyzer);
        }
      }      
    }

    newSchema.refreshAnalyzers();
    
    boolean success = newSchema.persistManagedSchema(false);
    if (success) {
      if (log.isDebugEnabled()) {
        StringBuilder fieldTypeNames = new StringBuilder();
        for (int i=0; i < fieldTypeList.size(); i++) {
          if (i > 0) fieldTypeNames.append(", ");
          fieldTypeNames.append(fieldTypeList.get(i).typeName);
        }
        log.debug("Added field types: {}", fieldTypeNames.toString());
      }
    } else {
      // this is unlikely to happen as most errors are handled as exceptions in the persist code
      log.error("Failed to add field types: {}", fieldTypeList);
      throw new SolrException(ErrorCode.SERVER_ERROR, 
          "Failed to persist updated schema due to underlying storage issue; check log for more details!");
    }
    
    return newSchema;
  }  

