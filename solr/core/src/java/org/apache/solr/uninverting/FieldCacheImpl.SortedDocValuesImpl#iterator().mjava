    public SortedDocValues iterator() {
      final BytesRef term = new BytesRef();
      return new SortedDocValues() {
        private int docID = -1;

        @Override
        public int docID() {
          return docID;
        }

        @Override
        public int nextDoc() {
          while (true) {
            docID++;
            if (docID >= docToTermOrd.size()) {
              docID = NO_MORE_DOCS;
              return docID;
            }
            if (docToTermOrd.get(docID) != 0) {
              return docID;
            }
          }
        }

        @Override
        public int advance(int target) {
          if (target < docToTermOrd.size()) {
            docID = target;
            if (docToTermOrd.get(docID) != 0) {
              return docID;
            } else{
              return nextDoc();
            }
          } else {
            docID = NO_MORE_DOCS;
            return docID;
          }
        }

        @Override
        public long cost() {
          return 0;
        }
        
        @Override
        public int ordValue() {
          // Subtract 1, matching the 1+ord we did when
          // storing, so that missing values, which are 0 in the
          // packed ints, are returned as -1 ord:
          return (int) docToTermOrd.get(docID)-1;
        }

        @Override
        public int getValueCount() {
          return numOrd;
        }

        @Override
        public BytesRef lookupOrd(int ord) {
          if (ord < 0) {
            throw new IllegalArgumentException("ord must be >=0 (got ord=" + ord + ")");
          }
          bytes.fill(term, termOrdToBytesOffset.get(ord));
          return term;
        }
      };
    }

