    private String translateComparison(RexNode node) {
      Pair<String, RexLiteral> binaryTranslated = null;
      if (((RexCall) node).getOperands().size() == 2) {
        binaryTranslated = translateBinary((RexCall) node);
      }

      switch (node.getKind()) {
        case NOT:
          return "-"+translateComparison(((RexCall) node).getOperands().get(0));
        case EQUALS:
          String terms = binaryTranslated.getValue().getValue2().toString().trim();
          if(!terms.startsWith("(")){
            terms = "\""+terms+"\"";
          }

          String clause = binaryTranslated.getKey() + ":" + terms;
          this.negativeQuery = false;
          return clause;
        case NOT_EQUALS:
          return "-(" + binaryTranslated.getKey() + ":" + binaryTranslated.getValue().getValue2()+")";
        case LESS_THAN:
          this.negativeQuery = false;
          return "("+binaryTranslated.getKey() + ": [ * TO " + binaryTranslated.getValue().getValue2() + " })";
        case LESS_THAN_OR_EQUAL:
          this.negativeQuery = false;
          return "("+binaryTranslated.getKey() + ": [ * TO " + binaryTranslated.getValue().getValue2() + " ])";
        case GREATER_THAN:
          this.negativeQuery = false;
          return "("+binaryTranslated.getKey() + ": { " + binaryTranslated.getValue().getValue2() + " TO * ])";
        case GREATER_THAN_OR_EQUAL:
          this.negativeQuery = false;
          return "("+binaryTranslated.getKey() + ": [ " + binaryTranslated.getValue().getValue2() + " TO * ])";
        default:
          throw new AssertionError("cannot translate " + node);
      }
    }

