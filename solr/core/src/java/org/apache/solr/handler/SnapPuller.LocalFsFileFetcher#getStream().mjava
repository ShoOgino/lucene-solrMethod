    /**
     * Open a new stream using HttpClient
     */
    FastInputStream getStream() throws IOException {

      ModifiableSolrParams params = new ModifiableSolrParams();

//    //the method is command=filecontent
      params.set(COMMAND, CMD_GET_FILE);
      params.set(GENERATION, Long.toString(indexGen));
      params.set(CommonParams.QT, "/replication");
      //add the version to download. This is used to reserve the download
      if (isConf) {
        //set cf instead of file for config file
        params.set(CONF_FILE_SHORT, fileName);
      } else {
        params.set(FILE, fileName);
      }
      if (useInternal) {
        params.set(COMPRESSION, "true"); 
      }
      //use checksum
      if (this.includeChecksum) {
        params.set(CHECKSUM, true);
      }
      //wt=filestream this is a custom protocol
      params.set(CommonParams.WT, FILE_STREAM);
        // This happen if there is a failure there is a retry. the offset=<sizedownloaded> ensures that
        // the server starts from the offset
      if (bytesDownloaded > 0) {
        params.set(OFFSET, Long.toString(bytesDownloaded));
      }
      

      NamedList response;
      InputStream is = null;
      HttpSolrClient client = new HttpSolrClient(masterUrl, myHttpClient, null);  //XXX use shardhandler
      try {
        client.setSoTimeout(60000);
        client.setConnectionTimeout(15000);
        QueryRequest req = new QueryRequest(params);
        response = client.request(req);
        is = (InputStream) response.get("stream");
        if(useInternal) {
          is = new InflaterInputStream(is);
        }
        return new FastInputStream(is);
      } catch (Exception e) {
        //close stream on error
        IOUtils.closeQuietly(is);
        throw new IOException("Could not download file '" + fileName + "'", e);
      } finally {
        client.shutdown();
      }
    }

