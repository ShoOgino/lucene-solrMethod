  @SuppressWarnings("unchecked")
  private void getFileList(SolrParams solrParams, SolrQueryResponse rsp) {
    String v = solrParams.required().get(GENERATION);
    long gen = Long.parseLong(v);
    if (gen == -1) {
      IndexCommit commitPoint = core.getDeletionPolicy().getLatestCommit();
      if(commitPoint == null) {
        rsp.add(CMD_GET_FILE_LIST, Collections.EMPTY_LIST);
        return;
      }
      gen = commitPoint.getGeneration();
    }
    IndexCommit commit = core.getDeletionPolicy().getCommitPoint(gen);

    if (commit == null) {
      reportErrorOnResponse(rsp, "invalid index generation", null);
      return;
    }

    // reserve the indexcommit for sometime
    core.getDeletionPolicy().setReserveDuration(gen, reserveCommitDuration);
    List<Map<String, Object>> result = new ArrayList<>();
    Directory dir = null;
    try {
      dir = core.getDirectoryFactory().get(core.getNewIndexDir(), DirContext.DEFAULT, core.getSolrConfig().indexConfig.lockType);
      SegmentInfos infos = SegmentInfos.readCommit(dir, commit.getSegmentsFileName());
      for (SegmentCommitInfo commitInfo : infos) {
        for (String file : commitInfo.files()) {
          Map<String, Object> fileMeta = new HashMap<>();
          fileMeta.put(NAME, file);
          fileMeta.put(SIZE, dir.fileLength(file));

          try (final IndexInput in = dir.openInput(file, IOContext.READONCE)) {
            try {
              long checksum = CodecUtil.retrieveChecksum(in);
              fileMeta.put(CHECKSUM, checksum);
            } catch (Exception e) {
              //TODO Should this trigger a larger error?
              log.warn("Could not read checksum from index file: " + file, e);
            }
          }

          result.add(fileMeta);
        }
      }

      // add the segments_N file

      Map<String, Object> fileMeta = new HashMap<>();
      fileMeta.put(NAME, infos.getSegmentsFileName());
      fileMeta.put(SIZE, dir.fileLength(infos.getSegmentsFileName()));
      if (infos.getId() != null) {
        try (final IndexInput in = dir.openInput(infos.getSegmentsFileName(), IOContext.READONCE)) {
          try {
            fileMeta.put(CHECKSUM, CodecUtil.retrieveChecksum(in));
          } catch (Exception e) {
            //TODO Should this trigger a larger error?
            log.warn("Could not read checksum from index file: " + infos.getSegmentsFileName(), e);
          }
        }
      }
      result.add(fileMeta);
    } catch (IOException e) {
      log.error("Unable to get file names for indexCommit generation: " + gen, e);
      reportErrorOnResponse(rsp, "unable to get file names for given index generation", e);
      return;
    } finally {
      if (dir != null) {
        try {
          core.getDirectoryFactory().release(dir);
        } catch (IOException e) {
          SolrException.log(log, "Could not release directory after fetching file list", e);
        }
      }
    }
    rsp.add(CMD_GET_FILE_LIST, result);

    if (solrParams.getBool(TLOG_FILES, false)) {
      try {
        List<Map<String, Object>> tlogfiles = getTlogFileList(commit);
        log.info("Adding tlog files to list: " + tlogfiles);
        rsp.add(TLOG_FILES, tlogfiles);
      }
      catch (IOException e) {
        log.error("Unable to get tlog file names for indexCommit generation: " + gen, e);
        reportErrorOnResponse(rsp, "unable to get tlog file names for given index generation", e);
        return;
      }
    }

    if (confFileNameAlias.size() < 1 || core.getCoreContainer().isZooKeeperAware())
      return;
    log.debug("Adding config files to list: " + includeConfFiles);
    //if configuration files need to be included get their details
    rsp.add(CONF_FILES, getConfFileInfoFromCache(confFileNameAlias, confFileInfoCache));
    rsp.add(STATUS, OK_STATUS);
  }

