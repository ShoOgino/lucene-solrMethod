  private void createMainQuery(ResponseBuilder rb) {
    ShardRequest sreq = new ShardRequest();
    sreq.purpose = ShardRequest.PURPOSE_GET_TOP_IDS;

    String keyFieldName = rb.req.getSchema().getUniqueKeyField().getName();

    // one-pass algorithm if only id and score fields are requested, but not if fl=score since that's the same as fl=*,score
    ReturnFields fields = rb.rsp.getReturnFields();

    // distrib.singlePass=true forces a one-pass query regardless of requested fields
    boolean distribSinglePass = rb.req.getParams().getBool(ShardParams.DISTRIB_SINGLE_PASS, false);

    if(distribSinglePass || (fields != null && fields.wantsField(keyFieldName)
        && fields.getRequestedFieldNames() != null  
        && (!fields.hasPatternMatching() && Arrays.asList(keyFieldName, "score").containsAll(fields.getRequestedFieldNames())))) {
      sreq.purpose |= ShardRequest.PURPOSE_GET_FIELDS;
      rb.onePassDistributedQuery = true;
    }

    sreq.params = new ModifiableSolrParams(rb.req.getParams());
    // TODO: base on current params or original params?

    // don't pass through any shards param
    sreq.params.remove(ShardParams.SHARDS);

    // set the start (offset) to 0 for each shard request so we can properly merge
    // results from the start.
    if(rb.shards_start > -1) {
      // if the client set shards.start set this explicitly
      sreq.params.set(CommonParams.START,rb.shards_start);
    } else {
      sreq.params.set(CommonParams.START, "0");
    }
    // TODO: should we even use the SortSpec?  That's obtained from the QParser, and
    // perhaps we shouldn't attempt to parse the query at this level?
    // Alternate Idea: instead of specifying all these things at the upper level,
    // we could just specify that this is a shard request.
    if(rb.shards_rows > -1) {
      // if the client set shards.rows set this explicity
      sreq.params.set(CommonParams.ROWS,rb.shards_rows);
    } else {
      sreq.params.set(CommonParams.ROWS, rb.getSortSpec().getOffset() + rb.getSortSpec().getCount());
    }

    sreq.params.set(ResponseBuilder.FIELD_SORT_VALUES,"true");

    boolean shardQueryIncludeScore = (rb.getFieldFlags() & SolrIndexSearcher.GET_SCORES) != 0 || rb.getSortSpec().includesScore();
    if (distribSinglePass) {
      String fl = rb.req.getParams().get(CommonParams.FL);
      if (fl == null) {
        if (fields.getRequestedFieldNames() == null && fields.wantsAllFields()) {
          fl = "*";
        } else  {
          fl = "";
          for (String s : fields.getRequestedFieldNames()) {
            fl += s + ",";
          }
        }
      }
      if (!fields.wantsField(keyFieldName))  {
        // the user has not requested the unique key but
        // we still need to add it otherwise mergeIds can't work
        if (fl.endsWith(",")) {
          fl += keyFieldName;
        } else  {
          fl += "," + keyFieldName;
        }
      }
      sreq.params.set(CommonParams.FL, updateFl(fl, shardQueryIncludeScore));
    } else {
      // in this first phase, request only the unique key field and any fields needed for merging.
      if (shardQueryIncludeScore) {
        sreq.params.set(CommonParams.FL, keyFieldName + ",score");
      } else {
        sreq.params.set(CommonParams.FL, keyFieldName);
      }
    }

    rb.addRequest(this, sreq);
  }

