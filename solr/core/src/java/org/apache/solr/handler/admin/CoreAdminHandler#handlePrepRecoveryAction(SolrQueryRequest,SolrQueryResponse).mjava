  protected void handlePrepRecoveryAction(SolrQueryRequest req,
      SolrQueryResponse rsp) throws IOException, InterruptedException {
    final SolrParams params = req.getParams();
    
    String cname = params.get(CoreAdminParams.CORE);
    if (cname == null) {
      cname = "";
    }
    
    String nodeName = params.get("nodeName");
    String coreNodeName = params.get("coreNodeName");
    
 
    SolrCore core =  null;

    try {
      core = coreContainer.getCore(cname);
      if (core == null) {
        throw new SolrException(ErrorCode.BAD_REQUEST, "core not found:" + cname);
      }
      String state;
      int retry = 0;
      while (true) {
        // wait until we are sure the recovering node is ready
        // to accept updates
        CloudDescriptor cloudDescriptor = core.getCoreDescriptor()
            .getCloudDescriptor();
        CloudState cloudState = coreContainer
            .getZkController()
            .getCloudState();
        ZkNodeProps nodeProps = 
            cloudState.getSlice(cloudDescriptor.getCollectionName(),
                cloudDescriptor.getShardId()).getShards().get(coreNodeName);
        state = nodeProps.get(ZkStateReader.STATE_PROP);
        boolean live = cloudState.liveNodesContain(nodeName);
        if (nodeProps != null && state.equals(ZkStateReader.RECOVERING)
            && live) {
          break;
        }
        
        if (retry++ == 30) {
          throw new SolrException(ErrorCode.BAD_REQUEST,
              "I was asked to prep for recovery for " + nodeName
                  + " but she is not live or not in a recovery state - state: " + state + " live:" + live);
        }
        
        Thread.sleep(1000);
      }
      
      // small safety net for any updates that started with state that
      // kept it from sending the update to be buffered -
      // pause for a while to let any outstanding updates finish
      
      Thread.sleep(4000);
      
      UpdateRequestProcessorChain processorChain = core
          .getUpdateProcessingChain(params.get(UpdateParams.UPDATE_CHAIN));
      
      ModifiableSolrParams reqParams = new ModifiableSolrParams(req.getParams());
      reqParams.set(DistributedUpdateProcessor.COMMIT_END_POINT, "true");
      
      SolrQueryRequest sqr = new LocalSolrQueryRequest(core, reqParams);
      UpdateRequestProcessor processor = processorChain.createProcessor(sqr,
          new SolrQueryResponse());
      CommitUpdateCommand cuc = new CommitUpdateCommand(req, false);
      
      processor.processCommit(cuc);
      processor.finish();
      
      // solrcloud_debug
//      try {
//        RefCounted<SolrIndexSearcher> searchHolder = core.getNewestSearcher(false);
//        SolrIndexSearcher searcher = searchHolder.get();
//        try {
//          System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName() + " to replicate "
//              + searcher.search(new MatchAllDocsQuery(), 1).totalHits + " gen:" + core.getDeletionPolicy().getLatestCommit().getGeneration()  + " data:" + core.getDataDir());
//        } finally {
//          searchHolder.decref();
//        }
//      } catch (Exception e) {
//        
//      }
      
    } finally {
      if (core != null) {
        core.close();
      }
    }
  }

