  /** 
   * Given a list of {@link SuggesterResult} and <code>count</code>
   * returns a {@link SuggesterResult} containing <code>count</code>
   * number of {@link LookupResult}, sorted by their associated 
   * weights
   * */
  private static SuggesterResult merge(List<SuggesterResult> suggesterResults, int count) {
    SuggesterResult result = new SuggesterResult();
    Set<String> allTokens = new HashSet<String>();
    
    // collect all tokens
    for (SuggesterResult shardResult : suggesterResults) {
      allTokens.addAll(shardResult.getTokens());
    }
    
    // Get Top N for every token in every shard (using weights)
    for (String token : allTokens) {
      Lookup.LookupPriorityQueue resultQueue = new Lookup.LookupPriorityQueue(
          count);
      for (SuggesterResult shardResult : suggesterResults) {
        List<LookupResult> suggests = shardResult.getLookupResult(token);
        if (suggests == null) {
          continue;
        }
        for (LookupResult res : suggests) {
          resultQueue.insertWithOverflow(res);
        }
      }
      List<LookupResult> sortedSuggests = new LinkedList<LookupResult>();
      Collections.addAll(sortedSuggests, resultQueue.getResults());
      result.add(token, sortedSuggests);
    }
    return result;
  }

