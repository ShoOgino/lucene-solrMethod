  void start() {
    if (!isStarted) {
      scheduler = Executors.newSingleThreadScheduledExecutor(new SolrNamedThreadFactory("cdcr-scheduler"));
      replicatorsPool = ExecutorUtil.newMDCAwareFixedThreadPool(poolSize, new SolrNamedThreadFactory("cdcr-replicator"));

      // the scheduler thread is executed every second and submits one replication task
      // per available state in the queue
      scheduler.scheduleWithFixedDelay(() -> {
        int nCandidates = statesQueue.size();
        for (int i = 0; i < nCandidates; i++) {
          // a thread that poll one state from the queue, execute the replication task, and push back
          // the state in the queue when the task is completed
          replicatorsPool.execute(() -> {
            CdcrReplicatorState state = statesQueue.poll();
            assert state != null; // Should never happen
            try {
              if (!state.isBootstrapInProgress()) {
                new CdcrReplicator(state, batchSize).run();
              } else  {
                if (log.isDebugEnabled()) {
                  log.debug("Replicator state is bootstrapping, skipping replication for target collection {}", state.getTargetCollection());
                }
              }
            } finally {
              statesQueue.offer(state);
            }
          });

        }
      }, 0, timeSchedule, TimeUnit.MILLISECONDS);
      isStarted = true;
    }
  }

