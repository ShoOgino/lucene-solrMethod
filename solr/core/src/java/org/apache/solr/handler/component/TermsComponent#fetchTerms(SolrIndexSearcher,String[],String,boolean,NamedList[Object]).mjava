  private static void fetchTerms(SolrIndexSearcher indexSearcher, String[] fields, String termList,
      boolean includeTotalTermFreq, NamedList<Object> result) throws IOException {
    List<String> splitTermList = StrUtils.splitSmart(termList, ",", true);
    // Sort the terms once
    String[] splitTerms = splitTermList.toArray(new String[splitTermList.size()]);
    // Not a great idea to trim here, but it was in the original implementation
    for (int i = 0; i < splitTerms.length; i++) {
      splitTerms[i] = splitTerms[i].trim();
    }
    Arrays.sort(splitTerms);

    IndexReaderContext topReaderContext = indexSearcher.getTopReaderContext();
    for (String field : fields) {
      SchemaField sf = indexSearcher.getSchema().getField(field);
      FieldType fieldType = sf.getType();

      if (fieldType.isPointField()) {
        NamedList<Object> termsMap = new SimpleOrderedMap<>();
        for (String term : splitTerms) {
          Query q = fieldType.getFieldQuery(null, sf, term);
          int count = indexSearcher.getDocSet(q).size();
          termsMap.add(term, count);
        }
        result.add(field, termsMap);
        continue;
      }

      // Since splitTerms is already sorted, this array will also be sorted. NOTE: this may not be true, it depends on readableToIndexed.
      Term[] terms = new Term[splitTerms.length];
      for (int i = 0; i < splitTerms.length; i++) {
        terms[i] = new Term(field, fieldType.readableToIndexed(splitTerms[i]));
      }

      TermStates[] termStates = new TermStates[terms.length];
      collectTermStates(topReaderContext, termStates, terms);

      NamedList<Object> termsMap = new SimpleOrderedMap<>();
      for (int i = 0; i < terms.length; i++) {
        if (termStates[i] != null) {
          String outTerm = fieldType.indexedToReadable(terms[i].bytes().utf8ToString());
          int docFreq = termStates[i].docFreq();
          if (!includeTotalTermFreq) {
            termsMap.add(outTerm, docFreq);
          } else {
            long totalTermFreq = termStates[i].totalTermFreq();
            NamedList<Long> termStats = new SimpleOrderedMap<>();
            termStats.add("df", (long) docFreq);
            termStats.add("ttf", totalTermFreq);
            termsMap.add(outTerm, termStats);
          }
        }
      }

      result.add(field, termsMap);
    }
  }

