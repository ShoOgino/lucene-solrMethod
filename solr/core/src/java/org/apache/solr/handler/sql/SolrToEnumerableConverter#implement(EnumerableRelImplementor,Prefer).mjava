  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
    // Generates a call to "query" with the appropriate fields
    final BlockBuilder list = new BlockBuilder();
    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();
    solrImplementor.visitChild(0, getInput());
    final RelDataType rowType = getRowType();
    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));
    final Expression table = list.append("table", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));
    final Expression fields = list.append("fields",
        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));
    final Expression query = list.append("query", Expressions.constant(solrImplementor.query, String.class));
    final Expression order = list.append("order", constantArrayList(solrImplementor.order, String.class));
    final Expression buckets = list.append("buckets", constantArrayList(solrImplementor.buckets, String.class));
    final Expression metricPairs = list.append("metricPairs", constantArrayList(solrImplementor.metricPairs, Pair.class));
    final Expression limit = list.append("limit", Expressions.constant(solrImplementor.limitValue));
    Expression enumerable = list.append("enumerable", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,
        fields, query, order, buckets, metricPairs, limit));
    Hook.QUERY_PLAN.run(query);
    list.add(Expressions.return_(null, enumerable));
    return implementor.result(physType, list.toBlock());
  }

