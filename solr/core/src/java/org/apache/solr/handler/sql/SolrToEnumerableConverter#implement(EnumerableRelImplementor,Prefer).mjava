  public Result implement(EnumerableRelImplementor implementor, Prefer pref) {
    // Generates a call to "query" with the appropriate fields and filterQueries
    final BlockBuilder list = new BlockBuilder();
    final SolrRel.Implementor solrImplementor = new SolrRel.Implementor();
    solrImplementor.visitChild(0, getInput());
    final RelDataType rowType = getRowType();
    final PhysType physType = PhysTypeImpl.of(implementor.getTypeFactory(), rowType, pref.prefer(JavaRowFormat.ARRAY));
    final Expression table = list.append("table", solrImplementor.table.getExpression(SolrTable.SolrQueryable.class));
    final Expression fields = list.append("fields",
        constantArrayList(generateFields(SolrRules.solrFieldNames(rowType), solrImplementor.fieldMappings), String.class));
    final Expression filterQueries = list.append("query", Expressions.constant(solrImplementor.query, String.class));
    final Expression order = list.append("order", constantArrayList(solrImplementor.order, String.class));
    final Expression buckets = list.append("buckets", constantArrayList(solrImplementor.buckets, String.class));
    final Expression metrics = list.append("metrics", constantArrayList(solrImplementor.metrics, Metric.class));
    final Expression limit = list.append("limit", Expressions.constant(solrImplementor.limitValue));
    Expression enumerable = list.append("enumerable", Expressions.call(table, SolrMethod.SOLR_QUERYABLE_QUERY.method,
        fields, filterQueries, order, buckets, metrics, limit));
    if (CalcitePrepareImpl.DEBUG) {
      System.out.println("Solr: " + filterQueries);
    }
    Hook.QUERY_PLAN.run(filterQueries);
    list.add(Expressions.return_(null, enumerable));
    return implementor.result(physType, list.toBlock());
  }

