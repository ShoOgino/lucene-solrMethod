  /**
   * Obtains the latest document for a given id from the tlog or through the realtime searcher (if not found in the tlog). 
   * @param versionReturned If a non-null AtomicLong is passed in, it is set to the version of the update returned from the TLog.
   * @param avoidRetrievingStoredFields Setting this to true avoids fetching stored fields through the realtime searcher,
   *                  however has no effect on documents obtained from the tlog. 
   *                  Non-stored docValues fields are populated anyway, and are not affected by this parameter. Note that if
   *                  the id field is a stored field, it will not be populated if this parameter is true and the document is
   *                  obtained from the index.
   * @param onlyTheseNonStoredDVs If not-null, populate only these DV fields in the document fetched through the realtime searcher. 
   *                  If this is null, decorate all non-stored  DVs (that are not targets of copy fields) from the searcher.
   * @param resolveFullDocument In case the document is fetched from the tlog, it could only be a partial document if the last update
   *                  was an in-place update. In that case, should this partial document be resolved to a full document (by following
   *                  back prevPointer/prevVersion)?
   */
  public static SolrInputDocument getInputDocument(SolrCore core, BytesRef idBytes, AtomicLong versionReturned, boolean avoidRetrievingStoredFields,
      Set<String> onlyTheseNonStoredDVs, boolean resolveFullDocument) throws IOException {
    SolrInputDocument sid = null;
    RefCounted<SolrIndexSearcher> searcherHolder = null;
    try {
      SolrIndexSearcher searcher = null;
      sid = getInputDocumentFromTlog(core, idBytes, versionReturned, onlyTheseNonStoredDVs, resolveFullDocument);
      if (sid == DELETED) {
        return null;
      }

      if (sid == null) {
        // didn't find it in the update log, so it should be in the newest searcher opened
        if (searcher == null) {
          searcherHolder = core.getRealtimeSearcher();
          searcher = searcherHolder.get();
        }

        // SolrCore.verbose("RealTimeGet using searcher ", searcher);
        SchemaField idField = core.getLatestSchema().getUniqueKeyField();

        int docid = searcher.getFirstMatch(new Term(idField.getName(), idBytes));
        if (docid < 0) return null;

        SolrDocumentFetcher docFetcher = searcher.getDocFetcher();
        if (avoidRetrievingStoredFields) {
          sid = new SolrInputDocument();
        } else {
          Document luceneDocument = docFetcher.doc(docid);
          sid = toSolrInputDocument(luceneDocument, core.getLatestSchema());
        }
        if (onlyTheseNonStoredDVs != null) {
          docFetcher.decorateDocValueFields(sid, docid, onlyTheseNonStoredDVs);
        } else {
          docFetcher.decorateDocValueFields(sid, docid, docFetcher.getNonStoredDVsWithoutCopyTargets());
        }
      }
    } finally {
      if (searcherHolder != null) {
        searcherHolder.decref();
      }
    }

    if (versionReturned != null) {
      if (sid.containsKey(VERSION_FIELD)) {
        versionReturned.set((long)sid.getFieldValue(VERSION_FIELD));
      }
    }
    return sid;
  }

