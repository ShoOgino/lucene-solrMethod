  /** Creates a new core and registers it. The returned core will have it's reference count incremented an extra time and close() should be called when finished. */
  private SolrCore createCore(SolrCore current, int ord, HashPartitioner.Range newRange) throws IOException, SAXException, ParserConfigurationException {
    CoreDescriptor currCoreD = current.getCoreDescriptor();
    CloudDescriptor currCloudD = currCoreD.getCloudDescriptor();

    String currName = currCoreD.getName();

    // TODO: nicer way to come up with core names?
    String name = currName + "_" + ord;

    String instanceDir = name;


    // TODO: do this via a clone / constructor?
    CoreDescriptor dcore = new CoreDescriptor(coreContainer, name, instanceDir);
    dcore.setConfigName( currCoreD.getConfigName() );
    dcore.setSchemaName(currCoreD.getSchemaName());
    // default dcore.setDataDir()

    // TODO: for this to work in non-cloud mode, we will either need to make a copy of the conf directory, or
    // develop named configs like we have in cloud mode.


    CloudDescriptor cd = null;
    if (currCloudD != null) {
      cd = new CloudDescriptor();

      // TODO: should we copy these?  any params that are core specific?
      cd.setParams( currCloudD.getParams() );
      cd.setCollectionName( currCloudD.getCollectionName() );
      cd.setRoles( currCloudD.getRoles() );

      // TODO: we must be careful that an unrelated node starting up does not try
      // to become the new shard leader!  How do we designate ourselves as the
      // leader but prevent new shards from trying to replicate from us before we are ready (i.e. have the split index)?
      String shardId = currCloudD.getShardId() + "_" + ord;
      cd.setShardId( shardId );

      dcore.setCloudDescriptor(cd);
    }

    SolrCore core = coreContainer.create(dcore);
    core.open();  // inc ref count before registering to ensure no one can close the core before we are done with it
    coreContainer.register(name, core, false);
    return core;
  }

