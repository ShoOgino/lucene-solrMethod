  /**
   * Given a mapping of keys to {@link StatsValues} representing the currently 
   * known "merged" stats (which may be null if none exist yet), and a 
   * {@link NamedList} containing the "stats" response block returned by an individual 
   * shard, this method accumulates the stasts for each {@link StatsField} found in 
   * the shard response with the existing mergeStats
   *
   * @return the original <code>merged</code> Map after modifying, or a new Map if the <code>merged</code> param was originally null.
   * @see StatsInfo#getStatsField
   * @see StatsValuesFactory#createStatsValues
   * @see StatsValues#accumulate(NamedList)
   */
  public static Map<String,StatsValues> mergeStats
    (Map<String,StatsValues> merged, 
     NamedList<NamedList<NamedList<?>>> remoteWrapper, 
     StatsInfo statsInfo) {

    if (null == merged) merged = new LinkedHashMap<String,StatsValues>();

    NamedList<NamedList<?>> remoteStats = StatsComponent.unwrapStats(remoteWrapper);

    for (Entry<String,NamedList<?>> entry : remoteStats) {
      StatsValues receivingStatsValues = merged.get(entry.getKey());
      if (receivingStatsValues == null) {
        StatsField recievingStatsField = statsInfo.getStatsField(entry.getKey());
        if (null == recievingStatsField) {
          throw new SolrException(ErrorCode.SERVER_ERROR , "No stats.field found corrisponding to pivot stats recieved from shard: "+entry.getKey());
        }
        receivingStatsValues = StatsValuesFactory.createStatsValues(recievingStatsField);
        merged.put(entry.getKey(), receivingStatsValues);
      }
      receivingStatsValues.accumulate(entry.getValue());
    }
    return merged;
  }

