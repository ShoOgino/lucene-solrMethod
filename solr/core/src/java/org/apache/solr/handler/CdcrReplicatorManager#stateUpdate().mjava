  /**
   * <p>
   * Inform the replicator manager of a change of state, and tell him to update its own state.
   * </p>
   * <p>
   * If we are the leader and the process state is STARTED, we need to initialise the log readers and start the
   * scheduled thread poll.
   * Otherwise, if the process state is STOPPED or if we are not the leader, we need to close the log readers and stop
   * the thread pool.
   * </p>
   * <p>
   * This method is synchronised as it can both be called by the leaderStateManager and the processStateManager.
   * </p>
   */
  @Override
  public synchronized void stateUpdate() {
    if (leaderStateManager.amILeader() && processStateManager.getState().equals(CdcrParams.ProcessState.STARTED)) {
      if (replicatorStates.size() > 0)  {
        this.bootstrapExecutor = ExecutorUtil.newMDCAwareFixedThreadPool(replicatorStates.size(),
            new SolrjNamedThreadFactory("cdcr-bootstrap-status"));
      }
      this.initLogReaders();
      this.scheduler.start();
      return;
    }

    this.scheduler.shutdown();
    if (bootstrapExecutor != null)  {
      IOUtils.closeQuietly(bootstrapStatusRunnable);
      ExecutorUtil.shutdownAndAwaitTermination(bootstrapExecutor);
    }
    this.closeLogReaders();
    Callable callable = core.getSolrCoreState().getCdcrBootstrapCallable();
    if (callable != null)  {
      CdcrRequestHandler.BootstrapCallable bootstrapCallable = (CdcrRequestHandler.BootstrapCallable) callable;
      IOUtils.closeQuietly(bootstrapCallable);
    }
  }

