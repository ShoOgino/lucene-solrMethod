  private void handleBootstrapAction(SolrQueryRequest req, SolrQueryResponse rsp) throws IOException, InterruptedException, SolrServerException {
    String collectionName = core.getCoreDescriptor().getCloudDescriptor().getCollectionName();
    String shard = core.getCoreDescriptor().getCloudDescriptor().getShardId();
    if (!leaderStateManager.amILeader()) {
      log.warn("Action {} sent to non-leader replica @ {}:{}", CdcrParams.CdcrAction.BOOTSTRAP, collectionName, shard);
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Action " + CdcrParams.CdcrAction.BOOTSTRAP +
          " sent to non-leader replica");
    }
    CountDownLatch latch = new CountDownLatch(1); // latch to make sure BOOTSTRAP_STATUS gives correct response

    //additional logging
    log.info("cdcr: bootstrap executing for collection: " + collectionName + " and shard: " + shard);

    Runnable runnable = () -> {
      Lock recoveryLock = req.getCore().getSolrCoreState().getRecoveryLock();
      boolean locked = recoveryLock.tryLock();
      SolrCoreState coreState = core.getSolrCoreState();
      try {
        if (!locked)  {
          //additional logging
          log.info("cdcr: couldn't acquire lock for bootstrap, issue CANCEL");
          handleCancelBootstrap(req, rsp);
        } else if (leaderStateManager.amILeader())  {
          coreState.setCdcrBootstrapRunning(true);
          latch.countDown(); // free the latch as current bootstrap is executing
          //additional logging
          log.info("cdcr: acquire lock for bootstrap, latch removed");
          //running.set(true);
          String masterUrl = req.getParams().get(ReplicationHandler.MASTER_URL);
          BootstrapCallable bootstrapCallable = new BootstrapCallable(masterUrl, core);
          coreState.setCdcrBootstrapCallable(bootstrapCallable);
          Future<Boolean> bootstrapFuture = core.getCoreContainer().getUpdateShardHandler().getRecoveryExecutor()
              .submit(bootstrapCallable);
          coreState.setCdcrBootstrapFuture(bootstrapFuture);
          try {
            bootstrapFuture.get();
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Bootstrap was interrupted", e);
          } catch (ExecutionException e) {
            log.error("Bootstrap operation failed", e);
          }
        } else  {
          log.error("Action {} sent to non-leader replica @ {}:{}. Aborting bootstrap.", CdcrParams.CdcrAction.BOOTSTRAP, collectionName, shard);
        }
      } finally {
        if (locked) {
          coreState.setCdcrBootstrapRunning(false);
          recoveryLock.unlock();
        } else {
          latch.countDown(); // free the latch as current bootstrap is executing
        }
      }
      //additional logging
      log.info("cdcr: bootstrap status after action: " + coreState.getCdcrBootstrapRunning());
    };

    try {
      core.getCoreContainer().getUpdateShardHandler().getUpdateExecutor().submit(runnable);
      rsp.add(RESPONSE_STATUS, "submitted");
      latch.await(10000, TimeUnit.MILLISECONDS); // put the latch for current bootstrap command
    } catch (RejectedExecutionException ree)  {
      // no problem, we're probably shutting down
      rsp.add(RESPONSE_STATUS, "failed");
    }
  }

