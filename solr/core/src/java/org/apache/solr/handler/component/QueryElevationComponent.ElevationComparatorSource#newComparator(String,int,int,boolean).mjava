  @Override
  public FieldComparator<Integer> newComparator(final String fieldname, final int numHits, int sortPos, boolean reversed) throws IOException {
    return new FieldComparator<Integer>() {
      private final int[] values = new int[numHits];
      private int bottomVal;
      private TermsEnum termsEnum;
      private DocsEnum docsEnum;
      Set<String> seen = new HashSet<String>(elevations.ids.size());

      @Override
      public int compare(int slot1, int slot2) {
        return values[slot2] - values[slot1];  // values will be small enough that there is no overflow concern
      }

      @Override
      public void setBottom(int slot) {
        bottomVal = values[slot];
      }

      private int docVal(int doc) throws IOException {
        if (ordSet.size() > 0) {
          int slot = ordSet.find(doc);
          if (slot >= 0) {
            BytesRef id = termValues[slot];
            Integer prio = elevations.priority.get(id);
            return prio == null ? 0 : prio.intValue();
          }
        }
        return 0;
      }

      @Override
      public int compareBottom(int doc) throws IOException {
        return docVal(doc) - bottomVal;
      }

      @Override
      public void copy(int slot, int doc) throws IOException {
        values[slot] = docVal(doc);
      }

      @Override
      public FieldComparator setNextReader(AtomicReaderContext context) throws IOException {
        //convert the ids to Lucene doc ids, the ordSet and termValues needs to be the same size as the number of elevation docs we have
        ordSet.clear();
        Fields fields = context.reader.fields();
        if (fields == null) return this;
        Terms terms = fields.terms(fieldname);
        if (terms == null) return this;
        termsEnum = terms.iterator(termsEnum);
        BytesRef term = new BytesRef();
        Bits liveDocs = context.reader.getLiveDocs();

        for (String id : elevations.ids) {
          term.copyChars(id);
          if (seen.contains(id) == false  && termsEnum.seekExact(term, false)) {
            docsEnum = termsEnum.docs(liveDocs, docsEnum, false);
            if (docsEnum != null) {
              int docId = docsEnum.nextDoc();
              if (docId == DocIdSetIterator.NO_MORE_DOCS ) continue;  // must have been deleted
              termValues[ordSet.put(docId)] = BytesRef.deepCopyOf(term);
              seen.add(id);
              assert docsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;
            }
          }
        }
        return this;
      }

      @Override
      public Integer value(int slot) {
        return values[slot];
      }
    };
  }

