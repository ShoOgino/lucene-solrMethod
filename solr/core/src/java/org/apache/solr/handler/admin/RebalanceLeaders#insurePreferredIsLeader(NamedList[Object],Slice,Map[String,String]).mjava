  private void insurePreferredIsLeader(NamedList<Object> results,
                                       Slice slice, Map<String, String> currentRequests) throws KeeperException, InterruptedException {
    final String inactivePreferreds = "inactivePreferreds";
    final String alreadyLeaders = "alreadyLeaders";
    String collectionName = req.getParams().get(COLLECTION_PROP);

    for (Replica replica : slice.getReplicas()) {
      // Tell the replica to become the leader if we're the preferred leader AND active AND not the leader already
      if (replica.getBool(SliceMutator.PREFERRED_LEADER_PROP, false) == false) {
        continue;
      }
      // OK, we are the preferred leader, are we the actual leader?
      if (replica.getBool(LEADER_PROP, false)) {
        //We're a preferred leader, but we're _also_ the leader, don't need to do anything.
        NamedList<Object> noops = (NamedList<Object>) results.get(alreadyLeaders);
        if (noops == null) {
          noops = new NamedList<>();
          results.add(alreadyLeaders, noops);
        }
        NamedList<Object> res = new NamedList<>();
        res.add("status", "success");
        res.add("msg", "Already leader");
        res.add("shard", slice.getName());
        res.add("nodeName", replica.getNodeName());
        noops.add(replica.getName(), res);
        return; // already the leader, do nothing.
      }

      // We're the preferred leader, but someone else is leader. Only become leader if we're active.
      if (replica.getState() != Replica.State.ACTIVE) {
        NamedList<Object> inactives = (NamedList<Object>) results.get(inactivePreferreds);
        if (inactives == null) {
          inactives = new NamedList<>();
          results.add(inactivePreferreds, inactives);
        }
        NamedList<Object> res = new NamedList<>();
        res.add("status", "skipped");
        res.add("msg", "Node is a referredLeader, but it's inactive. Skipping");
        res.add("shard", slice.getName());
        res.add("nodeName", replica.getNodeName());
        inactives.add(replica.getName(), res);
        return; // Don't try to become the leader if we're not active!
      }

      // Replica is the preferred leader but not the actual leader, do something about that.
      // "Something" is
      // 1> if the preferred leader isn't first in line, tell it to re-queue itself.
      // 2> tell the actual leader to re-queue itself.

      ZkStateReader zkStateReader = coreContainer.getZkController().getZkStateReader();

      List<String> electionNodes = OverseerTaskProcessor.getSortedElectionNodes(zkStateReader.getZkClient(),
          ZkStateReader.getShardLeadersElectPath(collectionName, slice.getName()));

      if (electionNodes.size() < 2) { // if there's only one node in the queue, should already be leader and we shouldn't be here anyway.
        CollectionsHandler.log.warn("Rebalancing leaders and slice " + slice.getName() + " has less than two elements in the leader " +
            "election queue, but replica " + replica.getName() + " doesn't think it's the leader. Do nothing");
        return;
      }

      // Ok, the sorting for election nodes is a bit strange. If the sequence numbers are the same, then the whole
      // string is used, but that sorts nodes with the same sequence number by their session IDs from ZK.
      // While this is determinate, it's not quite what we need, so re-queue nodes that aren't us and are
      // watching the leader node..

      String firstWatcher = electionNodes.get(1);

      if (LeaderElector.getNodeName(firstWatcher).equals(replica.getName()) == false) {
        makeReplicaFirstWatcher(collectionName, slice, replica);
      }

      String coreName = slice.getReplica(LeaderElector.getNodeName(electionNodes.get(0))).getStr(CORE_NAME_PROP);
      rejoinElection(collectionName, slice, electionNodes.get(0), coreName, false);
      waitForNodeChange(collectionName, slice, electionNodes.get(0));


      return; // Done with this slice, skip the rest of the replicas.
    }
  }

