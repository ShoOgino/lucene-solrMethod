  public static SimpleOrderedMap<Object> getIndexInfo( DirectoryReader reader, int numTerms,
                                                       Map<String, TopTermQueue> topTerms,
                                                       Set<String> fieldList) throws IOException {
    Directory dir = reader.directory();
    SimpleOrderedMap<Object> indexInfo = new SimpleOrderedMap<Object>();

    indexInfo.add("numDocs", reader.numDocs());
    indexInfo.add("maxDoc", reader.maxDoc());
    final CharsRef spare = new CharsRef();
    if( numTerms > 0 ) {
      Fields fields = MultiFields.getFields(reader);
      long totalTerms = 0;
      if (fields != null) {
        FieldsEnum fieldsEnum = fields.iterator();
        String field;
        while ((field = fieldsEnum.next()) != null) {
          Terms terms = fieldsEnum.terms();
          if (terms == null) {
            continue;
          }
          totalTerms += terms.getUniqueTermCount();

          if (fieldList != null && ! fieldList.contains(field) && ! fieldList.contains("*")) {
            continue;
          }

          TermsEnum termsEnum = terms.iterator(null);
          BytesRef text;
          int[] buckets = new int[HIST_ARRAY_SIZE];
          TopTermQueue tiq = topTerms.get(field);
          if (tiq == null) {
            tiq = new TopTermQueue(numTerms + 1);   // Allocating slots for the top N terms to collect freqs.
            topTerms.put(field, tiq);
          }
          while ((text = termsEnum.next()) != null) {
            int freq = termsEnum.docFreq();  // This calculation seems odd, but it gives the same results as it used to.
            int slot = 32 - Integer.numberOfLeadingZeros(Math.max(0, freq - 1));
            buckets[slot] = buckets[slot] + 1;
            if (freq > tiq.minFreq) {
              UnicodeUtil.UTF8toUTF16(text, spare);
              String t = spare.toString();
              tiq.distinctTerms = new Long(fieldsEnum.terms().getUniqueTermCount()).intValue();

              tiq.add(new TopTermQueue.TermInfo(new Term(field, t), termsEnum.docFreq()));
              if (tiq.size() > numTerms) { // if tiq full
                tiq.pop(); // remove lowest in tiq
                tiq.minFreq  = tiq.getTopTermInfo().docFreq;
              }
            }
          }
          tiq.histogram.add(buckets);
        }
      }
      //Clumsy, but I'm tired.
      indexInfo.add("numTerms", (new Long(totalTerms)).intValue());

    }
        
    indexInfo.add("version", reader.getVersion());  // TODO? Is this different then: IndexReader.getCurrentVersion( dir )?
    indexInfo.add("segmentCount", reader.getSequentialSubReaders().length);
    indexInfo.add("current", reader.isCurrent() );
    indexInfo.add("hasDeletions", reader.hasDeletions() );
    indexInfo.add("directory", dir );
    indexInfo.add("userData", reader.getIndexCommit().getUserData());
    String s = reader.getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY);
    if (s != null) {
      indexInfo.add("lastModified", new Date(Long.parseLong(s)));
    }
    return indexInfo;
  }
  //////////////////////// SolrInfoMBeans methods //////////////////////

