  public void handleKeyRequest(String[] keys, BiConsumer<String, Object> consumer) throws Exception {
    SimpleOrderedMap result = new SimpleOrderedMap();
    SimpleOrderedMap errors = new SimpleOrderedMap();
    for (String key : keys) {
      if (key == null || key.isEmpty()) {
        continue;
      }
      String[] parts = KEY_REGEX.split(key);
      if (parts.length < 2 || parts.length > 3) {
        errors.add(key, "at least two and at most three colon-separated parts must be provided");
        continue;
      }
      final String registryName = unescape(parts[0]);
      final String metricName = unescape(parts[1]);
      final String propertyName = parts.length > 2 ? unescape(parts[2]) : null;
      if (!metricManager.hasRegistry(registryName)) {
        errors.add(key, "registry '" + registryName + "' not found");
        continue;
      }
      MetricRegistry registry = metricManager.registry(registryName);
      Metric m = registry.getMetrics().get(metricName);
      if (m == null) {
        errors.add(key, "metric '" + metricName + "' not found");
        continue;
      }
      MetricUtils.PropertyFilter propertyFilter = MetricUtils.PropertyFilter.ALL;
      if (propertyName != null) {
        propertyFilter = (name) -> name.equals(propertyName);
        // use escaped versions
        key = parts[0] + ":" + parts[1];
      }
      MetricUtils.convertMetric(key, m, propertyFilter, false, true, true, false, ":", (k, v) -> {
        if ((v instanceof Map) && propertyName != null) {
          ((Map)v).forEach((k1, v1) -> result.add(k + ":" + k1, v1));
        } else {
          result.add(k, v);
        }
      });
    }
    consumer.accept("metrics", result);
    if (errors.size() > 0) {
      consumer.accept("errors", errors);
    }
  }

