  /**
   * Recursive function to do all the pivots
   */
  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,
                                             String field, String subField, Deque<String> fnames,
                                             DocSet docs) throws IOException
  {
    SolrIndexSearcher searcher = rb.req.getSearcher();
    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below
    SchemaField sfield = searcher.getSchema().getField(field);
    FieldType ftype = sfield.getType();

    String nextField = fnames.poll();

    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );
    for (Map.Entry<String, Integer> kv : superFacets) {
      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though
      if (kv.getValue() >= minMatch) {

        // may be null when using facet.missing
        final String fieldValue = kv.getKey(); 

        // don't reuse the same BytesRef each time since we will be 
        // constructing Term objects used in TermQueries that may be cached.
        BytesRef termval = null;

        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();
        pivot.add( "field", field );
        if (null == fieldValue) {
          pivot.add( "value", null );
        } else {
          termval = new BytesRef();
          ftype.readableToIndexed(fieldValue, termval);
          pivot.add( "value", ftype.toObject(sfield, termval) );
        }
        pivot.add( "count", kv.getValue() );
        
        if( subField == null ) {
          values.add( pivot );
        }
        else {
          DocSet subset = null;
          if ( null == termval ) {
            DocSet hasVal = searcher.getDocSet
              (new TermRangeQuery(field, null, null, false, false));
            subset = docs.andNot(hasVal);
          } else {
            Query query = new TermQuery(new Term(field, termval));
            subset = searcher.getDocSet(query, docs);
          }
          super.docs = subset;//used by getTermCounts()

          NamedList<Integer> nl = this.getTermCounts(subField);
          if (nl.size() >= minMatch) {
            pivot.add( "pivot", doPivots( nl, subField, nextField, fnames, subset) );
            values.add( pivot ); // only add response if there are some counts
          }
        }
      }
    }
    
    // put the field back on the list
    fnames.push( nextField );
    return values;
  }

