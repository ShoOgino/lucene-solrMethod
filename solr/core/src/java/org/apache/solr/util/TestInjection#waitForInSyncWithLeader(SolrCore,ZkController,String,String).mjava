  @SuppressForbidden(reason = "Need currentTimeMillis, because COMMIT_TIME_MSEC_KEY use currentTimeMillis as value")
  public static boolean waitForInSyncWithLeader(SolrCore core, ZkController zkController, String collection, String shardId) {
    if (waitForReplicasInSync == null) return true;
    log.info("Start waiting for replica in sync with leader");
    long currentTime = System.currentTimeMillis();
    Pair<Boolean,Integer> pair = parseValue(waitForReplicasInSync);
    boolean enabled = pair.first();
    if (!enabled) return true;
    long t = System.currentTimeMillis() - 200;
    for (int i = 0; i < pair.second(); i++) {
      try {
        if (core.isClosed()) return true;
        Replica leaderReplica = zkController.getZkStateReader().getLeaderRetry(
            collection, shardId);
        try (HttpSolrClient leaderClient = new HttpSolrClient.Builder(leaderReplica.getCoreUrl()).build()) {
          ModifiableSolrParams params = new ModifiableSolrParams();
          params.set(CommonParams.QT, ReplicationHandler.PATH);
          params.set(COMMAND, CMD_DETAILS);
  
          NamedList<Object> response = leaderClient.request(new QueryRequest(params));
          long leaderVersion = (long) ((NamedList)response.get("details")).get("indexVersion");
          String localVersion = core.withSearcher(searcher ->
              searcher.getIndexReader().getIndexCommit().getUserData().get(SolrIndexWriter.COMMIT_TIME_MSEC_KEY));
          if (localVersion == null && leaderVersion == 0 && !core.getUpdateHandler().getUpdateLog().hasUncommittedChanges())
            return true;
          if (localVersion != null && Long.parseLong(localVersion) == leaderVersion && (leaderVersion >= t || i >= 6)) {
            log.info("Waiting time for tlog replica to be in sync with leader: {}", System.currentTimeMillis()-currentTime);
            return true;
          } else {
            log.debug("Tlog replica not in sync with leader yet. Attempt: {}. Local Version={}, leader Version={}", i, localVersion, leaderVersion);
            Thread.sleep(500);
          }
  
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        if (core.isClosed()) return true;
        log.error("Thread interrupted while waiting for core {} to be in sync with leader", core.getName());
        return false;
      } catch (Exception e) {
        if (core.isClosed()) return true;
        log.error("Exception when wait for replicas in sync with master. Will retry until timeout.", e);
      }
    }
    return false;
  }

