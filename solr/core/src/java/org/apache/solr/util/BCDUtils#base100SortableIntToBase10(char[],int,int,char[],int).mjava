  // Converts a base100 sortable number to base10 character form
// returns number of chars written.
// At least 1 char is always written.
  public static int base100SortableIntToBase10(char[] arr, int start, int end,
                                               char[] out, int offset)
  {
    // Take care of "0" case first.  It's the only number that is represented
    // in one char.
    if (end-start == 1) {
      out[offset]='0';
      return 1;
    }

    int wpos = offset;  // write position
    boolean neg = false;
    int exp = arr[start++];
    if (exp < ZERO_EXPONENT) {
      neg=true;
      exp = ZERO_EXPONENT - exp;
      out[wpos++]='-';
    }

    boolean firstDigit=true;
    while (start < end) {
      int val = arr[start++];
      if (neg) val = 99 - val;
      // opt - if we ever want a faster version we can avoid one integer
      // divide by using fixed point math to multiply by 1/10
      // http://www.cs.uiowa.edu/~jones/bcd/divide.html
      // TIP: write a small function in gcc or cl and see what
      // the optimized assemply output looks like (and which is fastest).
      // In C you can specify "unsigned" which gives the compiler more
      // info than the Java compiler has.
      char tens = (char)(val / 10 + '0');
      if (!firstDigit || tens!='0') {  // skip leading 0
        out[wpos++] = tens;      // write tens position
      }
      out[wpos++] = (char)(val % 10 + '0');    // write ones position
      firstDigit=false;
    }

    // OPTIONAL: if trailing zeros were truncated, then this is where
    // we would restore them (compare number of chars read vs exponent)

    return wpos-offset;
  }

