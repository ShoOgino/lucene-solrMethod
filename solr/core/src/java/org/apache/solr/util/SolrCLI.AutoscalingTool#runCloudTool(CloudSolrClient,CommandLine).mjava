    @Override
    protected void runCloudTool(CloudSolrClient cloudSolrClient, CommandLine cli) throws Exception {
      DistributedQueueFactory dummmyFactory = new DistributedQueueFactory() {
        @Override
        public DistributedQueue makeQueue(String path) throws IOException {
          throw new UnsupportedOperationException("makeQueue");
        }

        @Override
        public void removeQueue(String path) throws IOException {
          throw new UnsupportedOperationException("removeQueue");
        }
      };
      try (SolrClientCloudManager realCloudManager = new SolrClientCloudManager(dummmyFactory, cloudSolrClient)) {
        AutoScalingConfig config = null;
        HashSet<String> liveNodes = new HashSet<>();
        String configFile = cli.getOptionValue("a");
        if (configFile != null) {
          if (verbose) {
            log.info("- reading autoscaling config from " + configFile);
          }
          config = new AutoScalingConfig(IOUtils.toByteArray(new FileInputStream(configFile)));
        } else {
          if (verbose) {
            log.info("- reading autoscaling config from the cluster.");
          }
          config = realCloudManager.getDistribStateManager().getAutoScalingConfig();
        }
        // freeze the cluster state
        SimCloudManager cloudManager = SimCloudManager.createCluster(realCloudManager, TimeSource.get("simTime:50"));
        liveNodes.addAll(cloudManager.getClusterStateProvider().getLiveNodes());
        boolean withSuggestions = cli.hasOption("s");
        boolean withDiagnostics = cli.hasOption("d") || cli.hasOption("n");
        boolean withSortedNodes = cli.hasOption("n");
        boolean withClusterState = cli.hasOption("c");
        boolean withStats = cli.hasOption("stats");
        boolean redact = cli.hasOption("r");
        if (cli.hasOption("all")) {
          withSuggestions = true;
          withDiagnostics = true;
          withSortedNodes = true;
          withClusterState = true;
          withStats = true;
        }
        // prepare to redact also host names / IPs in base_url and other properties
        Set<String> redactNames = new HashSet<>();
        for (String nodeName : liveNodes) {
          String urlString = Utils.getBaseUrlForNodeName(nodeName, "http");
          try {
            URL u = new URL(urlString);
            // protocol format
            redactNames.add(u.getHost() + ":" + u.getPort());
            // node name format
            redactNames.add(u.getHost() + "_" + u.getPort() + "_");
          } catch (MalformedURLException e) {
            log.warn("Invalid URL for node name " + nodeName + ", replacing including protocol and path", e);
            redactNames.add(urlString);
            redactNames.add(Utils.getBaseUrlForNodeName(nodeName, "https"));
          }
        }
        // redact collection names too
        Set<String> redactCollections = new HashSet<>();
        ClusterState clusterState = cloudManager.getClusterStateProvider().getClusterState();
        clusterState.forEachCollection(coll -> redactCollections.add(coll.getName()));
        if (!withSuggestions && !withDiagnostics) {
          withSuggestions = true;
        }
        Map<String, Object> results = prepareResults(cloudManager, config, withClusterState,
            withStats, withSuggestions, withSortedNodes, withDiagnostics);
        if (cli.hasOption("simulate")) {
          String iterStr = cli.getOptionValue("i", "10");
          int iterations;
          try {
            iterations = Integer.parseInt(iterStr);
          } catch (Exception e) {
            log.warn("Invalid option 'i' value, using default 10:" + e);
            iterations = 10;
          }
          Map<String, Object> simulationResults = new HashMap<>();
          simulate(cloudManager, config, simulationResults, withClusterState,
              withStats, withSuggestions, withSortedNodes, withDiagnostics, iterations);
          results.put("simulation", simulationResults);
        }
        String data = Utils.toJSONString(results);
        if (redact) {
          data = RedactionUtils.redactNames(redactCollections, COLL_REDACTION_PREFIX, data);
          data = RedactionUtils.redactNames(redactNames, NODE_REDACTION_PREFIX, data);
        }
        stdout.println(data);
      }
    }

