  @Override
  public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
    // prescreen access first
    V val = get(key);
    if (val != null) {
      return val;
    }
    AtomicBoolean newValue = new AtomicBoolean();
    if (islive) {
      stats.accessCounter.increment();
    }
    CacheEntry<K, V> entry =  map.computeIfAbsent(key, k -> {
      V value = mappingFunction.apply(key);
      // preserve the semantics of computeIfAbsent
      if (value == null) {
        return null;
      }
      CacheEntry<K, V> e = new CacheEntry<>(key, value, timeSource.getEpochTimeNs());
      newValue.set(true);
      oldestEntry.updateAndGet(x -> x > e.lastAccessed  || x == 0 ? e.lastAccessed : x);
      stats.size.increment();
      ramBytes.add(e.ramBytesUsed() + HASHTABLE_RAM_BYTES_PER_ENTRY); // added key + value + entry
      if (islive) {
        stats.putCounter.increment();
      } else {
        stats.nonLivePutCounter.increment();
      }
      return e;
    });
    if (newValue.get()) {
      maybeMarkAndSweep();
    } else {
      if (islive && entry != null) {
        entry.lastAccessed = timeSource.getEpochTimeNs();
        entry.hits.increment();
      }
    }
    return entry != null ? entry.value : null;
  }

