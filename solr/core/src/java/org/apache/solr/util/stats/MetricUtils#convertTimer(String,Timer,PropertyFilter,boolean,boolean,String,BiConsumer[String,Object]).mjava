  /**
   * Convert a {@link Timer} to a map.
   * @param name metric name
   * @param timer timer instance
   * @param propertyFilter limit what properties of a metric are returned
   * @param skipHistograms if true then discard the histogram part of the timer.
   * @param simple use simplified representation for complex metrics - instead of a (name, map)
   *             only the selected (name "." key, value) pairs will be produced.
   * @param consumer consumer that accepts produced objects
   */
  public static void convertTimer(String name, Timer timer, PropertyFilter propertyFilter, boolean skipHistograms,
                                                boolean simple, String separator, BiConsumer<String, Object> consumer) {
    if (simple) {
      String prop = "meanRate";
      if (propertyFilter.accept(prop)) {
        consumer.accept(name + separator + prop, timer.getMeanRate());
      }
    } else {
      Map<String, Object> response = new LinkedHashMap<>();
      BiConsumer<String,Object> filter = (k, v) -> {
        if (propertyFilter.accept(k)) {
          response.put(k, v);
        }
      };
      filter.accept("count", timer.getCount());
      filter.accept("meanRate", timer.getMeanRate());
      filter.accept("1minRate", timer.getOneMinuteRate());
      filter.accept("5minRate", timer.getFiveMinuteRate());
      filter.accept("15minRate", timer.getFifteenMinuteRate());
      if (!skipHistograms) {
        // time-based values in nanoseconds
        addSnapshot(response, timer.getSnapshot(), propertyFilter, true);
      }
      if (!response.isEmpty()) {
        consumer.accept(name, response);
      }
    }
  }

