  /**
   * Convert an instance of {@link AggregateMetric}.
   * @param name metric name
   * @param metric an instance of {@link AggregateMetric}
   * @param skipAggregateValues discard internal values of {@link AggregateMetric}-s.
   * @param simple use simplified representation for complex metrics - instead of a (name, map)
   *             only the selected (name "." key, value) pairs will be produced.
   * @param consumer consumer that accepts produced objects
   */
  static void convertAggregateMetric(String name, AggregateMetric metric,
      boolean skipAggregateValues, boolean simple, BiConsumer<String, Object> consumer) {
    if (simple) {
      consumer.accept(name + "." + MEAN, metric.getMean());
    } else {
      Map<String, Object> response = new LinkedHashMap<>();
      response.put("count", metric.size());
      response.put(MAX, metric.getMax());
      response.put(MIN, metric.getMin());
      response.put(MEAN, metric.getMean());
      response.put(STDDEV, metric.getStdDev());
      response.put(SUM, metric.getSum());
      if (!(metric.isEmpty() || skipAggregateValues)) {
        Map<String, Object> values = new LinkedHashMap<>();
        response.put(VALUES, values);
        metric.getValues().forEach((k, v) -> {
          Map<String, Object> map = new LinkedHashMap<>();
          map.put("value", v.value);
          map.put("updateCount", v.updateCount.get());
          values.put(k, map);
        });
      }
      consumer.accept(name, response);
    }
  }

