  public static void toNamedMaps(MetricRegistry registry, List<MetricFilter> shouldMatchFilters,
                MetricFilter mustMatchFilter, boolean skipHistograms, boolean skipAggregateValues,
                BiConsumer<String, Map<String, Object>> consumer) {
    Map<String, Metric> metrics = registry.getMetrics();
    SortedSet<String> names = registry.getNames();
    names.stream()
        .filter(s -> shouldMatchFilters.stream().anyMatch(metricFilter -> metricFilter.matches(s, metrics.get(s))))
        .filter(s -> mustMatchFilter.matches(s, metrics.get(s)))
        .forEach(n -> {
          Metric metric = metrics.get(n);
          if (metric instanceof Counter) {
            Counter counter = (Counter) metric;
            consumer.accept(n, counterToMap(counter));
          } else if (metric instanceof Gauge) {
            Gauge gauge = (Gauge) metric;
            consumer.accept(n, gaugeToMap(gauge));
          } else if (metric instanceof Meter) {
            Meter meter = (Meter) metric;
            consumer.accept(n, meterToMap(meter));
          } else if (metric instanceof Timer) {
            Timer timer = (Timer) metric;
            consumer.accept(n, timerToMap(timer, skipHistograms));
          } else if (metric instanceof Histogram) {
            if (!skipHistograms) {
              Histogram histogram = (Histogram) metric;
              consumer.accept(n, histogramToMap(histogram));
            }
          } else if (metric instanceof AggregateMetric) {
            consumer.accept(n, aggregateMetricToMap((AggregateMetric)metric, skipAggregateValues));
          }
        });
  }

