  @SuppressWarnings({"unchecked"})
  private static boolean usePolicyFramework(Optional<DocCollection> collection, SolrCloudManager cloudManager) throws IOException, InterruptedException {
    boolean useLegacyAssignment = true;
    Map<String, Object> clusterProperties = cloudManager.getClusterStateProvider().getClusterProperties();
    if (clusterProperties.containsKey(CollectionAdminParams.DEFAULTS))  {
      Map<String, Object> defaults = (Map<String, Object>) clusterProperties.get(CollectionAdminParams.DEFAULTS);
      Map<String, Object> collectionDefaults = (Map<String, Object>) defaults.getOrDefault(CollectionAdminParams.CLUSTER, Collections.emptyMap());
      useLegacyAssignment = Boolean.parseBoolean(collectionDefaults.getOrDefault(CollectionAdminParams.USE_LEGACY_REPLICA_ASSIGNMENT, "true").toString());
    }

    if (!useLegacyAssignment) {
      // if legacy assignment is not selected then autoscaling is always available through the implicit policy/preferences
      return true;
    }

    // legacy assignment is turned on, which means we must look at the actual autoscaling config
    // to determine whether policy framework can be used or not for this collection

    AutoScalingConfig autoScalingConfig = cloudManager.getDistribStateManager().getAutoScalingConfig();
    // if no autoscaling configuration exists then obviously we cannot use the policy framework
    if (autoScalingConfig.getPolicy().isEmpty()) return false;
    // do custom preferences exist
    if (!autoScalingConfig.getPolicy().hasEmptyPreferences()) return true;
    // does a cluster policy exist
    if (!autoScalingConfig.getPolicy().getClusterPolicy().isEmpty()) return true;
    // finally we check if the current collection has a policy
    return !collection.isPresent() || collection.get().getPolicyName() != null;
  }

