  /**
   * Factory method for implementations of this interface. There should be no reason to construct instances
   * elsewhere, and routed alias types are encouraged to have package private constructors.
   *
   * @param aliasName The alias name (will be returned by {@link #getAliasName()}
   * @param props     The properties from an overseer message.
   * @return An implementation appropriate for the supplied properties, or null if no type is specified.
   * @throws SolrException If the properties are invalid or the router type is unknown.
   */
  static RoutedAlias fromProps(String aliasName, Map<String, String> props) throws SolrException {

    String typeStr = props.get(ROUTER_TYPE_NAME);
    if (typeStr == null) {
      return null; // non-routed aliases are being created
    }
    SupportedRouterTypes routerType;
    try {
       routerType = SupportedRouterTypes.valueOf(typeStr.toUpperCase(Locale.ENGLISH));
    } catch (IllegalArgumentException e) {
      throw new SolrException(BAD_REQUEST, "Router name: " + typeStr + " is not in supported types, "
          + Arrays.asList(SupportedRouterTypes.values()));
    }
    switch (routerType) {
      case TIME:
        return new TimeRoutedAlias(aliasName, props);
      case CATEGORY:
        return new CategoryRoutedAlias(aliasName, props);
      default:
        // if we got a type not handled by the switch there's been a bogus implementation.
        throw new SolrException(SERVER_ERROR, "Router " + routerType + " is not fully implemented. If you see this" +
            "error in an official release please file a bug report. Available types were:"
            + Arrays.asList(SupportedRouterTypes.values()));

    }
  }

