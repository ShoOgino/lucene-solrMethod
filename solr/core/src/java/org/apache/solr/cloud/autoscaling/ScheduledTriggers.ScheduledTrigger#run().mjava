    @Override
    public void run() {
      if (isClosed) {
        throw new AlreadyClosedException("ScheduledTrigger " + trigger.getName() + " has been closed.");
      }
      // fire a trigger only if an action is not pending
      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger
      // is still executing. There is additional protection against that scenario in the event listener.
      if (!hasPendingActions.get())  {
        // replay accumulated events on first run, if any
        if (replay) {
          TriggerEvent event;
          // peek first without removing - we may crash before calling the listener
          while ((event = queue.peekEvent()) != null) {
            // override REPLAYING=true
            event.getProperties().put(TriggerEvent.REPLAYING, true);
            if (! trigger.getProcessor().process(event)) {
              log.error("Failed to re-play event, discarding: " + event);
            }
            queue.pollEvent(); // always remove it from queue
          }
          // now restore saved state to possibly generate new events from old state on the first run
          try {
            trigger.restoreState();
          } catch (Exception e) {
            // log but don't throw - see below
            log.error("Error restoring trigger state " + trigger.getName(), e);
          }
          replay = false;
        }
        try {
          trigger.run();
        } catch (Exception e) {
          // log but do not propagate exception because an exception thrown from a scheduled operation
          // will suppress future executions
          log.error("Unexpected execution from trigger: " + trigger.getName(), e);
        } finally {
          // checkpoint after each run
          trigger.saveState();
        }
      }
    }

