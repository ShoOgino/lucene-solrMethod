  private boolean createCollection(ClusterState clusterState, ZkNodeProps message) {
    String collectionName = message.getStr("name");
    if (clusterState.getCollections().contains(collectionName)) {
      SolrException.log(log, "collection already exists: " + collectionName);
      return false;
    }

    // look at the replication factor and see if it matches reality
    // if it does not, find best nodes to create more cores
    
    String numReplicasString = message.getStr(REPLICATION_FACTOR);
    int numReplicas;
    try {
      numReplicas = numReplicasString == null ? 0 : Integer.parseInt(numReplicasString);
    } catch (Exception ex) {
      SolrException.log(log, "Could not parse " + REPLICATION_FACTOR, ex);
      return false;
    }
    String numShardsString = message.getStr("numShards");
    int numShards;
    try {
      numShards = numShardsString == null ? 0 : Integer.parseInt(numShardsString);
    } catch (Exception ex) {
      SolrException.log(log, "Could not parse numShards", ex);
      return false;
    }
    
    if (numReplicas < 0) {
      SolrException.log(log, REPLICATION_FACTOR + " must be > 0");
      return false;
    }
    
    if (numShards < 0) {
      SolrException.log(log, "numShards must be > 0");
      return false;
    }
    
    
    String name = message.getStr("name");
    String configName = message.getStr("collection.configName");
    
    // we need to look at every node and see how many cores it serves
    // add our new cores to existing nodes serving the least number of cores
    // but (for now) require that each core goes on a distinct node.
    
    ModifiableSolrParams params = new ModifiableSolrParams();
    params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATE.toString());
    
    
    // TODO: add smarter options that look at the current number of cores per node?
    // for now we just go random
    Set<String> nodes = clusterState.getLiveNodes();
    List<String> nodeList = new ArrayList<String>(nodes.size());
    nodeList.addAll(nodes);
    Collections.shuffle(nodeList);
    
    int numNodes = numShards * (numReplicas + 1);
    if (nodeList.size() < numNodes) {
      log.warn("Not enough nodes available to satisfy create collection request for collection:"
          + collectionName
          + " nodes needed:"
          + numNodes
          + " nodes available:"
          + nodeList.size() + " - using nodes available");
    }

    List<String> createOnNodes = nodeList.subList(0, Math.min(nodeList.size(), numNodes));
    
    log.info("Create collection " + name + " on " + createOnNodes);
    
    for (String replica : createOnNodes) {
      // TODO: this does not work if original url had _ in it
      // We should have a master list
      replica = replica.replaceAll("_", "/");
      params.set(CoreAdminParams.NAME, name);
      params.set("collection.configName", configName);
      params.set("numShards", numShards);
      ShardRequest sreq = new ShardRequest();
      params.set("qt", adminPath);
      sreq.purpose = 1;
      // TODO: this sucks
      if (replica.startsWith("http://")) replica = replica.substring(7);
      sreq.shards = new String[] {replica};
      sreq.actualShards = sreq.shards;
      sreq.params = params;
      
      shardHandler.submit(sreq, replica, sreq.params);
    }
    
    int failed = 0;
    ShardResponse srsp;
    do {
      srsp = shardHandler.takeCompletedOrError();
      if (srsp != null) {
        Throwable e = srsp.getException();
        if (e != null) {
          // should we retry?
          // TODO: we should return errors to the client
          // TODO: what if one fails and others succeed?
          failed++;
          log.error("Error talking to shard: " + srsp.getShard(), e);
        }
      }
    } while (srsp != null);

    
    // if all calls succeeded, return true
    if (failed > 0) {
      return false;
    }
    return true;
  }

