  @Override
  public Object call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {
    ZkStateReader zkStateReader = ocmh.zkStateReader;
    ocmh.checkRequired(message, "source", "target");
    String source = message.getStr("source");
    String target = message.getStr("target");
    boolean parallel = message.getBool("parallel", false);
    ClusterState clusterState = zkStateReader.getClusterState();

    if (!clusterState.liveNodesContain(source)) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Source Node: " + source + " is not live");
    }
    if (!clusterState.liveNodesContain(target)) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "Target Node: " + target + " is not live");
    }
    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);

    List<ZkNodeProps> createdReplicas = new ArrayList<>();

    AtomicBoolean anyOneFailed = new AtomicBoolean(false);
    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());

    for (ZkNodeProps sourceReplica : sourceReplicas) {
      NamedList nl = new NamedList();
      log.info("going to create replica {}", Utils.toJSONString(sourceReplica));
      ZkNodeProps msg = sourceReplica.plus("parallel", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);
      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,
          msg, nl, () -> {
            countDownLatch.countDown();
            if (nl.get("failure") != null) {
              log.warn("failed to create : " + Utils.toJSONString(msg));
              // one replica creation failed. Make the best attempt to
              // delete all the replicas created so far in the target
              // and exit
              synchronized (results) {
                results.add("failure", "Could not create copy of replica " + Utils.toJSONString(sourceReplica));
                anyOneFailed.set(true);
              }
            } else {
              log.info("successfully created : " + Utils.toJSONString(msg));

            }
          });

      if (addedReplica != null) {
        createdReplicas.add(addedReplica);
      }
    }

    log.info("Waiting for creates to complete ");
    countDownLatch.await(5, TimeUnit.MINUTES);
    log.info("Waiting over for creates to complete ");

    if (anyOneFailed.get()) {
      log.info("failed to create some cores delete all " + Utils.toJSONString(createdReplicas));
      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());
      for (ZkNodeProps createdReplica : createdReplicas) {
        NamedList deleteResult = new NamedList();
        try {
          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus("parallel", "true"), deleteResult, () -> {
            cleanupLatch.countDown();
            if (deleteResult.get("failure") != null) {
              synchronized (results) {
                results.add("failure", "could not cleanup, because  : " + deleteResult.get("failure") + "  " + Utils.toJSONString(createdReplica));
              }
            }
          });
        } catch (KeeperException e) {
          cleanupLatch.countDown();
          log.info("Error deleting ", e);
        } catch (Exception e) {
          log.error("Unknown Error deleteing", e);
          cleanupLatch.countDown();
          throw e;
        }
      }
      cleanupLatch.await(5, TimeUnit.MINUTES);
      return null;
    }


    // we have reached this far means all replicas could be recreated
    //now cleanup the replicas in the source node
    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh);
    results.add("success", "REPLACENODE completed successfully from  : " + source + " to : " + target);
    return null;
  }

