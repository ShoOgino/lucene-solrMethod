  private void calculateHotOps(List<TriggerEvent.Op> ops,
                               Map<String, Map<String, AtomicInteger>> searchableReplicationFactors,
                               Map<String, Double> hotNodes,
                               Map<String, Double> hotCollections,
                               Map<String, Map<String, Double>> hotShards,
                               List<ReplicaInfo> hotReplicas) {
    // calculate the number of replicas to add to each hot shard, based on how much the rate was
    // exceeded - but within limits.

    // first resolve a situation when only a node is hot but no collection / shard / replica is hot
    // TODO: eventually we may want to commission a new node
    if (!hotNodes.isEmpty() && hotShards.isEmpty() && hotCollections.isEmpty() && hotReplicas.isEmpty()) {
      // move replicas around
      if (aboveNodeOp != null) {
        hotNodes.forEach((n, r) -> {
          ops.add(new TriggerEvent.Op(aboveNodeOp, Suggester.Hint.SRC_NODE, n));
        });
      }
    } else {
      // add replicas
      Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();

      hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {
        List<Pair<String, String>> perShard = hints
            .computeIfAbsent(coll, c -> new HashMap<>())
            .computeIfAbsent(s, sh -> new ArrayList<>());
        addReplicaHints(coll, s, r, searchableReplicationFactors.get(coll).get(s).get(), perShard);
      }));
      hotReplicas.forEach(ri -> {
        double r = (Double)ri.getVariable(AutoScalingParams.RATE);
        // add only if not already accounted for in hotShards
        List<Pair<String, String>> perShard = hints
            .computeIfAbsent(ri.getCollection(), c -> new HashMap<>())
            .computeIfAbsent(ri.getShard(), sh -> new ArrayList<>());
        if (perShard.isEmpty()) {
          addReplicaHints(ri.getCollection(), ri.getShard(), r, searchableReplicationFactors.get(ri.getCollection()).get(ri.getShard()).get(), perShard);
        }
      });

      hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {
        ops.add(new TriggerEvent.Op(aboveOp, Suggester.Hint.COLL_SHARD, p));
      })));
    }

  }

