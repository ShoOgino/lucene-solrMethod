  private void simRunLeaderElection(final String collection, final String slice,
                                    final boolean saveState) throws Exception {
    
    log.trace("Attempting leader election ({} / {})", collection, slice);
    final AtomicBoolean stateChanged = new AtomicBoolean(Boolean.FALSE);
    
    lock.lockInterruptibly();
    try {
      final ClusterState state = getClusterState();
      final DocCollection col = state.getCollectionOrNull(collection);
      
      if (null == col) {
        log.trace("-- collection does not exist (anymore), skipping leader election ({} / {})",
                  collection, slice);
        return;
      }
      final Slice s = col.getSlice(slice);
      if (null == s) {
        log.trace("-- slice does not exist, skipping leader election ({} / {})",
                  collection, slice);
        return;
      }        
      if (s.getState() == Slice.State.INACTIVE) {
        log.trace("-- slice state is {}, skipping leader election ({} / {})",
                  s.getState(), collection, slice);
        return;
      }
      if (s.getReplicas().isEmpty()) {
        log.trace("-- no replicas, skipping leader election ({} / {})",  collection, slice);
        return;
      }
      
      final Replica leader = s.getLeader();
      if (null != leader && liveNodes.contains(leader.getNodeName())) {
        log.trace("-- already has livenode leader, skipping leader election {} / {}",
                  collection, slice);
        return;
      }
      
      if (s.getState() != Slice.State.ACTIVE) {
        log.trace("-- slice state is {}, but I will run leader election anyway ({} / {})",
                  s.getState(), collection, slice);
      }
      
      log.debug("Running leader election ({} / {})", collection, slice);
      ActionThrottle lt = getThrottle(collection, s.getName());
      synchronized (lt) {
        // collect all active and live
        List<ReplicaInfo> active = new ArrayList<>();
        AtomicBoolean alreadyHasLeader = new AtomicBoolean(false);
        s.getReplicas().forEach(r -> {
            // find our ReplicaInfo for this replica
            ReplicaInfo ri = getReplicaInfo(r);
            if (ri == null) {
              throw new IllegalStateException("-- could not find ReplicaInfo for replica " + r);
            }
            synchronized (ri) {
              if (r.isActive(liveNodes.get())) {
                if (ri.getVariables().get(ZkStateReader.LEADER_PROP) != null) {
                  log.trace("-- found existing leader {} / {}: {}, {}", collection, s.getName(), ri, r);
                  alreadyHasLeader.set(true);
                  return;
                } else {
                  active.add(ri);
                }
              } else { // if it's on a node that is not live mark it down
                log.trace("-- replica not active on live nodes: {}, {}", liveNodes.get(), r);
                if (!liveNodes.contains(r.getNodeName())) {
                  ri.getVariables().put(ZkStateReader.STATE_PROP, Replica.State.DOWN.toString());
                  ri.getVariables().remove(ZkStateReader.LEADER_PROP);
                  stateChanged.set(true);
                }
              }
            }
          });
        if (alreadyHasLeader.get()) {
          log.trace("-- already has leader {} / {}: {}", collection, s.getName(), s);
          return;
        }
        if (active.isEmpty()) {
          log.warn("Can't find any active replicas for {} / {}: {}", collection, s.getName(), s);
          log.debug("-- liveNodes: {}", liveNodes.get());
          return;
        }
        // pick first active one
        ReplicaInfo ri = null;
        for (ReplicaInfo a : active) {
          if (!a.getType().equals(Replica.Type.PULL)) {
            ri = a;
            break;
          }
        }
        if (ri == null) {
          log.warn("-- can't find any suitable replica type for {} / {}: {}", collection, s.getName(), s);
          return;
        }
        // now mark the leader election throttle
        lt.minimumWaitBetweenActions();
        lt.markAttemptingAction();
        synchronized (ri) {
          ri.getVariables().put(ZkStateReader.LEADER_PROP, "true");
        }
        log.debug("-- elected new leader for {} / {} (currentVersion={}): {}", collection,
                  s.getName(), clusterStateVersion, ri);
        stateChanged.set(true);
      }
    } finally {
      if (stateChanged.get() || saveState) {
        collectionsStatesRef.set(null);
      }
      lock.unlock();
    }
  }

