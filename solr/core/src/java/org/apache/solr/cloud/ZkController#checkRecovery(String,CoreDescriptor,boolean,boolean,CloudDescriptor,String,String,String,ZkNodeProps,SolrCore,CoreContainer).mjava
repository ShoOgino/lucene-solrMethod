  private boolean checkRecovery(String coreName, final CoreDescriptor desc,
      boolean recoverReloadedCores, final boolean isLeader,
      final CloudDescriptor cloudDesc, final String collection,
      final String shardZkNodeName, String shardId, ZkNodeProps leaderProps,
      SolrCore core, CoreContainer cc) throws InterruptedException,
      KeeperException, IOException, ExecutionException {

    
    boolean doRecovery = true;


    if (isLeader) {
      doRecovery = false;
      
      // recover from local transaction log and wait for it to complete before
      // going active
      // TODO: should this be moved to another thread? To recoveryStrat?
      // TODO: should this actually be done earlier, before (or as part of)
      // leader election perhaps?
      // TODO: ensure that a replica that is trying to recover waits until I'm
      // active (or don't make me the
      // leader until my local replay is done. But this replay is only needed
      // on the leader - replicas
      // will do recovery anyway
      
      UpdateLog ulog = core.getUpdateHandler().getUpdateLog();
      if (!core.isReloaded() && ulog != null) {
        Future<UpdateLog.RecoveryInfo> recoveryFuture = core.getUpdateHandler()
            .getUpdateLog().recoverFromLog();
        if (recoveryFuture != null) {
          recoveryFuture.get(); // NOTE: this could potentially block for
                                // minutes or more!
          // TODO: public as recovering in the mean time?
        }
      }
      return false;
    } else {
      
      if (core.isReloaded() && !recoverReloadedCores) {
        doRecovery = false;
      }
    }
    
    if (doRecovery && !SKIP_AUTO_RECOVERY) {
      log.info("Core needs to recover:" + core.getName());
      core.getUpdateHandler().getSolrCoreState().doRecovery(core);
      return true;
    }
    
    return false;
  }

