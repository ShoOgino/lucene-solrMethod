  @Override
  public void run() {
    boolean replayed = false;
    boolean succesfulRecovery = false;

    UpdateLog ulog = core.getUpdateHandler().getUpdateLog();
    if (ulog == null) {
      SolrException.log(log, "No UpdateLog found - cannot recover");
      recoveryFailed(core, zkController, baseUrl, coreZkNodeName,
          core.getCoreDescriptor());
      return;
    }

    List<Long> startingRecentVersions;
    UpdateLog.RecentUpdates startingRecentUpdates = ulog.getRecentUpdates();
    try {
      startingRecentVersions = startingRecentUpdates.getVersions(100);
    } finally {
      startingRecentUpdates.close();
    }
    
    while (!succesfulRecovery && !close && !isInterrupted()) {
      try {
        // first thing we just try to sync
        zkController.publish(core, ZkStateReader.RECOVERING);
        CloudDescriptor cloudDesc = core.getCoreDescriptor()
            .getCloudDescriptor();
        ZkNodeProps leaderprops = null;
        
        leaderprops = zkStateReader.getLeaderProps(
            cloudDesc.getCollectionName(), cloudDesc.getShardId());
        
        String leaderUrl = ZkCoreNodeProps.getCoreUrl(leaderprops.get(ZkStateReader.BASE_URL_PROP), leaderprops.get(ZkStateReader.CORE_NAME_PROP));

        // TODO: we should only try this the first time through the loop?
        log.info("Attempting to PeerSync from " + leaderUrl);
        PeerSync peerSync = new PeerSync(core,
            Collections.singletonList(leaderUrl), 100);
        peerSync.setStartingVersions(startingRecentVersions);
        boolean syncSuccess = peerSync.sync();
        if (syncSuccess) {
          SolrQueryRequest req = new LocalSolrQueryRequest(core,
              new ModifiableSolrParams());
          core.getUpdateHandler().commit(new CommitUpdateCommand(req, false));
          log.info("Sync Recovery was succesful - registering as Active");
          // sync success - register as active and return
          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),
              coreZkNodeName, coreName);
          return;
        }
        log.info("Sync Recovery was not successful - trying replication");
        
        log.info("Begin buffering updates");
        ulog.bufferUpdates();
        replayed = false;
        
        try {
          
          replicate(zkController.getNodeName(), core,
              leaderprops, leaderUrl);
          
          replay(ulog);
          replayed = true;
          
          log.info("Recovery was succesful - registering as Active");
          // if there are pending recovery requests, don't advert as active
          zkController.publishAsActive(baseUrl, core.getCoreDescriptor(),
              coreZkNodeName, coreName);
          
          succesfulRecovery = true;
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          log.warn("Recovery was interrupted", e);
          retries = INTERRUPTED;
        } catch (Throwable t) {
          SolrException.log(log, "Error while trying to recover", t);
        } finally {
          if (!replayed) {
            try {
              ulog.dropBufferedUpdates();
            } catch (Throwable t) {
              SolrException.log(log, "", t);
            }
          }
          
        }
        
      } catch (Throwable t) {
        SolrException.log(log, "Error while trying to recover", t);
      }
      
      if (!succesfulRecovery) {
        // lets pause for a moment and we need to try again...
        // TODO: we don't want to retry for some problems?
        // Or do a fall off retry...
        try {
          
          SolrException.log(log, "Recovery failed - trying again...");
          retries++;
          if (retries >= MAX_RETRIES) {
            if (retries == INTERRUPTED) {
              
            } else {
              // TODO: for now, give up after X tries - should we do more?
              recoveryFailed(core, zkController, baseUrl, coreZkNodeName,
                  core.getCoreDescriptor());
            }
            break;
          }
          
        } catch (Exception e) {
          SolrException.log(log, "", e);
        }
        
        try {
          Thread.sleep(Math.min(START_TIMEOUT * retries, 60000));
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          log.warn("Recovery was interrupted", e);
          retries = INTERRUPTED;
        }
      }
      
      log.info("Finished recovery process");
      
    }
  }

