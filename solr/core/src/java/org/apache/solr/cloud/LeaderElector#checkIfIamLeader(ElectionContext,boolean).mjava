  /**
   * Check if the candidate with the given n_* sequence number is the leader.
   * If it is, set the leaderId on the leader zk node. If it is not, start
   * watching the candidate that is in line before this one - if it goes down, check
   * if this candidate is the leader again.
   *
   * @param replacement has someone else been the leader already?
   */
  private void checkIfIamLeader(final ElectionContext context, boolean replacement) throws KeeperException,
      InterruptedException, IOException {
    context.checkIfIamLeaderFired();
    // get all other numbers...
    final String holdElectionPath = context.electionPath + ELECTION_NODE;
    List<String> seqs = zkClient.getChildren(holdElectionPath, null, true);

    sortSeqs(seqs);
    List<Integer> intSeqs = getSeqs(seqs);
    if (intSeqs.size() == 0) {
      log.warn("Our node is no longer in line to be leader");
      return;
    }
    // We can't really rely on the sequence number stored in the old watcher, it may be stale, thus this check.

    int seq = -1;

    // See if we've already been re-added, and this is an old context. In which case, use our current sequence number.
    String newLeaderSeq = "";
    for (String elec : seqs) {
      if (getNodeName(elec).equals(getNodeName(context.leaderSeqPath)) && seq < getSeq(elec)) {
        seq = getSeq(elec); // so use the current sequence number.
        newLeaderSeq = elec;
        break;
      }
    }

    // Now, if we've been re-added, presumably we've also set up watchers and all that kind of thing, so we're done
    if (StringUtils.isNotBlank(newLeaderSeq) && seq > getSeq(context.leaderSeqPath)) {
      log.info("Node " + context.leaderSeqPath + " already in queue as " + newLeaderSeq + " nothing to do.");
      return;
    }

    // Fallback in case we're all coming in here fresh and there is no node for this core already in the election queue.
    if (seq == -1) {
      seq = getSeq(context.leaderSeqPath);
    }

    if (seq <= intSeqs.get(0)) {
      if (seq == intSeqs.get(0) && !context.leaderSeqPath.equals(holdElectionPath + "/" + seqs.get(0))) {//somebody else already  became the leader with the same sequence id , not me
        log.info("was going to be leader {} , seq(0) {}", context.leaderSeqPath, holdElectionPath + "/" + seqs.get(0));//but someone else jumped the line

        // The problem is that deleting the ZK node that's watched by others
        // results in an unpredictable sequencing of the events and sometime the context that comes in for checking
        // this happens to be after the node has already taken over leadership. So just leave out of here.
        // This caused one of the tests to fail on having two nodes with the same name in the queue. I'm not sure
        // the assumption that this is a bad state is valid.
        if (getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(0)))) {
          return;
        }
        retryElection(context, false);//join at the tail again
        return;
      }

      try {
        runIamLeaderProcess(context, replacement);
      } catch (KeeperException.NodeExistsException e) {
        log.error("node exists",e);
        retryElection(context, false);
        return;
      }
    } else {
      // I am not the leader - watch the node below me
      int toWatch = -1;
      for (int idx = 0; idx < intSeqs.size(); idx++) {
        if (intSeqs.get(idx) < seq && ! getNodeName(context.leaderSeqPath).equals(getNodeName(seqs.get(idx)))) {
          toWatch = idx;
        }
        if (intSeqs.get(idx) >= seq) {
          break;
        }
      }
      if (toWatch < 0) {
        log.warn("Our node is no longer in line to be leader");
        return;
      }
      try {
        String watchedNode = holdElectionPath + "/" + seqs.get(toWatch);

        zkClient.getData(watchedNode, watcher = new ElectionWatcher(context.leaderSeqPath , watchedNode,seq, context) , null, true);
        log.info("Watching path {} to know if I could be the leader", watchedNode);
      } catch (KeeperException.SessionExpiredException e) {
        throw e;
      } catch (KeeperException e) {
        log.warn("Failed setting watch", e);
        // we couldn't set our watch - the node before us may already be down?
        // we need to check if we are the leader again
        checkIfIamLeader(context, true);
      }
    }
  }

