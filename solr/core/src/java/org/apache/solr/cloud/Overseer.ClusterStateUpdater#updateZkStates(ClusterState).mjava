    private void updateZkStates(ClusterState clusterState) throws KeeperException, InterruptedException {
      TimerContext timerContext = stats.time("update_state");
      boolean success = false;
      try {
        if (!updateNodes.isEmpty()) {
          for (Entry<String,Object> e : updateNodes.entrySet()) {
            if (e.getValue() == null) {
              if (zkClient.exists(e.getKey(), true)) zkClient.delete(e.getKey(), 0, true);
            } else {
              byte[] data = ZkStateReader.toJSON(e.getValue());
              if (zkClient.exists(e.getKey(), true)) {
                log.info("going to update_collection {}", e.getKey());
                zkClient.setData(e.getKey(), data, true);
              } else {
                log.info("going to create_collection {}", e.getKey());
                String parentPath = e.getKey().substring(0, e.getKey().lastIndexOf('/'));
                if (!zkClient.exists(parentPath, true)) {
                  // if the /collections/collection_name path doesn't exist then it means that
                  // 1) the user invoked a DELETE collection API and the OverseerCollectionProcessor has deleted
                  // this zk path.
                  // 2) these are most likely old "state" messages which are only being processed now because
                  // if they were new "state" messages then in legacy mode, a new collection would have been
                  // created with stateFormat = 1 (which is the default state format)
                  // 3) these can't be new "state" messages created for a new collection because
                  // otherwise the OverseerCollectionProcessor would have already created this path
                  // as part of the create collection API call -- which is the only way in which a collection
                  // with stateFormat > 1 can possibly be created
                  continue;
                }
                zkClient.create(e.getKey(), data, CreateMode.PERSISTENT, true);
              }
            }
          }
          updateNodes.clear();
        }
        
        if (isClusterStateModified) {
          lastUpdatedTime = System.nanoTime();
          zkClient.setData(ZkStateReader.CLUSTER_STATE,
              ZkStateReader.toJSON(clusterState), true);
          isClusterStateModified = false;
        }
        success = true;
      } finally {
        timerContext.stop();
        if (success)  {
          stats.success("update_state");
        } else  {
          stats.error("update_state");
        }
      }
    }

