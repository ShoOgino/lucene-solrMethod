  /**
   * Process change in shard leaders. Make sure we have watches for each leader.
   */
  private void processLeaderNodesChanged(final String collection, final Collection<String> shardIds) {
    if(log.isInfoEnabled()) {
      log.info("Leader nodes changed for collection: " + collection + " nodes now:" + shardIds);
    }
    
    Map<String, ShardLeaderWatcher> watches = shardLeaderWatches.get(collection);
    Set<String> currentWatches = new HashSet<String>();
    currentWatches.addAll(watches.keySet());
    
    Set<String> newLeaders = complement(shardIds, currentWatches);

    Set<String> lostLeaders = complement(currentWatches, shardIds);
    //remove watches for lost shards
    for (String shardId : lostLeaders) {
      ShardLeaderWatcher watcher = watches.remove(shardId);
      if (watcher != null) {
        watcher.close();
      }
    }
    
    //add watches for the new shards
    for(String shardId: newLeaders) {
      try {
        ShardLeaderWatcher watcher = new ShardLeaderWatcher(shardId, collection, zkClient, this);
        watches.put(shardId, watcher);
      } catch (KeeperException e) {
        log.error("Failed to create watcher for shard leader col:" + collection + " shard:" + shardId + ", exception: " + e.getClass());
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        log.error("Failed to create watcher for shard leader col:" + collection + " shard:" + shardId + ", exception: " + e.getClass());
      }
    }
  }

