  /**
   * Create as many collections as required. This method loops to allow for the possibility that the docTimestamp
   * requires more than one collection to be created. Since multiple threads may be invoking maintain on separate
   * requests to the same alias, we must pass in the name of the collection that this thread believes to be the most
   * recent collection. This assumption is checked when the command is executed in the overseer. When this method
   * finds that all collections required have been created it returns the (possibly new) most recent collection.
   * The return value is ignored by the calling code in the async preemptive case.
   *
   * @param docTimestamp the timestamp from the document that determines routing
   * @param cmd the update command being processed
   * @param targetCollectionDesc the descriptor for the presently selected collection which should also be
   *                             the most recent collection in all cases where this method is invoked.
   * @return The latest collection, including collections created during maintenance
   */
  private String createAllRequiredCollections( Instant docTimestamp, AddUpdateCommand cmd,
                                               Map.Entry<Instant, String> targetCollectionDesc) {
    SolrQueryRequest req = cmd.getReq();
    SolrCore core = req.getCore();
    CoreContainer coreContainer = core.getCoreContainer();
    CollectionsHandler collectionsHandler = coreContainer.getCollectionsHandler();
    do {
      switch(typeOfCreationRequired(docTimestamp, targetCollectionDesc.getKey())) {
        case NONE:
          return targetCollectionDesc.getValue(); // we don't need another collection
        case ASYNC_PREEMPTIVE:
          // can happen when preemptive interval is longer than one time slice
          String mostRecentCollName = this.parsedCollectionsDesc.get(0).getValue();
          preemptiveAsync(() -> createNextCollection(mostRecentCollName, collectionsHandler), core);
          return targetCollectionDesc.getValue();
        case SYNCHRONOUS:
          createNextCollection(targetCollectionDesc.getValue(), collectionsHandler); // *should* throw if fails for some reason but...
          ZkController zkController = coreContainer.getZkController();
          if (!updateParsedCollectionAliases(zkController)) { // thus we didn't make progress...
            // this is not expected, even in known failure cases, but we check just in case
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,
                "We need to create a new time routed collection but for unknown reasons were unable to do so.");
          }
          // then retry the loop ... have to do find again in case other requests also added collections
          // that were made visible when we called updateParsedCollectionAliases()
          targetCollectionDesc = findCandidateGivenTimestamp(docTimestamp, cmd.getPrintableId());
          break;
        default:
          throw unknownCreateType();

      }
    } while (true);
  }

