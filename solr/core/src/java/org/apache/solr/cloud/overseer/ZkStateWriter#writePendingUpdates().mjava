  /**
   * Writes all pending updates to ZooKeeper and returns the modified cluster state
   *
   * @return the modified cluster state
   * @throws IllegalStateException if the current instance is no longer usable and must be discarded
   * @throws KeeperException       if any ZooKeeper operation results in an error
   * @throws InterruptedException  if the current thread is interrupted
   */
  public ClusterState writePendingUpdates() throws IllegalStateException, KeeperException, InterruptedException {
    if (invalidState) {
      throw new IllegalStateException("ZkStateWriter has seen a tragic error, this instance can no longer be used");
    }
    if (!hasPendingUpdates()) return clusterState;
    TimerContext timerContext = stats.time("update_state");
    boolean success = false;
    try {
      if (!updates.isEmpty()) {
        for (Map.Entry<String, DocCollection> entry : updates.entrySet()) {
          String name = entry.getKey();
          String path = ZkStateReader.getCollectionPath(name);
          DocCollection c = entry.getValue();

          if (c == null) {
            // let's clean up the collections path for this collection
            log.info("going to delete_collection {}", path);
            reader.getZkClient().clean("/collections/" + name);
          } else if (c.getStateFormat() > 1) {
            byte[] data = Utils.toJSON(singletonMap(c.getName(), c));
            if (reader.getZkClient().exists(path, true)) {
              log.info("going to update_collection {} version: {}", path, c.getZNodeVersion());
              assert c.getZNodeVersion() >= 0;
              Stat stat = reader.getZkClient().setData(path, data, c.getZNodeVersion(), true);
              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), stat.getVersion(), path);
              clusterState = clusterState.copyWith(name, newCollection);
            } else {
              log.info("going to create_collection {}", path);
              reader.getZkClient().create(path, data, CreateMode.PERSISTENT, true);
              DocCollection newCollection = new DocCollection(name, c.getSlicesMap(), c.getProperties(), c.getRouter(), 0, path);
              clusterState = clusterState.copyWith(name, newCollection);
            }
          } else if (c.getStateFormat() == 1) {
            isClusterStateModified = true;
          }
        }

        updates.clear();
      }

      if (isClusterStateModified) {
        assert clusterState.getZkClusterStateVersion() >= 0;
        byte[] data = Utils.toJSON(clusterState);
        Stat stat = reader.getZkClient().setData(ZkStateReader.CLUSTER_STATE, data, clusterState.getZkClusterStateVersion(), true);
        Set<String> collectionNames = clusterState.getCollections();
        Map<String, DocCollection> collectionStates = new HashMap<>(collectionNames.size());
        for (String c : collectionNames) {
          collectionStates.put(c, clusterState.getCollection(c));
        }
        // use the reader's live nodes because our cluster state's live nodes may be stale
        clusterState = new ClusterState(stat.getVersion(), reader.getClusterState().getLiveNodes(), collectionStates);
        isClusterStateModified = false;
      }
      lastUpdatedTime = System.nanoTime();
      success = true;
    } catch (KeeperException.BadVersionException bve) {
      // this is a tragic error, we must disallow usage of this instance
      invalidState = true;
      throw bve;
    } finally {
      timerContext.stop();
      if (success) {
        stats.success("update_state");
      } else {
        stats.error("update_state");
      }
    }

    return clusterState;
  }

