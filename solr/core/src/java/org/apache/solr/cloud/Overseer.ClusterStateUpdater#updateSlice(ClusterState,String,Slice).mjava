      private ClusterState updateSlice(ClusterState state, String collectionName, Slice slice) {
        // System.out.println("###!!!### OLD CLUSTERSTATE: " + JSONUtil.toJSON(state.getCollectionStates()));
        // System.out.println("Updating slice:" + slice);
        DocCollection newCollection = null;
        DocCollection coll = state.getCollectionOrNull(collectionName) ;
        Map<String,Slice> slices;
        
        if (coll == null) {
          //  when updateSlice is called on a collection that doesn't exist, it's currently when a core is publishing itself
          // without explicitly creating a collection.  In this current case, we assume custom sharding with an "implicit" router.
          slices = new LinkedHashMap<>(1);
          slices.put(slice.getName(), slice);
          Map<String,Object> props = new HashMap<>(1);
          props.put(DocCollection.DOC_ROUTER, ZkNodeProps.makeMap("name",ImplicitDocRouter.NAME));
          newCollection = new DocCollection(collectionName, slices, props, new ImplicitDocRouter());
        } else {
          slices = new LinkedHashMap<>(coll.getSlicesMap()); // make a shallow copy
          slices.put(slice.getName(), slice);
          newCollection = coll.copyWithSlices(slices);
        }

        // System.out.println("###!!!### NEW CLUSTERSTATE: " + JSONUtil.toJSON(newCollections));

        return newState(state, singletonMap(collectionName, newCollection));
      }

