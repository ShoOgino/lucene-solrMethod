  /**
   * Deletes some of the oldest collection(s) based on {@link TimeRoutedAlias#getAutoDeleteAgeMath()}. If not present
   * then does nothing.  Returns non-null results if something was deleted (or if we tried to).
   * {@code now} is the date from which the math is relative to.
   */
  NamedList deleteOldestCollectionsAndUpdateAlias(TimeRoutedAlias timeRoutedAlias,
                                                  ZkStateReader.AliasesManager aliasesManager,
                                                  Instant now) throws Exception {
    final String autoDeleteAgeMathStr = timeRoutedAlias.getAutoDeleteAgeMath();
    if (autoDeleteAgeMathStr == null) {
      return null;
    }
    final Instant delBefore;
    try {
      delBefore = new DateMathParser(Date.from(now), timeRoutedAlias.getTimeZone()).parseMath(autoDeleteAgeMathStr).toInstant();
    } catch (ParseException e) {
      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e); // note: should not happen by this point
    }

    String aliasName = timeRoutedAlias.getAliasName();

    Collection<String> collectionsToDelete = new LinkedHashSet<>();

    // First update the alias    (there may be no change to make!)
    aliasesManager.applyModificationAndExportToZk(curAliases -> {
      // note: we could re-parse the TimeRoutedAlias object from curAliases but I don't think there's a point to it.

      final List<Map.Entry<Instant, String>> parsedCollections =
          timeRoutedAlias.parseCollections(curAliases);

      //iterating from newest to oldest, find the first collection that has a time <= "before".  We keep this collection
      // (and all newer to left) but we delete older collections, which are the ones that follow.
      // This logic will always keep the first collection, which we can't delete.
      int numToKeep = 0;
      for (Map.Entry<Instant, String> parsedCollection : parsedCollections) {
        numToKeep++;
        final Instant colInstant = parsedCollection.getKey();
        if (colInstant.isBefore(delBefore) || colInstant.equals(delBefore)) {
          break;
        }
      }
      if (numToKeep == parsedCollections.size()) {
        log.debug("No old time routed collections to delete.");
        return curAliases;
      }

      final List<String> targetList = curAliases.getCollectionAliasListMap().get(aliasName);
      // remember to delete these... (oldest to newest)
      for (int i = targetList.size() - 1; i >= numToKeep; i--) {
        collectionsToDelete.add(targetList.get(i));
      }
      // new alias list has only "numToKeep" first items
      final List<String> collectionsToKeep = targetList.subList(0, numToKeep);
      final String collectionsToKeepStr = StrUtils.join(collectionsToKeep, ',');
      return curAliases.cloneWithCollectionAlias(aliasName, collectionsToKeepStr);
    });

    if (collectionsToDelete.isEmpty()) {
      return null;
    }

    log.info("Removing old time routed collections: {}", collectionsToDelete);
    // Should this be done asynchronously?  If we got "ASYNC" then probably.
    //   It would shorten the time the Overseer holds a lock on the alias name
    //   (deleting the collections will be done later and not use that lock).
    //   Don't bother about parallel; it's unusual to have more than 1.
    // Note we don't throw an exception here under most cases; instead the response will have information about
    //   how each delete request went, possibly including a failure message.
    final CollectionsHandler collHandler = ocmh.overseer.getCoreContainer().getCollectionsHandler();
    NamedList results = new NamedList();
    for (String collection : collectionsToDelete) {
      final SolrParams reqParams = CollectionAdminRequest.deleteCollection(collection).getParams();
      SolrQueryResponse rsp = new SolrQueryResponse();
      collHandler.handleRequestBody(new LocalSolrQueryRequest(null, reqParams), rsp);
      results.add(collection, rsp.getValues());
    }
    return results;
  }

