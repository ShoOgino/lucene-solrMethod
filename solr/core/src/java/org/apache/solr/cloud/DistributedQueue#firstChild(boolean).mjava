  /**
   * Returns the name if the first known child node, or {@code null} if the queue is empty.
   * This is the only place {@link #knownChildren} is ever updated!
   * The caller must double check that the actual node still exists, since the in-memory
   * list is inherently stale.
   */
  private String firstChild(boolean remove) throws KeeperException, InterruptedException {
    updateLock.lockInterruptibly();
    try {
      if (!isDirty) {
        // If we're not in a dirty state...
        if (!knownChildren.isEmpty()) {
          // and we have in-memory children, return from in-memory.
          return remove ? knownChildren.pollFirst() : knownChildren.first();
        } else {
          // otherwise there's nothing to return
          return null;
        }
      }

      // Dirty, try to fetch an updated list of children from ZK.
      // Only set a new watcher if there isn't already a watcher.
      ChildWatcher newWatcher = (watcherCount == 0) ? new ChildWatcher() : null;
      knownChildren = fetchZkChildren(newWatcher);
      if (newWatcher != null) {
        watcherCount++; // watcher was successfully set
      }
      isDirty = false;
      if (knownChildren.isEmpty()) {
        return null;
      }
      changed.signalAll();
      return remove ? knownChildren.pollFirst() : knownChildren.first();
    } finally {
      updateLock.unlock();
    }
  }

