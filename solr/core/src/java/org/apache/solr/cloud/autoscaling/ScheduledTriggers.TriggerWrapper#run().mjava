    @Override
    public void run() {
      if (isClosed) {
        throw new AlreadyClosedException("ScheduledTrigger " + trigger.getName() + " has been closed.");
      }
      // fire a trigger only if an action is not pending
      // note this is not fool proof e.g. it does not prevent an action being executed while a trigger
      // is still executing. There is additional protection against that scenario in the event listener.
      if (!hasPendingActions.get()) {
        // this synchronization is usually never under contention
        // but the only reason to have it here is to ensure that when the set-properties API is used
        // to change the schedule delay, we can safely cancel the old scheduled task
        // and create another one with the new delay without worrying about concurrent
        // execution of the same trigger instance
        synchronized (TriggerWrapper.this) {
          // replay accumulated events on first run, if any

          try {
            if (replay) {
              TriggerEvent event;
              // peek first without removing - we may crash before calling the listener
              while ((event = queue.peekEvent()) != null) {
                // override REPLAYING=true
                event.getProperties().put(TriggerEvent.REPLAYING, true);
                if (!trigger.getProcessor().process(event)) {
                  log.error("Failed to re-play event, discarding: " + event);
                }
                queue.pollEvent(); // always remove it from queue
              }
              // now restore saved state to possibly generate new events from old state on the first run
              try {
                trigger.restoreState();
              } catch (Exception e) {
                // log but don't throw - see below
                log.error("Error restoring trigger state " + trigger.getName(), e);
              }
              replay = false;
            }
          } catch (AlreadyClosedException e) {
            
          } catch (Exception e) {
            log.error("Unexpected exception from trigger: " + trigger.getName(), e);
          }
          try {
            trigger.run();
          } catch (AlreadyClosedException e) {

          } catch (Exception e) {
            // log but do not propagate exception because an exception thrown from a scheduled operation
            // will suppress future executions
            log.error("Unexpected exception from trigger: " + trigger.getName(), e);
          } finally {
            // checkpoint after each run
            trigger.saveState();
          }
        }
      }
    }

