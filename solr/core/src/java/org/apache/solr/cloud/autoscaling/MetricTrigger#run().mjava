  @Override
  public void run() {
    AutoScaling.TriggerEventProcessor processor = processorRef.get();
    if (processor == null) {
      return;
    }

    Set<String> liveNodes = null;
    if (node.equals(Policy.ANY)) {
      if (collection.equals(Policy.ANY)) {
        liveNodes = cloudManager.getClusterStateProvider().getLiveNodes();
      } else {
        final Set<String> nodes = new HashSet<>();
        ClusterState.CollectionRef ref = cloudManager.getClusterStateProvider().getState(collection);
        DocCollection docCollection;
        if (ref == null || (docCollection = ref.get()) == null) {
          log.warn("MetricTrigger could not find collection: {}", collection);
          return;
        }
        if (shard.equals(Policy.ANY)) {
          docCollection.getReplicas().forEach(replica -> {
            nodes.add(replica.getNodeName());
          });
        } else {
          Slice slice = docCollection.getSlice(shard);
          if (slice == null) {
            log.warn("MetricTrigger could not find collection: {} shard: {}", collection, shard);
            return;
          }
          slice.getReplicas().forEach(replica -> nodes.add(replica.getNodeName()));
        }
        liveNodes = nodes;
      }
    } else {
      liveNodes = Collections.singleton(node);
    }

    Map<String, Number> rates = new HashMap<>(liveNodes.size());
    for (String node : liveNodes) {
      Map<String, Object> values = cloudManager.getNodeStateProvider().getNodeValues(node, Collections.singletonList(metric));
      values.forEach((tag, rate) -> rates.computeIfAbsent(node, s -> (Number) rate));
    }

    long now = cloudManager.getTimeSource().getTimeNs();
    // check for exceeded rates and filter out those with less than waitFor from previous events
    Map<String, Number> hotNodes = rates.entrySet().stream()
        .filter(entry -> waitForElapsed(entry.getKey(), now, lastNodeEvent))
        .filter(entry -> (below != null && Double.compare(entry.getValue().doubleValue(), below.doubleValue()) < 0) || (above != null && Double.compare(entry.getValue().doubleValue(), above.doubleValue()) > 0))
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));

    if (hotNodes.isEmpty()) return;

    final AtomicLong eventTime = new AtomicLong(now);
    hotNodes.forEach((n, r) -> {
      long time = lastNodeEvent.get(n);
      if (eventTime.get() > time) {
        eventTime.set(time);
      }
    });

    if (processor.process(new MetricBreachedEvent(getName(), collection, shard, preferredOp, eventTime.get(), metric, hotNodes))) {
      hotNodes.keySet().forEach(node -> lastNodeEvent.put(node, now));
    }
  }

