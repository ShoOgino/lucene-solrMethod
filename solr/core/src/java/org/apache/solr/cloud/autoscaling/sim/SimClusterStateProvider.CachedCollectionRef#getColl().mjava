    public DocCollection getColl() throws InterruptedException, IOException {
      DocCollection dc = coll;
      if (dc != null) {
        return dc;
      }
      lock.lock();
      try {
        if (coll != null) {
          return coll;
        } else {
          Map<String, Map<String, Map<String, Replica>>> collMap = new HashMap<>();
          nodeReplicaMap.forEach((n, replicas) -> {
            synchronized (replicas) {
              replicas.forEach(ri -> {
                if (!ri.getCollection().equals(name)) {
                  return;
                }
                Map<String, Object> props;
                synchronized (ri) {
                  props = new HashMap<>(ri.getVariables());
                }
                props.put(ZkStateReader.NODE_NAME_PROP, n);
                props.put(ZkStateReader.CORE_NAME_PROP, ri.getCore());
                props.put(ZkStateReader.REPLICA_TYPE, ri.getType().toString());
                props.put(ZkStateReader.STATE_PROP, ri.getState().toString());
                Replica r = new Replica(ri.getName(), props, ri.getCollection(), ri.getShard());
                collMap.computeIfAbsent(ri.getCollection(), c -> new HashMap<>())
                    .computeIfAbsent(ri.getShard(), s -> new HashMap<>())
                    .put(ri.getName(), r);
              });
            }
          });

          // add empty slices
          sliceProperties.forEach((c, perSliceProps) -> {
            if (!c.equals(name)) {
              return;
            }
            perSliceProps.forEach((slice, props) -> {
              collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>()).computeIfAbsent(slice, s -> new ConcurrentHashMap<>());
            });
          });
          // add empty collections
          collProperties.keySet().forEach(c -> {
            if (!c.equals(name)) {
              return;
            }
            collMap.computeIfAbsent(c, co -> new ConcurrentHashMap<>());
          });

          Map<String, Map<String, Replica>> shards = collMap.get(name);
          Map<String, Slice> slices = new HashMap<>();
          shards.forEach((s, replicas) -> {
            Map<String, Object> sliceProps = sliceProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>()).computeIfAbsent(s, sl -> new ConcurrentHashMap<>());
            Slice slice = new Slice(s, replicas, sliceProps, name);
            slices.put(s, slice);
          });
          Map<String, Object> collProps = collProperties.computeIfAbsent(name, c -> new ConcurrentHashMap<>());
          Map<String, Object> routerProp = (Map<String, Object>) collProps.getOrDefault(DocCollection.DOC_ROUTER, Collections.singletonMap("name", DocRouter.DEFAULT_NAME));
          DocRouter router = DocRouter.getDocRouter((String)routerProp.getOrDefault("name", DocRouter.DEFAULT_NAME));
          String path = ZkStateReader.getCollectionPath(name);
          coll = new DocCollection(name, slices, collProps, router, zkVersion + 1, path);
          try {
            SimDistribStateManager stateManager = cloudManager.getSimDistribStateManager();
            byte[] data = Utils.toJSON(Collections.singletonMap(name, coll));
            if (!stateManager.hasData(path)) {
              try {
                stateManager.makePath(path, data, CreateMode.PERSISTENT, true);
              } catch (AlreadyExistsException e) {
                // try updating
                stateManager.setData(path, data, zkVersion);
              }
            } else {
              stateManager.setData(path, data, zkVersion);
            }
            // verify version
            VersionedData vd = stateManager.getData(path);
            assert vd.getVersion() == zkVersion + 1;
            zkVersion++;
          } catch (KeeperException | BadVersionException e) {
            // should never happen?
            throw new RuntimeException("error saving " + coll, e);
          }
        }
      } finally {
        lock.unlock();
      }
      return coll;
    }

