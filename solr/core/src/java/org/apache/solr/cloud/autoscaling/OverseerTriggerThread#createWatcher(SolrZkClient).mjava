  private void createWatcher(SolrZkClient zkClient) {
    try {
      zkClient.exists(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, new Watcher() {
        @Override
        public void process(WatchedEvent watchedEvent) {
          // session events are not change events, and do not remove the watcher
          if (Event.EventType.None.equals(watchedEvent.getType())) {
            return;
          }

          try {
            refreshAndWatch();
          } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {
            log.warn("ZooKeeper watch triggered for autoscaling conf, but Solr cannot talk to ZK: [{}]", e.getMessage());
          } catch (KeeperException e) {
            log.error("A ZK error has occurred", e);
            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, "A ZK error has occurred", e);
          } catch (InterruptedException e) {
            // Restore the interrupted status
            Thread.currentThread().interrupt();
            log.warn("Interrupted", e);
          } catch (Exception e)  {
            log.error("Unexpected exception", e);
          }
        }

        private void refreshAndWatch() throws KeeperException, InterruptedException {
          updateLock.lock();
          try {
            if (isClosed) {
              return;
            }
            final Stat stat = new Stat();
            final byte[] data = zkClient.getData(ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, this, stat, true);
            log.debug("{} watcher fired with znode version {}", ZkStateReader.SOLR_AUTOSCALING_CONF_PATH, stat.getVersion());
            if (znodeVersion >= stat.getVersion()) {
              // protect against reordered watcher fires by ensuring that we only move forward
              return;
            }
            znodeVersion = stat.getVersion();
            Map<String, AutoScaling.Trigger> triggerMap = loadTriggers(triggerFactory, data);

            // remove all active triggers that have been removed from ZK
            Set<String> trackingKeySet = activeTriggers.keySet();
            trackingKeySet.retainAll(triggerMap.keySet());

            // now lets add or remove triggers which have been enabled or disabled respectively
            for (Map.Entry<String, AutoScaling.Trigger> entry : triggerMap.entrySet()) {
              String triggerName = entry.getKey();
              AutoScaling.Trigger trigger = entry.getValue();
              if (trigger.isEnabled()) {
                activeTriggers.put(triggerName, trigger);
              } else {
                activeTriggers.remove(triggerName);
              }
            }
            updated.signalAll();
          } finally {
            updateLock.unlock();
          }
        }
      }, true);
    } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {
      log.error("OverseerTriggerThread could not talk to ZooKeeper", e);
    } catch (KeeperException e) {
      log.error("Exception in OverseerTriggerThread", e);
      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e);
    } catch (InterruptedException e) {
      // Restore the interrupted status
      Thread.currentThread().interrupt();
      log.error("OverseerTriggerThread interrupted", e);
    }
  }

