  protected Policy.Suggester getSuggester(Policy.Session session, TriggerEvent event, ZkStateReader zkStateReader) {
    Policy.Suggester suggester;
    switch (event.getEventType()) {
      case NODEADDED:
        suggester = session.getSuggester(CollectionParams.CollectionAction.MOVEREPLICA)
            .hint(Policy.Suggester.Hint.TARGET_NODE, event.getProperty(TriggerEvent.NODE_NAMES));
        log.debug("Created suggester with targetNode: {}", event.getProperty(TriggerEvent.NODE_NAMES));
        break;
      case NODELOST:
        suggester = session.getSuggester(CollectionParams.CollectionAction.MOVEREPLICA)
            .hint(Policy.Suggester.Hint.SRC_NODE, event.getProperty(TriggerEvent.NODE_NAMES));
        log.debug("Created suggester with srcNode: {}", event.getProperty(TriggerEvent.NODE_NAMES));
        break;
      case SEARCHRATE:
        Map<String, Map<String, Double>> hotShards = (Map<String, Map<String, Double>>)event.getProperty(AutoScalingParams.SHARD);
        Map<String, Double> hotCollections = (Map<String, Double>)event.getProperty(AutoScalingParams.COLLECTION);
        List<ReplicaInfo> hotReplicas = (List<ReplicaInfo>)event.getProperty(AutoScalingParams.REPLICA);
        Map<String, Double> hotNodes = (Map<String, Double>)event.getProperty(AutoScalingParams.NODE);

        if (hotShards.isEmpty() && hotCollections.isEmpty() && hotReplicas.isEmpty()) {
          // node -> MOVEREPLICA
          if (hotNodes.isEmpty()) {
            log.warn("Neither hot replicas / collection nor nodes are reported in event: " + event);
            return NoneSuggester.INSTANCE;
          }
          suggester = session.getSuggester(CollectionParams.CollectionAction.MOVEREPLICA);
          for (String node : hotNodes.keySet()) {
            suggester = suggester.hint(Policy.Suggester.Hint.SRC_NODE, node);
          }
        } else {
          // collection || shard || replica -> ADDREPLICA
          suggester = session.getSuggester(CollectionParams.CollectionAction.ADDREPLICA);
          Map<String, Set<String>> collShards = new HashMap<>();
          // AddReplicaSuggester needs a list of Pair(coll, shard)
          hotReplicas.forEach(r -> collShards.computeIfAbsent(r.getCollection(), c -> new HashSet<>()).add(r.getShard()));
          hotShards.forEach((coll, shards) -> collShards.computeIfAbsent(coll, c -> new HashSet<>()).addAll(shards.keySet()));
          // if we only have hotCollections then use warmShards to pick ones to replicate
          Map<String, String> warmShards = (Map<String, String>)event.getProperty(AutoScalingParams.WARM_SHARD);
          hotCollections.forEach((coll, rate) -> {
            Set<String> shards = collShards.get(coll);
            if (shards == null || shards.isEmpty()) {
              String warmShard = warmShards.get(coll);
              if (warmShard == null) {
                log.warn("Got hot collection '" + coll + "' but no warm shard! Ignoring...");
                return;
              }
              collShards.computeIfAbsent(coll, s -> new HashSet<>()).add(warmShard);
            }
          });
          for (Map.Entry<String, Set<String>> e : collShards.entrySet()) {
            for (String shard : e.getValue()) {
              suggester = suggester.hint(Policy.Suggester.Hint.COLL_SHARD, new Pair<>(e.getKey(), shard));
            }
          }
        }
        break;
      default:
        throw new UnsupportedOperationException("No support for events other than nodeAdded and nodeLost, received: " + event.getEventType());
    }
    return suggester;
  }

