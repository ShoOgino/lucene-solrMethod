  static void cleanupReplicas(NamedList results,
                              ClusterState clusterState,
                              List<ZkNodeProps> sourceReplicas,
                              OverseerCollectionMessageHandler ocmh) throws InterruptedException {
    CountDownLatch cleanupLatch = new CountDownLatch(sourceReplicas.size());
    for (ZkNodeProps sourceReplica : sourceReplicas) {
      log.info("deleting replica from from node {} ", Utils.toJSONString(sourceReplica));
      NamedList deleteResult = new NamedList();
      try {
        ocmh.deleteReplica(clusterState, sourceReplica.plus("parallel", "true"), deleteResult, () -> {
          cleanupLatch.countDown();
          if (deleteResult.get("failure") != null) {
            synchronized (results) {
              results.add("failure", "could not delete because  " + deleteResult.get("failure") + "  " + Utils.toJSONString(sourceReplica));
            }
          }
        });
      } catch (KeeperException e) {
        log.info("Error deleting ", e);
        cleanupLatch.countDown();
      } catch (Exception e) {
        cleanupLatch.countDown();
        throw e;
      }
    }
    log.info("Waiting for deletes to complete");
    cleanupLatch.await(5, TimeUnit.MINUTES);
  }

