    @Override
    public void run() {

      LeaderStatus isLeader = amILeader();
      while (isLeader == LeaderStatus.DONT_KNOW) {
        log.debug("am_i_leader unclear {}", isLeader);
        isLeader = amILeader();  // not a no, not a yes, try ask again
      }
      if (!this.isClosed && LeaderStatus.YES == isLeader) {
        // see if there's something left from the previous Overseer and re
        // process all events that were not persisted into cloud state
        synchronized (reader.getUpdateLock()) { // XXX this only protects
                                                // against edits inside single
                                                // node
          try {
            byte[] head = workQueue.peek();
            
            if (head != null) {
              reader.updateClusterState(true);
              ClusterState clusterState = reader.getClusterState();
              log.info("Replaying operations from work queue.");
              
              while (head != null) {
                isLeader = amILeader();
                if (LeaderStatus.NO == isLeader) {
                  break;
                }
                else if (LeaderStatus.YES == isLeader) {
                  final ZkNodeProps message = ZkNodeProps.load(head);
                  final String operation = message.getStr(QUEUE_OPERATION);
                  clusterState = processMessage(clusterState, message, operation);
                  zkClient.setData(ZkStateReader.CLUSTER_STATE,
                      ZkStateReader.toJSON(clusterState), true);
                  
                  workQueue.poll(); // poll-ing removes the element we got by peek-ing
                }
                else {
                  log.info("am_i_leader unclear {}", isLeader);                  
                  // re-peek below in case our 'head' value is out-of-date by now
                }
                
                head = workQueue.peek();
              }
            }
          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn("Solr cannot talk to ZK, exiting Overseer work queue loop", e);
              return;
            }
            log.error("Exception in Overseer work queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
            
          } catch (Exception e) {
            log.error("Exception in Overseer work queue loop", e);
          }
        }
        
      }
      
      log.info("Starting to work on the main queue");
      while (!this.isClosed) {
        isLeader = amILeader();
        if (LeaderStatus.NO == isLeader) {
          break;
        }
        else if (LeaderStatus.YES != isLeader) {
          log.debug("am_i_leader unclear {}", isLeader);
          continue; // not a no, not a yes, try ask again
        }
        DistributedQueue.QueueEvent head = null;
        try {
          head = stateUpdateQueue.peek(true);
        } catch (KeeperException e) {
          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
            log.warn(
                "Solr cannot talk to ZK, exiting Overseer main queue loop", e);
            return;
          }
          log.error("Exception in Overseer main queue loop", e);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          return;
          
        } catch (Exception e) {
          log.error("Exception in Overseer main queue loop", e);
        }
        synchronized (reader.getUpdateLock()) {
          try {
            reader.updateClusterState(true);
            ClusterState clusterState = reader.getClusterState();

            while (head != null) {
              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());
              final String operation = message.getStr(QUEUE_OPERATION);

              clusterState = processMessage(clusterState, message, operation);
              workQueue.offer(head.getBytes());

              stateUpdateQueue.poll();

              if (System.currentTimeMillis() - lastUpdatedTime > STATE_UPDATE_DELAY) break;
              
              // if an event comes in the next 100ms batch it together
              head = stateUpdateQueue.peek(100); 
            }
            lastUpdatedTime = System.currentTimeMillis();
            zkClient.setData(ZkStateReader.CLUSTER_STATE,
                ZkStateReader.toJSON(clusterState), true);
            // clean work queue
            while (workQueue.poll() != null) ;

          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop", e);
              return;
            }
            log.error("Exception in Overseer main queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
            
          } catch (Exception e) {
            log.error("Exception in Overseer main queue loop", e);
          }
        }
        
      }
    }

