    @Override
    public void run() {

      LeaderStatus isLeader = amILeader();
      while (isLeader == LeaderStatus.DONT_KNOW) {
        log.debug("am_i_leader unclear {}", isLeader);
        isLeader = amILeader();  // not a no, not a yes, try ask again
      }
      if (!this.isClosed && LeaderStatus.YES == isLeader) {
        // see if there's something left from the previous Overseer and re
        // process all events that were not persisted into cloud state
        synchronized (reader.getUpdateLock()) { // XXX this only protects
                                                // against edits inside single
                                                // node
          try {
            byte[] head = workQueue.peek();
            
            if (head != null) {
              reader.updateClusterState(true);
              ClusterState clusterState = reader.getClusterState();
              log.info("Replaying operations from work queue.");
              
              while (head != null) {
                isLeader = amILeader();
                if (LeaderStatus.NO == isLeader) {
                  break;
                }
                else if (LeaderStatus.YES == isLeader) {
                  final ZkNodeProps message = ZkNodeProps.load(head);
                  final String operation = message.getStr(QUEUE_OPERATION);
                  final TimerContext timerContext = stats.time(operation);
                  try {
                    clusterState = processMessage(clusterState, message, operation);
                    stats.success(operation);
                  } catch (Exception e) {
                    // generally there is nothing we can do - in most cases, we have
                    // an issue that will fail again on retry or we cannot communicate with
                    // ZooKeeper in which case another Overseer should take over
                    // TODO: if ordering for the message is not important, we could
                    // track retries and put it back on the end of the queue
                    log.error("Overseer could not process the current clusterstate state update message, skipping the message.", e);
                    stats.error(operation);
                  } finally {
                    timerContext.stop();
                  }
                  zkClient.setData(ZkStateReader.CLUSTER_STATE,
                      ZkStateReader.toJSON(clusterState), true);

                  workQueue.poll(); // poll-ing removes the element we got by peek-ing
                }
                else {
                  log.info("am_i_leader unclear {}", isLeader);                  
                  // re-peek below in case our 'head' value is out-of-date by now
                }
                
                head = workQueue.peek();
              }
            }
          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn("Solr cannot talk to ZK, exiting Overseer work queue loop", e);
              return;
            }
            log.error("Exception in Overseer work queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
            
          } catch (Exception e) {
            log.error("Exception in Overseer work queue loop", e);
          }
        }
        
      }
      
      log.info("Starting to work on the main queue");
      while (!this.isClosed) {
        isLeader = amILeader();
        if (LeaderStatus.NO == isLeader) {
          break;
        }
        else if (LeaderStatus.YES != isLeader) {
          log.debug("am_i_leader unclear {}", isLeader);
          continue; // not a no, not a yes, try ask again
        }
        DistributedQueue.QueueEvent head = null;
        try {
          head = stateUpdateQueue.peek(true);
        } catch (KeeperException e) {
          if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
            log.warn(
                "Solr cannot talk to ZK, exiting Overseer main queue loop", e);
            return;
          }
          log.error("Exception in Overseer main queue loop", e);
        } catch (InterruptedException e) {
          Thread.currentThread().interrupt();
          return;
          
        } catch (Exception e) {
          log.error("Exception in Overseer main queue loop", e);
        }
        synchronized (reader.getUpdateLock()) {
          try {
            reader.updateClusterState(true);
            ClusterState clusterState = reader.getClusterState();

            while (head != null) {
              final ZkNodeProps message = ZkNodeProps.load(head.getBytes());
              final String operation = message.getStr(QUEUE_OPERATION);
              final TimerContext timerContext = stats.time(operation);
              try {
                clusterState = processMessage(clusterState, message, operation);
                stats.success(operation);
              } catch (Exception e) {
                // generally there is nothing we can do - in most cases, we have
                // an issue that will fail again on retry or we cannot communicate with
                // ZooKeeper in which case another Overseer should take over
                // TODO: if ordering for the message is not important, we could
                // track retries and put it back on the end of the queue
                log.error("Overseer could not process the current clusterstate state update message, skipping the message.", e);
                stats.error(operation);
              } finally {
                timerContext.stop();
              }
              workQueue.offer(head.getBytes());

              stateUpdateQueue.poll();

              if (System.nanoTime() - lastUpdatedTime > TimeUnit.NANOSECONDS.convert(STATE_UPDATE_DELAY, TimeUnit.MILLISECONDS)) break;
              
              // if an event comes in the next 100ms batch it together
              head = stateUpdateQueue.peek(100); 
            }
            lastUpdatedTime = System.nanoTime();
            zkClient.setData(ZkStateReader.CLUSTER_STATE,
                ZkStateReader.toJSON(clusterState), true);
            // clean work queue
            while (workQueue.poll() != null) ;

          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop", e);
              return;
            }
            log.error("Exception in Overseer main queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
            
          } catch (Exception e) {
            log.error("Exception in Overseer main queue loop", e);
          }
        }
        
      }
    }

