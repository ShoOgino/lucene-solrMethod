    @Override
    public void run() {

      LeaderStatus isLeader = amILeader();
      while (isLeader == LeaderStatus.DONT_KNOW) {
        log.debug("am_i_leader unclear {}", isLeader);
        isLeader = amILeader();  // not a no, not a yes, try ask again
      }
      if (!this.isClosed && LeaderStatus.YES == isLeader) {
        // see if there's something left from the previous Overseer and re
        // process all events that were not persisted into cloud state
        synchronized (reader.getUpdateLock()) { // XXX this only protects
                                                // against edits inside single
                                                // node
          try {
            byte[] head = workQueue.peek();
            
            if (head != null) {
              reader.updateClusterState(true);
              ClusterState clusterState = reader.getClusterState();
              log.info("Replaying operations from work queue.");

              ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);

              while (head != null) {
                isLeader = amILeader();
                if (LeaderStatus.NO == isLeader) {
                  break;
                }
                else if (LeaderStatus.YES == isLeader) {
                  final ZkNodeProps message = ZkNodeProps.load(head);
                  log.info("processMessage: queueSize: {}, message = {}", workQueue.getStats().getQueueLength(), message);
                  clusterState = processQueueItem(message, clusterState, zkStateWriter);
                  workQueue.poll(); // poll-ing removes the element we got by peek-ing
                }
                else {
                  log.info("am_i_leader unclear {}", isLeader);                  
                  // re-peek below in case our 'head' value is out-of-date by now
                }
                head = workQueue.peek();
              }
              // force flush at the end of the loop
              clusterState = zkStateWriter.writePendingUpdates();
            }
          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn("Solr cannot talk to ZK, exiting Overseer work queue loop", e);
              return;
            }
            log.error("Exception in Overseer work queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;
            
          } catch (Exception e) {
            log.error("Exception in Overseer work queue loop", e);
          }
        }
        
      }
      
      log.info("Starting to work on the main queue");
      try {
        ZkStateWriter zkStateWriter = new ZkStateWriter(reader, stats);
        ClusterState clusterState = null;
        boolean refreshClusterState = true; // let's refresh in the first iteration
        while (!this.isClosed) {
          isLeader = amILeader();
          if (LeaderStatus.NO == isLeader) {
            break;
          }
          else if (LeaderStatus.YES != isLeader) {
            log.debug("am_i_leader unclear {}", isLeader);
            continue; // not a no, not a yes, try ask again
          }
          DistributedQueue.QueueEvent head = null;
          try {
            head = stateUpdateQueue.peek(true);
          } catch (KeeperException e) {
            if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
              log.warn(
                  "Solr cannot talk to ZK, exiting Overseer main queue loop", e);
              return;
            }
            log.error("Exception in Overseer main queue loop", e);
          } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return;

          } catch (Exception e) {
            log.error("Exception in Overseer main queue loop", e);
          }
          synchronized (reader.getUpdateLock()) {
            try {
              if (refreshClusterState) {
                reader.updateClusterState(true);
                clusterState = reader.getClusterState();
                refreshClusterState = false;

                // if there were any errors while processing
                // the state queue, items would have been left in the
                // work queue so let's process those first
                byte[] data = workQueue.peek();
                boolean hadWorkItems = data != null;
                while (data != null)  {
                  final ZkNodeProps message = ZkNodeProps.load(data);
                  log.info("processMessage: queueSize: {}, message = {}", workQueue.getStats().getQueueLength(), message);
                  clusterState = processQueueItem(message, clusterState, zkStateWriter);
                  workQueue.poll(); // poll-ing removes the element we got by peek-ing
                  data = workQueue.peek();
                }
                // force flush at the end of the loop
                if (hadWorkItems) {
                  clusterState = zkStateWriter.writePendingUpdates();
                }
              }

              while (head != null) {
                final ZkNodeProps message = ZkNodeProps.load(head.getBytes());
                log.info("processMessage: queueSize: {}, message = {} current state version: {}", stateUpdateQueue.getStats().getQueueLength(), message, clusterState.getZkClusterStateVersion());
                clusterState = processQueueItem(message, clusterState, zkStateWriter);
                workQueue.offer(head.getBytes());

                stateUpdateQueue.poll();

                if (isClosed) break;
                // if an event comes in the next 100ms batch it together
                head = stateUpdateQueue.peek(100);
              }
              // we should force write all pending updates because the next iteration might sleep until there
              // are more items in the main queue
              clusterState = zkStateWriter.writePendingUpdates();
              // clean work queue
              while (workQueue.poll() != null);

            } catch (KeeperException e) {
              if (e.code() == KeeperException.Code.SESSIONEXPIRED) {
                log.warn("Solr cannot talk to ZK, exiting Overseer main queue loop", e);
                return;
              }
              log.error("Exception in Overseer main queue loop", e);
              refreshClusterState = true; // it might have been a bad version error
            } catch (InterruptedException e) {
              Thread.currentThread().interrupt();
              return;
            } catch (Exception e) {
              log.error("Exception in Overseer main queue loop", e);
              refreshClusterState = true; // it might have been a bad version error
            }
          }

        }
      } finally {
        log.info("Overseer Loop exiting : {}", LeaderElector.getNodeName(myId));
        new Thread("OverseerExitThread"){
          //do this in a separate thread because any wait is interrupted in this main thread
          @Override
          public void run() {
            checkIfIamStillLeader();
          }
        }.start();
      }
    }

