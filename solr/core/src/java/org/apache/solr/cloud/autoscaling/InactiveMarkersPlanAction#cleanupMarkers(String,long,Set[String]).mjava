  private void cleanupMarkers(String path, long currentTimeNs, Set<String> cleanedUp) throws Exception {
    DistribStateManager stateManager = cloudManager.getDistribStateManager();
    if (!stateManager.hasData(path)) {
      return;
    }
    List<String> markers = stateManager.listData(path);
    markers.forEach(m -> {
      String markerPath = path + "/" + m;
      try {
        Map<String, Object> payload = Utils.getJson(stateManager, markerPath);
        if (payload.isEmpty()) {
          log.trace(" -- ignore {}: either missing or unsupported format", markerPath);
          return;
        }
        boolean activeMarker = payload.getOrDefault(MARKER_STATE, MARKER_ACTIVE)
            .equals(MARKER_ACTIVE);
        long timestamp = ((Number)payload.get("timestamp")).longValue();
        long delta = TimeUnit.NANOSECONDS.toSeconds(currentTimeNs - timestamp);
        if (delta > cleanupTTL || !activeMarker) {
          try {
            stateManager.removeData(markerPath, -1);
            log.trace(" -- remove {}, delta={}, ttl={}, active={}", markerPath, delta, cleanupTTL, activeMarker);
            cleanedUp.add(m);
          } catch (NoSuchElementException nse) {
            // someone already removed it - ignore
            return;
          } catch (BadVersionException be) {
            throw new RuntimeException("should never happen", be);
          } catch (NotEmptyException ne) {
            log.error("Marker znode should be empty but it's not! Ignoring {} ({})", markerPath, ne);
          }
        } else {
          log.trace(" -- keep {}, delta={}, ttl={}, active={}", markerPath, delta, cleanupTTL, activeMarker);
        }
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        return;
      } catch (IOException | KeeperException e) {
        log.warn("Could not cleanup marker at {}, skipping... ({}}", markerPath, e.getMessage());
      }
    });
  }

