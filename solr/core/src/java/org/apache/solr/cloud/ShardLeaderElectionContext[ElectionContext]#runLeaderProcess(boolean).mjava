  @Override
  void runLeaderProcess(boolean weAreReplacement) throws KeeperException,
      InterruptedException, IOException {
    log.info("Running the leader process.");
    
    String coreName = leaderProps.getStr(ZkStateReader.CORE_NAME_PROP);
    
    // clear the leader in clusterstate
    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "leader",
        ZkStateReader.SHARD_ID_PROP, shardId, ZkStateReader.COLLECTION_PROP,
        collection);
    Overseer.getInQueue(zkClient).offer(ZkStateReader.toJSON(m));
    
    String leaderVoteWait = cc.getZkController().getLeaderVoteWait();
    if (!weAreReplacement && leaderVoteWait != null) {
      waitForReplicasToComeUp(weAreReplacement, leaderVoteWait);
    }
    
    SolrCore core = null;
    try {
      
      core = cc.getCore(coreName);
      
      if (core == null) {
        cancelElection();
        throw new SolrException(ErrorCode.SERVER_ERROR,
            "Fatal Error, SolrCore not found:" + coreName + " in "
                + cc.getCoreNames());
      }
      
      // should I be leader?
      if (weAreReplacement && !shouldIBeLeader(leaderProps, core)) {
        rejoinLeaderElection(leaderSeqPath, core);
        return;
      }
      
      log.info("I may be the new leader - try and sync");
      // we are going to attempt to be the leader
      // first cancel any current recovery
      core.getUpdateHandler().getSolrCoreState().cancelRecovery();
      boolean success = false;
      try {
        success = syncStrategy.sync(zkController, core, leaderProps);
      } catch (Throwable t) {
        SolrException.log(log, "Exception while trying to sync", t);
        success = false;
      }
      
      // if !success but no one else is in active mode,
      // we are the leader anyway
      // TODO: should we also be leader if there is only one other active?
      // if we couldn't sync with it, it shouldn't be able to sync with us
      // TODO: this needs to be moved to the election context - the logic does
      // not belong here.
      if (!success
          && !areAnyOtherReplicasActive(zkController, leaderProps, collection,
              shardId)) {
        log.info("Sync was not a success but no one else is active! I am the leader");
        success = true;
      }
      
      // solrcloud_debug
      // try {
      // RefCounted<SolrIndexSearcher> searchHolder =
      // core.getNewestSearcher(false);
      // SolrIndexSearcher searcher = searchHolder.get();
      // try {
      // System.out.println(core.getCoreDescriptor().getCoreContainer().getZkController().getNodeName()
      // + " synched "
      // + searcher.search(new MatchAllDocsQuery(), 1).totalHits);
      // } finally {
      // searchHolder.decref();
      // }
      // } catch (Exception e) {
      //
      // }
      if (!success) {
        rejoinLeaderElection(leaderSeqPath, core);
        return;
      }

      log.info("I am the new leader: "
          + ZkCoreNodeProps.getCoreUrl(leaderProps));
      core.getCoreDescriptor().getCloudDescriptor().isLeader = true;
    } finally {
      if (core != null) {
        core.close();
      }
    }
    
    try {
      super.runLeaderProcess(weAreReplacement);
    } catch (Throwable t) {
      try {
        core = cc.getCore(coreName);
        core.getCoreDescriptor().getCloudDescriptor().isLeader = false;
        
        // we could not publish ourselves as leader - rejoin election
        rejoinLeaderElection(coreName, core);
      } finally {
        if (core != null) {
          core.close();
        }
      }
    }
    
  }

