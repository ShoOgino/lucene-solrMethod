  /**
   * Delete a collection
   * @param collection collection name
   * @param async async id
   * @param results results of the operation
   */
  public void simDeleteCollection(String collection, String async, NamedList results) throws Exception {
    ensureNotClosed();
    if (async != null) {
      results.add(CoreAdminParams.REQUESTID, async);
    }
    
    lock.lockInterruptibly();
    try {
      collProperties.remove(collection);
      sliceProperties.remove(collection);
      leaderThrottles.remove(collection);
      colShardReplicaMap.remove(collection);
      SplitShardCmd.unlockForSplit(cloudManager, collection, null);

      opDelay(collection, CollectionParams.CollectionAction.DELETE.name());

      opDelays.remove(collection);
      nodeReplicaMap.forEach((n, replicas) -> {
          synchronized (replicas) {  
            for (Iterator<ReplicaInfo> it = replicas.iterator(); it.hasNext(); ) {
              ReplicaInfo ri = it.next();
              if (ri.getCollection().equals(collection)) {
                it.remove();
                // update the number of cores in node values
                Number cores = (Number) cloudManager.getSimNodeStateProvider().simGetNodeValue(n, "cores");
                if (cores != null) { // node is still up
                  if (cores.intValue() == 0) {
                    throw new RuntimeException("Unexpected value of 'cores' (" + cores + ") on node: " + n);
                  }
                  try {
                    cloudManager.getSimNodeStateProvider().simSetNodeValue(n, "cores", cores.intValue() - 1);
                  } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new RuntimeException("interrupted");
                  }
                }
              }
            }
          }
        });
      cloudManager.getDistribStateManager().removeRecursively(ZkStateReader.getCollectionPath(collection), true, true);
      collectionsStatesRef.remove(collection);
      results.add("success", "");
    } catch (Exception e) {
      log.warn("Exception", e);
    } finally {
      lock.unlock();
    }
  }

