  /**
   * When a leader receives a communication error when trying to send a request to a replica,
   * it calls this method to ensure the replica enters recovery when connectivity is restored.
   * 
   * returns true if the node hosting the replica is still considered "live" by ZooKeeper;
   * false means the node is not live either, so no point in trying to send recovery commands
   * to it.
   */
  public boolean ensureReplicaInLeaderInitiatedRecovery(final String collection, 
      final String shardId, final String replicaUrl, final ZkCoreNodeProps replicaCoreProps, boolean forcePublishState) 
          throws KeeperException, InterruptedException 
  {    
    if (collection == null)
      throw new IllegalArgumentException("collection parameter cannot be null for starting leader-initiated recovery for replica: "+replicaUrl);

    if (shardId == null)
      throw new IllegalArgumentException("shard parameter cannot be null for starting leader-initiated recovery for replica: "+replicaUrl);
    
    if (replicaUrl == null)
      throw new IllegalArgumentException("replicaUrl parameter cannot be null for starting leader-initiated recovery");
    
    // First, determine if this replica is already in recovery handling
    // which is needed because there can be many concurrent errors flooding in
    // about the same replica having trouble and we only need to send the "needs"
    // recovery signal once
    boolean nodeIsLive = true;
    boolean publishDownState = false;
    synchronized (replicasInLeaderInitiatedRecovery) {
      if (replicasInLeaderInitiatedRecovery.containsKey(replicaUrl)) {     
        if (!forcePublishState) {
          log.debug("Replica {} already in leader-initiated recovery handling.", replicaUrl);
          return false; // already in this recovery process
        }
      }
      
      // if the replica's state is not DOWN right now, make it so ...        
      String replicaNodeName = replicaCoreProps.getNodeName();      
      String replicaCoreName = replicaCoreProps.getCoreName();      
      assert replicaCoreName != null : "No core name for replica "+replicaNodeName;
      
      // we only really need to try to send the recovery command if the node itself is "live"
      if (getZkStateReader().getClusterState().liveNodesContain(replicaNodeName)) {
        replicasInLeaderInitiatedRecovery.put(replicaUrl, 
            getLeaderInitiatedRecoveryZnodePath(collection, shardId, replicaCoreName));          
        // create a znode that requires the replica needs to "ack" to verify it knows it was out-of-sync
        updateLeaderInitiatedRecoveryState(collection, shardId, replicaCoreName, ZkStateReader.DOWN);
        log.info("Put replica "+replicaCoreName+" on "+
          replicaNodeName+" into leader-initiated recovery.");
        publishDownState = true;        
      } else {
        nodeIsLive = false; // we really don't need to send the recovery request if the node is NOT live
        log.info("Node "+replicaNodeName+
          " is not live, so skipping leader-initiated recovery for replica: "+
          replicaCoreName);
        // publishDownState will be false to avoid publishing the "down" state too many times
        // as many errors can occur together and will each call into this method (SOLR-6189)        
      }      
    }    
    
    if (publishDownState || forcePublishState) {
      String replicaCoreName = replicaCoreProps.getCoreName();    
      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state", 
          ZkStateReader.STATE_PROP, ZkStateReader.DOWN, 
          ZkStateReader.BASE_URL_PROP, replicaCoreProps.getBaseUrl(), 
          ZkStateReader.CORE_NAME_PROP, replicaCoreProps.getCoreName(),
          ZkStateReader.NODE_NAME_PROP, replicaCoreProps.getNodeName(),
          ZkStateReader.SHARD_ID_PROP, shardId,
          ZkStateReader.COLLECTION_PROP, collection);
      log.warn("Leader is publishing core={} state={} on behalf of un-reachable replica {}; forcePublishState? "+forcePublishState,
          replicaCoreName, ZkStateReader.DOWN, replicaUrl);
      overseerJobQueue.offer(ZkStateReader.toJSON(m));      
    }
    
    return nodeIsLive;
  }  

