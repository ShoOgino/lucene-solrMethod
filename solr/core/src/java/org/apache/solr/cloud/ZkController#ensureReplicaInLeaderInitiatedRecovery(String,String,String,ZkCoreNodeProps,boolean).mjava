  /**
   * When a leader receives a communication error when trying to send a request to a replica,
   * it calls this method to ensure the replica enters recovery when connectivity is restored.
   * 
   * returns true if the node hosting the replica is still considered "live" by ZooKeeper;
   * false means the node is not live either, so no point in trying to send recovery commands
   * to it.
   */
  public boolean ensureReplicaInLeaderInitiatedRecovery(final String collection, 
      final String shardId, final String replicaUrl, final ZkCoreNodeProps replicaCoreProps, boolean forcePublishState) 
          throws KeeperException, InterruptedException 
  {
    
    // First, determine if this replica is already in recovery handling
    // which is needed because there can be many concurrent errors flooding in
    // about the same replica having trouble and we only need to send the "needs"
    // recovery signal once
    boolean nodeIsLive = true;
    synchronized (replicasInLeaderInitiatedRecovery) {
      if (replicasInLeaderInitiatedRecovery.containsKey(replicaUrl)) {     
        if (!forcePublishState) {
          return false; // already in this recovery process
        }
      }
      
      // if the replica's state is not DOWN right now, make it so ...        
      String replicaNodeName = replicaCoreProps.getNodeName();      
      String replicaCoreName = replicaCoreProps.getCoreName();      
      assert replicaCoreName != null : "No core name for replica "+replicaNodeName;
      
      // we only really need to try to send the recovery command if the node itself is "live"
      if (getZkStateReader().getClusterState().liveNodesContain(replicaNodeName)) {
        replicasInLeaderInitiatedRecovery.put(replicaUrl, 
            getLeaderInitiatedRecoveryZnodePath(collection, shardId, replicaCoreName));          
        // create a znode that requires the replica needs to "ack" to verify it knows it was out-of-sync
        updateLeaderInitiatedRecoveryState(collection, shardId, replicaCoreName, ZkStateReader.DOWN);
      } else {
        nodeIsLive = false; // we really don't need to send the recovery request if the node is NOT live
      }      
    }    
    
    String replicaCoreName = replicaCoreProps.getCoreName();    
    ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, "state", 
        ZkStateReader.STATE_PROP, ZkStateReader.DOWN, 
        ZkStateReader.BASE_URL_PROP, replicaCoreProps.getBaseUrl(), 
        ZkStateReader.CORE_NAME_PROP, replicaCoreProps.getCoreName(),
        ZkStateReader.NODE_NAME_PROP, replicaCoreProps.getNodeName(),
        ZkStateReader.SHARD_ID_PROP, shardId,
        ZkStateReader.COLLECTION_PROP, collection);
    log.warn("Leader is publishing core={} state={} on behalf of un-reachable replica {}; forcePublishState? "+forcePublishState,
        replicaCoreName, ZkStateReader.DOWN, replicaUrl);
    overseerJobQueue.offer(ZkStateReader.toJSON(m));
    
    return nodeIsLive;
  }  

