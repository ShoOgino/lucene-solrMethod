  /**
   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed
   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this
   * operation becomes a no-op.
   *
   * @param newTrigger the trigger to be managed
   * @throws AlreadyClosedException if this class has already been closed
   */
  public synchronized void add(AutoScaling.Trigger newTrigger) {
    if (isClosed) {
      throw new AlreadyClosedException("ScheduledTriggers has been closed and cannot be used anymore");
    }
    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);
    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);
    if (old != null) {
      if (old.trigger.equals(newTrigger)) {
        // the trigger wasn't actually modified so we do nothing
        return;
      }
      IOUtils.closeQuietly(old);
      newTrigger.restoreState(old.trigger);
      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);
    }
    newTrigger.setListener(event -> {
      AutoScaling.Trigger source = event.getSource();
      if (source.isClosed()) {
        log.warn("Ignoring autoscaling event because the source trigger: " + source + " has already been closed");
        // we do not want to lose this event just because the trigger were closed, perhaps a replacement will need it
        return false;
      }
      if (hasPendingActions.compareAndSet(false, true)) {
        List<TriggerAction> actions = source.getActions();
        if (actions != null) {
          actionExecutor.submit(() -> {
            assert hasPendingActions.get();
            try {
              // let the action executor thread wait instead of the trigger thread so we use the throttle here
              actionThrottle.minimumWaitBetweenActions();
              actionThrottle.markAttemptingAction();
              for (TriggerAction action : actions) {
                try {
                  action.process(event);
                } catch (Exception e) {
                  log.error("Error executing action: " + action.getName() + " for trigger event: " + event, e);
                  throw e;
                }
              }
            } finally {
              hasPendingActions.set(false);
            }
          });
        }
        return true;
      } else {
        // there is an action in the queue and we don't want to enqueue another until it is complete
        return false;
      }
    });
    List<TriggerAction> actions = newTrigger.getActions();
    for (TriggerAction action : actions) {
      action.init(newTrigger.getProperties());
    }
    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0, DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS);
  }

