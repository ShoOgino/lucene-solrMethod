  /**
   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed
   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this
   * operation becomes a no-op.
   *
   * @param newTrigger the trigger to be managed
   * @throws AlreadyClosedException if this class has already been closed
   */
  public synchronized void add(AutoScaling.Trigger newTrigger) {
    if (isClosed) {
      throw new AlreadyClosedException("ScheduledTriggers has been closed and cannot be used anymore");
    }
    ScheduledTrigger st;
    try {
      st = new ScheduledTrigger(newTrigger, cloudManager, queueStats);
    } catch (Exception e) {
      if (isClosed) {
        throw new AlreadyClosedException("ScheduledTriggers has been closed and cannot be used anymore");
      }
      if (cloudManager.isClosed()) {
        log.error("Failed to add trigger " + newTrigger.getName() + " - closing or disconnected from data provider", e);
      } else {
        log.error("Failed to add trigger " + newTrigger.getName(), e);
      }
      return;
    }
    ScheduledTrigger scheduledTrigger = st;

    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);
    if (old != null) {
      if (old.trigger.equals(newTrigger)) {
        // the trigger wasn't actually modified so we do nothing
        return;
      }
      IOUtils.closeQuietly(old);
      newTrigger.restoreState(old.trigger);
      scheduledTrigger.setReplay(false);
      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);
    }
    newTrigger.setProcessor(event -> {
      if (cloudManager.isClosed()) {
        String msg = String.format(Locale.ROOT, "Ignoring autoscaling event %s because Solr has been shutdown.", event.toString());
        log.warn(msg);
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);
        return false;
      }
      ScheduledTrigger scheduledSource = scheduledTriggers.get(event.getSource());
      if (scheduledSource == null) {
        String msg = String.format(Locale.ROOT, "Ignoring autoscaling event %s because the source trigger: %s doesn't exist.", event.toString(), event.getSource());
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, msg);
        log.warn(msg);
        return false;
      }
      boolean replaying = event.getProperty(TriggerEvent.REPLAYING) != null ? (Boolean)event.getProperty(TriggerEvent.REPLAYING) : false;
      AutoScaling.Trigger source = scheduledSource.trigger;
      if (scheduledSource.isClosed || source.isClosed()) {
        String msg = String.format(Locale.ROOT, "Ignoring autoscaling event %s because the source trigger: %s has already been closed", event.toString(), source);
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);
        log.warn(msg);
        // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it
        return false;
      }
      if (event.isIgnored())  {
        log.debug("-------- Ignoring event: " + event);
        event.getProperties().put(TriggerEvent.IGNORED, true);
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, "Event was ignored.");
        return true; // always return true for ignored events
      }
      // even though we pause all triggers during action execution there is a possibility that a trigger was already
      // running at the time and would have already created an event so we reject such events during cooldown period
      if (cooldownStart.get() + cooldownPeriod.get() > cloudManager.getTimeSource().getTime()) {
        log.debug("-------- Cooldown period - rejecting event: " + event);
        event.getProperties().put(TriggerEvent.COOLDOWN, true);
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, "In cooldown period.");
        return false;
      } else {
        log.debug("++++++++ Cooldown inactive - processing event: " + event);
      }
      if (hasPendingActions.compareAndSet(false, true)) {
        // pause all triggers while we execute actions so triggers do not operate on a cluster in transition
        pauseTriggers();

        final boolean enqueued;
        if (replaying) {
          enqueued = false;
        } else {
          enqueued = scheduledTrigger.enqueue(event);
        }
        // fire STARTED event listeners after enqueuing the event is successful
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.STARTED);
        List<TriggerAction> actions = source.getActions();
        if (actions != null) {
          if (actionExecutor.isShutdown()) {
            String msg = String.format(Locale.ROOT, "Ignoring autoscaling event %s from trigger %s because the executor has already been closed", event.toString(), source);
            listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.ABORTED, msg);
            log.warn(msg);
            // we do not want to lose this event just because the trigger was closed, perhaps a replacement will need it
            return false;
          }
          actionExecutor.submit(() -> {
            assert hasPendingActions.get();
            long eventProcessingStart = cloudManager.getTimeSource().getTime();
            log.debug("-- processing actions for " + event);
            try {
              // in future, we could wait for pending tasks in a different thread and re-enqueue
              // this event so that we continue processing other events and not block this action executor
              waitForPendingTasks(newTrigger, actions);

              ActionContext actionContext = new ActionContext(cloudManager, newTrigger, new HashMap<>());
              for (TriggerAction action : actions) {
                List<String> beforeActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.BEFORE_ACTION.toString(), k -> new ArrayList<String>());
                beforeActions.add(action.getName());
                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.BEFORE_ACTION, action.getName(), actionContext);
                try {
                  action.process(event, actionContext);
                } catch (Exception e) {
                  listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.FAILED, action.getName(), actionContext, e, null);
                  throw new Exception("Error executing action: " + action.getName() + " for trigger event: " + event, e);
                }
                List<String> afterActions = (List<String>) actionContext.getProperties().computeIfAbsent(TriggerEventProcessorStage.AFTER_ACTION.toString(), k -> new ArrayList<String>());
                afterActions.add(action.getName());
                listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.AFTER_ACTION, action.getName(), actionContext);
              }
              if (enqueued) {
                TriggerEvent ev = scheduledTrigger.dequeue();
                assert ev.getId().equals(event.getId());
              }
              listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);
            } catch (Exception e) {
              log.warn("Exception executing actions", e);
            } finally {
              cooldownStart.set(cloudManager.getTimeSource().getTime());
              hasPendingActions.set(false);
              // resume triggers after cool down period
              resumeTriggers(cloudManager.getTimeSource().convertDelay(TimeUnit.NANOSECONDS, cooldownPeriod.get(), TimeUnit.MILLISECONDS));
            }
            log.debug("-- processing took {} ms for event id={}",
                TimeUnit.NANOSECONDS.toMillis(cloudManager.getTimeSource().getTime() - eventProcessingStart), event.id);
          });
        } else {
          if (enqueued) {
            TriggerEvent ev = scheduledTrigger.dequeue();
            if (!ev.getId().equals(event.getId())) {
              throw new RuntimeException("Wrong event dequeued, queue of " + scheduledTrigger.trigger.getName()
              + " is broken! Expected event=" + event + " but got " + ev);
            }
          }
          listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.SUCCEEDED);
          hasPendingActions.set(false);
          // resume triggers now
          resumeTriggers(0);
        }
        return true;
      } else {
        // there is an action in the queue and we don't want to enqueue another until it is complete
        listeners.fireListeners(event.getSource(), event, TriggerEventProcessorStage.IGNORED, "Already processing another event.");
        return false;
      }
    });
    newTrigger.init(); // mark as ready for scheduling
    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(scheduledTrigger, 0,
        cloudManager.getTimeSource().convertDelay(TimeUnit.SECONDS, triggerDelay.get(), TimeUnit.MILLISECONDS),
        TimeUnit.MILLISECONDS);
  }

