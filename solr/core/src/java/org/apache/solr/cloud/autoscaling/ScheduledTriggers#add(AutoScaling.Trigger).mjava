  /**
   * Adds a new trigger or replaces an existing one. The replaced trigger, if any, is closed
   * <b>before</b> the new trigger is run. If a trigger is replaced with itself then this
   * operation becomes a no-op.
   *
   * @param newTrigger the trigger to be managed
   * @throws AlreadyClosedException if this class has already been closed
   */
  public synchronized void add(AutoScaling.Trigger newTrigger) {
    if (isClosed) {
      throw new AlreadyClosedException("ScheduledTriggers has been closed and cannot be used anymore");
    }
    ScheduledTrigger scheduledTrigger = new ScheduledTrigger(newTrigger);
    ScheduledTrigger old = scheduledTriggers.putIfAbsent(newTrigger.getName(), scheduledTrigger);
    if (old != null) {
      if (old.trigger.equals(newTrigger)) {
        // the trigger wasn't actually modified so we do nothing
        return;
      }
      IOUtils.closeQuietly(old);
      scheduledTriggers.replace(newTrigger.getName(), scheduledTrigger);
    }
    newTrigger.setListener(event -> {
      AutoScaling.Trigger source = event.getSource();
      if (source.isClosed()) {
        log.warn("Ignoring autoscaling event because the source trigger: " + source + " has already been closed");
        return;
      }
      List<TriggerAction> actions = source.getActions();
      if (actions != null) {
        actionExecutor.submit(() -> {
          for (TriggerAction action : actions) {
            try {
              action.process(event);
            } catch (Exception e) {
              log.error("Error executing action: " + action.getName() + " for trigger event: " + event, e);
              throw e;
            }
          }
        });
      }
    });
    scheduledTrigger.scheduledFuture = scheduledThreadPoolExecutor.scheduleWithFixedDelay(newTrigger, 0, 1, TimeUnit.SECONDS);
  }

