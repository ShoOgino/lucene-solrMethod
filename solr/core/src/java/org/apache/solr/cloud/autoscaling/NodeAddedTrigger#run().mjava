  @Override
  public void run() {
    try {
      synchronized (this) {
        if (isClosed) {
          log.warn("NodeAddedTrigger ran but was already closed");
          throw new RuntimeException("Trigger has been closed");
        }
      }
      log.debug("Running NodeAddedTrigger");

      ZkStateReader reader = container.getZkController().getZkStateReader();
      Set<String> newLiveNodes = reader.getClusterState().getLiveNodes();
      log.info("Found livenodes: " + newLiveNodes);
      if (lastLiveNodes == null) {
        lastLiveNodes = newLiveNodes;
        return;
      }

      // have any nodes that we were tracking been removed from the cluster?
      // if so, remove them from the tracking map
      Set<String> trackingKeySet = nodeNameVsTimeAdded.keySet();
      trackingKeySet.retainAll(newLiveNodes);

      // have any new nodes been added?
      Set<String> copyOfNew = new HashSet<>(newLiveNodes);
      copyOfNew.removeAll(lastLiveNodes);
      copyOfNew.forEach(n -> {
        log.info("Tracking new node: {}", n);
        nodeNameVsTimeAdded.put(n, System.nanoTime());
      });

      // has enough time expired to trigger events for a node?
      for (Map.Entry<String, Long> entry : nodeNameVsTimeAdded.entrySet()) {
        String nodeName = entry.getKey();
        Long timeAdded = entry.getValue();
        if (TimeUnit.SECONDS.convert(System.nanoTime() - timeAdded, TimeUnit.NANOSECONDS) >= getWaitForSecond()) {
          // fire!
          AutoScaling.TriggerListener<NodeAddedEvent> listener = listenerRef.get();
          if (listener != null) {
            log.info("NodeAddedTrigger firing registered listener");
            listener.triggerFired(new NodeAddedEvent(this, timeAdded, nodeName));
          }
          trackingKeySet.remove(nodeName);
        }
      }

      lastLiveNodes = newLiveNodes;
    } catch (RuntimeException e) {
      log.error("Unexpected exception in NodeAddedTrigger", e);
    }
  }

