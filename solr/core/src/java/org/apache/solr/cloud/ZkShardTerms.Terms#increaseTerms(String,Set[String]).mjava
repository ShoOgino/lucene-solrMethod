    /**
     * Return a new {@link Terms} in which term of {@code leader} is higher than {@code replicasNeedingRecovery}
     * @param leader coreNodeName of leader
     * @param replicasNeedingRecovery set of replicas in which their terms should be lower than leader's term
     * @return null if term of {@code leader} is already higher than {@code replicasNeedingRecovery}
     */
    Terms increaseTerms(String leader, Set<String> replicasNeedingRecovery) {
      if (!values.containsKey(leader)) {
        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Can not find leader's term " + leader);
      }

      boolean changed = false;
      boolean foundReplicasInLowerTerms = false;

      HashMap<String, Long> newValues = new HashMap<>(values);
      long leaderTerm = newValues.get(leader);
      for (String replica : newValues.keySet()) {
        if (replicasNeedingRecovery.contains(replica)) foundReplicasInLowerTerms = true;
        if (Objects.equals(newValues.get(replica), leaderTerm)) {
          if(replicasNeedingRecovery.contains(replica)) {
            changed = true;
          } else {
            newValues.put(replica, leaderTerm+1);
          }
        }
      }

      // We should skip the optimization if there are no replicasNeedingRecovery present in local terms,
      // this may indicate that the current value is stale
      if (!changed && foundReplicasInLowerTerms) return null;
      return new Terms(newValues, version);
    }

