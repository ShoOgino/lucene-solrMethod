  /**
   * Simulate getting replica metrics values. This uses per-replica properties set in
   * {@link SimClusterStateProvider#simSetCollectionValue(String, String, Object, boolean, boolean)} and
   * similar methods.
   * @param node node id
   * @param tags metrics names
   * @return map of metrics names / values
   */
  public Map<String, Object> getReplicaMetricsValues(String node, Collection<String> tags) {
    if (!liveNodesSet.contains(node)) {
      throw new RuntimeException("non-live node " + node);
    }
    Map<String, Object> values = new HashMap<>();
    for (String tag : tags) {
      Matcher m = METRIC_KEY_PATTERN.matcher(tag);
      if (!m.matches() || m.groupCount() < 2) {
        log.warn("Invalid metrics: tag: {}", tag);
        continue;
      }
      String registryName = m.group(1);
      String key = m.group(3) != null ? m.group(2) + m.group(3) : m.group(2);
      if (!registryName.startsWith("solr.core.")) {
        // skip - this is probably solr.node or solr.jvm metric
        continue;
      }
      m = REGISTRY_PATTERN.matcher(registryName);

      if (!m.matches()) {
        log.warn("Invalid registry name: {}", registryName);
        continue;
      }
      String collection = m.group(1);
      String shard = m.group(2);
      String replica = m.group(3);
      List<Replica> replicas = clusterStateProvider.simGetReplicaInfos(collection, shard);
      replicas.forEach(r -> {
        if (r.getNodeName().equals(node) && r.getCoreName().endsWith(replica)) {
          Object value = r.getProperties().get(key);
          if (value != null) {
            values.put(tag, value);
          } else {
            value = r.getProperties().get(tag);
            if (value != null) {
              values.put(tag, value);
            }
          }
        }
      });
    }
    return values;
  }

