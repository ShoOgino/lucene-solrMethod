  private void prioritizeOverseerNodes() throws KeeperException, InterruptedException {
    log.info("prioritizing overseer nodes");
    SolrZkClient zk = zkStateReader.getZkClient();
    if(!zk.exists(ZkStateReader.ROLES,true))return;
    Map m = (Map) ZkStateReader.fromJSON(zk.getData(ZkStateReader.ROLES, null, new Stat(), true));

    List overseerDesignates = (List) m.get("overseer");
    if(overseerDesignates==null || overseerDesignates.isEmpty()) return;

    log.debug("overseer designates {}", overseerDesignates);

    List<String> children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);


    if(children.size()<2) return;

    LeaderElector.sortSeqs(children);
    ArrayList<String> nodeNames = new ArrayList<>(children.size());
    for (String c : children) nodeNames.add(LeaderElector.getNodeName(c));
    boolean overseerDesignateAvailable = false;
    //ensure that the node right behind the leader , i.r at position 1 is a Overseer
    String newOverseerDesignate = null;
    log.debug("sorted nodes {}", nodeNames);
    for (int i = 1; i < nodeNames.size(); i++) {
      String s = nodeNames.get(i);
      if (overseerDesignates.contains(s)) {
        log.info(" found an overseer designate to be promoted to the front : {}, pushing others back", s);
        overseerDesignateAvailable = true;
        newOverseerDesignate = s;
        for (int j = 1; j < i; j++) {
          String nodeName = nodeNames.get(j);
          log.debug("pushing back {} ", nodeName);
          invokeRejoinOverseer(nodeName);
        }
        break;
      }
      if(overseerDesignateAvailable) break;
    }

    if(overseerDesignateAvailable){
      //wait for a while to ensure the designate has indeed come in front
      boolean prioritizationComplete = false;
      long timeout = System.currentTimeMillis() + 5000;

      for(;System.currentTimeMillis()< timeout ;){
        children = zk.getChildren(OverseerElectionContext.PATH + LeaderElector.ELECTION_NODE, null, true);
        LeaderElector.sortSeqs(children);

        String frontRunner = LeaderElector.getNodeName(children.get(1));
        log.debug("Frontrunner : {}", frontRunner);
        if(newOverseerDesignate.equals(frontRunner)){
          prioritizationComplete = true;
          break;
        }
        Thread.sleep(50);
      }

      if(!prioritizationComplete) {
        log.warn("Could not make the Overseer designate '{}' the frontrunner", newOverseerDesignate);
      }

    } else {
      log.warn("No overseer designates are available, overseerDesignates: {}, nodes : ",overseerDesignates,nodeNames);
      return;
    }



    if(!overseerDesignates.contains( nodeNames.get(0)) && overseerDesignateAvailable){
      //this means there are designated Overseer nodes and I am not one of them , kill myself
      invokeRejoinOverseer(nodeNames.get(0));
    }


  }

