  @Override
  public void run() {
    AutoScaling.TriggerEventProcessor processor = processorRef.get();
    if (processor == null) {
      return;
    }

    Map<String, Map<String, List<ReplicaInfo>>> collectionRates = new HashMap<>();
    Map<String, AtomicDouble> nodeRates = new HashMap<>();
    Map<String, Integer> replicationFactors = new HashMap<>();

    for (String node : cloudManager.getClusterStateProvider().getLiveNodes()) {
      Map<String, ReplicaInfo> metricTags = new HashMap<>();
      // coll, shard, replica
      Map<String, Map<String, List<ReplicaInfo>>> infos = cloudManager.getNodeStateProvider().getReplicaInfo(node, Collections.emptyList());
      infos.forEach((coll, shards) -> {
        replicationFactors.computeIfAbsent(coll, c -> shards.size());
        shards.forEach((sh, replicas) -> {
          replicas.forEach(replica -> {
            // we have to translate to the metrics registry name, which uses "_replica_nN" as suffix
            String replicaName = Utils.parseMetricsReplicaName(coll, replica.getCore());
            if (replicaName == null) { // should never happen???
              replicaName = replica.getName(); // which is actually coreNode name...
            }
            String registry = SolrCoreMetricManager.createRegistryName(true, coll, sh, replicaName, null);
            String tag = "metrics:" + registry
                + ":QUERY." + handler + ".requestTimes:1minRate";
            metricTags.put(tag, replica);
          });
        });
      });
      if (metricTags.isEmpty()) {
        continue;
      }
      Map<String, Object> rates = cloudManager.getNodeStateProvider().getNodeValues(node, metricTags.keySet());
      rates.forEach((tag, rate) -> {
        ReplicaInfo info = metricTags.get(tag);
        if (info == null) {
          log.warn("Missing replica info for response tag " + tag);
        } else {
          Map<String, List<ReplicaInfo>> perCollection = collectionRates.computeIfAbsent(info.getCollection(), s -> new HashMap<>());
          List<ReplicaInfo> perShard = perCollection.computeIfAbsent(info.getShard(), s -> new ArrayList<>());
          info.getVariables().put(AutoScalingParams.RATE, rate);
          perShard.add(info);
          AtomicDouble perNode = nodeRates.computeIfAbsent(node, s -> new AtomicDouble());
          perNode.addAndGet((Double)rate);
        }
      });
    }

    long now = cloudManager.getTimeSource().getTimeNs();
    // check for exceeded rates and filter out those with less than waitFor from previous events
    Map<String, Double> hotNodes = nodeRates.entrySet().stream()
        .filter(entry -> node.equals(Policy.ANY) || node.equals(entry.getKey()))
        .filter(entry -> waitForElapsed(entry.getKey(), now, lastNodeEvent))
        .filter(entry -> entry.getValue().get() > rate)
        .collect(Collectors.toMap(entry -> entry.getKey(), entry -> entry.getValue().get()));

    Map<String, Map<String, Double>> hotShards = new HashMap<>();
    List<ReplicaInfo> hotReplicas = new ArrayList<>();
    collectionRates.forEach((coll, shardRates) -> {
      shardRates.forEach((sh, replicaRates) -> {
        double shardRate = replicaRates.stream()
            .map(r -> {
              if (waitForElapsed(r.getCollection() + "." + r.getCore(), now, lastReplicaEvent) &&
                  ((Double)r.getVariable(AutoScalingParams.RATE) > rate)) {
                hotReplicas.add(r);
              }
              return r;
            })
            .mapToDouble(r -> (Double)r.getVariable(AutoScalingParams.RATE)).sum();
        if (waitForElapsed(coll + "." + sh, now, lastShardEvent) &&
            (shardRate > rate) &&
            (collection.equals(Policy.ANY) || collection.equals(coll)) &&
            (shard.equals(Policy.ANY) || shard.equals(sh))) {
          hotShards.computeIfAbsent(coll, s -> new HashMap<>()).put(sh, shardRate);
        }
      });
    });

    Map<String, Double> hotCollections = new HashMap<>();
    collectionRates.forEach((coll, shardRates) -> {
      double total = shardRates.entrySet().stream()
          .mapToDouble(e -> e.getValue().stream()
              .mapToDouble(r -> (Double)r.getVariable(AutoScalingParams.RATE)).sum()).sum();
      if (waitForElapsed(coll, now, lastCollectionEvent) &&
          (total > rate) &&
          (collection.equals(Policy.ANY) || collection.equals(coll))) {
        hotCollections.put(coll, total);
      }
    });

    if (hotCollections.isEmpty() && hotShards.isEmpty() && hotReplicas.isEmpty() && hotNodes.isEmpty()) {
      return;
    }

    // generate event

    // find the earliest time when a condition was exceeded
    final AtomicLong eventTime = new AtomicLong(now);
    hotCollections.forEach((c, r) -> {
      long time = lastCollectionEvent.get(c);
      if (eventTime.get() > time) {
        eventTime.set(time);
      }
    });
    hotShards.forEach((c, shards) -> {
      shards.forEach((s, r) -> {
        long time = lastShardEvent.get(c + "." + s);
        if (eventTime.get() > time) {
          eventTime.set(time);
        }
      });
    });
    hotReplicas.forEach(r -> {
      long time = lastReplicaEvent.get(r.getCollection() + "." + r.getCore());
      if (eventTime.get() > time) {
        eventTime.set(time);
      }
    });
    hotNodes.forEach((n, r) -> {
      long time = lastNodeEvent.get(n);
      if (eventTime.get() > time) {
        eventTime.set(time);
      }
    });

    // calculate the number of replicas to add to each hot shard, based on how much the rate was
    // exceeded - but within limits.
    final List<TriggerEvent.Op> ops = new ArrayList<>();
    if (hotShards.isEmpty() && hotCollections.isEmpty() && hotReplicas.isEmpty()) {
      // move replicas around
      hotNodes.forEach((n, r) -> {
        ops.add(new TriggerEvent.Op(CollectionParams.CollectionAction.MOVEREPLICA, Suggester.Hint.SRC_NODE, n));
      });
    } else {
      // add replicas
      Map<String, Map<String, List<Pair<String, String>>>> hints = new HashMap<>();

      hotShards.forEach((coll, shards) -> shards.forEach((s, r) -> {
        List<Pair<String, String>> perShard = hints
            .computeIfAbsent(coll, c -> new HashMap<>())
            .computeIfAbsent(s, sh -> new ArrayList<>());
        addHints(coll, s, r, replicationFactors.get(coll), perShard);
      }));
      hotReplicas.forEach(ri -> {
        double r = (Double)ri.getVariable(AutoScalingParams.RATE);
        // add only if not already accounted for in hotShards
        List<Pair<String, String>> perShard = hints
            .computeIfAbsent(ri.getCollection(), c -> new HashMap<>())
            .computeIfAbsent(ri.getShard(), sh -> new ArrayList<>());
        if (perShard.isEmpty()) {
          addHints(ri.getCollection(), ri.getShard(), r, replicationFactors.get(ri.getCollection()), perShard);
        }
      });

      hints.values().forEach(m -> m.values().forEach(lst -> lst.forEach(p -> {
        ops.add(new TriggerEvent.Op(CollectionParams.CollectionAction.ADDREPLICA, Suggester.Hint.COLL_SHARD, p));
      })));
    }

    if (processor.process(new SearchRateEvent(getName(), eventTime.get(), ops, hotNodes, hotCollections, hotShards, hotReplicas))) {
      // update lastEvent times
      hotNodes.keySet().forEach(node -> lastNodeEvent.put(node, now));
      hotCollections.keySet().forEach(coll -> lastCollectionEvent.put(coll, now));
      hotShards.entrySet().forEach(e -> e.getValue()
          .forEach((sh, rate) -> lastShardEvent.put(e.getKey() + "." + sh, now)));
      hotReplicas.forEach(r -> lastReplicaEvent.put(r.getCollection() + "." + r.getCore(), now));
    }
  }

