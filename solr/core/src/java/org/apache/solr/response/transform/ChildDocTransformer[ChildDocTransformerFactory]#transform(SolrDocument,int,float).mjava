  @Override
  public void transform(SolrDocument doc, int docid, float score) {

    FieldType idFt = idField.getType();
    Object parentIdField = doc.getFirstValue(idField.getName());
    
    String parentIdExt = parentIdField instanceof IndexableField
      ? idFt.toExternal((IndexableField)parentIdField)
      : parentIdField.toString();

    try {
      Query parentQuery = idFt.getFieldQuery(null, idField, parentIdExt);
      Query query = new ToChildBlockJoinQuery(parentQuery, parentsFilter);
      DocList children = context.getSearcher().getDocList(query, childFilterQuery, new Sort(), 0, limit);
      if(children.matches() > 0) {
        SolrDocumentFetcher docFetcher = context.getSearcher().getDocFetcher();

        Set<String> dvFieldsToReturn = docFetcher.getNonStoredDVs(true);
        boolean shouldDecorateWithDVs = dvFieldsToReturn.size() > 0;
        DocIterator i = children.iterator();

        while(i.hasNext()) {
          Integer childDocNum = i.next();
          Document childDoc = context.getSearcher().doc(childDocNum);
          SolrDocument solrChildDoc = DocsStreamer.convertLuceneDocToSolrDoc(childDoc, schema);

          if (shouldDecorateWithDVs) {
            docFetcher.decorateDocValueFields(solrChildDoc, childDocNum, dvFieldsToReturn);
          }

          // TODO: future enhancement...
          // support an fl local param in the transformer, which is used to build
          // a private ReturnFields instance that we use to prune unwanted field 
          // names from solrChildDoc
          doc.addChildDocument(solrChildDoc);
        }
      }
      
    } catch (IOException e) {
      doc.put(name, "Could not fetch child Documents");
    }
  }

