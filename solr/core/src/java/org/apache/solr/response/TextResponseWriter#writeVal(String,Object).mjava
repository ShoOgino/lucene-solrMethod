  public final void writeVal(String name, Object val) throws IOException {

    // if there get to be enough types, perhaps hashing on the type
    // to get a handler might be faster (but types must be exact to do that...)

    // go in order of most common to least common
    if (val==null) {
      writeNull(name);
    } else if (val instanceof String) {
      writeStr(name, val.toString(), true);
      // micro-optimization... using toString() avoids a cast first
    } else if (val instanceof StorableField) {
      StorableField f = (StorableField)val;
      SchemaField sf = schema.getFieldOrNull( f.name() );
      if( sf != null ) {
        sf.getType().write(this, name, f);
      }
      else {
        writeStr(name, f.stringValue(), true);
      }
    } else if (val instanceof Number) {
      if (val instanceof Integer) {
        writeInt(name, val.toString());
      } else if (val instanceof Long) {
        writeLong(name, val.toString());
      } else if (val instanceof Float) {
        // we pass the float instead of using toString() because
        // it may need special formatting. same for double.
        writeFloat(name, ((Float)val).floatValue());
      } else if (val instanceof Double) {
        writeDouble(name, ((Double)val).doubleValue());        
      } else if (val instanceof Short) {
        writeInt(name, val.toString());
      } else if (val instanceof Byte) {
        writeInt(name, val.toString());
      } else {
        // default... for debugging only
        writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
      }
    } else if (val instanceof Boolean) {
      writeBool(name, val.toString());
    } else if (val instanceof Date) {
      writeDate(name,(Date)val);
    } else if (val instanceof StoredDocument) {
      SolrDocument doc = toSolrDocument( (StoredDocument)val );
      DocTransformer transformer = returnFields.getTransformer();
      if( transformer != null ) {
        TransformContext context = new TransformContext();
        context.req = req;
        transformer.setContext(context);
        transformer.transform(doc, -1);
      }
      writeSolrDocument(name, doc, returnFields, 0 );
    } else if (val instanceof SolrDocument) {
      writeSolrDocument(name, (SolrDocument)val, returnFields, 0);
    } else if (val instanceof ResultContext) {
      // requires access to IndexReader
      writeDocuments(name, (ResultContext)val, returnFields);
    } else if (val instanceof DocList) {
      // Should not happen normally
      ResultContext ctx = new ResultContext();
      ctx.docs = (DocList)val;
      writeDocuments(name, ctx, returnFields);
    // }
    // else if (val instanceof DocSet) {
    // how do we know what fields to read?
    // todo: have a DocList/DocSet wrapper that
    // restricts the fields to write...?
    } else if (val instanceof SolrDocumentList) {
      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);
    } else if (val instanceof Map) {
      writeMap(name, (Map)val, false, true);
    } else if (val instanceof NamedList) {
      writeNamedList(name, (NamedList)val);
    } else if (val instanceof TupleStream) {
      writeTupleStream((TupleStream) val);
    } else if (val instanceof Iterable) {
      writeArray(name,((Iterable)val).iterator());
    } else if (val instanceof Object[]) {
      writeArray(name,(Object[])val);
    } else if (val instanceof Iterator) {
      writeArray(name, (Iterator) val);
    } else if (val instanceof byte[]) {
      byte[] arr = (byte[])val;
      writeByteArr(name, arr, 0, arr.length);
    } else if (val instanceof BytesRef) {
      BytesRef arr = (BytesRef)val;
      writeByteArr(name, arr.bytes, arr.offset, arr.length);
    } else {
      // default... for debugging only
      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
    }
  }

