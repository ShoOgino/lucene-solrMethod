  public final void writeVal(String name, Object val) throws IOException {

    // if there get to be enough types, perhaps hashing on the type
    // to get a handler might be faster (but types must be exact to do that...)

    // go in order of most common to least common
    if (val == null) {
      writeNull(name);
    } else if (val instanceof String) {
      writeStr(name, val.toString(), true);
      // micro-optimization... using toString() avoids a cast first
    } else if (val instanceof IndexableField) {
      IndexableField f = (IndexableField)val;
      SchemaField sf = schema.getFieldOrNull( f.name() );
      if( sf != null ) {
        sf.getType().write(this, name, f);
      }
      else {
        writeStr(name, f.stringValue(), true);
      }
    } else if (val instanceof Number) {
      writeNumber(name, (Number)val);
    } else if (val instanceof Boolean) {
      writeBool(name, (Boolean)val);
    } else if (val instanceof Date) {
      writeDate(name,(Date)val);
    } else if (val instanceof Document) {
      SolrDocument doc = DocsStreamer.getDoc((Document) val, schema);
      writeSolrDocument(name, doc,returnFields, 0 );
    } else if (val instanceof SolrDocument) {
      writeSolrDocument(name, (SolrDocument)val,returnFields, 0);
    } else if (val instanceof ResultContext) {
      // requires access to IndexReader
      writeDocuments(name, (ResultContext)val);
    } else if (val instanceof DocList) {
      // Should not happen normally
      ResultContext ctx = new BasicResultContext((DocList)val, returnFields, null, null, req);
      writeDocuments(name, ctx);
    // }
    // else if (val instanceof DocSet) {
    // how do we know what fields to read?
    // todo: have a DocList/DocSet wrapper that
    // restricts the fields to write...?
    } else if (val instanceof SolrDocumentList) {
      writeSolrDocumentList(name, (SolrDocumentList)val, returnFields);
    } else if (val instanceof Map) {
      writeMap(name, (Map)val, false, true);
    } else if (val instanceof NamedList) {
      writeNamedList(name, (NamedList)val);
    } else if (val instanceof TupleStream) {
      writeTupleStream((TupleStream) val);
    } else if (val instanceof Explanation){
      writeExplanation((Explanation) val);
    } else if (val instanceof Path) {
      writeStr(name, ((Path) val).toAbsolutePath().toString(), true);
    } else if (val instanceof Iterable) {
      writeArray(name,((Iterable)val).iterator());
    } else if (val instanceof Object[]) {
      writeArray(name,(Object[])val);
    } else if (val instanceof Iterator) {
      writeArray(name, (Iterator) val);
    } else if (val instanceof byte[]) {
      byte[] arr = (byte[])val;
      writeByteArr(name, arr, 0, arr.length);
    } else if (val instanceof BytesRef) {
      BytesRef arr = (BytesRef)val;
      writeByteArr(name, arr.bytes, arr.offset, arr.length);
    } else if (val instanceof EnumFieldValue) {
      writeStr(name, val.toString(), true);
    } else if (val instanceof WriteableValue) {
      ((WriteableValue)val).write(name, this);
    } else if (val instanceof MapSerializable) {
      //todo find a better way to reuse the map more efficiently
      writeMap(name, ((MapSerializable) val).toMap(new NamedList().asShallowMap()), false, true);
    } else {
      // default... for debugging only
      writeStr(name, val.getClass().getName() + ':' + val.toString(), true);
    }
  }

