  public static List<Api> getApis(Class<? extends Object> klas , Object obj) {
    if (!Modifier.isPublic(klas.getModifiers())) {
      throw new RuntimeException(klas.getName() + " is not public");
    }

    if (klas.getAnnotation(EndPoint.class) != null) {
      EndPoint endPoint = klas.getAnnotation(EndPoint.class);
      List<Method> methods = new ArrayList<>();
      Map<String, Cmd> commands = new HashMap<>();
      for (Method m : klas.getDeclaredMethods()) {
        Command command = m.getAnnotation(Command.class);
        if (command != null) {
          methods.add(m);
          if (commands.containsKey(command.name())) {
            throw new RuntimeException("Duplicate commands " + command.name());
          }
          commands.put(command.name(), new Cmd(command.name(), obj, m));
        }
      }
      if (commands.isEmpty()) {
        throw new RuntimeException("No method with @Command in class: " + klas.getName());
      }
      SpecProvider specProvider = readSpec(endPoint, methods);
      return Collections.singletonList(new AnnotatedApi(specProvider, endPoint, commands, null));
    } else {
      List<Api> apis = new ArrayList<>();
      for (Method m : klas.getDeclaredMethods()) {
        EndPoint endPoint = m.getAnnotation(EndPoint.class);
        if (endPoint == null) continue;
        if (!Modifier.isPublic(m.getModifiers())) {
          throw new RuntimeException("Non public method " + m.toGenericString());
        }
        Cmd cmd = new Cmd("", obj, m);
        SpecProvider specProvider = readSpec(endPoint, Collections.singletonList(m));
        apis.add(new AnnotatedApi(specProvider, endPoint, Collections.singletonMap("", cmd), null));
      }
      if (apis.isEmpty()) {
        throw new RuntimeException("Invalid Class : " + klas.getName() + " No @EndPoints");
      }

      return apis;
    }
  }

