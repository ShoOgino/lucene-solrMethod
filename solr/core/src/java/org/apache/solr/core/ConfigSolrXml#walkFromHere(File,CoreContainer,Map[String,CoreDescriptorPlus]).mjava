  // Basic recursive tree walking, looking for "core.properties" files. Once one is found, we'll stop going any
  // deeper in the tree.
  //
  // @param file - the directory we're to either read the properties file from or recurse into.
  private void walkFromHere(File file, CoreContainer container, Map<String, CoreDescriptorPlus> checkMap) throws IOException {
    log.info("Looking for cores in " + file.getAbsolutePath());
    for (File childFile : file.listFiles()) {
      // This is a little tricky, we are asking if core.properties exists in a child directory of the directory passed
      // in. In other words we're looking for core.properties in the grandchild directories of the parameter passed
      // in. That allows us to gracefully top recursing deep but continue looking wide.
      File propFile = new File(childFile, CORE_PROP_FILE);
      if (propFile.exists()) { // Stop looking after processing this file!
        log.info("Discovered properties file {}, adding to cores", propFile.getAbsolutePath());
        Properties propsOrig = new Properties();
        InputStream is = new FileInputStream(propFile);
        try {
          propsOrig.load(is);
        } finally {
          IOUtils.closeQuietly(is);
        }

        Properties props = new Properties();
        for (String prop : propsOrig.stringPropertyNames()) {
          props.put(prop, PropertiesUtil.substituteProperty(propsOrig.getProperty(prop), null));
        }

        if (props.getProperty(CoreDescriptor.CORE_INSTDIR) == null) {
          props.setProperty(CoreDescriptor.CORE_INSTDIR, childFile.getPath());
        }

        if (props.getProperty(CoreDescriptor.CORE_NAME) == null) {
          // Should default to this directory
          props.setProperty(CoreDescriptor.CORE_NAME, childFile.getName());
        }
        CoreDescriptor desc = new CoreDescriptor(container, props);
        CoreDescriptorPlus plus = new CoreDescriptorPlus(propFile.getAbsolutePath(), desc, propsOrig);
        CoreDescriptorPlus check = coreDescriptorPlusMap.get(desc.getName());
        if (check == null) { // It's bad to have two cores with the same name
          coreDescriptorPlusMap.put(desc.getName(), plus);
        } else {
          String msg = String.format(Locale.ROOT, "More than one core defined for core named %s, paths are '%s' and '%s' ",
              desc.getName(), check.getFilePath(), plus.getFilePath());
          log.error(msg);
          badCores.put(desc.getName(), msg);
        }
        check = coreDescriptorPlusMap.get(plus.getCoreDescriptor().getDataDir());
        if (check == null) {
          coreDescriptorPlusMap.put(desc.getName(), plus);
        } else {
          String msg = String.format(Locale.ROOT, "More than one core points to data dir %s. They are in %s and %s",
              plus.getCoreDescriptor().getDataDir(), plus.getFilePath(), check.getFilePath());
          log.error(msg);
          badCores.put(plus.getCoreDescriptor().getName(), msg);
        }

        continue; // Go on to the sibling directory
      }
      if (childFile.isDirectory()) {
        walkFromHere(childFile, container, checkMap);
      }
    }
  }

