  /**
   * Set the duration for which commit point is to be reserved by the deletion policy.
   *
   * @param indexGen gen of the commit point to be reserved
   * @param reserveTime  time in milliseconds for which the commit point is to be reserved
   */
  public void setReserveDuration(Long indexGen, long reserveTime) {
    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);
    for(;;) {
      Long previousTime = reserves.put(indexGen, timeToSet);

      // this is the common success case: the older time didn't exist, or
      // came before the new time.
      if (previousTime == null || previousTime <= timeToSet) {
        LOG.debug("Commit point reservation for generation {} set to {} (requested reserve time of {})",
            indexGen, timeToSet, reserveTime);
        break;
      }

      // At this point, we overwrote a longer reservation, so we want to restore the older one.
      // the problem is that an even longer reservation may come in concurrently
      // and we don't want to overwrite that one too.  We simply keep retrying in a loop
      // with the maximum time value we have seen.
      timeToSet = previousTime;      
    }
  }

