  // It's important that this be the _only_ thread removing things from pendingDynamicCloses!
  // This is single-threaded, but I tried a multi-threaded approach and didn't see any performance gains, so
  // there's no good justification for the complexity. I suspect that the locking on things like DefaultSolrCoreState
  // essentially create a single-threaded process anyway.
  @Override
  public void run() {
    while (! container.isShutDown()) {
      synchronized (coreMaps.getLocker()) { // need this so we can wait and be awoken.
        try {
          coreMaps.getLocker().wait();
        } catch (InterruptedException e) {
          // Well, if we've been told to stop, we will. Otherwise, continue on and check to see if there are
          // any cores to close.
        }
      }
      for (SolrCore removeMe = coreMaps.getCoreToClose();
           removeMe != null && !container.isShutDown();
           removeMe = coreMaps.getCoreToClose()) {
        try {
          coreMaps.addPersistOneCore(cfg, container.loader, removeMe.getCoreDescriptor(),
              container.getCoreToOrigName(removeMe));
          removeMe.close();
        } finally {
          coreMaps.removeFromPendingOps(removeMe.getName());
        }
      }
    }
  }

