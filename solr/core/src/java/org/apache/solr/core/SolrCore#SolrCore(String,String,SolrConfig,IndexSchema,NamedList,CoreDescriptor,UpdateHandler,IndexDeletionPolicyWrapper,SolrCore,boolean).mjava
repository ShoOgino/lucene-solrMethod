  /**
   * Creates a new core and register it in the list of cores. If a core with the
   * same name already exists, it will be stopped and replaced by this one.
   *
   * @param dataDir
   *          the index directory
   * @param config
   *          a solr config instance
   * @param schema
   *          a solr schema instance
   *
   * @since solr 1.3
   */
  public SolrCore(String name, String dataDir, SolrConfig config,
      IndexSchema schema, NamedList configSetProperties,
      CoreDescriptor coreDescriptor, UpdateHandler updateHandler,
      IndexDeletionPolicyWrapper delPolicy, SolrCore prev, boolean reload) {
    
    assert ObjectReleaseTracker.track(searcherExecutor); // ensure that in unclean shutdown tests we still close this
    
    this.coreDescriptor = Objects.requireNonNull(coreDescriptor, "coreDescriptor cannot be null");
    setName(name);
    MDCLoggingContext.setCore(this);
    
    resourceLoader = config.getResourceLoader();
    this.solrConfig = config;
    this.configSetProperties = configSetProperties;
    // Initialize the metrics manager
    this.coreMetricManager = initCoreMetricManager(config);
    this.coreMetricManager.loadReporters();

    if (updateHandler == null) {
      directoryFactory = initDirectoryFactory();
      recoveryStrategyBuilder = initRecoveryStrategyBuilder();
      solrCoreState = new DefaultSolrCoreState(directoryFactory, recoveryStrategyBuilder);
    } else {
      solrCoreState = updateHandler.getSolrCoreState();
      directoryFactory = solrCoreState.getDirectoryFactory();
      recoveryStrategyBuilder = solrCoreState.getRecoveryStrategyBuilder();
      isReloaded = true;
    }

    this.dataDir = initDataDir(dataDir, config, coreDescriptor);
    this.ulogDir = initUpdateLogDir(coreDescriptor);

    log.info("[{}] Opening new SolrCore at [{}], dataDir=[{}]", logid, resourceLoader.getInstancePath(), this.dataDir);

    checkVersionFieldExistsInSchema(schema, coreDescriptor);

    SolrMetricManager metricManager = this.coreDescriptor.getCoreContainer().getMetricManager();

    // initialize searcher-related metrics
    newSearcherCounter = metricManager.counter(coreMetricManager.getRegistryName(), "new", Category.SEARCHER.toString());
    newSearcherTimer = metricManager.timer(coreMetricManager.getRegistryName(), "time", Category.SEARCHER.toString(), "new");
    newSearcherWarmupTimer = metricManager.timer(coreMetricManager.getRegistryName(), "warmup", Category.SEARCHER.toString(), "new");
    newSearcherMaxReachedCounter = metricManager.counter(coreMetricManager.getRegistryName(), "maxReached", Category.SEARCHER.toString(), "new");
    newSearcherOtherErrorsCounter = metricManager.counter(coreMetricManager.getRegistryName(), "errors", Category.SEARCHER.toString(), "new");

    // Initialize JMX
    this.infoRegistry = initInfoRegistry(name, config);
    infoRegistry.put("fieldCache", new SolrFieldCacheMBean());

    initSchema(config, schema);

    this.maxWarmingSearchers = config.maxWarmingSearchers;
    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;

    booleanQueryMaxClauseCount();

    final CountDownLatch latch = new CountDownLatch(1);

    try {

      initListeners();

      this.snapshotMgr = initSnapshotMetaDataManager();
      this.solrDelPolicy = initDeletionPolicy(delPolicy);

      this.codec = initCodec(solrConfig, this.schema);

      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());
      initIndex(prev != null, reload);

      initWriters();
      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);
      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);
      transformerFactories.init(TransformerFactory.defaultFactories, this);
      loadSearchComponents();
      updateProcessors.init(Collections.emptyMap(), this);

      // Processors initialized before the handlers
      updateProcessorChains = loadUpdateProcessorChains();
      reqHandlers = new RequestHandlers(this);
      reqHandlers.initHandlersFromConfig(solrConfig);

      statsCache = initStatsCache();

      // cause the executor to stall so firstSearcher events won't fire
      // until after inform() has been called for all components.
      // searchExecutor must be single-threaded for this to work
      searcherExecutor.submit(() -> {
        latch.await();
        return null;
      });

      this.updateHandler = initUpdateHandler(updateHandler);
      
      initSearcher(prev);

      // Initialize the RestManager
      restManager = initRestManager();

      // Finally tell anyone who wants to know
      resourceLoader.inform(resourceLoader);
      resourceLoader.inform(this); // last call before the latch is released.
    } catch (Throwable e) {
      // release the latch, otherwise we block trying to do the close. This
      // should be fine, since counting down on a latch of 0 is still fine
      latch.countDown();
      if (e instanceof OutOfMemoryError) {
        throw (OutOfMemoryError)e;
      }

      try {
        // close down the searcher and any other resources, if it exists, as this
        // is not recoverable
       close();
      } catch (Throwable t) {
        if (t instanceof OutOfMemoryError) {
          throw (OutOfMemoryError) t;
        }
        log.error("Error while closing", t);
      }

      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);
    } finally {
      // allow firstSearcher events to fire and make sure it is released
      latch.countDown();
    }

    infoRegistry.put("core", this);

    // register any SolrInfoMBeans SolrResourceLoader initialized
    //
    // this must happen after the latch is released, because a JMX server impl may
    // choose to block on registering until properties can be fetched from an MBean,
    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher
    // from the core.
    resourceLoader.inform(infoRegistry);

    // Allow the directory factory to register MBeans as well
    for (SolrInfoMBean bean : directoryFactory.offerMBeans()) {
      log.debug("Registering JMX bean [{}] from directory factory.", bean.getName());
      // Not worried about concurrency, so no reason to use putIfAbsent
      if (infoRegistry.containsKey(bean.getName())){
        log.debug("Ignoring JMX bean [{}] due to name conflict.", bean.getName());
      } else {
        infoRegistry.put(bean.getName(), bean);
      }
    }

    // seed version buckets with max from index during core initialization ... requires a searcher!
    seedVersionBuckets();

    bufferUpdatesIfConstructing(coreDescriptor);

    this.ruleExpiryLock = new ReentrantLock();
    this.snapshotDelLock = new ReentrantLock();

    registerConfListener();
    
    assert ObjectReleaseTracker.track(this);
  }

