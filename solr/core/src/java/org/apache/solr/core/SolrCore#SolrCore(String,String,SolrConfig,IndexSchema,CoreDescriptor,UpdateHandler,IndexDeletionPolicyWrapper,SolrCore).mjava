  /**
   * Creates a new core and register it in the list of cores. If a core with the
   * same name already exists, it will be stopped and replaced by this one.
   *
   * @param dataDir
   *          the index directory
   * @param config
   *          a solr config instance
   * @param schema
   *          a solr schema instance
   *
   * @since solr 1.3
   */
  public SolrCore(String name, String dataDir, SolrConfig config,
      IndexSchema schema, CoreDescriptor coreDescriptor, UpdateHandler updateHandler,
      IndexDeletionPolicyWrapper delPolicy, SolrCore prev) {
    checkNotNull(coreDescriptor, "coreDescriptor cannot be null");
    
    this.coreDescriptor = coreDescriptor;
    setName(name);
    MDCUtils.setCore(name); // show the core name in the error logs
    
    resourceLoader = config.getResourceLoader();
    this.solrConfig = config;

    if (updateHandler == null) {
      directoryFactory = initDirectoryFactory();
      solrCoreState = new DefaultSolrCoreState(directoryFactory);
    } else {
      solrCoreState = updateHandler.getSolrCoreState();
      directoryFactory = solrCoreState.getDirectoryFactory();
      isReloaded = true;
    }

    this.dataDir = initDataDir(dataDir, config, coreDescriptor);
    this.ulogDir = initUpdateLogDir(coreDescriptor);

    log.info("[{}] Opening new SolrCore at [{}], dataDir=[{}]", logid, resourceLoader.getInstanceDir(), dataDir);

    checkVersionFieldExistsInSchema(schema, coreDescriptor);

    // Initialize JMX
    this.infoRegistry = initInfoRegistry(name, config);
    infoRegistry.put("fieldCache", new SolrFieldCacheMBean());

    this.schema = initSchema(config, schema);

    this.startTime = System.currentTimeMillis();
    this.maxWarmingSearchers = config.maxWarmingSearchers;
    this.slowQueryThresholdMillis = config.slowQueryThresholdMillis;

    booleanQueryMaxClauseCount();

    final CountDownLatch latch = new CountDownLatch(1);

    try {

      initListeners();

      this.solrDelPolicy = initDeletionPolicy(delPolicy);

      this.codec = initCodec(solrConfig, this.schema);

      memClassLoader = new MemClassLoader(PluginBag.RuntimeLib.getLibObjects(this, solrConfig.getPluginInfos(PluginBag.RuntimeLib.class.getName())), getResourceLoader());
      initIndex(prev != null);

      initWriters();
      qParserPlugins.init(createInstances(QParserPlugin.standardPlugins), this);
      valueSourceParsers.init(ValueSourceParser.standardValueSourceParsers, this);
      transformerFactories.init(TransformerFactory.defaultFactories, this);
      loadSearchComponents();
      updateProcessors.init(Collections.emptyMap(), this);

      // Processors initialized before the handlers
      updateProcessorChains = loadUpdateProcessorChains();
      reqHandlers = new RequestHandlers(this);
      reqHandlers.initHandlersFromConfig(solrConfig);

      // Handle things that should eventually go away
      initDeprecatedSupport();

      statsCache = initStatsCache();

      // cause the executor to stall so firstSearcher events won't fire
      // until after inform() has been called for all components.
      // searchExecutor must be single-threaded for this to work
      searcherExecutor.submit(new Callable<Void>() {
        @Override
        public Void call() throws Exception {
          latch.await();
          return null;
        }
      });

      this.updateHandler = initUpdateHandler(updateHandler);
      
      initSearcher(prev);

      // Initialize the RestManager
      restManager = initRestManager();

      // Finally tell anyone who wants to know
      resourceLoader.inform(resourceLoader);
      resourceLoader.inform(this); // last call before the latch is released.
    } catch (Throwable e) {
      // release the latch, otherwise we block trying to do the close. This
      // should be fine, since counting down on a latch of 0 is still fine
      latch.countDown();
      if (e instanceof OutOfMemoryError) {
        throw (OutOfMemoryError)e;
      }

      try {
        // close down the searcher and any other resources, if it exists, as this
        // is not recoverable
       close();
      } catch (Throwable t) {
        if (t instanceof OutOfMemoryError) {
          throw (OutOfMemoryError) t;
        }
        log.error("Error while closing", t);
      }

      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, e.getMessage(), e);
    } finally {
      // allow firstSearcher events to fire and make sure it is released
      latch.countDown();
    }

    infoRegistry.put("core", this);

    // register any SolrInfoMBeans SolrResourceLoader initialized
    //
    // this must happen after the latch is released, because a JMX server impl may
    // choose to block on registering until properties can be fetched from an MBean,
    // and a SolrCoreAware MBean may have properties that depend on getting a Searcher
    // from the core.
    resourceLoader.inform(infoRegistry);

    bufferUpdatesIfConstructing(coreDescriptor);
    
    // For debugging   
//    numOpens.incrementAndGet();
//    openHandles.put(this, new RuntimeException("unclosed core - name:" + getName() + " refs: " + refCount.get()));

    this.ruleExpiryLock = new ReentrantLock();
    registerConfListener();
  }

