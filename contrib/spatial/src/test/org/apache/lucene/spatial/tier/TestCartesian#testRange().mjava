  public void testRange() throws IOException, InvalidGeoException {
    searcher = new IndexSearcher(directory);

    final double[] milesToTest = new double[] {6.0, 0.5, 0.001, 0.0};
    final int[] expected = new int[] {7, 1, 0, 0};

    for(int x=0;x<expected.length;x++) {
    
      final double miles = milesToTest[x];
    
      // create a distance query
      final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
                                                               latField, lngField, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true);
     
      System.out.println(dq);
      //create a term query to search against all documents
      Query tq = new TermQuery(new Term("metafile", "doc"));
    
      FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
    
      CustomScoreQuery customScore = new CustomScoreQuery(dq.getQuery(tq),fsQuery){
      
          @Override
            public float customScore(int doc, float subQueryScore, float valSrcScore){
            //System.out.println(doc);
            if (dq.distanceFilter.getDistance(doc) == null)
              return 0;
        
            double distance = dq.distanceFilter.getDistance(doc);
            // boost score shouldn't exceed 1
            if (distance < 1.0d)
              distance = 1.0d;
            //boost by distance is invertly proportional to
            // to distance from center point to location
            float score = (float) ( (miles - distance) / miles );
            return score * subQueryScore;
          }
        };
      // Create a distance sort
      // As the radius filter has performed the distance calculations
      // already, pass in the filter to reuse the results.
      // 
      DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
      Sort sort = new Sort(new SortField("foo", dsort,false));
    
      // Perform the search, using the term query, the serial chain filter, and the
      // distance sort
      Hits hits = searcher.search(customScore,null,sort);

      int results = hits.length();
    
      // Get a list of distances 
      Map<Integer,Double> distances = dq.distanceFilter.getDistances();
    
      // distances calculated from filter first pass must be less than total
      // docs, from the above test of 20 items, 12 will come from the boundary box
      // filter, but only 5 are actually in the radius of the results.
    
      // Note Boundary Box filtering, is not accurate enough for most systems.
    
    
      System.out.println("Distance Filter filtered: " + distances.size());
      System.out.println("Results: " + results);
      System.out.println("=============================");
      System.out.println("Distances should be 7 "+ expected[x] + ":" + distances.size());
      System.out.println("Results should be 7 "+ expected[x] + ":" + results);

      assertEquals(expected[x], distances.size()); // fixed a store of only needed distances
      assertEquals(expected[x], results);
      double lastDistance = 0;
      for(int i =0 ; i < results; i++){
        Document d = hits.doc(i);
      
        String name = d.get("name");
        double rsLat = NumericUtils.prefixCodedToDouble(d.get(latField));
        double rsLng = NumericUtils.prefixCodedToDouble(d.get(lngField)); 
        Double geo_distance = distances.get(hits.id(i));
      
        double distance = DistanceUtils.getInstance().getDistanceMi(lat, lng, rsLat, rsLng);
        double llm = DistanceUtils.getInstance().getLLMDistance(lat, lng, rsLat, rsLng);
        System.out.println("Name: "+ name +", Distance "+ distance); //(res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ hits.score(i));
        assertTrue(Math.abs((distance - llm)) < 1);
        assertTrue((distance < miles ));
        assertTrue(geo_distance > lastDistance);
        lastDistance = geo_distance;
      }
    }
  }

