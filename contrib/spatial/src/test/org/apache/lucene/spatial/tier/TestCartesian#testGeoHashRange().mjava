  public void testGeoHashRange() throws IOException, InvalidGeoException {
    searcher = new IndexSearcher(directory, true);
	    
    final double[] milesToTest = new double[] {6.0, 0.5, 0.001, 0.0};
    final int[] expected = new int[] {7, 1, 0, 0};

    for(int x=0;x<expected.length;x++) {
      final double miles = milesToTest[x];
	    
      // create a distance query
      final DistanceQueryBuilder dq = new DistanceQueryBuilder(lat, lng, miles, 
                                                               geoHashPrefix, CartesianTierPlotter.DEFALT_FIELD_PREFIX, true);
	     
      if (VERBOSE) System.out.println(dq);
      //create a term query to search against all documents
      Query tq = new TermQuery(new Term("metafile", "doc"));
	    
      FieldScoreQuery fsQuery = new FieldScoreQuery("geo_distance", Type.FLOAT);
      CustomScoreQuery customScore = new CustomScoreQuery(tq,fsQuery){
        @Override
        protected CustomScoreProvider getCustomScoreProvider(IndexReader reader) {
          return new CustomScoreProvider(reader) {
              @Override // TODO: broken, as reader is not used!
              public float customScore(int doc, float subQueryScore, float valSrcScore){
              if (VERBOSE) System.out.println(doc);
              if (dq.distanceFilter.getDistance(doc) == null)
                return 0;
            
              double distance = dq.distanceFilter.getDistance(doc);
              // boost score shouldn't exceed 1
              if (distance < 1.0d)
                distance = 1.0d;
              //boost by distance is invertly proportional to
              // to distance from center point to location
              float score = (float) ( (miles - distance) / miles );
              return score * subQueryScore;
            }
          };
        }
      };
      // Create a distance sort
      // As the radius filter has performed the distance calculations
      // already, pass in the filter to reuse the results.
      // 
      //DistanceFieldComparatorSource dsort = new DistanceFieldComparatorSource(dq.distanceFilter);
      //Sort sort = new Sort(new SortField("foo", dsort));
	    
      // Perform the search, using the term query, the serial chain filter, and the
      // distance sort
      TopDocs hits = searcher.search(customScore.createWeight(searcher),dq.getFilter(), 1000); //,sort);
      int results = hits.totalHits;
      ScoreDoc[] scoreDocs = hits.scoreDocs; 
	    
      // Get a list of distances 
      Map<Integer,Double> distances = dq.distanceFilter.getDistances();
	    
      // distances calculated from filter first pass must be less than total
      // docs, from the above test of 20 items, 12 will come from the boundary box
      // filter, but only 5 are actually in the radius of the results.
	    
      // Note Boundary Box filtering, is not accurate enough for most systems.
	    
	    if (VERBOSE) {
        System.out.println("Distance Filter filtered: " + distances.size());
        System.out.println("Results: " + results);
        System.out.println("=============================");
        System.out.println("Distances should be 14 "+ expected[x] + ":" + distances.size());
        System.out.println("Results should be 7 "+ expected[x] + ":" + results);
      }

      assertEquals(expected[x], distances.size());
      assertEquals(expected[x], results);
	    
      for(int i =0 ; i < results; i++){
        Document d = searcher.doc(scoreDocs[i].doc);
	      
        String name = d.get("name");
        double rsLat = NumericUtils.prefixCodedToDouble(d.get(latField));
        double rsLng = NumericUtils.prefixCodedToDouble(d.get(lngField)); 
        Double geo_distance = distances.get(scoreDocs[i].doc);
	      
        double distance = DistanceUtils.getInstance().getDistanceMi(lat, lng, rsLat, rsLng);
        double llm = DistanceUtils.getInstance().getLLMDistance(lat, lng, rsLat, rsLng);
        if (VERBOSE) System.out.println("Name: "+ name +", Distance (res, ortho, harvesine):"+ distance +" |"+ geo_distance +"|"+ llm +" | score "+ scoreDocs[i].score);
        assertTrue(Math.abs((distance - llm)) < 1);
        assertTrue((distance < miles ));
	      
      }
    }
  }

