  public void testSplitIntRange() throws Exception {
    // a hard-coded "standard" range
    assertIntRangeSplit(-5000, 9500, 4, true, Arrays.asList(new Integer[]{
      new Integer(0x7fffec78),new Integer(0x7fffec7f),
      new Integer(0x80002510),new Integer(0x8000251c),
      new Integer(0x7fffec8), new Integer(0x7fffecf),
      new Integer(0x8000250), new Integer(0x8000250),
      new Integer(0x7fffed),  new Integer(0x7fffef),
      new Integer(0x800020),  new Integer(0x800024),
      new Integer(0x7ffff),   new Integer(0x80001)
    }).iterator());
    
    // the same with no range splitting
    assertIntRangeSplit(-5000, 9500, 32, true, Arrays.asList(new Integer[]{
      new Integer(0x7fffec78),new Integer(0x8000251c)
    }).iterator());
    
    // this tests optimized range splitting, if one of the inner bounds
    // is also the bound of the next lower precision, it should be used completely
    assertIntRangeSplit(0, 1024+63, 4, true, Arrays.asList(new Integer[]{
      new Integer(0x8000040), new Integer(0x8000043),
      new Integer(0x800000),  new Integer(0x800003)
    }).iterator());
    
    // the full int range should only consist of a lowest precision range; no bitset testing here, as too much memory needed :-)
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 8, false, Arrays.asList(new Integer[]{
      new Integer(0x00),new Integer(0xff)
    }).iterator());

    // the same with precisionStep=4
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 4, false, Arrays.asList(new Integer[]{
      new Integer(0x0),new Integer(0xf)
    }).iterator());

    // the same with precisionStep=2
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 2, false, Arrays.asList(new Integer[]{
      new Integer(0x0),new Integer(0x3)
    }).iterator());

    // the same with precisionStep=1
    assertIntRangeSplit(Integer.MIN_VALUE, Integer.MAX_VALUE, 1, false, Arrays.asList(new Integer[]{
      new Integer(0x0),new Integer(0x1)
    }).iterator());
  }

