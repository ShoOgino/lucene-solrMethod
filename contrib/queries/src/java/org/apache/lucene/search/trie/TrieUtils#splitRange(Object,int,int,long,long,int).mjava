  /** This helper does the splitting for both 32 and 64 bit. */
  private static void splitRange(
    final Object builder, final int valSize,
    final int precisionStep, final long minBound, final long maxBound,
    final int shift
  ) {
    // calculate new bounds for inner precision
    final long diff = 1L << (shift+precisionStep),
      mask = ((1L<<precisionStep) - 1L) << shift;
    final boolean
      hasLower = (minBound & mask) != 0L,
      hasUpper = (maxBound & mask) != mask;
    final long
      nextMinBound = (hasLower ? (minBound + diff) : minBound) & ~mask,
      nextMaxBound = (hasUpper ? (maxBound - diff) : maxBound) & ~mask;

    if (shift+precisionStep>=valSize || nextMinBound>nextMaxBound) {
      // We are in the lowest precision or the next precision is not available.
      addRange(builder, valSize, precisionStep, minBound, maxBound, shift);
    } else {
      if (hasLower)
        addRange(builder, valSize, precisionStep, minBound, minBound | mask, shift);
      if (hasUpper)
        addRange(builder, valSize, precisionStep, maxBound & ~mask, maxBound, shift);
      // recurse down to next precision
      splitRange(
        builder, valSize, precisionStep,
        nextMinBound, nextMaxBound,
        shift+precisionStep
      );
    }
  }

