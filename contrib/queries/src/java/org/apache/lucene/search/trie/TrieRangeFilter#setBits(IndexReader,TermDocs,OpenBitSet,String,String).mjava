	/** Marks documents in a specific range. Code borrowed from original RangeFilter and simplified (and returns number of terms) */
	private int setBits(final IndexReader reader, final TermDocs termDocs, final OpenBitSet bits, String lowerTerm, String upperTerm) throws IOException {
		//System.out.println(stringToHexDigits(lowerTerm)+" TO "+stringToHexDigits(upperTerm));
		int count=0,len=lowerTerm.length();
		final String field;
		if (len<trieVariant.TRIE_CODED_LENGTH) {
			// lower precision value is in helper field
			field=(this.field + trieVariant.LOWER_PRECISION_FIELD_NAME_SUFFIX).intern();
			// add padding before lower precision values to group them
			lowerTerm=new StringBuffer(len+1).append((char)(trieVariant.TRIE_CODED_PADDING_START+len)).append(lowerTerm).toString();
			upperTerm=new StringBuffer(len+1).append((char)(trieVariant.TRIE_CODED_PADDING_START+len)).append(upperTerm).toString();
			// length is longer by 1 char because of padding
			len++;
		} else {
			// full precision value is in original field
			field=this.field;
		}
		final TermEnum enumerator = reader.terms(new Term(field, lowerTerm));
		try {
			do {
				final Term term = enumerator.term();
				if (term!=null && term.field()==field) {
					// break out when upperTerm reached or length of term is different
					final String t=term.text();
					if (len!=t.length() || t.compareTo(upperTerm)>0) break;
					// we have a good term, find the docs
					count++;
					termDocs.seek(enumerator);
					while (termDocs.next()) bits.set(termDocs.doc());
				} else break;
			} while (enumerator.next());
		} finally {
			enumerator.close();
		}
		return count;
	}

