  /**
   * Extracts a matrix from a token stream.
   * @throws IOException
   */
  public void testTokenStream() throws IOException {

    ShingleMatrixFilter.defaultSettingsCodec = null;//new ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec();

    TokenStream ts;
    TokenListStream tls;
    LinkedList tokens;

    // test a plain old token stream with synonyms tranlated to rows.

    tokens = new LinkedList();
    tokens.add(tokenFactory("hello", 1, 0, 4));
    tokens.add(tokenFactory("greetings", 0, 0, 4));
    tokens.add(tokenFactory("world", 1, 5, 10));
    tokens.add(tokenFactory("earth", 0, 5, 10));
    tokens.add(tokenFactory("tellus", 0, 5, 10));

    tls = new TokenListStream(tokens);

    // bi-grams

    ts = new ShingleMatrixFilter(tls, 2, 2, new Character('_'), false, new ShingleMatrixFilter.TwoDimensionalNonWeightedSynonymTokenSettingsCodec());

    final Token reusableToken = new Token();
    assertNext(ts, reusableToken, "hello_world");
    assertNext(ts, reusableToken, "greetings_world");
    assertNext(ts, reusableToken, "hello_earth");
    assertNext(ts, reusableToken, "greetings_earth");
    assertNext(ts, reusableToken, "hello_tellus");
    assertNext(ts, reusableToken, "greetings_tellus");
    assertNull(ts.next(reusableToken));

    // bi-grams with no spacer character, start offset, end offset

    tls.reset();
    ts = new ShingleMatrixFilter(tls, 2, 2, null, false, new ShingleMatrixFilter.TwoDimensionalNonWeightedSynonymTokenSettingsCodec());
    assertNext(ts, reusableToken, "helloworld", 0, 10);
    assertNext(ts, reusableToken, "greetingsworld", 0, 10);
    assertNext(ts, reusableToken, "helloearth", 0, 10);
    assertNext(ts, reusableToken, "greetingsearth", 0, 10);
    assertNext(ts, reusableToken, "hellotellus", 0, 10);
    assertNext(ts, reusableToken, "greetingstellus", 0, 10);
    assertNull(ts.next(reusableToken));


    // add ^_prefix_and_suffix_$
    //
    // using 3d codec as it supports weights

    ShingleMatrixFilter.defaultSettingsCodec = new ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec();

    tokens = new LinkedList();
    tokens.add(tokenFactory("hello", 1, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.newColumn));
    tokens.add(tokenFactory("greetings", 0, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.newRow));
    tokens.add(tokenFactory("world", 1, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newColumn));
    tokens.add(tokenFactory("earth", 0, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newRow));
    tokens.add(tokenFactory("tellus", 0, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newRow));

    tls = new TokenListStream(tokens);

    ts = new PrefixAndSuffixAwareTokenFilter(new SingleTokenTokenStream(tokenFactory("^", 1, 100f, 0, 0)), tls, new SingleTokenTokenStream(tokenFactory("$", 1, 50f, 0, 0)));
    tls = new TokenListStream(ts);

    // bi-grams, position incrememnt, weight, start offset, end offset

    ts = new ShingleMatrixFilter(tls, 2, 2, new Character('_'), false);
//
//    for (Token token = ts.next(new Token()); token != null; token = ts.next(token)) {
//      System.out.println("assertNext(ts, \"" + token.term() + "\", " + token.getPositionIncrement() + ", " + (token.getPayload() == null ? "1.0" : PayloadHelper.decodeFloat(token.getPayload().getData())) + "f, " + token.startOffset() + ", " + token.endOffset() + ");");
//      token.clear();
//    }

    assertNext(ts, reusableToken, "^_hello", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "^_greetings", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "hello_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "world_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "earth_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "tellus_$", 1, 7.1414285f, 5, 10);
    assertNull(ts.next(reusableToken));

    // test unlimited size and allow single boundary token as shingle
    tls.reset();
    ts = new ShingleMatrixFilter(tls, 1, Integer.MAX_VALUE, new Character('_'), false);

//
//  for (Token token = ts.next(new Token()); token != null; token = ts.next(token)) {
//      System.out.println("assertNext(ts, \"" + token.term() + "\", " + token.getPositionIncrement() + ", " + (token.getPayload() == null ? "1.0" : PayloadHelper.decodeFloat(token.getPayload().getData())) + "f, " + token.startOffset() + ", " + token.endOffset() + ");");
//      token.clear();
//    }

    assertNext(ts, reusableToken, "^", 1, 10.0f, 0, 0);
    assertNext(ts, reusableToken, "^_hello", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "^_hello_world", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_world_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello", 1, 1.0f, 0, 4);
    assertNext(ts, reusableToken, "hello_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_world_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "world", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "world_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "$", 1, 7.071068f, 10, 10);
    assertNext(ts, reusableToken, "^_greetings", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "^_greetings_world", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_world_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings", 1, 1.0f, 0, 4);
    assertNext(ts, reusableToken, "greetings_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_world_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_earth", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_earth_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "earth", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "earth_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "^_greetings_earth", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_earth_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_earth_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_tellus", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_tellus_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "tellus", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "tellus_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "^_greetings_tellus", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_tellus_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_tellus_$", 1, 7.2111025f, 0, 10);

    assertNull(ts.next(reusableToken));

    // test unlimited size but don't allow single boundary token as shingle

    tls.reset();
    ts = new ShingleMatrixFilter(tls, 1, Integer.MAX_VALUE, new Character('_'), true);
//  for (Token token = ts.next(new Token()); token != null; token = ts.next(token)) {
//      System.out.println("assertNext(ts, \"" + token.term() + "\", " + token.getPositionIncrement() + ", " + (token.getPayload() == null ? "1.0" : PayloadHelper.decodeFloat(token.getPayload().getData())) + "f, " + token.startOffset() + ", " + token.endOffset() + ");");
//      token.clear();
//    }

    assertNext(ts, reusableToken, "^_hello", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "^_hello_world", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_world_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello", 1, 1.0f, 0, 4);
    assertNext(ts, reusableToken, "hello_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_world_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "world", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "world_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "^_greetings", 1, 10.049875f, 0, 4);
    assertNext(ts, reusableToken, "^_greetings_world", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_world_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings", 1, 1.0f, 0, 4);
    assertNext(ts, reusableToken, "greetings_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_world_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_earth", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_earth_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "earth", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "earth_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "^_greetings_earth", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_earth_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_earth_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_tellus", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_hello_tellus_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus_$", 1, 7.2111025f, 0, 10);
    assertNext(ts, reusableToken, "tellus", 1, 1.0f, 5, 10);
    assertNext(ts, reusableToken, "tellus_$", 1, 7.1414285f, 5, 10);
    assertNext(ts, reusableToken, "^_greetings_tellus", 1, 10.099504f, 0, 10);
    assertNext(ts, reusableToken, "^_greetings_tellus_$", 1, 12.328828f, 0, 10);
    assertNext(ts, reusableToken, "greetings_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_tellus_$", 1, 7.2111025f, 0, 10);


    assertNull(ts.next(reusableToken));

    System.currentTimeMillis();

    // multi-token synonyms
    //
    // Token[][][] {
    //    {{hello}, {greetings, and, salutations},
    //    {{world}, {earth}, {tellus}}
    // }
    //


    tokens = new LinkedList();
    tokens.add(tokenFactory("hello", 1, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.newColumn));
    tokens.add(tokenFactory("greetings", 1, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.newRow));
    tokens.add(tokenFactory("and", 1, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.sameRow));
    tokens.add(tokenFactory("salutations", 1, 1f, 0, 4, ShingleMatrixFilter.TokenPositioner.sameRow));
    tokens.add(tokenFactory("world", 1, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newColumn));
    tokens.add(tokenFactory("earth", 1, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newRow));
    tokens.add(tokenFactory("tellus", 1, 1f, 5, 10, ShingleMatrixFilter.TokenPositioner.newRow));

    tls = new TokenListStream(tokens);

    // 2-3 grams

    ts = new ShingleMatrixFilter(tls, 2, 3, new Character('_'), false);

//  for (Token token = ts.next(new Token()); token != null; token = ts.next(token)) {
//      System.out.println("assertNext(ts, \"" + token.term() + "\", " + token.getPositionIncrement() + ", " + (token.getPayload() == null ? "1.0" : PayloadHelper.decodeFloat(token.getPayload().getData())) + "f, " + token.startOffset() + ", " + token.endOffset() + ");");
//      token.clear();
//    }

    // shingle, position increment, weight, start offset, end offset

    assertNext(ts, reusableToken, "hello_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "greetings_and", 1, 1.4142135f, 0, 4);
    assertNext(ts, reusableToken, "greetings_and_salutations", 1, 1.7320508f, 0, 4);
    assertNext(ts, reusableToken, "and_salutations", 1, 1.4142135f, 0, 4);
    assertNext(ts, reusableToken, "and_salutations_world", 1, 1.7320508f, 0, 10);
    assertNext(ts, reusableToken, "salutations_world", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "and_salutations_earth", 1, 1.7320508f, 0, 10);
    assertNext(ts, reusableToken, "salutations_earth", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "hello_tellus", 1, 1.4142135f, 0, 10);
    assertNext(ts, reusableToken, "and_salutations_tellus", 1, 1.7320508f, 0, 10);
    assertNext(ts, reusableToken, "salutations_tellus", 1, 1.4142135f, 0, 10);

    assertNull(ts.next(reusableToken));

    System.currentTimeMillis();


  }

