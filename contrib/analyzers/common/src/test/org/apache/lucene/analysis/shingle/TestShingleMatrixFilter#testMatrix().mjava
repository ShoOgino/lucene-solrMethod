  /**
   * Tests creat shingles from a pre-assembled matrix
   *
   * Tests the row token z-axis, multi token synonyms.
   *
   * @throws IOException
   */
  public void testMatrix() throws IOException {

    Matrix matrix = new Matrix();

    matrix.new Column(tokenFactory("no", 1));
    matrix.new Column(tokenFactory("surprise", 1));
    matrix.new Column(tokenFactory("to", 1));
    matrix.new Column(tokenFactory("see", 1));
    matrix.new Column(tokenFactory("england", 1));
    matrix.new Column(tokenFactory("manager", 1));

    Column col = matrix.new Column();

    // sven göran eriksson is a multi token synonym to svennis
    col.new Row().getTokens().add(tokenFactory("svennis", 1));

    Column.Row row = col.new Row();
    row.getTokens().add(tokenFactory("sven", 1));
    row.getTokens().add(tokenFactory("göran", 1));
    row.getTokens().add(tokenFactory("eriksson", 1));

    matrix.new Column(tokenFactory("in", 1));
    matrix.new Column(tokenFactory("the", 1));
    matrix.new Column(tokenFactory("croud", 1));

    TokenStream ts = new ShingleMatrixFilter(matrix, 2, 4, new Character('_'), true, new ShingleMatrixFilter.SimpleThreeDimensionalTokenSettingsCodec());

//  for (Token token = ts.next(new Token()); token != null; token = ts.next(token)) {
//      System.out.println("assertNext(ts, \"" + token.term() + "\", " + token.getPositionIncrement() + ", " + (token.getPayload() == null ? "1.0" : PayloadHelper.decodeFloat(token.getPayload().getData())) + "f, " + token.startOffset() + ", " + token.endOffset() + ");");
//      token.clear();
//    }

    final Token reusableToken = new Token();
    assertNext(ts, reusableToken, "no_surprise", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "no_surprise_to", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "no_surprise_to_see", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "surprise_to", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "surprise_to_see", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "surprise_to_see_england", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "to_see", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "to_see_england", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "to_see_england_manager", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "see_england", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "see_england_manager", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "see_england_manager_svennis", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "england_manager", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "england_manager_svennis", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "england_manager_svennis_in", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "manager_svennis", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "manager_svennis_in", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "manager_svennis_in_the", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "svennis_in", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "svennis_in_the", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "svennis_in_the_croud", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "in_the", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "in_the_croud", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "the_croud", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "see_england_manager_sven", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "england_manager_sven", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "england_manager_sven_göran", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "manager_sven", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "manager_sven_göran", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "manager_sven_göran_eriksson", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "sven_göran", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "sven_göran_eriksson", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "sven_göran_eriksson_in", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "göran_eriksson", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "göran_eriksson_in", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "göran_eriksson_in_the", 1, 2.0f, 0, 0);
    assertNext(ts, reusableToken, "eriksson_in", 1, 1.4142135f, 0, 0);
    assertNext(ts, reusableToken, "eriksson_in_the", 1, 1.7320508f, 0, 0);
    assertNext(ts, reusableToken, "eriksson_in_the_croud", 1, 2.0f, 0, 0);

    assertNull(ts.next(reusableToken));

  }

