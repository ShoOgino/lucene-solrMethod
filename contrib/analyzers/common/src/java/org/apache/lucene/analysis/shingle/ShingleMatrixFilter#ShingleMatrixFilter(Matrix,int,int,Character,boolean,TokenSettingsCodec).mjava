  /**
   * Creates a shingle filter based on a user defined matrix.
   *
   * The filter /will/ delete columns from the input matrix! You will not be able to reset the filter if you used this constructor.
   * todo: don't touch the matrix! use a boolean, set the input stream to null or something, and keep track of where in the matrix we are at.
   *
   * @param matrix the input based for creating shingles. Does not need to contain any information until {@link org.apache.lucene.analysis.shingle.ShingleMatrixFilter#next(org.apache.lucene.analysis.Token)} is called the first time.
   * @param minimumShingleSize minimum number of tokens in any shingle.
   * @param maximumShingleSize maximum number of tokens in any shingle.
   * @param spacerCharacter character to use between texts of the token parts in a shingle. null for none.
   * @param ignoringSinglePrefixOrSuffixShingle if true, shingles that only contains permutation of the first of the last column will not be produced as shingles. Useful when adding boundary marker tokens such as '^' and '$'.
   * @param settingsCodec codec used to read input token weight and matrix positioning.
   */
  public ShingleMatrixFilter(Matrix matrix, int minimumShingleSize, int maximumShingleSize, Character spacerCharacter, boolean ignoringSinglePrefixOrSuffixShingle, TokenSettingsCodec settingsCodec) {
    this.matrix = matrix;
    this.minimumShingleSize = minimumShingleSize;
    this.maximumShingleSize = maximumShingleSize;
    this.spacerCharacter = spacerCharacter;
    this.ignoringSinglePrefixOrSuffixShingle = ignoringSinglePrefixOrSuffixShingle;
    this.settingsCodec = settingsCodec;

    // set the input to be an empty token stream, we already have the data.
    this.input = new EmptyTokenStream();
  }

