	/**
	 * Returns a simple analyzer wrapper that logs all tokens produced by the
	 * underlying child analyzer to the given log stream (typically System.err);
	 * Otherwise behaves exactly like the child analyzer, delivering the very
	 * same tokens; useful for debugging purposes on custom indexing and/or
	 * querying.
	 * 
	 * @param child
	 *            the underlying child analyzer
	 * @param log
	 *            the print stream to log to (typically System.err)
	 * @param logName
	 *            a name for this logger (typically "log" or similar)
	 * @return a logging analyzer
	 */
	public static Analyzer getLoggingAnalyzer(final Analyzer child, 
			final PrintStream log, final String logName) {
		
		if (child == null) 
			throw new IllegalArgumentException("child analyzer must not be null");
		if (log == null) 
			throw new IllegalArgumentException("logStream must not be null");

		return new Analyzer() {
			public TokenStream tokenStream(final String fieldName, Reader reader) {
				return new TokenFilter(child.tokenStream(fieldName, reader)) {
					private int position = -1;
					
					public Token next() throws IOException {
						Token token = input.next(); // from filter super class
						log.println(toString(token));
						return token;
					}
					
					private String toString(Token token) {
						if (token == null) return "[" + logName + ":EOS:" + fieldName + "]\n";
						
						position += token.getPositionIncrement();
						return "[" + logName + ":" + position + ":" + fieldName + ":"
								+ token.termText() + ":" + token.startOffset()
								+ "-" + token.endOffset() + ":" + token.type()
								+ "]";
					}					
				};
			}
		};
	}

