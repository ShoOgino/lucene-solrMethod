  /**
   * Returns a reasonable approximation of the main memory [bytes] consumed by
   * this instance. Useful for smart memory sensititve caches/pools. Assumes
   * fieldNames are interned, whereas tokenized terms are memory-overlaid. For
   * simplicity, assumes no VM word boundary alignment of instance vars.
   * 
   * @return the main memory consumption
   */
  public int getMemorySize() {
    // for example usage in a smart cache see nux.xom.pool.Pool
    int HEADER = 12; // object header of any java object
    int PTR = 4; // pointer on 32 bit VMs
    int ARR = HEADER + 4;
    int STR = HEADER + 3*4 + PTR + ARR; // string
    int INTARRLIST = HEADER + 4 + PTR + ARR;
    int HASHMAP = HEADER + 4*PTR + 4*4 + ARR;
    
    int size = 0;
    size += HEADER + 2*PTR + 4; // memory index
    if (sortedFields != null) size += ARR + PTR * sortedFields.length;
    
    size += HASHMAP + fields.size() * (PTR + HEADER + 3*PTR + 4); // Map.entries
    Iterator iter = fields.entrySet().iterator();
    while (iter.hasNext()) { // for each Field Info
      Map.Entry entry = (Map.Entry) iter.next();      
      Info info = (Info) entry.getValue();
      size += HEADER + 4 + 4 + PTR + PTR + PTR; // Info instance vars
      if (info.sortedTerms != null) size += ARR + PTR * info.sortedTerms.length;
      
      int len = info.terms.size();
      size += HASHMAP + len * (PTR + HEADER + 3*PTR + 4); // Map.entries
      Iterator iter2 = info.terms.entrySet().iterator();
      while (--len >= 0) { // for each term
        Map.Entry e = (Map.Entry) iter2.next();
        size += STR - ARR; // assumes substring() memory overlay
//        size += STR + 2 * ((String) e.getKey()).length();
        ArrayIntList positions = (ArrayIntList) e.getValue();
        size += INTARRLIST + 4*positions.size();
      }
    }
    return size;
  } 

