    public void testGoodCases() throws Exception {
	
	IndexSearcher searcher;
	final float[] scores = new float[NUM_DOCS];
	float lastScore = 0.0f;
	
	// default similarity should put docs with shorter length first
  searcher = new IndexSearcher(store);
  searcher.search(new TermQuery(new Term("field", "word")), new Collector() {
    private int docBase = 0;
    private Scorer scorer;
    public final void collect(int doc) throws IOException {
      scores[doc + docBase] = scorer.score();
    }
    public void setNextReader(IndexReader reader, int docBase) {
      this.docBase = docBase;
    }
    public void setScorer(Scorer scorer) throws IOException {
      this.scorer = scorer;
    }
  });
  searcher.close();
	
	lastScore = Float.MAX_VALUE;
	for (int i = 0; i < NUM_DOCS; i++) {
	    String msg = "i=" + i + ", "+scores[i]+" <= "+lastScore;
	    assertTrue(msg, scores[i] <= lastScore);
	    //System.out.println(msg);
	    lastScore = scores[i];
	}

	// override the norms to be inverted
	Similarity s = new DefaultSimilarity() {
		public float lengthNorm(String fieldName, int numTokens) {
		    return numTokens;
		}
	    };
	FieldNormModifier fnm = new FieldNormModifier(store, s);
	fnm.reSetNorms("field");

	// new norm (with default similarity) should put longer docs first
	searcher = new IndexSearcher(store);
	searcher.search(new TermQuery(new Term("field", "word")), new Collector() {
      private int docBase = 0;
      private Scorer scorer;
      public final void collect(int doc) throws IOException {
        scores[doc + docBase] = scorer.score();
      }
      public void setNextReader(IndexReader reader, int docBase) {
        this.docBase = docBase;
      }
      public void setScorer(Scorer scorer) throws IOException {
        this.scorer = scorer;
      }
    });
    searcher.close();
	
	lastScore = 0.0f;
	for (int i = 0; i < NUM_DOCS; i++) {
	    String msg = "i=" + i + ", "+scores[i]+" >= "+lastScore;
	    assertTrue(msg, scores[i] >= lastScore);
	    //System.out.println(msg);
	    lastScore = scores[i];
	}
	
    }

