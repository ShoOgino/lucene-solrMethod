    /**
     * All registered {@link ServerComponent} registered via this method are
     * available via the
     * {@link GDataServerRegistry#lookup(Class, ComponentType)} method. For each
     * {@link ComponentType} there will be one single instance registered in the
     * registry.
     * <p>
     * Eventually this method invokes the initialize method of the
     * ServerComponent interface to prepare the component to be available via
     * the lookup service
     * </p>
     * 
     * @param <E> -
     *            The interface of the component to register
     * @param componentClass -
     *            a implementation of a ServerComponent interface to register in
     *            the registry
     * @param configuration -
     *            the component configuration {@link ComponentConfiguration}
     * @throws RegistryException -
     *             if the provided class does not implement the
     *             {@link ServerComponent} interface, if the mandatory
     *             annotations not visible at runtime or not set, if the super
     *             type provided by the {@link ComponentType} for the class to
     *             register is not a super type of the class or if the
     *             invocation of the {@link ServerComponent#initialize()} method
     *             throws an exception.
     */
    @SuppressWarnings("unchecked")
    public <E extends ServerComponent> void registerComponent(
            final Class<E> componentClass,
            final ComponentConfiguration configuration)
            throws RegistryException {

        if (componentClass == null)
            throw new IllegalArgumentException(
                    "component class must not be null");

        if (!ReflectionUtils.implementsType(componentClass,
                ServerComponent.class))
            throw new RegistryException(
                    "can not register component. the given class does not implement ServerComponent interface -- "
                            + componentClass.getName());
        try {

            Component annotation = componentClass
                    .getAnnotation(Component.class);
            if (annotation == null)
                throw new RegistryException(
                        "can not register component. the given class is not a component -- "
                                + componentClass.getName());
            ComponentType type = annotation.componentType();
            if (this.componentMap.containsKey(type))
                throw new RegistryException("component already registered -- "
                        + type.name());
            Class superType = type.getClass().getField(type.name())
                    .getAnnotation(SuperType.class).superType();
            if (!ReflectionUtils.isTypeOf(componentClass, superType))
                throw new RegistryException("Considered super type <"
                        + superType.getName() + "> is not a super type of <"
                        + componentClass + ">");
            ServerComponent comp = componentClass.newInstance();
            if (configuration == null) {
                if (LOG.isInfoEnabled())
                    LOG.info("no configuration for ComponentType: "
                            + type.name());
            } else
                configureComponent(comp, type, configuration);
            comp.initialize();
            ComponentBean bean = new ComponentBean(comp, superType);

            this.componentMap.put(type, bean);
            if (ReflectionUtils.implementsType(componentClass,
                    ScopeVisitor.class))
                this.registerScopeVisitor((ScopeVisitor) comp);
        } catch (Exception e) {
            throw new RegistryException("Can not register component -- "
                    + e.getMessage(), e);
        }

    }

