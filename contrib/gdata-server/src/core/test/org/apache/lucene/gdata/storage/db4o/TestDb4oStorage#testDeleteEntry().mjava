    /*
     * Test method for
     * 'org.apache.lucene.gdata.storage.db4o.DB4oStorage.deleteEntry(ServerBaseEntry)'
     */
    public void testDeleteEntry() throws StorageException, InterruptedException {
        ObjectContainer container = getContainer();
        storeServerBaseFeed();
        Storage storage = this.controller.getStorage();
        
        try {

            storage.deleteEntry(null);
            fail("entry is null");
        } catch (StorageException e) {
            //
        }
        ServerBaseEntry exEntry = new ServerBaseEntry();
        exEntry.setFeedId("some");
        try {

            storage.deleteEntry(exEntry);
            fail("entry id is null");
        } catch (StorageException e) {
            //
        }
        exEntry.setId("someID");
        exEntry.setFeedId(null);
        try {

            storage.storeEntry(exEntry);
            fail("feed id is null");
        } catch (StorageException e) {
            //
        }
        
        
        ServerBaseEntry e = createServerBaseEntry();
        storage.storeEntry(e);
        ServerBaseEntry e1 = createServerBaseEntry();
        storage.storeEntry(e1);

        storage.deleteEntry(e);

        container.close();
        container = getContainer();
        Query query = container.query();
        query.constrain(BaseEntry.class);
        query.descend("id").constrain(e.getId());
        ObjectSet resultSet = query.execute();
        assertEquals(0, resultSet.size());

        // #### test version matching
        ServerBaseEntry eVersion = createServerBaseEntry();
        storage.storeEntry(eVersion);
        eVersion.setVersion(33);
        try {
            storage.deleteEntry(eVersion);
            fail("version does not match");
        } catch (Exception ex) {
            // TODO: handle exception
        }
        try {
            storage.deleteEntry(null);
            fail("entry id is null");
        } catch (Exception ex) {
            // TODO: handle exception
        }
        storage = this.controller.getStorage();
        storage.deleteEntry(e1);
        container.close();
        container = getContainer();
        query = container.query();
        query.constrain(BaseEntry.class);
        query.descend("id").constrain(e1.getId());
        resultSet = query.execute();
        assertEquals(0, resultSet.size());

        // ############ test concurrency

        // ############ test concurrency
        Object monitor = new Object();
        AtomicBoolean reached = new AtomicBoolean(false);
        MultiThreadEntryStub concuEntry = new MultiThreadEntryStub();
        concuEntry.setId(System.currentTimeMillis() + "");
        ProvidedServiceConfig conf = new ProvidedServiceConfig();
        conf.setName(SERVICENAME);
        concuEntry.setServiceConfig(conf);
        concuEntry.setUpdated(DateTime.now());
        concuEntry.setFeedId(FEEDID);

        storage = this.controller.getStorage();

        storage.storeEntry(concuEntry);
        storage.close();
        concuEntry.acceptGetVersionVisitor(getMonitorVisitor(monitor, reached));

        Thread t1 = getDelThread(controller, concuEntry, false);

        Thread t2 = getDelThread(controller, concuEntry, true);
        t1.start();
        /*
         * Wait active -- not nice but works fine here wait until thread parked
         */

        while (true) {
            synchronized (monitor) {
                if (reached.get())
                    break;
                monitor.wait(10);
            }
        }
        t2.start();
        t2.join(800);
        /*
         * Wait active -- not nice but works fine here wake up the waiting
         * thread
         */
        while (true) {
            synchronized (monitor) {
                if (!reached.get())
                    break;
                monitor.notifyAll();
            }
        }
        t1.join(300);
        if (fail)
            fail("thread failed -- see stacktrace");

        container.close();

    }

