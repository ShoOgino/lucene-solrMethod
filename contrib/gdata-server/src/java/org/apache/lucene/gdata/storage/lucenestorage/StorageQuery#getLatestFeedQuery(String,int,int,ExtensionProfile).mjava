    /** 
     * This method fetches the latest feed entries from the storage. Feed 
     * ususaly requested via a search query or as a simple query to the REST 
     * interface. 
     * <p> 
     * The REST interface requestes all the entries from a Storage. The Storage 
     * retrieves the entries corresponding to the parameters specified. This 
     * method first requests the latest entries or updated entries from the 
     * {@link StorageBuffer}. If the buffer already contains enought entries 
     * for the the specified result count the entires will be returned. If not, 
     * the underlaying lucene index will be searcher for all documents of the 
     * specified feed sorted by storing timestamp desc. 
     * </p> 
     * <p> 
     * The entries will be searched in a feed context specified by the given 
     * feed ID 
     * </p> 
     *  
     *  
     * @param feedId - 
     *            the requested feed, this id will be used to retrieve the 
     *            entries. 
     * @param resultCount - 
     *            how many entries are requested 
     * @param startIndex - 
     *            the offset of the entriy to start from. 
     * @param profil - 
     *            the extension profile used to create the entriy instances 
     * @return - an ordered list of {@link BaseEntry} objects, or an empty list 
     *         if no entries could be found 
     * @throws IOException - 
     *             if the index could not be queries or the entries could not be 
     *             build 
     * @throws FeedNotFoundException - 
     *             if the requested feed is not registered 
     * @throws ParseException - 
     *             if an entry could not be parsed while building it from the 
     *             Lucene Document. 
     */ 
    // TODO check input parameter 
    public List<BaseEntry> getLatestFeedQuery(final String feedId, 
            final int resultCount, final int startIndex, 
            final ExtensionProfile profil) throws IOException, 
            FeedNotFoundException, ParseException { 
        List<BaseEntry> returnList = new ArrayList<BaseEntry>(resultCount); 
        List<StorageEntryWrapper> bufferedWrapperList = this.buffer 
                .getSortedEntries(feedId); 
        int alreadyAdded = 0; 
        int offset = startIndex - 1; 
        if (bufferedWrapperList != null 
                && bufferedWrapperList.size() >= startIndex) { 
 
            for (; alreadyAdded < resultCount; alreadyAdded++) { 
                if ((bufferedWrapperList.size() - offset) > 0) { 
                    StorageEntryWrapper wrappedEntry = bufferedWrapperList 
                            .get(offset++); 
                    returnList.add(wrappedEntry.getEntry()); 
                } else 
                    break; 
            } 
            // reset offset 
            offset = startIndex - 1; 
            if (alreadyAdded == resultCount) 
                return returnList; 
        } else { 
            /* 
             * if the buffersize is less than the startindex the buffersize must 
             * be considered. Sublists would not be a repeatable read part of 
             * the whole list 
             */ 
            if (bufferedWrapperList != null) 
                offset = startIndex - 1 - bufferedWrapperList.size(); 
        } 
 
        Hits hits = storageFeedQuery(feedId, this.timeStampSort); 
        if (hits.length() > 0) { 
 
            for (; (offset < hits.length()) && (alreadyAdded < resultCount); offset++, alreadyAdded++) { 
                Document doc = hits.doc(offset); 
                BaseEntry entry = buildEntryFromLuceneDocument(doc, profil); 
                returnList.add(entry); 
            } 
 
        } 
        return returnList; 
    } 

