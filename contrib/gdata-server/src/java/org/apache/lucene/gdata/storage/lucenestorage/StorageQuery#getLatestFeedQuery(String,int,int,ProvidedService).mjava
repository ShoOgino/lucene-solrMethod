    /**
     * This method fetches the latest feed entries from the storage. Feed
     * ususaly requested via a search query or as a simple query to the REST
     * interface.
     * <p>
     * The REST interface requestes all the entries from a Storage. The Storage
     * retrieves the entries corresponding to the parameters specified. This
     * method first requests the latest entries or updated entries from the
     * {@link StorageBuffer}. If the buffer already contains enought entries
     * for the the specified result count the entires will be returned. If not,
     * the underlaying lucene index will be searcher for all documents of the
     * specified feed sorted by storing timestamp desc.
     * </p>
     * <p>
     * The entries will be searched in a feed context specified by the given
     * feed ID
     * </p>
     * 
     * 
     * @param feedId -
     *            the requested feed, this id will be used to retrieve the
     *            entries.
     * @param resultCount -
     *            how many entries are requested
     * @param startIndex -
     *            the offset of the entriy to start from.
     * @param config -
     *            the FeedInstanceConfiguration contaning extension profile used
     *            to create the entriy instances
     * @return - an ordered list of {@link BaseEntry} objects, or an empty list
     *         if no entries could be found
     * @throws IOException -
     *             if the index could not be queries or the entries could not be
     *             build
     * @throws ParseException -
     *             if an entry could not be parsed while building it from the
     *             Lucene Document.
     */
    // TODO check input parameter
    @SuppressWarnings("unchecked")
    public BaseFeed getLatestFeedQuery(final String feedId,
            final int resultCount, final int startIndex,
            final ProvidedService config) throws IOException,
            ParseException {
        DateTime updated = null;
        Hits feedHits = storageFeedQuery(feedId);
        if(feedHits.length() == 0)
            return null;
        BaseFeed retVal = buildFeedFromLuceneDocument(feedHits.doc(0),config);
        
        List<BaseEntry> returnList = new ArrayList<BaseEntry>(resultCount);
        List<StorageEntryWrapper> bufferedWrapperList = this.buffer
                .getSortedEntries(feedId);
        int alreadyAdded = 0;
        int offset = startIndex - 1;
        
        if (bufferedWrapperList != null
                && bufferedWrapperList.size() >= startIndex) {
            updated = bufferedWrapperList.get(0).getEntry().getUpdated();
            for (; alreadyAdded < resultCount; alreadyAdded++) {
                if ((bufferedWrapperList.size() - offset) > 0) {
                    StorageEntryWrapper wrappedEntry = bufferedWrapperList
                            .get(offset++);
                    returnList
                            .add(wrappedEntry.getEntry());
                } else
                    break;
            }
            // reset offset
            offset = startIndex - 1;
            if (alreadyAdded == resultCount){
                retVal.getEntries().addAll(returnList);
                retVal.setUpdated(updated);
                return retVal;
            }
        } else {
            /*
             * if the buffersize is less than the startindex the buffersize must
             * be considered. Sublists would not be a repeatable read part of
             * the whole list
             */
            if (bufferedWrapperList != null)
                offset = startIndex - 1 - bufferedWrapperList.size();
        }

        Hits hits = storageFeedQuery(feedId, this.timeStampSort);
        if (hits.length() > 0) {

            for (; (offset < hits.length()) && (alreadyAdded < resultCount); offset++, alreadyAdded++) {
                Document doc = hits.doc(offset);
                BaseEntry entry = buildEntryFromLuceneDocument(doc, config);
                returnList.add(entry);
            }
            if(updated == null){
            try{
                long updatedTimeStamp = Long.parseLong(hits.doc(0).get(StorageEntryWrapper.FIELD_TIMESTAMP));
                updated = new DateTime(updatedTimeStamp);
            }catch (Exception e) {
                LOG.warn("could not create DateTime -- "+e.getMessage(),e);
                updated = buildEntryFromLuceneDocument(hits.doc(0),config).getUpdated();
            }
            }
        }
        retVal.setUpdated(updated);
        retVal.getEntries().addAll(returnList);
        return retVal;
    }

