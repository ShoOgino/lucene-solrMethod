    /**
     * This is the method where all the XML parsing happens. For each 
     * tag/subtag read from the source, this method is called recursively.
     *
     */
    private void parse(XMLStreamReader parser, Handler handler,
                       Map<String, Object> values, Stack<Set<String>> stack,
                       boolean recordStarted) throws IOException, XMLStreamException {
      Set<String> valuesAddedinThisFrame = null;
      if (isRecord) {
        // This Node is a match for an XPATH from a forEach attribute, 
        // prepare to emit a new record when its END_ELEMENT is matched 
        recordStarted = true;
        valuesAddedinThisFrame = new HashSet<String>();
        stack.push(valuesAddedinThisFrame);
      } else if (recordStarted) {
        // This node is a child of some parent which matched against forEach 
        // attribute. Continue to add values to an existing record.
        valuesAddedinThisFrame = stack.peek();
      } else {
        //if this tag has an attribute or text which is a brank/leaf just push an item up the stack
        if (attributes != null || hasText)
          valuesAddedinThisFrame = new HashSet<String>();
        stack.push(valuesAddedinThisFrame);
      }

      try {
        if (attributes != null) {
          for (Node node : attributes) {
            String value = parser.getAttributeValue(null, node.name);
            if (value != null || (recordStarted && !isRecord)) {
              putText(values, value, node.fieldName, node.multiValued);
              valuesAddedinThisFrame.add(node.fieldName);
            }
          }
        }

        Set<Node> childrenFound = new HashSet<Node>();
        // Internally we have to gobble CDATA | CHARACTERS | SPACE events as we
        // store text, the gobbling continues till we have fetched some other 
        // event. We use "isNextEventFetched" to indcate that the gobbling has
        // already fetched the next event.
        boolean isNextEventFetched = false;
        int event = -1;

        while (true) {
          if (!isNextEventFetched) {
            event = parser.next();
            isNextEventFetched = false;
          }
          if (event == END_DOCUMENT) {
            return;
          }
          if (event == END_ELEMENT) {
            if (isRecord)
              handler.handle(getDeepCopy(values), forEachPath);
            if (recordStarted && !isRecord
                    && !childrenFound.containsAll(childNodes)) {
              for (Node n : childNodes) {
                if (!childrenFound.contains(n))
                  n.putNulls(values);
              }
            }
            return;
          }
          if ((event == CDATA || event == CHARACTERS || event == SPACE)
                  && hasText) {
            valuesAddedinThisFrame.add(fieldName);
            // becuase we are fetching events here we need to ensure the outer
            // loop does not end up doing an extra parser.next()
            isNextEventFetched = true;
            String text = parser.getText();
            event = parser.next();

            while (true) {
              if(event == CDATA || event == CHARACTERS || event == SPACE) {
                text = text + parser.getText();
              } else if(event == START_ELEMENT) {
                if (flatten) {
                  int starts = 1;
                  while (true) {
                    event = parser.next();
                    if (event == CDATA || event == CHARACTERS || event == SPACE) {
                      text = text + parser.getText();
                    } else if (event == START_ELEMENT) {
                      starts++;
                    } else if (event == END_ELEMENT) {
                      starts--;
                      if (starts == 0) break;
                    }
                  }
                } else {
                  // We are not flatten-ing, so look to see if any of the child
                  // elements are wanted, and recurse if any are found.
                  handleStartElement(parser, childrenFound, handler, values, stack, recordStarted);
                }
              } else {
                break;
              }
              event = parser.next();
            }
            // save the text we have read against the fieldName in the Map values
            putText(values, text, fieldName, multiValued);
          } else if (event == START_ELEMENT) {
            handleStartElement(parser, childrenFound, handler, values, stack, recordStarted);
          }
        }
      } finally {
        /*If a record has ended  (tag closed) then clearup all the fields found
        in this record after this tag started */
        Set<String> cleanThis = null;
        if (isRecord || !recordStarted) {
          cleanThis = stack.pop();
        } else {
          return;
        }
        if (cleanThis != null) {
          for (String fld : cleanThis) {
            values.remove(fld);
          }
        }
      }
    }

