  /**
   * This is called by a consumer when it is ready to deal with a new SolrInputDocument.  Overriding
   * classes can use this hook to add in or change whatever they deem fit for the document at that time.
   * The base implementation adds the metadata as fields, allowing for potential remapping.
   *
   * @return The {@link org.apache.solr.common.SolrInputDocument}.
   */
  public SolrInputDocument newDocument() {
    float boost = 1.0f;
    //handle the metadata extracted from the document
    for (String name : metadata.names()) {
      String[] vals = metadata.getValues(name);
      name = findMappedMetadataName(name);
      SchemaField schFld = schema.getFieldOrNull(name);
      if (schFld != null) {
        boost = getBoost(name);
        if (schFld.multiValued()) {
          for (int i = 0; i < vals.length; i++) {
            String val = vals[i];
            document.addField(name, transformValue(val, schFld), boost);
          }
        } else {
          StringBuilder builder = new StringBuilder();
          for (int i = 0; i < vals.length; i++) {
            builder.append(vals[i]).append(' ');
          }
          document.addField(name, transformValue(builder.toString().trim(), schFld), boost);
        }
      } else {
        //TODO: error or log?
        if (ignoreUndeclaredFields == false) {
          // Arguably we should handle this as a special case. Why? Because unlike basically
          // all the other fields in metadata, this one was probably set not by Tika by in
          // ExtractingDocumentLoader.load(). You shouldn't have to define a mapping for this
          // field just because you specified a resource.name parameter to the handler, should
          // you?
          if (name != Metadata.RESOURCE_NAME_KEY) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "Invalid field: " + name);
          }
        }
      }
    }
    //handle the literals from the params
    Iterator<String> paramNames = params.getParameterNamesIterator();
    while (paramNames.hasNext()) {
      String name = paramNames.next();
      if (name.startsWith(LITERALS_PREFIX)) {
        String fieldName = name.substring(LITERALS_PREFIX.length());
        //no need to map names here, since they are literals from the user
        SchemaField schFld = schema.getFieldOrNull(fieldName);
        if (schFld != null) {
          String[] values = params.getParams(name);
          if (schFld.multiValued() == false && values.length > 1) {
            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, "The Field " + fieldName + " is not multivalued");
          }
          boost = getBoost(fieldName);
          for (int i = 0; i < values.length; i++) {
            //no need to transform here, b/c we can assume the user sent it in correctly
            document.addField(fieldName, values[i], boost);

          }
        } else {
          handleUndeclaredField(fieldName);
        }
      }
    }
    //add in the content
    document.addField(defaultFieldName, catchAllBuilder.toString(), getBoost(defaultFieldName));

    //add in the captured content
    for (Map.Entry<String, StringBuilder> entry : fieldBuilders.entrySet()) {
      if (entry.getValue().length() > 0) {
        String fieldName = findMappedName(entry.getKey());
        SchemaField schFld = schema.getFieldOrNull(fieldName);
        if (schFld != null) {
          document.addField(fieldName, transformValue(entry.getValue().toString(), schFld), getBoost(fieldName));
        } else {
          handleUndeclaredField(fieldName);
        }
      }
    }
    //make sure we have a unique id, if one is needed
    SchemaField uniqueField = schema.getUniqueKeyField();
    if (uniqueField != null) {
      String uniqueFieldName = uniqueField.getName();
      SolrInputField uniqFld = document.getField(uniqueFieldName);
      if (uniqFld == null) {
        String uniqId = generateId(uniqueField);
        if (uniqId != null) {
          document.addField(uniqueFieldName, uniqId);
        }
      }
    }
    if (log.isDebugEnabled()) {
      log.debug("Doc: " + document);
    }
    return document;
  }

